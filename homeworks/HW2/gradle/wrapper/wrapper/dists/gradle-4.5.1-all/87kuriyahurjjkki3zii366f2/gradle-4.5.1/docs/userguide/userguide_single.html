<html><head><META http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Gradle User Manual Version 4.5.1 (Single Page)</title><meta content="noindex" name="robots"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,400i,700"><link crossorigin="crossorigin" href="//assets.gradle.com" rel="preconnect"><meta content="width=device-width, initial-scale=1" name="viewport"><link type="text/css" rel="stylesheet" href="base.css"><meta content="DocBook XSL Stylesheets V1.75.2" name="generator"></head><body><div class="book"><div xmlns:xslthl="http://xslthl.sf.net" class="titlepage"><div class="title"><div><h1 class="title"><a name="N10002"></a>Gradle User Manual</h1></div><div><h3 class="releaseinfo">Version 4.5.1</h3></div></div><div><p class="copyright">Copyright &copy; 2007-2018 Hans Dockter, Adam Murdoch</p></div><div><div class="legalnotice" title="Legal Notice"><a name="N1000E"></a><p>Gradle build tool source code is open and licensed under the <a class="ulink" href="https://github.com/gradle/gradle/blob/master/LICENSE" target="_top"><em class="citetitle">Apache License 2.0</em></a>. Gradle user manual and DSL references are licensed under <a class="ulink" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_top"><em class="citetitle">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</em></a>.</p></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="part"><a href="#N1001E">About Gradle</a></span></dt><dd><dl><dt><span class="chapter"><a href="#introduction">Introduction</a></span></dt><dt><span class="chapter"><a href="#overview">Overview</a></span></dt></dl></dd><dt><span class="part"><a href="#N100D8">Working with existing builds</a></span></dt><dd><dl><dt><span class="chapter"><a href="#installation">Installing Gradle</a></span></dt><dt><span class="chapter"><a href="#command_line_interface">Command-Line Interface</a></span></dt><dt><span class="chapter"><a href="#gradle_wrapper">The Gradle Wrapper</a></span></dt><dt><span class="chapter"><a href="#gradle_daemon">The Gradle Daemon</a></span></dt><dt><span class="chapter"><a href="#artifact_dependencies_tutorial">Dependency Management for Java Projects</a></span></dt><dt><span class="chapter"><a href="#intro_multi_project_builds">Executing Multi-Project Builds</a></span></dt><dt><span class="chapter"><a href="#continuous_build">Continuous build</a></span></dt><dt><span class="chapter"><a href="#composite_builds">Composite builds</a></span></dt><dt><span class="chapter"><a href="#build_environment">Build Environment</a></span></dt><dt><span class="chapter"><a href="#troubleshooting">Troubleshooting</a></span></dt><dt><span class="chapter"><a href="#embedding">Embedding Gradle using the Tooling API</a></span></dt><dt><span class="chapter"><a href="#build_cache">Build Cache</a></span></dt></dl></dd><dt><span class="part"><a href="#N11577">Writing Gradle build scripts</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tutorial_using_tasks">Build Script Basics</a></span></dt><dt><span class="chapter"><a href="#build_init_plugin">Build Init Plugin</a></span></dt><dt><span class="chapter"><a href="#writing_build_scripts">Writing Build Scripts</a></span></dt><dt><span class="chapter"><a href="#more_about_tasks">Authoring Tasks</a></span></dt><dt><span class="chapter"><a href="#working_with_files">Working With Files</a></span></dt><dt><span class="chapter"><a href="#ant">Using Ant from Gradle</a></span></dt><dt><span class="chapter"><a href="#build_lifecycle">Build Lifecycle</a></span></dt><dt><span class="chapter"><a href="#logging">Logging</a></span></dt><dt><span class="chapter"><a href="#multi_project_builds">Authoring Multi-Project Builds</a></span></dt><dt><span class="chapter"><a href="#plugins">Using Gradle Plugins</a></span></dt><dt><span class="chapter"><a href="#standard_plugins">Standard Gradle plugins</a></span></dt><dt><span class="chapter"><a href="#project_report_plugin">The Project Report Plugin</a></span></dt><dt><span class="chapter"><a href="#build_dashboard_plugin">The Build Dashboard Plugin</a></span></dt><dt><span class="chapter"><a href="#comparing_builds">Comparing Builds</a></span></dt><dt><span class="chapter"><a href="#artifact_management">Publishing artifacts</a></span></dt><dt><span class="chapter"><a href="#maven_plugin">The Maven Plugin</a></span></dt><dt><span class="chapter"><a href="#signing_plugin">The Signing Plugin</a></span></dt><dt><span class="chapter"><a href="#publishing_ivy">Ivy Publishing (new)</a></span></dt><dt><span class="chapter"><a href="#publishing_maven">Maven Publishing (new)</a></span></dt><dt><span class="chapter"><a href="#distribution_plugin">The Distribution Plugin</a></span></dt><dt><span class="chapter"><a href="#announce_plugin">The Announce Plugin</a></span></dt><dt><span class="chapter"><a href="#build_announcements_plugin">The Build Announcements Plugin</a></span></dt></dl></dd><dt><span class="part"><a href="#N14EC0">Dependency management</a></span></dt><dd><dl><dt><span class="chapter"><a href="#introduction_dependency_management">Introduction to Dependency Management</a></span></dt><dt><span class="chapter"><a href="#declaring_dependencies">Declaring Dependencies</a></span></dt><dt><span class="chapter"><a href="#declaring_repositories">Declaring Repositories</a></span></dt><dt><span class="chapter"><a href="#inspecting_dependencies">Inspecting Dependencies</a></span></dt><dt><span class="chapter"><a href="#managing_transitive_dependencies">Managing Transitive Dependencies</a></span></dt><dt><span class="chapter"><a href="#working_with_dependencies">Working with Dependencies</a></span></dt><dt><span class="chapter"><a href="#customizing_dependency_resolution_behavior">Customizing Dependency Resolution Behavior</a></span></dt><dt><span class="chapter"><a href="#troubleshooting_dependency_resolution">Troubleshooting Dependency Resolution</a></span></dt></dl></dd><dt><span class="part"><a href="#N15705">Extending the build</a></span></dt><dd><dl><dt><span class="chapter"><a href="#custom_tasks">Writing Custom Task Classes</a></span></dt><dt><span class="chapter"><a href="#custom_plugins">Writing Custom Plugins</a></span></dt><dt><span class="chapter"><a href="#java_gradle_plugin">Gradle Plugin Development Plugin</a></span></dt><dt><span class="chapter"><a href="#organizing_build_logic">Organizing Build Logic</a></span></dt><dt><span class="chapter"><a href="#lazy_configuration">Lazy Configuration</a></span></dt><dt><span class="chapter"><a href="#init_scripts">Initialization Scripts</a></span></dt><dt><span class="chapter"><a href="#test_kit">Testing Build Logic with TestKit</a></span></dt></dl></dd><dt><span class="part"><a href="#N1666C">Building JVM projects</a></span></dt><dd><dl><dt><span class="chapter"><a href="#tutorial_java_projects">Java Quickstart</a></span></dt><dt><span class="chapter"><a href="#java_plugin">The Java Plugin</a></span></dt><dt><span class="chapter"><a href="#java_library_plugin">The Java Library Plugin</a></span></dt><dt><span class="chapter"><a href="#web_project_tutorial">Web Application Quickstart</a></span></dt><dt><span class="chapter"><a href="#war_plugin">The War Plugin</a></span></dt><dt><span class="chapter"><a href="#ear_plugin">The Ear Plugin</a></span></dt><dt><span class="chapter"><a href="#jetty_plugin">The Jetty Plugin</a></span></dt><dt><span class="chapter"><a href="#application_plugin">The Application Plugin</a></span></dt><dt><span class="chapter"><a href="#java_library_distribution_plugin">The Java Library Distribution Plugin</a></span></dt><dt><span class="chapter"><a href="#tutorial_groovy_projects">Groovy Quickstart</a></span></dt><dt><span class="chapter"><a href="#groovy_plugin">The Groovy Plugin</a></span></dt><dt><span class="chapter"><a href="#scala_plugin">The Scala Plugin</a></span></dt><dt><span class="chapter"><a href="#antlr_plugin">The ANTLR Plugin</a></span></dt><dt><span class="chapter"><a href="#checkstyle_plugin">The Checkstyle Plugin</a></span></dt><dt><span class="chapter"><a href="#codenarc_plugin">The CodeNarc Plugin</a></span></dt><dt><span class="chapter"><a href="#findbugs_plugin">The FindBugs Plugin</a></span></dt><dt><span class="chapter"><a href="#jdepend_plugin">The JDepend Plugin</a></span></dt><dt><span class="chapter"><a href="#pmd_plugin">The PMD Plugin</a></span></dt><dt><span class="chapter"><a href="#jacoco_plugin">The JaCoCo Plugin</a></span></dt><dt><span class="chapter"><a href="#osgi_plugin">The OSGi Plugin</a></span></dt><dt><span class="chapter"><a href="#eclipse_plugin">The Eclipse Plugins</a></span></dt><dt><span class="chapter"><a href="#idea_plugin">The IDEA Plugin</a></span></dt></dl></dd><dt><span class="part"><a href="#N19166">The Software model</a></span></dt><dd><dl><dt><span class="chapter"><a href="#software_model">Rule based model configuration</a></span></dt><dt><span class="chapter"><a href="#software_model_concepts">Software model concepts</a></span></dt><dt><span class="chapter"><a href="#rule_source">Implementing model rules in a plugin</a></span></dt><dt><span class="chapter"><a href="#java_software">Building Java Libraries</a></span></dt><dt><span class="chapter"><a href="#play_plugin">Building Play applications</a></span></dt><dt><span class="chapter"><a href="#native_software">Building native software</a></span></dt><dt><span class="chapter"><a href="#software_model_extend">Extending the software model</a></span></dt></dl></dd><dt><span class="part"><a href="#N1AD43">Glossary</a></span></dt><dd><dl><dt><span class="chapter"><a href="#dependency_types">Dependency Types</a></span></dt><dt><span class="chapter"><a href="#repository_types">Repository Types</a></span></dt></dl></dd><dt><span class="part"><a href="#N1B144">Appendix</a></span></dt><dd><dl><dt><span class="appendix"><a href="#sample_list">A. Gradle Samples</a></span></dt><dt><span class="appendix"><a href="#potential_traps">B. Potential Traps</a></span></dt><dt><span class="appendix"><a href="#feature_lifecycle">C. The Feature Lifecycle</a></span></dt><dt><span class="appendix"><a href="#licenses">D. Documentation licenses</a></span></dt></dl></dd></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>1. <a href="#excludeTask">Excluding tasks</a></dt><dt>2. <a href="#abbreviateCamelCaseTaskName">Abbreviated camel case task name</a></dt><dt>3. <a href="#taskHelp">Obtaining detailed help for tasks</a></dt><dt>4. <a href="#propertyListReport">Information about properties</a></dt><dt>5. <a href="#wrapperCommandLine">Running the Wrapper task</a></dt><dt>6. <a href="#N1067B">The generated distribution URL</a></dt><dt>7. <a href="#wrapperCommandLine">Providing options to Wrapper task</a></dt><dt>8. <a href="#N106CC">The generated distribution URL</a></dt><dt>9. <a href="#wrapperBatchFileExecution">Executing the build with the Wrapper batch file</a></dt><dt>10. <a href="#wrapperGradleVersionUpgrade">Upgrading the Wrapper version</a></dt><dt>11. <a href="#wrapperGradleVersionAfterUpgrade">Checking the Wrapper version after upgrading</a></dt><dt>12. <a href="#wrapperCustomized">Customizing the Wrapper task</a></dt><dt>13. <a href="#N10786">The generated distribution URL</a></dt><dt>14. <a href="#N107B8">Specifying the HTTP Basic Authentication credentials using system properties</a></dt><dt>15. <a href="#N107D1">Specifying the HTTP Basic Authentication credentials in <code class="literal">distributionUrl</code></a></dt><dt>16. <a href="#N10814">Configuring SHA-256 checksum verification</a></dt><dt>17. <a href="#basicDependencyDeclarations">Declaring dependencies</a></dt><dt>18. <a href="#externalDependencies">Definition of an external dependency</a></dt><dt>19. <a href="#externalDependencies">Shortcut definition of an external dependency</a></dt><dt>20. <a href="#defineMavenCentral">Usage of Maven central repository</a></dt><dt>21. <a href="#defineJCenter">Usage of JCenter repository</a></dt><dt>22. <a href="#defineRemoteMavenRepo">Usage of a remote Maven repository</a></dt><dt>23. <a href="#defineRemoteIvyRepo">Usage of a remote Ivy directory</a></dt><dt>24. <a href="#defineRemoteIvyRepo">Usage of a local Ivy directory</a></dt><dt>25. <a href="#publishIvyRepository">Publishing to an Ivy repository</a></dt><dt>26. <a href="#publishMavenRepository">Publishing to a Maven repository</a></dt><dt>27. <a href="#listProjects">Listing the projects in a build</a></dt><dt>28. <a href="#compositeBuilds_basic">Dependencies of my-app</a></dt><dt>29. <a href="#compositeBuilds_basic_cli">Declaring a command-line composite</a></dt><dt>30. <a href="#compositeBuilds_basic_composite">Declaring a separate composite</a></dt><dt>31. <a href="#compositeBuilds_basic_composite_run">Depending on task from included build</a></dt><dt>32. <a href="#compositeBuilds_declared_unpublished">Build that does not declare group attribute</a></dt><dt>33. <a href="#compositeBuilds_declared_unpublished">Declaring the substitutions for an included build</a></dt><dt>34. <a href="#compositeBuilds_tasks_single">Depending on a single task from an included build</a></dt><dt>35. <a href="#compositeBuilds_tasks_multiple">Depending on a tasks with path in all included builds</a></dt><dt>36. <a href="#properties">Setting properties with a gradle.properties file</a></dt><dt>37. <a href="#N10FB8">Specifying system properties in <code class="literal">gradle.properties</code></a></dt><dt>38. <a href="#N11034">Setting a project property via gradle.properties</a></dt><dt>39. <a href="#N1103B">Setting a project property via environment variable</a></dt><dt>40. <a href="#N1106E">Changing JVM settings for Gradle client JVM</a></dt><dt>41. <a href="#N1107E">Changing JVM settings for forked Gradle JVMs</a></dt><dt>42. <a href="#N1109B">Set Java compile options for <code class="classname">JavaCompile</code> tasks</a></dt><dt>43. <a href="#configureTaskUsingProjectProperty">Prevent releasing outside of CI</a></dt><dt>44. <a href="#N110EC">Configuring an HTTP proxy using <code class="literal">gradle.properties</code></a></dt><dt>45. <a href="#N110F7">Configuring an HTTPS proxy using <code class="literal">gradle.properties</code></a></dt><dt>46. <a href="#useToolingApi">Using the tooling API</a></dt><dt>47. <a href="#directoryBuildCacheConfiguration">Configure the local cache</a></dt><dt>48. <a href="#httpBuildCache">Pull from HttpBuildCache</a></dt><dt>49. <a href="#httpBuildCacheConfiguration">Configure remote HTTP cache</a></dt><dt>50. <a href="#httpBuildCacheAllowUntrustedServer">Allow untrusted SSL certificate for HttpBuildCache</a></dt><dt>51. <a href="#developerCiSetup">Recommended setup for CI push use case</a></dt><dt>52. <a href="#buildCacheBuildSrc">Consistent setup for buildSrc and main build</a></dt><dt>53. <a href="#buildCacheConfigurationInitScript">Init script to configure the build cache</a></dt><dt>54. <a href="#hello">Your first build script</a></dt><dt>55. <a href="#hello">Execution of a build script</a></dt><dt>56. <a href="#helloShortcut">A task definition shortcut</a></dt><dt>57. <a href="#upper">Using Groovy in Gradle's tasks</a></dt><dt>58. <a href="#count">Using Groovy in Gradle's tasks</a></dt><dt>59. <a href="#intro">Declaration of task that depends on other task</a></dt><dt>60. <a href="#lazyDependsOn">Lazy dependsOn - the other task does not exist (yet)</a></dt><dt>61. <a href="#dynamic">Dynamic creation of a task</a></dt><dt>62. <a href="#dynamicDepends">Accessing a task via API - adding a dependency</a></dt><dt>63. <a href="#helloEnhanced">Accessing a task via API - adding behaviour</a></dt><dt>64. <a href="#helloWithShortCut">Accessing task as a property of the build script</a></dt><dt>65. <a href="#extraTaskProperties">Adding extra properties to a task</a></dt><dt>66. <a href="#antLoadfile">Using AntBuilder to execute ant.loadfile target</a></dt><dt>67. <a href="#antLoadfileWithMethod">Using methods to organize your build logic</a></dt><dt>68. <a href="#defaultTasks">Defining a default task</a></dt><dt>69. <a href="#configByDagNoRelease">Different outcomes of build depending on chosen tasks</a></dt><dt>70. <a href="#projectApi">Accessing property of the Project object</a></dt><dt>71. <a href="#localVariables">Using local variables</a></dt><dt>72. <a href="#extraProperties">Using extra properties</a></dt><dt>73. <a href="#configureObject">Configuring arbitrary objects</a></dt><dt>74. <a href="#configureObjectUsingScript">Configuring arbitrary objects using a script</a></dt><dt>75. <a href="#groovyBasics">Groovy JDK methods</a></dt><dt>76. <a href="#groovyBasics">Property accessors</a></dt><dt>77. <a href="#groovyBasics">Method call without parentheses</a></dt><dt>78. <a href="#groovyBasics">List and map literals</a></dt><dt>79. <a href="#groovyBasics">Closure as method parameter</a></dt><dt>80. <a href="#groovyBasics">Closure delegates</a></dt><dt>81. <a href="#defineAsExpression">Defining tasks</a></dt><dt>82. <a href="#defineUsingStringTaskNames">Defining tasks - using strings for task names</a></dt><dt>83. <a href="#addToTaskContainer">Defining tasks with alternative syntax</a></dt><dt>84. <a href="#accessAsProperty">Accessing tasks as properties</a></dt><dt>85. <a href="#accessFromTaskContainer">Accessing tasks via tasks collection</a></dt><dt>86. <a href="#accessUsingPath">Accessing tasks by path</a></dt><dt>87. <a href="#declareTask">Creating a copy task</a></dt><dt>88. <a href="#configureUsingVar">Configuring a task - various ways</a></dt><dt>89. <a href="#configureUsingClosure">Configuring a task - with closure</a></dt><dt>90. <a href="#defineAndConfigure">Defining a task with closure</a></dt><dt>91. <a href="#addDependencyUsingPath">Adding dependency on task from another project</a></dt><dt>92. <a href="#addDependencyUsingTask">Adding dependency using task object</a></dt><dt>93. <a href="#addDependencyUsingClosure">Adding dependency using closure</a></dt><dt>94. <a href="#mustRunAfter">Adding a 'must run after' task ordering</a></dt><dt>95. <a href="#shouldRunAfter">Adding a 'should run after' task ordering</a></dt><dt>96. <a href="#mustRunAfterSingleTask">Task ordering does not imply task execution</a></dt><dt>97. <a href="#shouldRunAfterWithCycle">A 'should run after' task ordering is ignored if it introduces an ordering cycle</a></dt><dt>98. <a href="#describeTask">Adding a description to a task</a></dt><dt>99. <a href="#replaceTask">Overwriting a task</a></dt><dt>100. <a href="#taskOnlyIf">Skipping a task using a predicate</a></dt><dt>101. <a href="#stopExecutionException">Skipping tasks with StopExecutionException</a></dt><dt>102. <a href="#disableTask">Enabling and disabling tasks</a></dt><dt>103. <a href="#customTaskClassWithInputOutputAnnotations">Custom task class</a></dt><dt>104. <a href="#incrementalAdHocTask">Ad-hoc task</a></dt><dt>105. <a href="#destroyableAdHocTask">Ad-hoc task declaring a destroyable</a></dt><dt>106. <a href="#runtimeIncrementalApi">Using runtime API with custom task type</a></dt><dt>107. <a href="#runtimeIncrementalApiConfiguration">Using skipWhenEmpty() via the runtime API</a></dt><dt>108. <a href="#inferredTaskDep">Inferred task dependency via task outputs</a></dt><dt>109. <a href="#inferredTaskDep2">Inferred task dependency via a task argument</a></dt><dt>110. <a href="#incrementalBuildCustomMethods">Declaring a method to add task inputs</a></dt><dt>111. <a href="#incrementalBuildCustomMethodsWithTaskArg">Declaring a method to add a task as an input</a></dt><dt>112. <a href="#incrementalBuildBadInputFilesConfig">Failed attempt at setting up an inferred task dependency</a></dt><dt>113. <a href="#incrementalBuildInputFilesConfig">Setting up an inferred task dependency between output dir and input files</a></dt><dt>114. <a href="#incrementalBuildInputFilesConfigUsingTask">Setting up an inferred task dependency with files()</a></dt><dt>115. <a href="#inferredTaskDependencyWithBuiltBy">Setting up an inferred task dependency with builtBy()</a></dt><dt>116. <a href="#incrementalBuildUpToDateWhen">Ignoring up-to-date checks</a></dt><dt>117. <a href="#runtimeClasspathNormalization">Runtime classpath normalization</a></dt><dt>118. <a href="#taskRule">Task rule</a></dt><dt>119. <a href="#taskRuleDependsOn">Dependency on rule based tasks</a></dt><dt>120. <a href="#taskFinalizers">Adding a task finalizer</a></dt><dt>121. <a href="#taskFinalizersWithFailure">Task finalizer for a failing task</a></dt><dt>122. <a href="#resolveFile">Locating files</a></dt><dt>123. <a href="#fileCollections">Creating a file collection</a></dt><dt>124. <a href="#fileCollections">Using a file collection</a></dt><dt>125. <a href="#fileCollections">Implementing a file collection</a></dt><dt>126. <a href="#fileTrees">Creating a file tree</a></dt><dt>127. <a href="#fileTrees">Using a file tree</a></dt><dt>128. <a href="#fileTrees">Using an archive as a file tree</a></dt><dt>129. <a href="#inputFiles">Specifying a set of files</a></dt><dt>130. <a href="#inputFiles">Appending a set of files</a></dt><dt>131. <a href="#copy">Copying files using the copy task</a></dt><dt>132. <a href="#copy">Specifying copy task source files and destination directory</a></dt><dt>133. <a href="#copy">Selecting the files to copy</a></dt><dt>134. <a href="#copy">Copying files using the copy() method without up-to-date check</a></dt><dt>135. <a href="#copy">Copying files using the copy() method with up-to-date check</a></dt><dt>136. <a href="#renameOnCopy">Renaming files as they are copied</a></dt><dt>137. <a href="#filterOnCopy">Filtering files as they are copied</a></dt><dt>138. <a href="#nestedCopySpecs">Nested copy specs</a></dt><dt>139. <a href="#syncDependencies">Using the Sync task to copy dependencies</a></dt><dt>140. <a href="#createZip">Creating a ZIP archive</a></dt><dt>141. <a href="#archiveNaming">Creation of ZIP archive</a></dt><dt>142. <a href="#zipWithCustomName">Configuration of archive task - custom archive name</a></dt><dt>143. <a href="#zipWithArguments">Configuration of archive task - appendix &amp; classifier</a></dt><dt>144. <a href="#createZip">Activating reproducible archives</a></dt><dt>145. <a href="#useAntTask">Using an Ant task</a></dt><dt>146. <a href="#taskWithNestedText">Passing nested text to an Ant task</a></dt><dt>147. <a href="#taskWithNestedElements">Passing nested elements to an Ant task</a></dt><dt>148. <a href="#useAntType">Using an Ant type</a></dt><dt>149. <a href="#useExternalAntTask">Using a custom Ant task</a></dt><dt>150. <a href="#useExternalAntTaskWithConfig">Declaring the classpath for a custom Ant task</a></dt><dt>151. <a href="#useExternalAntTaskWithConfig">Using a custom Ant task and dependency management together</a></dt><dt>152. <a href="#antHello">Importing an Ant build</a></dt><dt>153. <a href="#dependsOnAntTarget">Task that depends on Ant target</a></dt><dt>154. <a href="#addBehaviourToAntTarget">Adding behaviour to an Ant target</a></dt><dt>155. <a href="#dependsOnTask">Ant target that depends on Gradle task</a></dt><dt>156. <a href="#renameAntDelegate">Renaming imported Ant targets</a></dt><dt>157. <a href="#antProperties">Setting an Ant property</a></dt><dt>158. <a href="#antProperties">Getting an Ant property</a></dt><dt>159. <a href="#antProperties">Setting an Ant reference</a></dt><dt>160. <a href="#antProperties">Getting an Ant reference</a></dt><dt>161. <a href="#antLogging">Fine tuning Ant logging</a></dt><dt>162. <a href="#buildlifecycle">Single project build</a></dt><dt>163. <a href="#standardLayouts">Hierarchical layout</a></dt><dt>164. <a href="#standardLayouts">Flat layout</a></dt><dt>165. <a href="#customLayout">Lookup of elements of the project tree</a></dt><dt>166. <a href="#customLayout">Modification of elements of the project tree</a></dt><dt>167. <a href="#projectEvaluateEvents">Adding of test task to each project which has certain property set</a></dt><dt>168. <a href="#buildProjectEvaluateEvents">Notifications</a></dt><dt>169. <a href="#taskCreationEvents">Setting of certain property to all tasks</a></dt><dt>170. <a href="#taskExecutionEvents">Logging of start and end of each task execution</a></dt><dt>171. <a href="#logging_to_stdout">Using stdout to write log messages</a></dt><dt>172. <a href="#logging_ex">Writing your own log messages</a></dt><dt>173. <a href="#logging_placeholder">Writing a log message with placeholder</a></dt><dt>174. <a href="#logging_with_slf4j">Using SLF4J to write log messages</a></dt><dt>175. <a href="#project_stdout_capture">Configuring standard output capture</a></dt><dt>176. <a href="#task_stdout_capture">Configuring standard output capture for a task</a></dt><dt>177. <a href="#custom_logging_ui">Customizing what Gradle logs</a></dt><dt>178. <a href="#multiprojectFirstExample">Multi-project tree - water &amp; bluewhale projects</a></dt><dt>179. <a href="#multiprojectFirstExample">Build script of water (parent) project</a></dt><dt>180. <a href="#multiprojectAddKrill">Multi-project tree - water, bluewhale  &amp; krill projects</a></dt><dt>181. <a href="#multiprojectAddKrill">Water project build script</a></dt><dt>182. <a href="#multiprojectUseSubprojects">Defining common behavior of all projects and subprojects</a></dt><dt>183. <a href="#multiprojectSubprojectsAddFromTop">Defining specific behaviour for particular project</a></dt><dt>184. <a href="#multiprojectSpreadSpecifics">Defining specific behaviour for project krill</a></dt><dt>185. <a href="#multiprojectAddTropical">Adding custom behaviour to some projects (filtered by project name)</a></dt><dt>186. <a href="#multiprojectTropicalWithProperties">Adding custom behaviour to some projects (filtered by project properties)</a></dt><dt>187. <a href="#multiprojectSubBuild">Running build from subproject</a></dt><dt>188. <a href="#multiprojectPartialTasks">Evaluation and execution of projects</a></dt><dt>189. <a href="#multiprojectPartialTasksNotQuiet">Evaluation and execution of projects</a></dt><dt>190. <a href="#multiprojectAbsoluteTaskPaths">Running tasks by their absolute path</a></dt><dt>191. <a href="#multiprojectFirstMessages">Dependencies and execution order</a></dt><dt>192. <a href="#multiprojectMessagesHack">Dependencies and execution order</a></dt><dt>193. <a href="#multiprojectMessagesHackBroken">Dependencies and execution order</a></dt><dt>194. <a href="#multiprojectMessagesDependencies">Declaring dependencies</a></dt><dt>195. <a href="#multiprojectMessagesDependenciesSubBuild">Declaring dependencies</a></dt><dt>196. <a href="#multiprojectMessagesTaskDependencies">Cross project task dependencies</a></dt><dt>197. <a href="#multiprojectMessagesConfigDependenciesBroken">Configuration time dependencies</a></dt><dt>198. <a href="#multiprojectMessagesConfigDependencies">Configuration time dependencies - evaluationDependsOn</a></dt><dt>199. <a href="#multiprojectMessagesConfigDependenciesAltSolution">Configuration time dependencies</a></dt><dt>200. <a href="#webdist">Dependencies - real life example - crossproject configuration</a></dt><dt>201. <a href="#javadependencies_1">Project lib dependencies</a></dt><dt>202. <a href="#javadependencies_2">Project lib dependencies</a></dt><dt>203. <a href="#javaWithCustomConf">Fine grained control over dependencies</a></dt><dt>204. <a href="#multitestingBuild">Build and Test Single Project</a></dt><dt>205. <a href="#multitestingBuildDashA">Partial Build and Test Single Project</a></dt><dt>206. <a href="#multitestingBuildNeeded">Build and Test Depended On Projects</a></dt><dt>207. <a href="#multitestingBuildDependents">Build and Test Dependent Projects</a></dt><dt>208. <a href="#configureProjectUsingScript">Applying a script plugin</a></dt><dt>209. <a href="#useJavaPluginDSL">Applying a core plugin</a></dt><dt>210. <a href="#useCommunityPluginDSL">Applying a community plugin</a></dt><dt>211. <a href="#pluginsOnSubprojects">Applying plugins only on certain subprojects.</a></dt><dt>212. <a href="#customPluginRepositories">Using plugins from custom plugin repositories.</a></dt><dt>213. <a href="#pluginResolutionStrategy">Plugin resolution strategy.</a></dt><dt>214. <a href="#completePluginPublishing">Complete Plugin Publishing Sample</a></dt><dt>215. <a href="#useJavaPlugin">Applying a binary plugin</a></dt><dt>216. <a href="#pluginIntro">Applying a binary plugin by type</a></dt><dt>217. <a href="#applyPluginBuildscript">Applying a plugin with the buildscript block</a></dt><dt>218. <a href="#useBuildDashboardPlugin">Using the Build Dashboard plugin</a></dt><dt>219. <a href="#archiveTaskArtifact">Defining an artifact using an archive task</a></dt><dt>220. <a href="#fileArtifact">Defining an artifact using a file</a></dt><dt>221. <a href="#fileArtifact">Customizing an artifact</a></dt><dt>222. <a href="#fileArtifact">Map syntax for defining an artifact using a file</a></dt><dt>223. <a href="#uploading">Configuration of the upload task</a></dt><dt>224. <a href="#useMavenPlugin">Using the Maven plugin</a></dt><dt>225. <a href="#newPom">Creating a standalone pom.</a></dt><dt>226. <a href="#uploadFile">Upload of file to remote Maven repository</a></dt><dt>227. <a href="#uploadWithSsh">Upload of file via SSH</a></dt><dt>228. <a href="#customizePom">Customization of pom</a></dt><dt>229. <a href="#pomBuilder">Builder style customization of pom</a></dt><dt>230. <a href="#pomBuilder">Modifying auto-generated content</a></dt><dt>231. <a href="#customizeInstaller">Customization of Maven installer</a></dt><dt>232. <a href="#multiplePoms">Generation of multiple poms</a></dt><dt>233. <a href="#mappings">Accessing a mapping configuration</a></dt><dt>234. <a href="#useSigningPlugin">Using the Signing plugin</a></dt><dt>235. <a href="#useGnupg">Sign with GnuPG</a></dt><dt>236. <a href="#configureGnupg">Configure the GnupgSignatory</a></dt><dt>237. <a href="#signingArchives">Signing a configuration</a></dt><dt>238. <a href="#signingArchivesOutput">Signing a configuration output</a></dt><dt>239. <a href="#signingTasks">Signing a task</a></dt><dt>240. <a href="#signingTaskOutput">Signing a task output</a></dt><dt>241. <a href="#conditionalSigning">Conditional signing</a></dt><dt>242. <a href="#signingMavenPom">Signing a POM for deployment</a></dt><dt>243. <a href="#publishing_ivy:apply-plugin-snippet">Applying the &ldquo;ivy-publish&rdquo; plugin</a></dt><dt>244. <a href="#publishing_ivy:publish-component-snippet">Publishing a Java module to Ivy</a></dt><dt>245. <a href="#publishing_ivy:publish-custom-artifact-snippet">Publishing additional artifact to Ivy</a></dt><dt>246. <a href="#publishing_ivy:publish-customize-identity">customizing the publication identity</a></dt><dt>247. <a href="#publishing_ivy:descriptor-customization-snippet">Customizing the module descriptor file</a></dt><dt>248. <a href="#publishing_ivy:publish-multiple-publications">Publishing multiple modules from a single project</a></dt><dt>249. <a href="#publishing_ivy:sample_repositories">Declaring repositories to publish to</a></dt><dt>250. <a href="#publishingIvyPublishSingle">Choosing a particular publication to publish</a></dt><dt>251. <a href="#publishingIvyPublishLifecycle">Publishing all publications via the &ldquo;publish&rdquo; lifecycle task</a></dt><dt>252. <a href="#publishingIvyGenerateDescriptor">Generating the Ivy module descriptor file</a></dt><dt>253. <a href="#publishing_ivy:complete_example">Publishing a Java module</a></dt><dt>254. <a href="#publishing_ivy:output_ivy.xml">Example generated ivy.xml</a></dt><dt>255. <a href="#publishing_maven:apply_plugin">Applying the 'maven-publish' plugin</a></dt><dt>256. <a href="#publishing_maven:publish-component">Adding a MavenPublication for a Java component</a></dt><dt>257. <a href="#publishing_maven:publish-custom-artifact">Adding additional artifact to a MavenPublication</a></dt><dt>258. <a href="#publishing_maven:publish-customize-identity">customizing the publication identity</a></dt><dt>259. <a href="#publishing_maven:pom_modification">Modifying the POM file</a></dt><dt>260. <a href="#publishing_maven:publish-multiple-publications">Publishing multiple modules from a single project</a></dt><dt>261. <a href="#publishing_maven:repositories">Declaring repositories to publish to</a></dt><dt>262. <a href="#publishingMavenPublishMinimal">Publishing a project to a Maven repository</a></dt><dt>263. <a href="#publishingMavenPublishLocal">Publish a project to the Maven local repository</a></dt><dt>264. <a href="#publishingMavenGeneratePom">Generate a POM file without publishing</a></dt><dt>265. <a href="#useDistributionPlugin">Using the distribution plugin</a></dt><dt>266. <a href="#multipleDistribution">Adding extra distributions</a></dt><dt>267. <a href="#configureDistribution">Configuring the main distribution</a></dt><dt>268. <a href="#publishDistribution">publish main distribution</a></dt><dt>269. <a href="#useAnnouncePlugin">Applying the announce plugin</a></dt><dt>270. <a href="#useAnnouncePlugin">Configure the announce plugin</a></dt><dt>271. <a href="#useAnnouncePlugin">Using the announce plugin</a></dt><dt>272. <a href="#useBuildAnnouncementsPlugin">Using the build announcements plugin</a></dt><dt>273. <a href="#useBuildAnnouncementsPlugin">Using the build announcements plugin from an init script</a></dt><dt>274. <a href="#binary-dependencies-concrete-version">Declaring a binary dependencies with a concrete version</a></dt><dt>275. <a href="#binary-dependencies-dynamic-version">Declaring a binary dependencies with a dynamic version</a></dt><dt>276. <a href="#binary-dependencies-changing-version">Declaring a binary dependencies with a changing version</a></dt><dt>277. <a href="#file-dependencies">Declaring multiple file dependencies</a></dt><dt>278. <a href="#project-dependencies">Declaring project dependencies</a></dt><dt>279. <a href="#custom-configuration">Declaring and using a custom configuration</a></dt><dt>280. <a href="#artifact-only-dependency-declaration">Resolving a JavaScript artifact for a declared dependency</a></dt><dt>281. <a href="#artifact-only-dependency-declaration-with-classifier">Resolving a JavaScript artifact with classifier for a declared dependency</a></dt><dt>282. <a href="#public-repository">Declaring JCenter repository as source for resolving dependencies</a></dt><dt>283. <a href="#custom-repository">Declaring a custom repository by URL</a></dt><dt>284. <a href="#multiple-repositories">Declaring multiple repositories</a></dt><dt>285. <a href="#jgit-dependency">Declaring the JGit dependency with a custom configuration</a></dt><dt>286. <a href="#dependencyReport">Rendering the dependency report for a custom configuration</a></dt><dt>287. <a href="#jgit-dependency-with-conflict">Declaring the JGit dependency and a conflicting dependency</a></dt><dt>288. <a href="#dependencyInsightReport">Using the dependency insight report for a given dependency</a></dt><dt>289. <a href="#unresolvedTransitiveDependencies">Unresolved artifacts for transitive dependencies</a></dt><dt>290. <a href="#exclude-transitive-for-dependency">Excluding transitive dependency for a particular dependency declaration</a></dt><dt>291. <a href="#exclude-transitive-for-configuration">Excluding transitive dependency for a particular configuration</a></dt><dt>292. <a href="#force-per-dependency">Enforcing a dependency version</a></dt><dt>293. <a href="#force-per-configuration">Enforcing a dependency version on the configuration-level</a></dt><dt>294. <a href="#disabling-transitive-dependency-resolution">Disabling transitive dependency resolution for a declared dependency</a></dt><dt>295. <a href="#disabling-transitive-dependency-resolution-for-configuration">Disabling transitive dependency resolution on the configuration-level</a></dt><dt>296. <a href="#configurationHandlingSetup">Configuration.copy</a></dt><dt>297. <a href="#configurationHandlingDependencies">Accessing declared dependencies</a></dt><dt>298. <a href="#configurationHandlingAllFiles">Configuration.files</a></dt><dt>299. <a href="#configurationHandlingFiles">Configuration.files with spec</a></dt><dt>300. <a href="#configurationHandlingCopy">Configuration.copy</a></dt><dt>301. <a href="#configurationHandlingCopyVsFiles">Configuration.copy vs. Configuration.files</a></dt><dt>302. <a href="#releasable-unit">Forcing consistent version for a group of libraries</a></dt><dt>303. <a href="#custom-versioning-scheme">Using a custom versioning scheme</a></dt><dt>304. <a href="#blacklisting_version">Blacklisting a version with a replacement</a></dt><dt>305. <a href="#module_substitution">Changing dependency group and/or name at the resolution</a></dt><dt>306. <a href="#module_to_project_substitution">Substituting a module with a project</a></dt><dt>307. <a href="#project_to_module_substitution">Substituting a project with a module</a></dt><dt>308. <a href="#project_substitution">Conditionally substituting a dependency</a></dt><dt>309. <a href="#configuration_default_dependencies">Specifying default dependencies on a configuration</a></dt><dt>310. <a href="#dynamicResolveMode">Enabling dynamic resolve mode</a></dt><dt>311. <a href="#latestSelector">'Latest' version selector</a></dt><dt>312. <a href="#customStatusScheme">Custom status scheme</a></dt><dt>313. <a href="#customStatusSchemeModule">Custom status scheme by module</a></dt><dt>314. <a href="#ivyComponentMetadataRule">Ivy component metadata rule</a></dt><dt>315. <a href="#ruleSourceComponentMetadataRule">Rule source component metadata rule</a></dt><dt>316. <a href="#componentSelectionRulesReject">Component selection rule</a></dt><dt>317. <a href="#componentSelectionRulesTarget">Component selection rule with module target</a></dt><dt>318. <a href="#componentSelectionRulesMetadata">Component selection rule with metadata</a></dt><dt>319. <a href="#componentSelectionRulesRuleSource">Component selection rule using a rule source object</a></dt><dt>320. <a href="#module_replacement_declaration">Declaring module replacement</a></dt><dt>321. <a href="#dynamic-version-cache-control">Dynamic version cache control</a></dt><dt>322. <a href="#changing-module-cache-control">Changing module cache control</a></dt><dt>323. <a href="#customTask">Defining a custom task</a></dt><dt>324. <a href="#customTaskWithAction">A hello world task</a></dt><dt>325. <a href="#customTaskWithProperty">A customizable hello world task</a></dt><dt>326. <a href="#customTaskStandalone">A build for a custom task</a></dt><dt>327. <a href="#customTaskStandalone">A custom task</a></dt><dt>328. <a href="#usingCustomTask">Using a custom task in another project</a></dt><dt>329. <a href="#customTaskStandalone">Testing a custom task</a></dt><dt>330. <a href="#taskDefinition">Defining an incremental task action</a></dt><dt>331. <a href="#incrementalTaskFirstRun">Running the incremental task for the first time</a></dt><dt>332. <a href="#incrementalTaskNoChange">Running the incremental task with unchanged inputs</a></dt><dt>333. <a href="#incrementalTaskUpdatedInputs">Running the incremental task with updated input files</a></dt><dt>334. <a href="#incrementalTaskRemovedInput">Running the incremental task with an input file removed</a></dt><dt>335. <a href="#incrementalTaskRemovedOutput">Running the incremental task with an output file removed</a></dt><dt>336. <a href="#incrementalTaskChangedProperty">Running the incremental task with an input property changed</a></dt><dt>337. <a href="#unitOfWork">Creating a unit of work implementation</a></dt><dt>338. <a href="#workSubmission">Submitting a unit of work for execution</a></dt><dt>339. <a href="#waitForCompletion">Waiting for asynchronous work to complete</a></dt><dt>340. <a href="#workerDaemon">Submitting an item of work to run in a worker daemon</a></dt><dt>341. <a href="#customPlugin">A custom plugin</a></dt><dt>342. <a href="#customPluginWithConvention">A custom plugin extension</a></dt><dt>343. <a href="#customPluginWithAdvancedConvention">A custom plugin with configuration closure</a></dt><dt>344. <a href="#lazyFileProperties">Evaluating file properties lazily</a></dt><dt>345. <a href="#mapExtensionPropertiesToTaskProperties">Mapping extension properties to task properties</a></dt><dt>346. <a href="#customPluginStandalone">A build for a custom plugin</a></dt><dt>347. <a href="#customPluginStandalone">Wiring for a custom plugin</a></dt><dt>348. <a href="#customPluginStandalone">Using a custom plugin in another project</a></dt><dt>349. <a href="#useCommunityPluginDSL">Applying a community plugin with the plugins DSL</a></dt><dt>350. <a href="#customPluginStandalone">Testing a custom plugin</a></dt><dt>351. <a href="#useJavaGradlePluginPlugin">Using the Java Gradle Plugin Development plugin</a></dt><dt>352. <a href="#nestedDslElement">Nested DSL elements</a></dt><dt>353. <a href="#domainObjectContainer">Managing a collection of objects</a></dt><dt>354. <a href="#useJavaGradlePluginPlugin">Using the Java Gradle Plugin Development plugin</a></dt><dt>355. <a href="#gradlePluginBlock">Using the gradlePlugin {} block.</a></dt><dt>356. <a href="#inheritedBuildLogic">Using inherited properties and methods</a></dt><dt>357. <a href="#injectedBuildLogic">Using injected properties and methods</a></dt><dt>358. <a href="#configureProjectUsingScript">Configuring the project using an external build script</a></dt><dt>359. <a href="#customBuildSrcBuild">Custom buildSrc build script</a></dt><dt>360. <a href="#multiProjectBuildSrc">Adding subprojects to the root buildSrc project</a></dt><dt>361. <a href="#nestedBuild">Running another build from a build</a></dt><dt>362. <a href="#declareExternalBuildDependency">Declaring external dependencies for the build script</a></dt><dt>363. <a href="#externalBuildDependency">A build script with external dependencies</a></dt><dt>364. <a href="#buildLogic">Ant optional dependencies</a></dt><dt>365. <a href="#usePropertyAndProvider">Using a read-only and configurable property</a></dt><dt>366. <a href="#workingWithFiles">Using file and directory property</a></dt><dt>367. <a href="#implicitTaskDependency">Implicit task dependency</a></dt><dt>368. <a href="#listProperty">List property</a></dt><dt>369. <a href="#initScriptConfiguration">Using init script to perform extra configuration before projects are evaluated</a></dt><dt>370. <a href="#declareExternalInitDependency">Declaring external dependencies for an init script</a></dt><dt>371. <a href="#externalInitDependency">An init script with external dependencies</a></dt><dt>372. <a href="#usePluginsInInitScripts">Using plugins in init scripts</a></dt><dt>373. <a href="#testKitDependency">Declaring the TestKit dependency</a></dt><dt>374. <a href="#junitDependency">Declaring the JUnit dependency</a></dt><dt>375. <a href="#testKitFunctionalTestJunit">Using GradleRunner with JUnit</a></dt><dt>376. <a href="#testKitFunctionalTestSpock">Using GradleRunner with Spock</a></dt><dt>377. <a href="#testKitFunctionalTestSpockClassesBuildConfig">Making the code under test classpath available to the tests</a></dt><dt>378. <a href="#testKitFunctionalTestSpockClassesTestConfig">Injecting the code under test classes into test builds</a></dt><dt>379. <a href="#testKitFunctionalTestSpockClassesTestConfigGradleVersionPrior2Dot8">Injecting the code under test classes into test builds for Gradle versions prior to 2.8</a></dt><dt>380. <a href="#testKitFunctionalTestSpockAutomaticClasspath">Using the Java Gradle Development plugin for generating the plugin metadata</a></dt><dt>381. <a href="#testKitFunctionalTestSpockAutomaticClassesTestConfig">Automatically injecting the code under test classes into test builds</a></dt><dt>382. <a href="#testKitFunctionalTestSpockAutomaticClasspath">Reconfiguring the classpath generation conventions of the Java Gradle Development plugin</a></dt><dt>383. <a href="#testKitFunctionalTestSpockGradleDistribution">Specifying a Gradle version for test execution</a></dt><dt>384. <a href="#testKitFunctionalTestSpockBuildCache">Testing cacheable tasks</a></dt><dt>385. <a href="#javaQuickstart">Using the Java plugin</a></dt><dt>386. <a href="#javaQuickstart">Building a Java project</a></dt><dt>387. <a href="#javaQuickstart">Adding Maven repository</a></dt><dt>388. <a href="#javaQuickstart">Adding dependencies</a></dt><dt>389. <a href="#javaQuickstart">Customization of MANIFEST.MF</a></dt><dt>390. <a href="#javaQuickstart">Adding a test system property</a></dt><dt>391. <a href="#javaQuickstart">Publishing the JAR file</a></dt><dt>392. <a href="#javaQuickstart">Eclipse plugin</a></dt><dt>393. <a href="#javaQuickstart">Java example - complete build file</a></dt><dt>394. <a href="#javaMultiProject">Multi-project build - hierarchical layout</a></dt><dt>395. <a href="#javaMultiProject">Multi-project build - settings.gradle file</a></dt><dt>396. <a href="#javaMultiProject">Multi-project build - common configuration</a></dt><dt>397. <a href="#javaMultiProject">Multi-project build - dependencies between projects</a></dt><dt>398. <a href="#javaMultiProject">Multi-project build - distribution file</a></dt><dt>399. <a href="#useJavaPlugin">Using the Java plugin</a></dt><dt>400. <a href="#customJavaSourceLayout">Custom Java source layout</a></dt><dt>401. <a href="#defineSourceSet">Accessing a source set</a></dt><dt>402. <a href="#configureSourceSet">Configuring the source directories of a source set</a></dt><dt>403. <a href="#defineSourceSet">Defining a source set</a></dt><dt>404. <a href="#sourceSetDependencies">Defining source set dependencies</a></dt><dt>405. <a href="#compileSourceSet">Compiling a source set</a></dt><dt>406. <a href="#configureSourceSet">Assembling a JAR for a source set</a></dt><dt>407. <a href="#configureSourceSet">Generating the Javadoc for a source set</a></dt><dt>408. <a href="#configureSourceSet">Running tests in a source set</a></dt><dt>409. <a href="#annotationProcessing">Declaring annotation processors</a></dt><dt>410. <a href="#testfiltering">Filtering tests in the build script</a></dt><dt>411. <a href="#junitcategories">JUnit Categories</a></dt><dt>412. <a href="#testnggrouping">Grouping TestNG tests</a></dt><dt>413. <a href="#testngpreserveorder">Preserving order of TestNG tests</a></dt><dt>414. <a href="#testnggroupbyinstances">Grouping TestNG tests by instances</a></dt><dt>415. <a href="#subProjectsTestReport">Creating a unit test report for subprojects</a></dt><dt>416. <a href="#manifest">Customization of MANIFEST.MF</a></dt><dt>417. <a href="#manifest">Creating a manifest object.</a></dt><dt>418. <a href="#manifest">Separate MANIFEST.MF for a particular archive</a></dt><dt>419. <a href="#manifest">Saving a MANIFEST.MF to disk</a></dt><dt>420. <a href="#javaCrossCompilation">Configure Java 6 build</a></dt><dt>421. <a href="#useJavaLibraryPlugin">Using the Java Library plugin</a></dt><dt>422. <a href="#useJavaLibraryPlugin">Declaring API and implementation dependencies</a></dt><dt>423. <a href="#useJavaLibraryPlugin">Making the difference between API and implementation</a></dt><dt>424. <a href="#useJavaLibraryPlugin">Declaring API and implementation dependencies</a></dt><dt>425. <a href="#useGroovyPlugin">Configuring the Groovy plugin to work with Java Library</a></dt><dt>426. <a href="#webQuickstart">War plugin</a></dt><dt>427. <a href="#webQuickstart">Running web application with Gretty plugin</a></dt><dt>428. <a href="#useWarPlugin">Using the War plugin</a></dt><dt>429. <a href="#webproject">Customization of war plugin</a></dt><dt>430. <a href="#earWithWar">Using the Ear plugin</a></dt><dt>431. <a href="#earCustomized">Customization of ear plugin</a></dt><dt>432. <a href="#useApplicationPlugin">Using the application plugin</a></dt><dt>433. <a href="#useApplicationPlugin">Configure the application main class</a></dt><dt>434. <a href="#configureApplicationDefaultJvmArgs">Configure default JVM settings</a></dt><dt>435. <a href="#configureApplicationDefaultJvmArgs">Configure custom directory for start scripts</a></dt><dt>436. <a href="#includeTaskOutputInApplicationDistribution">Include output from other tasks in the application distribution</a></dt><dt>437. <a href="#dependentTaskForApplicationDistributionOutput">Automatically creating files for distribution</a></dt><dt>438. <a href="#usejavaLibraryPlugin">Using the Java library distribution plugin</a></dt><dt>439. <a href="#useApplicationPlugin">Configure the distribution name</a></dt><dt>440. <a href="#includeTaskOutputInApplicationDistribution">Include files in the distribution</a></dt><dt>441. <a href="#groovyQuickstart">Groovy plugin</a></dt><dt>442. <a href="#groovyQuickstart">Dependency on Groovy</a></dt><dt>443. <a href="#groovyQuickstart">Groovy example - complete build file</a></dt><dt>444. <a href="#useGroovyPlugin">Using the Groovy plugin</a></dt><dt>445. <a href="#customGroovySourceLayout">Custom Groovy source layout</a></dt><dt>446. <a href="#quickstartGroovyDependency">Configuration of Groovy dependency</a></dt><dt>447. <a href="#groovyTestDependency">Configuration of Groovy test dependency</a></dt><dt>448. <a href="#bundledGroovyDependency">Configuration of bundled Groovy dependency</a></dt><dt>449. <a href="#groovyFileDependency">Configuration of Groovy file dependency</a></dt><dt>450. <a href="#groovyCrossCompilation">Configure Java 6 build for Groovy</a></dt><dt>451. <a href="#useScalaPlugin">Using the Scala plugin</a></dt><dt>452. <a href="#customScalaSourceLayout">Custom Scala source layout</a></dt><dt>453. <a href="#declareScalaDependency">Declaring a Scala dependency for production code</a></dt><dt>454. <a href="#declareScalaTestDependency">Declaring a Scala dependency for test code</a></dt><dt>455. <a href="#declareZincDependency">Declaring a version of the Zinc compiler to use</a></dt><dt>456. <a href="#allScalaLibraryDependency">Forcing a scala-library dependency for all configurations</a></dt><dt>457. <a href="#zincScalaLibraryDependency">Forcing a scala-library dependency for the zinc configuration</a></dt><dt>458. <a href="#zinc">Adjusting memory settings</a></dt><dt>459. <a href="#zinc">Forcing all code to be compiled</a></dt><dt>460. <a href="#scalaCrossCompilation">Configure Java 6 build for Scala</a></dt><dt>461. <a href="#ideaTargetVersion">Explicitly specify a target IntelliJ IDEA version</a></dt><dt>462. <a href="#useAntlrPlugin">Using the ANTLR plugin</a></dt><dt>463. <a href="#declareAntlrVersion">Declare ANTLR version</a></dt><dt>464. <a href="#advanced">setting custom max heap size and extra arguments for ANTLR</a></dt><dt>465. <a href="#useCheckstylePlugin">Using the Checkstyle plugin</a></dt><dt>466. <a href="#useConfigLoc">Using the config_loc property</a></dt><dt>467. <a href="#customizeCheckstyleReport">Customizing the HTML report</a></dt><dt>468. <a href="#useCodeNarcPlugin">Using the CodeNarc plugin</a></dt><dt>469. <a href="#useFindBugsPlugin">Using the FindBugs plugin</a></dt><dt>470. <a href="#customizeFindbugsReport">Customizing the HTML report</a></dt><dt>471. <a href="#useJDependPlugin">Using the JDepend plugin</a></dt><dt>472. <a href="#usePmdPlugin">Using the PMD plugin</a></dt><dt>473. <a href="#applyJacoco">Applying the JaCoCo plugin</a></dt><dt>474. <a href="#configJacoco">Configuring JaCoCo plugin settings</a></dt><dt>475. <a href="#configJacocoReport">Configuring test task</a></dt><dt>476. <a href="#configViolationRules">Configuring violation rules</a></dt><dt>477. <a href="#jacocotesttast">Configuring test task</a></dt><dt>478. <a href="#jacoco-application-setup">Using application plugin to generate code coverage data</a></dt><dt>479. <a href="#jacoco-application-output">Coverage reports generated by applicationCodeCoverageReport</a></dt><dt>480. <a href="#useOsgiPlugin">Using the OSGi plugin</a></dt><dt>481. <a href="#osgi">Configuration of OSGi MANIFEST.MF file</a></dt><dt>482. <a href="#useEclipsePlugin">Using the Eclipse plugin</a></dt><dt>483. <a href="#useEclipseWtpPlugin">Using the Eclipse WTP plugin</a></dt><dt>484. <a href="#partialOverwrites">Partial Overwrite for Classpath</a></dt><dt>485. <a href="#partialOverwritesProject">Partial Overwrite for Project</a></dt><dt>486. <a href="#exportDependencies">Export Classpath Entries</a></dt><dt>487. <a href="#wtpWithXml">Customizing the XML</a></dt><dt>488. <a href="#useIdeaPlugin">Using the IDEA plugin</a></dt><dt>489. <a href="#partialRewrites">Partial Rewrite for Module</a></dt><dt>490. <a href="#partialRewritesProject">Partial Rewrite for Project</a></dt><dt>491. <a href="#exportDependencies">Export Dependencies</a></dt><dt>492. <a href="#projectWithXml">Customizing the XML</a></dt><dt>493. <a href="#basicRuleSourcePlugin-all">applying a rule source plugin</a></dt><dt>494. <a href="#basicRuleSourcePlugin">a model creation rule</a></dt><dt>495. <a href="#basicRuleSourcePlugin">a model mutation rule</a></dt><dt>496. <a href="#basicRuleSourcePlugin">creating a task</a></dt><dt>497. <a href="#basicRuleSourcePlugin">a managed type</a></dt><dt>498. <a href="#basicRuleSourcePlugin">a String property</a></dt><dt>499. <a href="#basicRuleSourcePlugin">a File property</a></dt><dt>500. <a href="#basicRuleSourcePlugin">a Long property</a></dt><dt>501. <a href="#basicRuleSourcePlugin">a boolean property</a></dt><dt>502. <a href="#basicRuleSourcePlugin">an int property</a></dt><dt>503. <a href="#basicRuleSourcePlugin">a managed property</a></dt><dt>504. <a href="#basicRuleSourcePlugin">an enumeration type property</a></dt><dt>505. <a href="#basicRuleSourcePlugin">a managed set</a></dt><dt>506. <a href="#basicRuleSourcePlugin">a scalar collection</a></dt><dt>507. <a href="#model-language-support-all">strongly modelling sources sets</a></dt><dt>508. <a href="#ruleSourcePluginEach">a DSL example applying a rule to every element in a scope</a></dt><dt>509. <a href="#modelDslConfigure">DSL configuration rule</a></dt><dt>510. <a href="#modelDslConfigureRuleRunWhenRequired">Configuration run when required</a></dt><dt>511. <a href="#modelDslConfigureRuleNotRunWhenNotRequired">Configuration not run when not required</a></dt><dt>512. <a href="#modelDslCreate">DSL creation rule</a></dt><dt>513. <a href="#modelDslCreateNoConfig">DSL creation rule without initialization</a></dt><dt>514. <a href="#modelDslInitializationRuleRunsBeforeConfigurationRule">Initialization before configuration</a></dt><dt>515. <a href="#modelDslModelMapNestedCreate">Nested DSL creation rule</a></dt><dt>516. <a href="#modelDslModelMapNestedConfig">Nested DSL configuration rule</a></dt><dt>517. <a href="#modelDslModelMapNestedAll">DSL configuration rule for each element in a map</a></dt><dt>518. <a href="#modelDslManagedTypeNestedConfigure">Nested DSL property configuration</a></dt><dt>519. <a href="#modelDslConversions">a DSL example showing type conversions</a></dt><dt>520. <a href="#modelDslRuleInputs">a DSL rule using inputs</a></dt><dt>521. <a href="#basicRuleSourcePlugin-model-task">model task output</a></dt><dt>522. <a href="#javaLibraryQuickstart">Using the Java software plugins</a></dt><dt>523. <a href="#javaLibraryQuickstart">Creating a java library</a></dt><dt>524. <a href="#javaLibraryQuickstart">Configuring a source set</a></dt><dt>525. <a href="#javaLibraryQuickstart">Creating a new source set</a></dt><dt>526. <a href="#javaLibraryComponentReport">The components report</a></dt><dt>527. <a href="#javaLibraryMultiComponents">Declaring a dependency onto a library</a></dt><dt>528. <a href="#javaLibraryMultiComponents">Declaring a dependency onto a project with an explicit library</a></dt><dt>529. <a href="#javaLibraryMultiComponents">Declaring a dependency onto a project with an implicit library</a></dt><dt>530. <a href="#javaLibraryMultiComponents">Declaring a dependency onto a library published to a Maven repository</a></dt><dt>531. <a href="#javaLibraryMultiComponents">Declaring a module dependency using shorthand notation</a></dt><dt>532. <a href="#javaLibraryMultiComponents">Configuring repositories for dependency resolution</a></dt><dt>533. <a href="#apiSpecification">Specifying api packages</a></dt><dt>534. <a href="#apiDependencies">Specifying api dependencies</a></dt><dt>535. <a href="#apiSpecification-main-classes">Main sources</a></dt><dt>536. <a href="#apiSpecification-client">Client component</a></dt><dt>537. <a href="#apiSpecification-brokenclient">Broken client component</a></dt><dt>538. <a href="#apiSpecification-client">Making non-API implementation-only change</a></dt><dt>539. <a href="#apiSpecification-client">Recompiling the client</a></dt><dt>540. <a href="#javaLibraryTargetPlatforms">Declaring target platforms</a></dt><dt>541. <a href="#javaLibraryTargetPlatforms-java6MainJar">Declaring binary specific sources</a></dt><dt>542. <a href="#javaLibraryTargetPlatforms-server">Declaring target platforms</a></dt><dt>543. <a href="#testing-junit-standalone">Using the JUnit plugin</a></dt><dt>544. <a href="#testing-junit-standalone-run">Executing the test suite</a></dt><dt>545. <a href="#testing-junit-standalone-resources">Executing the test suite</a></dt><dt>546. <a href="#testing-junit-component-under-test">Declaring a component under test</a></dt><dt>547. <a href="#javaLibraryPlugin/toolchains">Declaring local Java installations</a></dt><dt>548. <a href="#usePlayPlugin">Using the Play plugin</a></dt><dt>549. <a href="#playComponentReport">The components report</a></dt><dt>550. <a href="#specifyPlayVersion">Selecting a version of the Play Framework</a></dt><dt>551. <a href="#addPlayDependencies">Adding dependencies to a Play application</a></dt><dt>552. <a href="#play26Project">A Play 2.6 project</a></dt><dt>553. <a href="#play26ProjectDependencies">Adding Guice dependency in Play 2.6 project</a></dt><dt>554. <a href="#addExtraPlaySourcesets">Configuring extra source sets to a Play application</a></dt><dt>555. <a href="#addExtraPlaySourcesets">Adding extra source sets to a Play application</a></dt><dt>556. <a href="#configureScalaCompiler">Configuring Scala compiler options</a></dt><dt>557. <a href="#configureRoutesCompiler">Configuring routes style</a></dt><dt>558. <a href="#customAssetsPipeline">Configuring a custom asset pipeline</a></dt><dt>559. <a href="#playMultiProjectDependencies">Configuring dependencies on Play subprojects</a></dt><dt>560. <a href="#addFilesToPlayDistribution">Add extra files to a Play application distribution</a></dt><dt>561. <a href="#applyPlayIde">Applying both the Play and IDEA plugins</a></dt><dt>562. <a href="#cppLibraries">Defining a library component</a></dt><dt>563. <a href="#cppExecutables">Defining executable components</a></dt><dt>564. <a href="#nativeDependentComponentsSample">Sample build</a></dt><dt>565. <a href="#nativeDependentComponentsReport">Dependent components report</a></dt><dt>566. <a href="#nativeDependentComponentsReportAll">Dependent components report</a></dt><dt>567. <a href="#nativeAssembleDependentComponentsReport">Report of components that depends on the operators component</a></dt><dt>568. <a href="#nativeBuildDependentComponentsReport">Report of components that depends on the operators component, including test suites</a></dt><dt>569. <a href="#nativeAssembleDependentComponents">Assemble components that depends on the passing/static binary of the operators component</a></dt><dt>570. <a href="#nativeBuildDependentComponents">Build components that depends on the passing/static binary of the operators component</a></dt><dt>571. <a href="#nativeComponentCustomCheck">Adding a custom check task</a></dt><dt>572. <a href="#nativeComponentCustomCheckOutput">Running checks for a given binary</a></dt><dt>573. <a href="#nativeComponentReport">The components report</a></dt><dt>574. <a href="#cppPlugin">The 'cpp' plugin</a></dt><dt>575. <a href="#cppSourceSet">C++ source set</a></dt><dt>576. <a href="#cPlugin">The 'c' plugin</a></dt><dt>577. <a href="#cSourceSet">C source set</a></dt><dt>578. <a href="#assemblerPlugin">The 'assembler' plugin</a></dt><dt>579. <a href="#objectiveCPlugin">The 'objective-c' plugin</a></dt><dt>580. <a href="#objectiveCppPlugin">The 'objective-cpp' plugin</a></dt><dt>581. <a href="#allBinarySettings">Settings that apply to all binaries</a></dt><dt>582. <a href="#allSharedLibraryBinarySettings">Settings that apply to all shared libraries</a></dt><dt>583. <a href="#componentBinarySettings">Settings that apply to all binaries produced for the 'main' executable component</a></dt><dt>584. <a href="#sharedLibraryArgs">Settings that apply only to shared libraries produced for the 'main' library component</a></dt><dt>585. <a href="#windowsResourcesPlugin">The 'windows-resources' plugin</a></dt><dt>586. <a href="#windowsResourceSet">Configuring the location of Windows resource sources</a></dt><dt>587. <a href="#resourceOnlyDll">Building a resource-only dll</a></dt><dt>588. <a href="#cppSourceLibrary">Providing a library dependency to the source set</a></dt><dt>589. <a href="#cppBinaryLibrary">Providing a library dependency to the binary</a></dt><dt>590. <a href="#cppProjectDependencies">Declaring project dependencies</a></dt><dt>591. <a href="#preCompiledHeaderFile">Creating a precompiled header file</a></dt><dt>592. <a href="#preCompiledHeaderFile">Including a precompiled header file in a source file</a></dt><dt>593. <a href="#preCompiledHeaderConfig">Configuring a precompiled header</a></dt><dt>594. <a href="#buildTypes">Defining build types</a></dt><dt>595. <a href="#buildTypeConfig">Configuring debug binaries</a></dt><dt>596. <a href="#platforms">Defining platforms</a></dt><dt>597. <a href="#flavors">Defining flavors</a></dt><dt>598. <a href="#targets">Targeting a component at particular platforms</a></dt><dt>599. <a href="#buildable">Building all possible variants</a></dt><dt>600. <a href="#toolChains">Defining tool chains</a></dt><dt>601. <a href="#withArguments">Reconfigure tool arguments</a></dt><dt>602. <a href="#targetPlatforms">Defining target platforms</a></dt><dt>603. <a href="#cunitSources">Registering CUnit tests</a></dt><dt>604. <a href="#cunitSources">Configuring CUnit tests</a></dt><dt>605. <a href="#completeCUnitExample">Running CUnit tests</a></dt><dt>606. <a href="#googleTestSources">Registering GoogleTest tests</a></dt><dt>607. <a href="#sm-extensible-build-script">an example of using a custom software model</a></dt><dt>608. <a href="#component-declaration">Declare a custom component</a></dt><dt>609. <a href="#component-registration">Register a custom component</a></dt><dt>610. <a href="#binary-declaration">Declare a custom binary</a></dt><dt>611. <a href="#binary-registration">Register a custom binary</a></dt><dt>612. <a href="#markdown-lang-declaration">Declare a custom source set</a></dt><dt>613. <a href="#markdown-lang-registration">Register a custom source set</a></dt><dt>614. <a href="#binaries-gen">Generates documentation binaries</a></dt><dt>615. <a href="#text-tasks-gen">Generates tasks for text source sets</a></dt><dt>616. <a href="#markdown-tasks-gen">Register a custom source set</a></dt><dt>617. <a href="#sm-extensible-build-script-re">an example of using a custom software model</a></dt><dt>618. <a href="#softwareModelExtend-components">components report</a></dt><dt>619. <a href="#iv-type-declaration">public type and internal view declaration</a></dt><dt>620. <a href="#iv-type-registration">type registration</a></dt><dt>621. <a href="#iv-view-mutation">public and internal data mutation</a></dt><dt>622. <a href="#softwareModelExtend-iv-model">example build script and model report output</a></dt><dt>623. <a href="#moduleDependencies">Module dependencies</a></dt><dt>624. <a href="#file-dependencies">File dependencies</a></dt><dt>625. <a href="#generatedFileDependencies">Generated file dependencies</a></dt><dt>626. <a href="#project-dependencies">Project dependencies</a></dt><dt>627. <a href="#gradle-api-dependencies">Gradle API dependencies</a></dt><dt>628. <a href="#gradle-testkit-dependencies">Gradle TestKit dependencies</a></dt><dt>629. <a href="#local-groovy-dependencies">Gradle's Groovy dependencies</a></dt><dt>630. <a href="#flatDirMulti">Flat repository resolver</a></dt><dt>631. <a href="#mavenCentral">Adding central Maven repository</a></dt><dt>632. <a href="#mavenJcenter">Adding Bintray's JCenter Maven repository</a></dt><dt>633. <a href="#mavenGoogleRepo">Adding Google Maven repository</a></dt><dt>634. <a href="#mavenLocalRepo">Adding the local Maven cache as a repository</a></dt><dt>635. <a href="#mavenLikeRepo">Adding custom Maven repository</a></dt><dt>636. <a href="#mavenLikeRepoWithJarRepo">Adding additional Maven repositories for JAR files</a></dt><dt>637. <a href="#mavenPasswordProtectedRepo">Accessing password-protected Maven repository</a></dt><dt>638. <a href="#ivyRepository">Ivy repository</a></dt><dt>639. <a href="#ivyRepository">Ivy repository with named layout</a></dt><dt>640. <a href="#ivyRepository">Ivy repository with pattern layout</a></dt><dt>641. <a href="#ivyRepository">Ivy repository with multiple custom patterns</a></dt><dt>642. <a href="#ivyRepository">Ivy repository with Maven compatible layout</a></dt><dt>643. <a href="#ivyRepository">Ivy repository with authentication</a></dt><dt>644. <a href="#mavenIvyRepositoriesNoAuth">Declaring a Maven and Ivy repository</a></dt><dt>645. <a href="#mavenIvyRepositoriesAuth">Using the SFTP protocol for a repository</a></dt><dt>646. <a href="#mavenIvyS3RepositoriesAuth">Declaring a S3 backed Maven and Ivy repository</a></dt><dt>647. <a href="#mavenIvyS3RepositoriesAuthWithIam">Declaring a S3 backed Maven and Ivy repository using IAM</a></dt><dt>648. <a href="#mavenIvyGCSRepositoriesAuthDefault">Declaring a Google Cloud Storage backed Maven and Ivy repository using default application credentials</a></dt><dt>649. <a href="#digestAuthentication">Configure repository to use only digest authentication</a></dt><dt>650. <a href="#preemptiveAuthentication">Configure repository to use preemptive authentication</a></dt><dt>B.1. <a href="#scope">Variables scope: local and script wide</a></dt><dt>B.2. <a href="#mkdirTrap">Distinct configuration and execution phase</a></dt></dl></div><div class="part" title="About Gradle"><div class="titlepage"><div><div><h1 class="title"><a name="N1001E"></a>About Gradle</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="introduction"></a>Introduction</h1></div></div></div><p>We would like to introduce Gradle to you, a build system that we think is a quantum leap for build technology in the Java (JVM) world. Gradle provides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A very flexible general purpose build tool like Ant.</p></li><li class="listitem"><p>Switchable, build-by-convention frameworks a la Maven. But we never lock you in!</p></li><li class="listitem"><p>Very powerful support for multi-project builds.</p></li><li class="listitem"><p>Very powerful dependency management (based on Apache Ivy).</p></li><li class="listitem"><p>Full support for your existing Maven or Ivy repository infrastructure.</p></li><li class="listitem"><p>Support for transitive dependency management without the need for remote repositories or <code class="literal">pom.xml</code> and <code class="literal">ivy.xml</code> files.</p></li><li class="listitem"><p>Ant tasks and builds as first class citizens.</p></li><li class="listitem"><p><span class="emphasis"><em>Groovy</em></span> build scripts.</p></li><li class="listitem"><p>A rich domain model for describing your build.</p></li></ul></div><p>In <a class="xref" href="#overview"><i>Overview</i></a> you will find a detailed overview of Gradle. Otherwise, the <a class="ulink" href="https://guides.gradle.org" target="_top">guides</a> are waiting, have fun :)</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:about_this_user_guide" class="section-anchor" href="#sec:about_this_user_guide"></a>About this user guide</h2></div></div></div><p>This user guide, like Gradle itself, is under very active development. Some parts of Gradle aren&rsquo;t documented as completely as they need to be. Some of the content presented won&rsquo;t be entirely clear or will assume that you know more about Gradle than you do. We need your help to improve this user guide. You can find out more about contributing to the documentation at the <a class="ulink" href="http://www.gradle.org/contribute" target="_top">Gradle web site</a>.</p><p>Throughout the user guide, you will find some diagrams that represent dependency relationships between Gradle tasks. These use something analogous to the UML dependency notation, which renders an arrow from one task to the task that the first task depends on.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="overview"></a>Overview</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:special_feature_of_gradle" class="section-anchor" href="#sec:special_feature_of_gradle"></a>Features</h2></div></div></div><p>Here is a list of some of Gradle&rsquo;s features.</p><div class="variablelist"><dl><dt><span class="term">Declarative builds and build-by-convention</span></dt><dd><p>At the heart of Gradle lies a rich extensible Domain Specific Language (DSL) based on Groovy. Gradle pushes declarative builds to the next level by providing declarative language elements that you can assemble as you like. Those elements also provide build-by-convention support for Java, Groovy, OSGi, Web and Scala projects. Even more, this declarative language is extensible. Add your own new language elements or enhance the existing ones, thus providing concise, maintainable and comprehensible builds.</p></dd><dt><span class="term">Language for dependency based programming</span></dt><dd><p>The declarative language lies on top of a general purpose task graph, which you can fully leverage in your builds. It provides utmost flexibility to adapt Gradle to your unique needs.</p></dd><dt><span class="term">Structure your build</span></dt><dd><p>The suppleness and richness of Gradle finally allows you to apply common design principles to your build. For example, it is very easy to compose your build from reusable pieces of build logic. Inline stuff where unnecessary indirections would be inappropriate. Don&rsquo;t be forced to tear apart what belongs together (e.g. in your project hierarchy). Avoid smells like shotgun changes or divergent change that turn your build into a maintenance nightmare. At last you can create a well structured, easily maintained, comprehensible build.</p></dd><dt><span class="term">Deep API</span></dt><dd><p>From being a pleasure to be used embedded to its many hooks over the whole lifecycle of build execution, Gradle allows you to monitor and customize its configuration and execution behavior to its very core.</p></dd><dt><span class="term">Gradle scales</span></dt><dd><p>Gradle scales very well. It significantly increases your productivity, from simple single project builds up to huge enterprise multi-project builds. This is true for structuring the build. With the state-of-art incremental build function, this is also true for tackling the performance pain many large enterprise builds suffer from.</p></dd><dt><span class="term">Multi-project builds</span></dt><dd><p>Gradle&rsquo;s support for multi-project build is outstanding. Project dependencies are first class citizens. We allow you to model the project relationships in a multi-project build as they really are for your problem domain. Gradle follows your layout not vice versa.</p><p>Gradle provides partial builds. If you build a single subproject Gradle takes care of building all the subprojects that subproject depends on. You can also choose to rebuild the subprojects that depend on a particular subproject. Together with incremental builds this is a big time saver for larger builds.</p></dd><dt><span class="term">Many ways to manage your dependencies</span></dt><dd><p>Different teams prefer different ways to manage their external dependencies. Gradle provides convenient support for any strategy. From transitive dependency management with remote Maven and Ivy repositories to jars or directories on the local file system.</p></dd><dt><span class="term">Gradle is the first build integration tool</span></dt><dd><p>Ant tasks are first class citizens. Even more interesting, Ant projects are first class citizens as well. Gradle provides a deep import for any Ant project, turning Ant targets into native Gradle tasks at runtime. You can depend on them from Gradle, you can enhance them from Gradle, you can even declare dependencies on Gradle tasks in your build.xml. The same integration is provided for properties, paths, etc &hellip;</p><p>Gradle fully supports your existing Maven or Ivy repository infrastructure for publishing and retrieving dependencies. Gradle also provides a converter for turning a Maven <code class="literal">pom.xml</code> into a Gradle script. Runtime imports of Maven projects will come soon.</p></dd><dt><span class="term">Ease of migration</span></dt><dd><p>Gradle can adapt to any structure you have. Therefore you can always develop your Gradle build in the same branch where your production build lives and both can evolve in parallel. We usually recommend to write tests that make sure that the produced artifacts are similar. That way migration is as less disruptive and as reliable as possible. This is following the best-practices for refactoring by applying baby steps.</p></dd><dt><span class="term">Groovy</span></dt><dd><p>Gradle&rsquo;s build scripts are written in Groovy, not XML. But unlike other approaches this is not for simply exposing the raw scripting power of a dynamic language. That would just lead to a very difficult to maintain build. The whole design of Gradle is oriented towards being used as a language, not as a rigid framework. And Groovy is our glue that allows you to tell your individual story with the abstractions Gradle (or you) provide. Gradle provides some standard stories but they are not privileged in any form. This is for us a major distinguishing feature compared to other declarative build systems. Our Groovy support is not just sugar coating. The whole Gradle API is fully Groovy-ized. Adding Groovy results in an enjoyable and productive experience.</p></dd><dt><span class="term">The Gradle wrapper</span></dt><dd><p>The Gradle Wrapper allows you to execute Gradle builds on machines where Gradle is not installed. This is useful for example for some continuous integration servers. It is also useful for an open source project to keep the barrier low for building it. The wrapper is also very interesting for the enterprise. It is a zero administration approach for the client machines. It also enforces the usage of a particular Gradle version thus minimizing support issues.</p></dd><dt><span class="term">Free and open source</span></dt><dd><p>Gradle is an open source project, and is licensed under the <a class="ulink" href="http://www.gradle.org/license" target="_top">ASL</a>.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:why_groovy" class="section-anchor" href="#sec:why_groovy"></a>Why Groovy?</h2></div></div></div><p>We think the advantages of an internal DSL (based on a dynamic language) over XML are tremendous when used in <span class="emphasis"><em>build scripts</em></span>. There are a couple of dynamic languages out there. Why Groovy? The answer lies in the context Gradle is operating in. Although Gradle is a general purpose build tool at its core, its main focus are Java projects. In such projects the team members will be very familiar with Java. We think a build should be as transparent as possible to <span class="emphasis"><em>all</em></span> team members.</p><p>In that case, you might argue why we don&rsquo;t just use Java as the language for build scripts. We think this is a valid question. It would have the highest transparency for your team and the lowest learning curve, but because of the limitations of Java, such a build language would not be as nice, expressive and powerful as it could be.<sup>[<a href="#ftn.N100CE" name="N100CE" class="footnote">1</a>]</sup> Languages like Python, Groovy or Ruby do a much better job here. We have chosen Groovy as it offers by far the greatest transparency for Java people. Its base syntax is the same as Java&rsquo;s as well as its type system, its package structure and other things. Groovy provides much more on top of that, but with the common foundation of Java.</p><p>For Java developers with Python or Ruby knowledge or the desire to learn them, the above arguments don&rsquo;t apply. The Gradle design is well-suited for creating another build script engine in JRuby or Jython. It just doesn&rsquo;t have the highest priority for us at the moment. We happily support any community effort to create additional build script engines.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N100CE" name="ftn.N100CE" class="para">1</a>] </sup>At <a class="ulink" href="http://www.defmacro.org/ramblings/lisp.html" target="_top">http://www.defmacro.org/ramblings/lisp.html</a> you find an interesting article comparing Ant, XML, Java and Lisp. It&rsquo;s funny that the 'if Java had that syntax' syntax in this article is actually the Groovy syntax.</p></div></div></div></div><div class="part" title="Working with existing builds"><div class="titlepage"><div><div><h1 class="title"><a name="N100D8"></a>Working with existing builds</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="installation"></a>Installing Gradle</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:prerequisites" class="section-anchor" href="#sec:prerequisites"></a>Prerequisites</h2></div></div></div><p>Gradle requires a Java JDK or JRE to be installed, version 7 or higher (to check, use <code class="literal">java -version</code>). Gradle ships with its own Groovy library, therefore Groovy does not need to be installed. Any existing Groovy installation is ignored by Gradle.</p><p>Gradle uses whatever JDK it finds in your path. Alternatively, you can set the <code class="literal">JAVA_HOME</code> environment variable to point to the installation directory of the desired JDK.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:download" class="section-anchor" href="#sec:download"></a>Download</h2></div></div></div><p>You can download one of the Gradle distributions from the <a class="ulink" href="http://www.gradle.org/downloads" target="_top">Gradle web site</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:unpacking" class="section-anchor" href="#sec:unpacking"></a>Unpacking</h2></div></div></div><p>The Gradle distribution comes packaged as a ZIP. The full distribution contains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Gradle binaries.</p></li><li class="listitem"><p>The user guide (HTML and PDF).</p></li><li class="listitem"><p>The DSL reference guide.</p></li><li class="listitem"><p>The API documentation (Javadoc).</p></li><li class="listitem"><p>Extensive samples, including the examples referenced in the user guide, along with some complete and more complex builds you can use as a starting point for your own build.</p></li><li class="listitem"><p>The binary sources. This is for reference only. If you want to build Gradle you need to download the source distribution or checkout the sources from the source repository. See the <a class="ulink" href="http://www.gradle.org/development" target="_top">Gradle web site</a> for details.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:installation_environment_variables" class="section-anchor" href="#sec:installation_environment_variables"></a>Environment variables</h2></div></div></div><p>For running Gradle, firstly add the environment variable <code class="literal">GRADLE_HOME</code>. This should point to the unpacked files from the Gradle website. Next add <code class="literal"><span class="emphasis"><em>GRADLE_HOME</em></span>/bin</code> to your <code class="literal">PATH</code> environment variable. Usually, this is sufficient to run Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:running_and_testing_your_installation" class="section-anchor" href="#sec:running_and_testing_your_installation"></a>Running and testing your installation</h2></div></div></div><p>You run Gradle via the <code class="literal">gradle</code> command. To check if Gradle is properly installed just type <code class="literal">gradle -v</code>. The output shows the Gradle version and also the local environment configuration (Groovy, JVM version, OS, etc.). The displayed Gradle version should match the distribution you have downloaded.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jvm_options" class="section-anchor" href="#sec:jvm_options"></a>JVM options</h2></div></div></div><p>JVM options for running Gradle can be set via environment variables. You can use either <code class="literal">GRADLE_OPTS</code> or <code class="literal">JAVA_OPTS</code>, or both. <code class="literal">JAVA_OPTS</code> is by convention an environment variable shared by many Java applications. A typical use case would be to set the HTTP proxy in <code class="literal">JAVA_OPTS</code> and the memory options in <code class="literal">GRADLE_OPTS</code>. Those variables can also be set at the beginning of the <code class="literal">gradle</code> or <code class="literal">gradlew</code> script.</p><p>Note that it&rsquo;s not currently possible to set JVM options for Gradle on the command line.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="command_line_interface"></a>Command-Line Interface</h1></div></div></div><p>The command-line interface is one of the primary methods of interacting with Gradle. The following serves as a reference of executing and customizing Gradle use of a command-line or when writing scripts or configuring continuous integration.</p><p>Use of the <a class="link" href="#gradle_wrapper">Gradle Wrapper</a> is highly encouraged. You should substitute <code class="literal">./gradlew</code> or <code class="literal">gradlew.bat</code> for <code class="literal">gradle</code> in all following examples when using the Wrapper.</p><p>Executing Gradle on the command-line conforms to the following structure. Options are allowed before and after task names.</p><pre class="screen">gradle [taskName...] [--option-name...]</pre><p>If multiple tasks are specified, they should be separated with a space.</p><p>Options that accept values can be specified with or without <code class="literal">=</code> between the option and argument; however, use of <code class="literal">=</code> is recommended.</p><pre class="screen">--console=plain</pre><p>Options that enable behavior have long-form options with inverses specified with <code class="literal">--no-</code>. The following are opposites.</p><pre class="screen">--build-cache
--no-build-cache</pre><p>Many long-form options, have short option equivalents. The following are equivalent:</p><pre class="screen">--help
-h</pre><div class="note"><p>Many command-line flags can be specified in <code class="literal">gradle.properties</code> to avoid needing to be typed. See the <a class="link" href="#sec:gradle_configuration_properties">configuring build environment guide</a> for details.</p></div><p>The following sections describe use of the Gradle command-line interface, grouped roughly by user goal. Some plugins also add their own command line options, for example <a class="link" href="#test_filtering"><code class="literal">--tests</code> for Java test filtering</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_executing_tasks" class="section-anchor" href="#sec:command_line_executing_tasks"></a>Executing tasks</h2></div></div></div><p>You can run a task and all of its <a class="link" href="#sec:task_dependencies">dependencies</a>.</p><pre class="screen"> gradle myTask</pre><p>You can learn about what projects and tasks are available in the <a class="link" href="#sec:command_line_project_reporting">project reporting section</a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_tasks_in_multi_project_builds" class="section-anchor" href="#_executing_tasks_in_multi_project_builds"></a>Executing tasks in multi-project builds</h3></div></div></div><p>In a <a class="link" href="#intro_multi_project_builds">multi-project build</a>, subproject tasks can be executed with ":" separating subproject name and task name. The following are equivalent <span class="emphasis"><em>when run from the root project</em></span>.</p><pre class="screen"> gradle :mySubproject:taskName
 gradle mySubproject:taskName</pre><p>You can also run a task for all subprojects using the task name only. For example, this will run the "test" task for all subprojects when invoked from the root project directory.</p><pre class="screen"> gradle test</pre><p>When invoking Gradle from within a subproject, the project name should be omitted:</p><pre class="screen"> cd mySubproject
 gradle taskName</pre><div class="note"><p>When executing the Gradle Wrapper from subprojects, one must reference <code class="literal">gradlew</code> relatively. For example: <code class="literal">../gradlew taskName</code>. The community <a class="ulink" href="http://www.gdub.rocks/" target="_top">gdub project</a> aims to make this more convenient.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_executing_multiple_tasks" class="section-anchor" href="#_executing_multiple_tasks"></a>Executing multiple tasks</h3></div></div></div><p>You can also specify multiple tasks. For example, the following will execute the <code class="literal">test</code> and <code class="literal">deploy</code> tasks in the order that they are listed on the command-line and will also execute the dependencies for each task.</p><pre class="screen"> gradle test deploy</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:excluding_tasks_from_the_command_line" class="section-anchor" href="#sec:excluding_tasks_from_the_command_line"></a>Excluding tasks from execution</h3></div></div></div><p>You can exclude a task from being executed using the <code class="literal">-x</code> or <code class="literal">--exclude-task</code> command-line option and providing the name of the task to exclude.</p><div class="figure"><a name="N101E2"></a><p class="title"><b>Figure&nbsp;1.&nbsp;Example Task Graph</b></p><div class="figure-contents"><img src="img/commandLineTutorialTasks.png" alt="Example Task Graph"></div></div><br class="figure-break"><div class="example"><a name="excludeTask"></a><p class="title"><b>Example&nbsp;1.&nbsp;Excluding tasks</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle dist --exclude-task test</code></strong></p><pre class="screen">&gt; gradle dist --exclude-task test
:compile
compiling source
:dist
building the distribution

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>You can see that the <code class="literal">test</code> task is not executed, even though it is a dependency of the <code class="literal">dist</code> task. The <code class="literal">test</code> task&rsquo;s dependencies such as <code class="literal">compileTest</code> are not executed either. Those dependencies of <code class="literal">test</code> that are required by another task, such as <code class="literal">compile</code>, are still executed.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:rerun_tasks" class="section-anchor" href="#sec:rerun_tasks"></a>Forcing tasks to execute</h3></div></div></div><p>You can force Gradle to execute all tasks ignoring <a class="link" href="#sec:up_to_date_checks">up-to-date checks</a> using the <code class="literal">--rerun-tasks</code> option:</p><pre class="screen"> gradle test --rerun-tasks</pre><p>This will force <code class="literal">test</code> and <span class="emphasis"><em>all</em></span> task dependencies of <code class="literal">test</code> to execute. It&rsquo;s a little like running <code class="literal">gradle clean test</code>, but without the build&rsquo;s generated output being deleted.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:continue_build_on_failure" class="section-anchor" href="#sec:continue_build_on_failure"></a>Continuing the build when a failure occurs</h3></div></div></div><p>By default, Gradle will abort execution and fail the build as soon as any task fails. This allows the build to complete sooner, but hides other failures that would have occurred. In order to discover as many failures as possible in a single build execution, you can use the <code class="literal">--continue</code> option.</p><pre class="screen"> gradle test --continue</pre><p>When executed with <code class="literal">--continue</code>, Gradle will execute <span class="emphasis"><em>every</em></span> task to be executed where all of the dependencies for that task completed without failure, instead of stopping as soon as the first failure is encountered. Each of the encountered failures will be reported at the end of the build.</p><p>If a task fails, any subsequent tasks that were depending on it will not be executed. For example, tests will not run if there is a compilation failure in the code under test; because the test task will depend on the compilation task (either directly or indirectly).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_task_name_abbreviation" class="section-anchor" href="#_task_name_abbreviation"></a>Task name abbreviation</h3></div></div></div><p>When you specify tasks on the command-line, you don&rsquo;t have to provide the full name of the task. You only need to provide enough of the task name to uniquely identify the task. For example, it&rsquo;s likely <code class="literal">gradle che</code> is enough for Gradle to identify the <code class="literal">check</code> task.</p><p>You can also abbreviate each word in a camel case task name. For example, you can execute task <code class="literal">compileTest</code> by running <code class="literal">gradle compTest</code> or even <code class="literal">gradle cT</code>.</p><div class="example"><a name="abbreviateCamelCaseTaskName"></a><p class="title"><b>Example&nbsp;2.&nbsp;Abbreviated camel case task name</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle cT</code></strong></p><pre class="screen">&gt; gradle cT
:compile
compiling source
:compileTest
compiling unit tests

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>You can also use these abbreviations with the -x command-line option.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="_common_tasks" class="section-anchor" href="#_common_tasks"></a>Common tasks</h2></div></div></div><p>The following are task conventions applied by built-in and most major Gradle plugins.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_computing_all_outputs" class="section-anchor" href="#_computing_all_outputs"></a>Computing all outputs</h3></div></div></div><p>It is common in Gradle builds for the <code class="literal">build</code> task to designate assembling all outputs and running all checks.</p><pre class="screen"> gradle build</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_applications" class="section-anchor" href="#_running_applications"></a>Running applications</h3></div></div></div><p>It is common for applications to be run with the <code class="literal">run</code> task, which assembles the application and executes some script or binary.</p><pre class="screen"> gradle run</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_running_all_checks" class="section-anchor" href="#_running_all_checks"></a>Running all checks</h3></div></div></div><p>It is common for <span class="emphasis"><em>all</em></span> verification tasks, including tests and linting, to be executed using the <code class="literal">check</code> task.</p><pre class="screen"> gradle check</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_cleaning_outputs" class="section-anchor" href="#_cleaning_outputs"></a>Cleaning outputs</h3></div></div></div><p>You can delete the contents of the build directory using the <code class="literal">clean</code> task, though doing so will cause pre-computed outputs to be lost, causing significant additional build time for the subsequent task execution.</p><pre class="screen"> gradle clean</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_project_reporting" class="section-anchor" href="#sec:command_line_project_reporting"></a>Project reporting</h2></div></div></div><p>Gradle provides several built-in tasks which show particular details of your build. This can be useful for understanding the structure and dependencies of your build, and for debugging problems.</p><p>You can get basic help about available reporting options using <code class="literal">gradle help</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_listing_projects" class="section-anchor" href="#_listing_projects"></a>Listing projects</h3></div></div></div><p>Running <code class="literal">gradle projects</code> gives you a list of the sub-projects of the selected project, displayed in a hierarchy.</p><pre class="screen"> gradle projects</pre><p>You also get a project report within build scans. Learn more about <a class="ulink" href="https://guides.gradle.org/creating-build-scans/" target="_top">creating build scans</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_listing_tasks" class="section-anchor" href="#_listing_tasks"></a>Listing tasks</h3></div></div></div><p>Running <code class="literal">gradle tasks</code> gives you a list of the main tasks of the selected project. This report shows the default tasks for the project, if any, and a description for each task.</p><pre class="screen"> gradle tasks</pre><p>By default, this report shows only those tasks which have been assigned to a task group. You can obtain more information in the task listing using the <code class="literal">--all</code> option.</p><pre class="screen"> gradle tasks --all</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:show_task_details" class="section-anchor" href="#sec:show_task_details"></a>Show task usage details</h3></div></div></div><p>Running <code class="literal">gradle help --task someTask</code> gives you detailed information about a specific task.</p><div class="example"><a name="taskHelp"></a><p class="title"><b>Example&nbsp;3.&nbsp;Obtaining detailed help for tasks</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q help --task libs</code></strong></p><pre class="screen">&gt; gradle -q help --task libs
Detailed task information for libs

Paths
     :api:libs
     :webapp:libs

Type
     Task (org.gradle.api.Task)

Description
     Builds the JAR

Group
     build
</pre></div></div><br class="example-break"><p>This information includes the full task path, the task type, possible command line options and the description of the given task.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_reporting_dependencies" class="section-anchor" href="#_reporting_dependencies"></a>Reporting dependencies</h3></div></div></div><p>Build scans give a full, visual report of what project and binary dependencies exist on which configurations, transitive dependencies, and dependency version selection.</p><pre class="screen"> gradle myTask --scan</pre><p>This will give you a link to a web-based report, where you can find dependency information like this.</p><div class="informalfigure"><div class="mediaobject"><img src="img/gradle-core-test-build-scan-dependencies.png" alt="Build Scan dependencies report"></div></div><p>Learn more in <a class="xref" href="#inspecting_dependencies"><i>Inspecting Dependencies</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_listing_project_dependencies" class="section-anchor" href="#_listing_project_dependencies"></a>Listing project dependencies</h3></div></div></div><p>Running <code class="literal">gradle dependencies</code> gives you a list of the dependencies of the selected project, broken down by configuration. For each configuration, the direct and transitive dependencies of that configuration are shown in a tree. Below is an example of this report:</p><pre class="screen"> gradle dependencies</pre><p>Concrete examples of build scripts and output available in the <a class="xref" href="#inspecting_dependencies"><i>Inspecting Dependencies</i></a>.</p><p>Running <code class="literal">gradle buildEnvironment</code> visualises the buildscript dependencies of the selected project, similarly to how <code class="literal">gradle dependencies</code> visualizes the dependencies of the software being built.</p><pre class="screen"> gradle buildEnvironment</pre><p>Running <code class="literal">gradle dependencyInsight</code> gives you an insight into a particular dependency (or dependencies) that match specified input.</p><pre class="screen"> gradle dependencyInsight</pre><p>Since a dependency report can get large, it can be useful to restrict the report to a particular configuration. This is achieved with the optional <code class="literal">--configuration</code> parameter:</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:listing_properties" class="section-anchor" href="#sec:listing_properties"></a>Listing project properties</h3></div></div></div><p>Running <code class="literal">gradle properties</code> gives you a list of the properties of the selected project.</p><div class="example"><a name="propertyListReport"></a><p class="title"><b>Example&nbsp;4.&nbsp;Information about properties</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q api:properties</code></strong></p><pre class="screen">&gt; gradle -q api:properties

------------------------------------------------------------
Project :api - The shared API for the application
------------------------------------------------------------

allprojects: [project ':api']
ant: org.gradle.api.internal.project.DefaultAntBuilder@12345
antBuilderFactory: org.gradle.api.internal.project.DefaultAntBuilderFactory@12345
artifacts: org.gradle.api.internal.artifacts.dsl.DefaultArtifactHandler_Decorated@12345
asDynamicObject: DynamicObject for project ':api'
baseClassLoaderScope: org.gradle.api.internal.initialization.DefaultClassLoaderScope@12345
buildDir: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build
buildFile: /home/user/gradle/samples/userguide/tutorial/projectReports/api/build.gradle
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_software_model_reports" class="section-anchor" href="#_software_model_reports"></a>Software Model reports</h3></div></div></div><p>You can get a hierarchical view of elements for <a class="link" href="#software_model">software model</a> projects using the <code class="literal">model</code> task:</p><pre class="screen"> gradle model</pre><p>Learn more about <a class="link" href="#model-report">the model report</a> in the software model documentation.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_completion" class="section-anchor" href="#sec:command_line_completion"></a>Command-line completion</h2></div></div></div><p>Gradle provides bash and zsh tab completion support for tasks, options, and Gradle properties through <a class="ulink" href="https://github.com/gradle/gradle-completion" target="_top">gradle-completion</a>, installed separately.</p><div class="figure"><a name="N10342"></a><p class="title"><b>Figure&nbsp;2.&nbsp;Gradle Completion</b></p><div class="figure-contents"><img src="img/gradle-completion-4.0.gif" alt="Gradle Completion"></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_debugging" class="section-anchor" href="#sec:command_line_debugging"></a>Debugging options</h2></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">-?</code>, <code class="literal">-h</code>, <code class="literal">--help</code></span></dt><dd><p>Shows a help message with all available CLI options.</p></dd><dt><span class="term"><code class="literal">-v</code>, <code class="literal">--version</code></span></dt><dd><p>Prints Gradle, Groovy, Ant, JVM, and operating system version information.</p></dd><dt><span class="term"><code class="literal">-S</code>, <code class="literal">--full-stacktrace</code></span></dt><dd><p>Print out the full (very verbose) stacktrace for any exceptions. See also <a class="link" href="#sec:command_line_logging">logging options</a>.</p></dd><dt><span class="term"><code class="literal">-s</code>, <code class="literal">--stacktrace</code></span></dt><dd><p>Print out the stacktrace also for user exceptions (e.g. compile error).  See also <a class="link" href="#sec:command_line_logging">logging options</a>.</p></dd><dt><span class="term"><code class="literal">--scan</code></span></dt><dd><p>Create a <a class="ulink" href="https://gradle.com/build-scans" target="_top">build scan</a> with fine-grained information about all aspects of your Gradle build.</p></dd><dt><span class="term"><code class="literal">-Dorg.gradle.debug=true</code></span></dt><dd><p>Debug Gradle client (non-Daemon) process. Gradle will wait for you to attach a debugger at <code class="literal">localhost:5005</code> by default.</p></dd><dt><span class="term"><code class="literal">-Dorg.gradle.daemon.debug=true</code></span></dt><dd><p>Debug <a class="link" href="#gradle_daemon">Gradle Daemon</a> process.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_performance" class="section-anchor" href="#sec:command_line_performance"></a>Performance options</h2></div></div></div><p>Try these options when optimizing build performance. Learn more about <a class="ulink" href="https://guides.gradle.org/performance/" target="_top">improving performance of Gradle builds here</a>.</p><p>Many of these options can be specified in <code class="literal">gradle.properties</code> so command-line flags are not necessary. See the <a class="link" href="#sec:gradle_configuration_properties">configuring build environment guide</a>.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">--build-cache</code>, <code class="literal">--no-build-cache</code></span></dt><dd><p>Toggles the <a class="link" href="#build_cache">Gradle build cache</a>. Gradle will try to reuse outputs from previous builds. <span class="emphasis"><em>Default is off</em></span>.</p></dd><dt><span class="term"><code class="literal">--configure-on-demand</code>, <code class="literal">--no-configure-on-demand</code></span></dt><dd><p>Toggles <a class="link" href="#sec:configuration_on_demand">Configure-on-demand</a>. Only relevant projects are configured in this build run. <span class="emphasis"><em>Default is off</em></span>.</p></dd><dt><span class="term"><code class="literal">--max-workers</code></span></dt><dd><p>Sets maximum number of workers that Gradle may use. <span class="emphasis"><em>Default is number of processors</em></span>.</p></dd><dt><span class="term"><code class="literal">--parallel</code>, <code class="literal">--no-parallel</code></span></dt><dd><p>Build projects in parallel. For limitations of this option please see <a class="xref" href="#sec:parallel_execution">the section called &ldquo;Parallel project execution&rdquo;</a>. <span class="emphasis"><em>Default is off</em></span>.</p></dd><dt><span class="term"><code class="literal">--profile</code></span></dt><dd><p>Generates a high-level performance report in the <code class="literal">$buildDir/reports/profile</code> directory. <code class="literal">--scan</code> is preferred.</p></dd><dt><span class="term"><code class="literal">--scan</code></span></dt><dd><p>Generate a build scan with detailed performance diagnostics.</p></dd></dl></div><p><span class="inlinemediaobject"><img src="img/gradle-core-test-build-scan-performance.png" alt="Build Scan performance report"></span></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_gradle_daemon_options" class="section-anchor" href="#_gradle_daemon_options"></a>Gradle daemon options</h3></div></div></div><p>You can manage the <a class="link" href="#gradle_daemon">Gradle Daemon</a> through the following command line options.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">--daemon</code>, <code class="literal">--no-daemon</code></span></dt><dd><p>Use the <a class="link" href="#gradle_daemon">Gradle Daemon</a> to run the build. Starts the daemon if not running or existing daemon busy. <span class="emphasis"><em>Default is on</em></span>.</p></dd><dt><span class="term"><code class="literal">--foreground</code></span></dt><dd><p>Starts the Gradle Daemon in a foreground process.</p></dd><dt><span class="term"><code class="literal">--status</code> (Standalone command)</span></dt><dd><p>Run <code class="literal">gradle --status</code> to list running and recently stopped Gradle daemons. Only displays daemons of the same Gradle version.</p></dd><dt><span class="term"><code class="literal">--stop</code> (Standalone command)</span></dt><dd><p>Run <code class="literal">gradle --stop</code> to stop all Gradle Daemons of the same version.</p></dd><dt><span class="term"><code class="literal">-Dorg.gradle.daemon.idletimeout=(number of milliseconds)</code></span></dt><dd><p>Gradle Daemon will stop itself after this number of milliseconds of idle time. <span class="emphasis"><em>Default is 10800000</em></span> (3 hours).</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_logging" class="section-anchor" href="#sec:command_line_logging"></a>Logging options</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_setting_log_level" class="section-anchor" href="#_setting_log_level"></a>Setting log level</h3></div></div></div><p>You can customize the verbosity of Gradle logging with the following options, ordered from least verbose to most verbose. Learn more in the <a class="link" href="#logging">logging documentation</a>.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-Dorg.gradle.logging.level=(quiet,warn,lifecycle,info,debug)</code></span></dt><dd><p>Set logging level via Gradle properties.</p></dd><dt><span class="term"><code class="literal">-q</code>, <code class="literal">--quiet</code></span></dt><dd><p>Log errors only.</p></dd><dt><span class="term"><code class="literal">-w</code>, <code class="literal">--warn</code></span></dt><dd><p>Set log level to warn.</p></dd><dt><span class="term"><code class="literal">-i</code>, <code class="literal">--info</code></span></dt><dd><p>Set log level to info.</p></dd><dt><span class="term"><code class="literal">-d</code>, <code class="literal">--debug</code></span></dt><dd><p>Log in debug mode (includes normal stacktrace).</p></dd></dl></div><p>Lifecycle is the default log level.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_customizing_log_format" class="section-anchor" href="#_customizing_log_format"></a>Customizing log format</h3></div></div></div><p>You can control the use of rich output (colors and font variants) by specifying the "console" mode in the following ways:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-Dorg.gradle.console=(auto,plain,rich,verbose)</code></span></dt><dd><p>Specify console mode via Gradle properties. Different modes described immediately below.</p></dd><dt><span class="term"><code class="literal">--console=(auto,plain,rich,verbose)</code></span></dt><dd><p>Specifies which type of console output to generate.</p><p>Set to <code class="literal">plain</code> to generate plain text only. This option disables all color and other rich output in the console output. This is the default when Gradle is <span class="emphasis"><em>not</em></span> attached to a terminal.</p><p>Set to <code class="literal">auto</code> (the default) to enable color and other rich output in the console output when the build process is attached to a console, or to generate plain text only when not attached to a console. <span class="emphasis"><em>This is the default when Gradle is attached to a terminal.</em></span></p><p>Set to <code class="literal">rich</code> to enable color and other rich output in the console output, regardless of whether the build process is not attached to a console. When not attached to a console, the build output will use ANSI control characters to generate the rich output.</p><p>Set to <code class="literal">verbose</code> to enable color and other rich output like the <code class="literal">rich</code>, but output task names and outcomes at the lifecycle log level, as is done by default in Gradle 3.5 and earlier.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:command_line_warnings" class="section-anchor" href="#sec:command_line_warnings"></a>Showing or hiding warnings</h3></div></div></div><p>By default, Gradle won&rsquo;t display all warnings (e.g. deprecation warnings). Instead, Gradle will collect them and render a summary at the end of the build like:</p><pre class="screen">Deprecated Gradle API and/or features were used in this build, making it incompatible with Gradle 5.0.</pre><p>You can control the verbosity of warnings on the console with the following options:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-Dorg.gradle.warning.mode=(all,none,summary)</code></span></dt><dd><p>Specify warning mode via <a class="link" href="#">Gradle properties</a>. Different modes described immediately below.</p></dd><dt><span class="term"><code class="literal">--warning-mode=(all,none,summary)</code></span></dt><dd><p>Specifies how to log warnings. Default is <code class="literal">summary</code>.</p><p>Set to <code class="literal">all</code> to log all warnings.</p><p>Set to <code class="literal">summary</code> to suppress all warnings and log a summary at the end of the build.</p><p>Set to <code class="literal">none</code> to suppress all warnings, including the summary at the end of the build.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_rich_console" class="section-anchor" href="#_rich_console"></a>Rich Console</h3></div></div></div><p>Gradle&rsquo;s rich console displays extra information while builds are running.</p><div class="informalfigure"><div class="mediaobject"><img src="img/rich-cli.png" alt="Gradle Rich Console"></div></div><p>Features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Logs above grouped by task that generated them</p></li><li class="listitem"><p>Progress bar and timer visually describe overall status</p></li><li class="listitem"><p>Parallel work-in-progress lines below describe what is happening now</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_execution_options" class="section-anchor" href="#sec:command_line_execution_options"></a>Execution options</h2></div></div></div><p>The following options affect how builds are executed, by changing what is built or how dependencies are resolved.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">--include-build</code></span></dt><dd><p>Run the build as a composite, including the specified build. See <a class="link" href="#composite_builds">Composite Builds</a>.</p></dd><dt><span class="term"><code class="literal">--offline</code></span></dt><dd><p>Specifies that the build should operate without accessing network resources. Learn more about <a class="link" href="#sec:controlling_dependency_caching_command_line">options to override dependency caching</a>.</p></dd><dt><span class="term"><code class="literal">--refresh-dependencies</code></span></dt><dd><p>Refresh the state of dependencies. Learn more about how to use this in the <a class="link" href="#sec:controlling_dependency_caching_command_line">dependency management docs</a>.</p></dd><dt><span class="term"><code class="literal">--dry-run</code></span></dt><dd><p>Run Gradle with all task actions disabled. Use this to show which task would have executed.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:command_line_bootstrapping_projects" class="section-anchor" href="#sec:command_line_bootstrapping_projects"></a>Bootstrapping new projects</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_creating_new_gradle_builds" class="section-anchor" href="#_creating_new_gradle_builds"></a>Creating new Gradle builds</h3></div></div></div><p>Use the built-in <code class="literal">gradle init</code> task to create a new Gradle builds, with new or existing projects.</p><pre class="screen"> gradle init</pre><p>Most of the time you&rsquo;ll want to specify a project type. Available types include <code class="literal">basic</code> (default), <code class="literal">java-library</code>, <code class="literal">java-application</code>, and more. See <a class="link" href="#build_init_plugin">init plugin documentation</a> for details.</p><pre class="screen"> gradle init --type java-library</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_standardize_and_provision_gradle" class="section-anchor" href="#_standardize_and_provision_gradle"></a>Standardize and provision Gradle</h3></div></div></div><p>The built-in <code class="literal">gradle wrapper</code> task generates a script, <code class="literal">gradlew</code>, that invokes a declared version of Gradle, downloading it beforehand if necessary.</p><pre class="screen"> gradle wrapper --gradle-version=4.4</pre><p>You can also specify <code class="literal">--distribution-type=(bin|all)</code>, <code class="literal">--gradle-distribution-url</code>, <code class="literal">--gradle-distribution-sha256-sum</code> in addition to <code class="literal">--gradle-version</code>. Full details on how to use these options are documented in the <a class="link" href="#gradle_wrapper">Gradle wrapper section</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="_environment_options" class="section-anchor" href="#_environment_options"></a>Environment options</h2></div></div></div><p>You can customize many aspects about where build scripts, settings, caches, and so on through the options below. Learn more about customizing your <a class="link" href="#build_environment">build environment</a>.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">-b</code>, <code class="literal">--build-file</code></span></dt><dd><p>Specifies the build file. For example: <code class="literal">gradle --build-file=foo.gradle</code>. The default is <code class="literal">build.gradle</code>, then <code class="literal">build.gradle.kts</code>, then <code class="literal">myProjectName.gradle</code>.</p></dd><dt><span class="term"><code class="literal">-c</code>, <code class="literal">--settings-file</code></span></dt><dd><p>Specifies the settings file. For example: <code class="literal">gradle --settings-file=somewhere/else/settings.gradle</code></p></dd><dt><span class="term"><code class="literal">-g</code>, <code class="literal">--gradle-user-home</code></span></dt><dd><p>Specifies the Gradle user home directory. The default is the <code class="literal">.gradle</code> directory in the user&rsquo;s home directory.</p></dd><dt><span class="term"><code class="literal">-p</code>, <code class="literal">--project-dir</code></span></dt><dd><p>Specifies the start directory for Gradle. Defaults to current directory.</p></dd><dt><span class="term"><code class="literal">--project-cache-dir</code></span></dt><dd><p>Specifies the project-specific cache directory. Default value is <code class="literal">.gradle</code> in the root project directory.</p></dd><dt><span class="term"><code class="literal">-u</code>, <code class="literal">--no-search-upward</code> (deprecated)</span></dt><dd><p>Don&rsquo;t search in parent directories for a <code class="literal">settings.gradle</code> file.</p></dd><dt><span class="term"><code class="literal">-D</code>, <code class="literal">--system-prop</code></span></dt><dd><p>Sets a system property of the JVM, for example <code class="literal">-Dmyprop=myvalue</code>. See <a class="xref" href="#sec:gradle_system_properties">the section called &ldquo;System properties&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">-I</code>, <code class="literal">--init-script</code></span></dt><dd><p>Specifies an initialization script. See <a class="xref" href="#init_scripts"><i>Initialization Scripts</i></a>.</p></dd><dt><span class="term"><code class="literal">-P</code>, <code class="literal">--project-prop</code></span></dt><dd><p>Sets a project property of the root project, for example <code class="literal">-Pmyprop=myvalue</code>. See <a class="xref" href="#sec:project_properties">the section called &ldquo;Project properties&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">-Dorg.gradle.jvmargs</code></span></dt><dd><p>Set JVM arguments.</p></dd><dt><span class="term"><code class="literal">-Dorg.gradle.java.home</code></span></dt><dd><p>Set JDK home dir.</p></dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="gradle_wrapper"></a>The Gradle Wrapper</h1></div></div></div><p>The recommended way to execute any Gradle build is with the help of the Gradle Wrapper (in short just &ldquo;Wrapper&rdquo;). The Wrapper is a script that invokes a declared version of Gradle, downloading it beforehand if necessary. As a result, developers can get up and running with a Gradle project quickly without having to follow manual installation processes saving your company time and money.</p><div class="figure"><a name="N10616"></a><p class="title"><b>Figure&nbsp;3.&nbsp;The Wrapper workflow</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="709"><tr><td><img src="img/wrapper-workflow.png" width="709" alt="The Wrapper workflow"></td></tr></table></div></div><br class="figure-break"><p><span class="strong"><strong>In a nutshell you gain the following benefits:</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Standardizes a project on a given Gradle version, leading to more reliable and robust builds.</p></li><li class="listitem"><p>Provisioning a new Gradle version to different users and execution environment (e.g. IDEs or Continuous Integration servers) is as simple as changing the Wrapper definition.</p></li></ul></div><p><span class="strong"><strong>So how does it work? For a user there are typically three different workflows:</strong></span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>You set up a new Gradle project and want to <a class="link" href="#sec:adding_wrapper">add the Wrapper</a> to it.</p></li><li class="listitem"><p>You want to <a class="link" href="#sec:using_wrapper">run a project with the Wrapper</a> that already provides it.</p></li><li class="listitem"><p>You want to <a class="link" href="#sec:upgrading_wrapper">upgrade the Wrapper</a> to a new version of Gradle.</p></li></ul></div><p>The following sections explain each of these use cases in more detail.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:adding_wrapper" class="section-anchor" href="#sec:adding_wrapper"></a>Adding the Gradle Wrapper</h2></div></div></div><p>Generating the Wrapper files requires an installed version of the Gradle runtime on your machine as described in <a class="xref" href="#installation"><i>Installing Gradle</i></a>. Thankfully, generating the initial Wrapper files is a one-time process.</p><p>Every vanilla Gradle build comes with a built-in task called <code class="literal">wrapper</code>. You&rsquo;ll be able to find the task listed under the group "Build Setup tasks" when <a class="link" href="#">listing the tasks</a>. Executing the <code class="literal">wrapper</code> task generates the necessary Wrapper files in the project directory.</p><div class="example"><a name="wrapperCommandLine"></a><p class="title"><b>Example&nbsp;5.&nbsp;Running the Wrapper task</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle wrapper</code></strong></p><pre class="screen">&gt; gradle wrapper
:wrapper

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><div class="note"><p>To make the Wrapper files available to other developers and execution environments you&rsquo;ll need to check them into version control. All Wrapper files including the JAR file are very small in size. Adding the JAR file to version control is expected. Some organizations do not allow projects to submit binary files to version control. At the moment there are no alternative options to the approach.</p></div><p>The generated Wrapper properties file, <code class="literal">gradle/wrapper/gradle-wrapper.properties</code>, stores the information about the Gradle distribution.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The server hosting the Gradle distribution.</p></li><li class="listitem"><p>The type of Gradle distribution. By default that&rsquo;s the <code class="literal">-bin</code> distribution containing only the runtime but no sample code and documentation.</p></li><li class="listitem"><p>The Gradle version used for executing the build. By default the <code class="literal">wrapper</code> task picks the exact same Gradle version that was used to generate the Wrapper files.</p></li></ul></div><div class="example"><a name="N1067B"></a><p class="title"><b>Example&nbsp;6.&nbsp;The generated distribution URL</b></p><div class="example-contents"><p title="gradle/wrapper/gradle-wrapper.properties"><b><code class="literal">gradle/wrapper/gradle-wrapper.properties</code>.&nbsp;</b>
</p><pre class="programlisting">distributionUrl=https\://services.gradle.org/distributions/gradle-4.3.1-bin.zip</pre><p title="gradle/wrapper/gradle-wrapper.properties">
</p></div></div><br class="example-break"><p>All of those aspects are configurable at the time of generating the Wrapper files with the help of the following command line options.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">--gradle-version</code></span></dt><dd><p>The Gradle version used for downloading and executing the Wrapper.</p></dd><dt><span class="term"><code class="literal">--distribution-type</code></span></dt><dd><p>The Gradle distribution type used for the Wrapper. Available options are <code class="literal">bin</code> and <code class="literal">all</code>. The default value is <code class="literal">bin</code>.</p></dd><dt><span class="term"><code class="literal">--gradle-distribution-url</code></span></dt><dd><p>The full URL pointing to Gradle distribution ZIP file. Using this option makes <code class="literal">--gradle-version</code> and <code class="literal">--distribution-type</code> obsolete as the URL already contains this information. This option is extremely valuable if you want to host the Gradle distribution inside your company&rsquo;s network.</p></dd><dt><span class="term"><code class="literal">--gradle-distribution-sha256-sum</code></span></dt><dd><p>The SHA256 hash sum used for <a class="link" href="#sec:verification">verifying the downloaded Gradle distribution</a>.</p></dd></dl></div><p>Let&rsquo;s assume the following use case to illustrate the use of the command line options. You would like to generate the Wrapper with version 4.0 and use the <code class="literal">-all</code> distribution to enable your IDE to enable code-completion and being able to navigate to the Gradle source code. Those requirements are captured by the following command line execution:</p><div class="example"><a name="wrapperCommandLine"></a><p class="title"><b>Example&nbsp;7.&nbsp;Providing options to Wrapper task</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle wrapper --gradle-version 4.0 --distribution-type all</code></strong></p><pre class="screen">&gt; gradle wrapper --gradle-version 4.0 --distribution-type all
:wrapper

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>As a result you can find the desired information in the Wrapper properties file.</p><div class="example"><a name="N106CC"></a><p class="title"><b>Example&nbsp;8.&nbsp;The generated distribution URL</b></p><div class="example-contents"><p title="gradle/wrapper/gradle-wrapper.properties"><b><code class="literal">gradle/wrapper/gradle-wrapper.properties</code>.&nbsp;</b>
</p><pre class="programlisting">distributionUrl=https\://services.gradle.org/distributions/gradle-4.0-all.zip</pre><p title="gradle/wrapper/gradle-wrapper.properties">
</p></div></div><br class="example-break"><p>Let&rsquo;s have a look at the following project layout to illustrate the expected Wrapper files:</p><pre class="screen">.
 build.gradle
 settings.gradle
 gradle
    wrapper
        gradle-wrapper.jar
        gradle-wrapper.properties
 gradlew
 gradlew.bat</pre><p>A Gradle project typically provides a <code class="literal">build.gradle</code> and a <code class="literal">settings.gradle</code> file. The Wrapper files live alongside in the <code class="literal">gradle</code> directory and the root directory of the project. The following list explains their purpose.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">gradle-wrapper.jar</code></span></dt><dd><p>The Wrapper JAR file containing code for downloading the Gradle distribution.</p></dd><dt><span class="term"><code class="literal">gradle-wrapper.properties</code></span></dt><dd><p>A properties file responsible for configuring the Wrapper runtime behavior e.g. the Gradle version compatible with this version.</p></dd><dt><span class="term"><code class="literal">gradlew</code>, <code class="literal">gradlew.bat</code></span></dt><dd><p>A shell script and a Windows batch script for executing the build with the Wrapper.</p></dd></dl></div><p>You can go ahead and <a class="link" href="#sec:using_wrapper">execute the build with the Wrapper</a> without having to install the Gradle runtime. If the project you are working on does not contain those Wrapper files then you&rsquo;ll need to <a class="link" href="#sec:adding_wrapper">generate them</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_wrapper" class="section-anchor" href="#sec:using_wrapper"></a>Using the Gradle Wrapper</h2></div></div></div><p>It is recommended to always execute a build with the Wrapper to ensure a reliable, controlled and standardized execution of the build. Using the Wrapper looks almost exactly like running the build with a Gradle installation. Depending on the operation system you either run <code class="literal">gradlew</code> or <code class="literal">gradlew.bat</code> instead of the <code class="literal">gradle</code> command. The following console output demonstrate the use of the Wrapper on a Windows machine for a Java-based project.</p><div class="example"><a name="wrapperBatchFileExecution"></a><p class="title"><b>Example&nbsp;9.&nbsp;Executing the build with the Wrapper batch file</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradlew.bat build</code></strong></p><pre class="screen">&gt; gradlew.bat build
Downloading https://services.gradle.org/distributions/gradle-4.0-all.zip
.....................................................................................
Unzipping C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-4.0-all\ac27o8rbd0ic8ih41or9l32mv\gradle-4.0-all.zip to C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-4.0-al\ac27o8rbd0ic8ih41or9l32mv
Set executable permissions for: C:\Documents and Settings\Claudia\.gradle\wrapper\dists\gradle-4.0-all\ac27o8rbd0ic8ih41or9l32mv\gradle-4.0\bin\gradle

BUILD SUCCESSFUL in 12s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>In case the Gradle distribution is not available on the machine, the Wrapper will download it and store in the local file system. Any subsequent build invocation is going to reuse the existing local distribution as long as the distribution URL in the Gradle properties doesn&rsquo;t change.</p><div class="note"><p>The Wrapper shell script and batch file reside in the root directory of a single or multi-project Gradle build. You will need to reference the correct path to those files in case you want to execute the build from a subproject directory e.g. <code class="literal">../../gradlew tasks</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:upgrading_wrapper" class="section-anchor" href="#sec:upgrading_wrapper"></a>Upgrading the Gradle Wrapper</h2></div></div></div><p>Projects will typically want to keep up with the times and upgrade their Gradle version to benefit from new features and improvements. One way to upgrade the Gradle version is manually change the <code class="literal">distributionUrl</code> property in the Wrapper property file. The better and recommended option is to run the <code class="literal">wrapper</code> task and provide the target Gradle version as described in <a class="xref" href="#sec:adding_wrapper">the section called &ldquo;Adding the Gradle Wrapper&rdquo;</a>. Using the <code class="literal">wrapper</code> task ensures that any optimizations made to the Wrapper shell script or batch file with that specific Gradle version are applied to the project. As usual you&rsquo;d commit the changes to the Wrapper files to version control.</p><p>Use the Gradle <code class="literal">wrapper</code> task to generate the wrapper, specifying a version. The default is the current version, which you can check by executing <code class="literal">./gradlew --version</code>.</p><div class="example"><a name="wrapperGradleVersionUpgrade"></a><p class="title"><b>Example&nbsp;10.&nbsp;Upgrading the Wrapper version</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>./gradlew wrapper --gradle-version 4.2.1</code></strong></p><pre class="screen">&gt; ./gradlew wrapper --gradle-version 4.2.1

BUILD SUCCESSFUL in 4s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><div class="example"><a name="wrapperGradleVersionAfterUpgrade"></a><p class="title"><b>Example&nbsp;11.&nbsp;Checking the Wrapper version after upgrading</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>./gradlew -v</code></strong></p><pre class="screen">&gt; ./gradlew -v
Downloading https://services.gradle.org/distributions/gradle-4.2.1-bin.zip
...................................................................
Unzipping /Users/claudia/.gradle/wrapper/dists/gradle-4.2.1-bin/dajvke9o8kmaxbu0kc5gcgeju/gradle-4.2.1-bin.zip to /Users/claudia/.gradle/wrapper/dists/gradle-4.2.1-bin/dajvke9o8kmaxbu0kc5gcgeju
Set executable permissions for: /Users/claudia/.gradle/wrapper/dists/gradle-4.2.1-bin/dajvke9o8kmaxbu0kc5gcgeju/gradle-4.2.1/bin/gradle

------------------------------------------------------------
Gradle 4.2.1
------------------------------------------------------------

Build time:   2017-10-02 15:36:21 UTC
Revision:     a88ebd6be7840c2e59ae4782eb0f27fbe3405ddf

Groovy:       2.4.12
Ant:          Apache Ant(TM) version 1.9.6 compiled on June 29 2015
JVM:          1.8.0_60 (Oracle Corporation 25.60-b23)
OS:           Mac OS X 10.13.1 x86_64
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="customizing_wrapper" class="section-anchor" href="#customizing_wrapper"></a>Customizing the Gradle Wrapper</h2></div></div></div><p>Most users of Gradle are happy with the default runtime behavior of the Wrapper. However, organizational policies, security constraints or personal preferences might require you to dive deeper into customizing the Wrapper. Thankfully, the built-in <code class="literal">wrapper</code> task exposes numerous options to bend the runtime behavior to your needs. Most configuration options are exposed by the underlying task type <a class="ulink" href="../dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_top"><code class="classname">Wrapper</code></a>.</p><p>Let&rsquo;s assume you grew tired of defining the <code class="literal">-all</code> distribution type on the command line every time you upgrade the Wrapper. You can save yourself some keyboard strokes by re-configuring the <code class="literal">wrapper</code> task.</p><div class="example"><a name="wrapperCustomized"></a><p class="title"><b>Example&nbsp;12.&nbsp;Customizing the Wrapper task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">wrapper {
    distributionType = Wrapper.DistributionType.ALL
}
</pre></div></div><br class="example-break"><p>With the configuration in place running <code class="literal">./gradlew wrapper --gradle-version 4.1</code> is enough to produce a <code class="literal">distributionUrl</code> value in the Wrapper properties file that will request the <code class="literal">-all</code> distribution.</p><div class="example"><a name="N10786"></a><p class="title"><b>Example&nbsp;13.&nbsp;The generated distribution URL</b></p><div class="example-contents"><p title="gradle/wrapper/gradle-wrapper.properties"><b><code class="literal">gradle/wrapper/gradle-wrapper.properties</code>.&nbsp;</b>
</p><pre class="programlisting">distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</pre><p title="gradle/wrapper/gradle-wrapper.properties">
</p></div></div><br class="example-break"><p>Check out the API documentation for more detail descriptions of the available configuration options. You can also find various samples for configuring the Wrapper in the Gradle distribution.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:authenticated_download" class="section-anchor" href="#sec:authenticated_download"></a>Authenticated Gradle distribution download</h3></div></div></div><p>The Gradle <code class="literal">Wrapper</code> can download Gradle distributions from servers using HTTP Basic Authentication. This enables you to host the Gradle distribution on a private protected server. You can specify a username and password in two different ways depending on your use case: as system properties or directly embedded in the <code class="literal">distributionUrl</code>. Credentials in system properties take precedence over the ones embedded in <code class="literal">distributionUrl</code>.</p><div class="tip"><h3 class="title">Security Warning</h3><p>HTTP Basic Authentication should only be used with <code class="literal">HTTPS</code> URLs and not plain <code class="literal">HTTP</code> ones. With Basic Authentication, the user credentials are sent in clear text.</p></div><p>Using system properties can be done in the <code class="literal">.gradle/gradle.properties</code> file in the user&rsquo;s home directory, or by other means, see <a class="xref" href="#sec:gradle_configuration_properties">the section called &ldquo;Gradle properties&rdquo;</a>.</p><div class="example"><a name="N107B8"></a><p class="title"><b>Example&nbsp;14.&nbsp;Specifying the HTTP Basic Authentication credentials using system properties</b></p><div class="example-contents"><p title="gradle.properties"><b><code class="literal">gradle.properties</code>.&nbsp;</b>
</p><pre class="programlisting">systemProp.gradle.wrapperUser=username
systemProp.gradle.wrapperPassword=password</pre><p title="gradle.properties">
</p></div></div><br class="example-break"><p>Embedding credentials in the <code class="literal">distributionUrl</code> in the <code class="literal">gradle/wrapper/gradle-wrapper.properties</code> file also works. Please note that this file is to be committed into your source control system. Shared credentials embedded in <code class="literal">distributionUrl</code> should only be used in a controlled environment.</p><div class="example"><a name="N107D1"></a><p class="title"><b>Example&nbsp;15.&nbsp;Specifying the HTTP Basic Authentication credentials in <code class="literal">distributionUrl</code></b></p><div class="example-contents"><p title="gradle/wrapper/gradle-wrapper.properties"><b><code class="literal">gradle/wrapper/gradle-wrapper.properties</code>.&nbsp;</b>
</p><pre class="programlisting">distributionUrl=https://username:password@somehost/path/to/gradle-distribution.zip</pre><p title="gradle/wrapper/gradle-wrapper.properties">
</p></div></div><br class="example-break"><p>This can be used in conjunction with a proxy, authenticated or not. See <a class="xref" href="#sec:accessing_the_web_via_a_proxy">the section called &ldquo;Accessing the web through a HTTP proxy&rdquo;</a> for more information on how to configure the <code class="literal">Wrapper</code> to use a proxy.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:verification" class="section-anchor" href="#sec:verification"></a>Verification of downloaded Gradle distributions</h3></div></div></div><p>The Gradle Wrapper allows for verification of the downloaded Gradle distribution via SHA-256 hash sum comparison. This increases security against targeted attacks by preventing a man-in-the-middle attacker from tampering with the downloaded Gradle distribution.</p><p>To enable this feature, download the <code class="literal">.sha256</code> file associated with the Gradle distribution you want to verify.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_downloading_the_sha_256_file" class="section-anchor" href="#_downloading_the_sha_256_file"></a>Downloading the SHA-256 file</h4></div></div></div><p>You can download the <code class="literal">.sha256</code> file from the <a class="ulink" href="https://services.gradle.org/distributions/" target="_top">stable releases</a> or <a class="ulink" href="https://services.gradle.org/distributions-snapshots/" target="_top">release candidate and nightly releases</a>. The format of the file is a single line of text that is the SHA-256 hash of the corresponding zip file.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="_configuring_checksum_verification" class="section-anchor" href="#_configuring_checksum_verification"></a>Configuring checksum verification</h4></div></div></div><p>Add the downloaded hash sum to <code class="literal">gradle-wrapper.properties</code> using the <code class="literal">distributionSha256Sum</code> property or use <code class="literal">--gradle-distribution-sha256-sum</code> on the command-line.</p><div class="example"><a name="N10814"></a><p class="title"><b>Example&nbsp;16.&nbsp;Configuring SHA-256 checksum verification</b></p><div class="example-contents"><p title="gradle/wrapper/gradle-wrapper.properties"><b><code class="literal">gradle/wrapper/gradle-wrapper.properties</code>.&nbsp;</b>
</p><pre class="programlisting">distributionSha256Sum=371cb9fbebbe9880d147f59bab36d61eee122854ef8c9ee1ecf12b82368bcf10</pre><p title="gradle/wrapper/gradle-wrapper.properties">
</p></div></div><br class="example-break"><p>Gradle will report a build failure in case the configured checksum does not match the checksum found on the server for hosting the distribution. Checksum Verification is only performed if the configured Wrapper distribution hasn&rsquo;t been downloaded yet.</p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="gradle_daemon"></a>The Gradle Daemon</h1></div></div></div><p>From Wikipedia&hellip;</p><div class="blockquote"><blockquote class="blockquote">A daemon is a computer program that runs as a background process, rather than being under the direct control of an interactive user.</blockquote></div><p>Gradle runs on the Java Virtual Machine (JVM) and uses several supporting libraries that require a non-trivial initialization time. As a result, it can sometimes seem a little slow to start. The solution to this problem is the Gradle <span class="emphasis"><em>Daemon</em></span>: a long-lived background process that executes your builds much more quickly than would otherwise be the case. We accomplish this by avoiding the expensive bootstrapping process as well as leveraging caching, by keeping data about your project in memory. Running Gradle builds with the Daemon is no different than without. Simply configure whether you want to use it or not - everything else is handled transparently by Gradle.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:why_the_daemon" class="section-anchor" href="#sec:why_the_daemon"></a>Why the Gradle Daemon is important for performance</h2></div></div></div><p>The Daemon is a long-lived process, so not only are we able to avoid the cost of JVM startup for every build, but we are able to cache information about project structure, files, tasks, and more in memory.</p><p>The reasoning is simple: improve build speed by reusing computations from previous builds. However, the benefits are dramatic: we typically measure build times reduced by 15-75% on subsequent builds. We recommend profiling your build by using <code class="literal">--profile</code> to get a sense of how much impact the Gradle Daemon can have for you.</p><p>The Gradle Daemon is enabled by default starting with Gradle 3.0, so you don&rsquo;t have to do anything to benefit from it.</p><p>If you run CI builds in ephemeral environments (such as containers) that do not reuse any processes, use of the Daemon will slightly decrease performance (due to caching additional information) for no benefit, and may be disabled.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:status" class="section-anchor" href="#sec:status"></a>Running Daemon Status</h2></div></div></div><p>To get a list of running Gradle Daemons and their statuses use the <code class="literal">--status</code> command.</p><p>Sample output:</p><pre class="screen">  PID VERSION                 STATUS
28411 3.0                     IDLE
34247 3.0                     BUSY</pre><p>Currently, a given Gradle version can only connect to daemons of the same version. This means the status output will only show Daemons for the version of Gradle being invoked and not for any other versions. Future versions of Gradle will lift this constraint and will show the running Daemons for all versions of Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:disabling_the_daemon" class="section-anchor" href="#sec:disabling_the_daemon"></a>Disabling the Daemon</h2></div></div></div><p>The Gradle Daemon is enabled by default, and we recommend always enabling it. There are several ways to disable the Daemon, but the most common one is to add the line</p><pre class="screen">org.gradle.daemon=false</pre><p>to the file <code class="literal">&laquo;USER_HOME&raquo;/.gradle/gradle.properties</code>, where <code class="literal">&laquo;USER_HOME&raquo;</code> is your home directory. That&rsquo;s typically one of the following, depending on your platform:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">C:\Users\&lt;username&gt;</code> (Windows Vista &amp; 7+)</p></li><li class="listitem"><p><code class="literal">/Users/&lt;username&gt;</code> (macOS)</p></li><li class="listitem"><p><code class="literal">/home/&lt;username&gt;</code> (Linux)</p></li></ul></div><p>If that file doesn&rsquo;t exist, just create it using a text editor. You can find details of other ways to disable (and enable) the Daemon in <a class="xref" href="#daemon_faq">the section called &ldquo;FAQ&rdquo;</a> further down. That section also contains more detailed information on how the Daemon works.</p><p>Note that having the Daemon enabled, all your builds will take advantage of the speed boost, regardless of the version of Gradle a particular build uses.</p><div class="tip"><h3 class="title">Continuous integration</h3><p>Since Gradle 3.0, we enable Daemon by default and recommend using it for both developers' machines and Continuous Integration servers. However, if you suspect that Daemon makes your CI builds unstable, you can disable it to use a fresh runtime for each build since the runtime is <span class="emphasis"><em>completely</em></span> isolated from any previous builds.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:stopping_an_existing_daemon" class="section-anchor" href="#sec:stopping_an_existing_daemon"></a>Stopping an existing Daemon</h2></div></div></div><p>As mentioned, the Daemon is a background process. You needn&rsquo;t worry about a build up of Gradle processes on your machine, though. Every Daemon monitors its memory usage compared to total system memory and will stop itself if idle when available system memory is low. If you want to explicitly stop running Daemon processes for any reason, just use the command <code class="literal">gradle --stop</code>.</p><p>This will terminate all Daemon processes that were started with the same version of Gradle used to execute the command. If you have the Java Development Kit (JDK) installed, you can easily verify that a Daemon has stopped by running the <code class="literal">jps</code> command. You&rsquo;ll see any running Daemons listed with the name <code class="literal">GradleDaemon</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="daemon_faq" class="section-anchor" href="#daemon_faq"></a>FAQ</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:ways_to_disable_gradle_daemon" class="section-anchor" href="#sec:ways_to_disable_gradle_daemon"></a>How do I disable the Gradle Daemon?</h3></div></div></div><p>There are two recommended ways to disable the Daemon persistently for an environment:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Via environment variables: add the flag <code class="literal">-Dorg.gradle.daemon=false</code> to the <code class="literal">GRADLE_OPTS</code> environment variable</p></li><li class="listitem"><p>Via properties file: add <code class="literal">org.gradle.daemon=false</code> to the <code class="literal">&laquo;GRADLE_USER_HOME&raquo;/gradle.properties</code> file</p></li></ul></div><div class="note"><p>Note, <code class="literal">&laquo;GRADLE_USER_HOME&raquo;</code> defaults to <code class="literal">&laquo;USER_HOME&raquo;/.gradle</code>, where <code class="literal">&laquo;USER_HOME&raquo;</code> is the home directory of the current user. This location can be configured via the <code class="literal">-g</code> and <code class="literal">--gradle-user-home</code> command line switches, as well as by the <code class="literal">GRADLE_USER_HOME</code> environment variable and <code class="literal">org.gradle.user.home</code> JVM system property.</p></div><p>Both approaches have the same effect. Which one to use is up to personal preference. Most Gradle users choose the second option and add the entry to the user <code class="literal">gradle.properties</code> file.</p><p>On Windows, this command will disable the Daemon for the current user:</p><pre class="screen">(if not exist "%USERPROFILE%/.gradle" mkdir "%USERPROFILE%/.gradle") &amp;&amp; (echo. &gt;&gt; "%USERPROFILE%/.gradle/gradle.properties" &amp;&amp; echo org.gradle.daemon=false &gt;&gt; "%USERPROFILE%/.gradle/gradle.properties")</pre><p>On UNIX-like operating systems, the following Bash shell command will disable the Daemon for the current user:</p><pre class="screen">mkdir -p ~/.gradle &amp;&amp; echo "org.gradle.daemon=false" &gt;&gt; ~/.gradle/gradle.properties</pre><p>Once the Daemon is disabled for a build environment in this way, a Gradle Daemon will not be started unless explicitly requested using the <code class="literal">--daemon</code> option.</p><p>The <code class="literal">--daemon</code> and <code class="literal">--no-daemon</code> command line options enable and disable usage of the Daemon for individual build invocations when using the Gradle command line interface. These command line options have the <span class="emphasis"><em>highest</em></span> precedence when considering the build environment. Typically, it is more convenient to enable the Daemon for an environment (e.g. a user account) so that all builds use the Daemon without requiring to remember to supply the <code class="literal">--daemon</code> option.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:why_is_there_more_than_one_daemon_process_on_my_machine" class="section-anchor" href="#sec:why_is_there_more_than_one_daemon_process_on_my_machine"></a>Why is there more than one Daemon process on my machine?</h3></div></div></div><p>There are several reasons why Gradle will create a new Daemon, instead of using one that is already running. The basic rule is that Gradle will start a new Daemon if there are no existing idle or compatible Daemons available. Gradle will kill any Daemon that has been idle for 3 hours or more, so you don&rsquo;t have to worry about cleaning them up manually.</p><div class="variablelist"><dl><dt><span class="term">idle</span></dt><dd><p>An idle Daemon is one that is not currently executing a build or doing other useful work.</p></dd><dt><span class="term">compatible</span></dt><dd><p>A compatible Daemon is one that can (or can be made to) meet the requirements of the requested build environment. The Java runtime used to execute the build is an example aspect of the build environment. Another example is the set of JVM system properties required by the build runtime.</p></dd></dl></div><p>Some aspects of the requested build environment may not be met by an Daemon. If the Daemon is running with a Java 7 runtime, but the requested environment calls for Java 8, then the Daemon is not compatible and another must be started. Moreover, certain properties of a Java runtime cannot be changed once the JVM has started. For example, it is not possible to change the memory allocation (e.g. <code class="literal">-Xmx1024m</code>), default text encoding, default locale, etc of a running JVM.</p><p>The &ldquo;requested build environment&rdquo; is typically constructed implicitly from aspects of the build client&rsquo;s (e.g. Gradle command line client, IDE etc.) environment and explicitly via command line switches and settings. See <a class="xref" href="#build_environment"><i>Build Environment</i></a> for details on how to specify and control the build environment.</p><p>The following JVM system properties are effectively immutable. If the requested build environment requires any of these properties, with a different value than a Daemon&rsquo;s JVM has for this property, the Daemon is not compatible.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>file.encoding</p></li><li class="listitem"><p>user.language</p></li><li class="listitem"><p>user.country</p></li><li class="listitem"><p>user.variant</p></li><li class="listitem"><p>java.io.tmpdir</p></li><li class="listitem"><p>javax.net.ssl.keyStore</p></li><li class="listitem"><p>javax.net.ssl.keyStorePassword</p></li><li class="listitem"><p>javax.net.ssl.keyStoreType</p></li><li class="listitem"><p>javax.net.ssl.trustStore</p></li><li class="listitem"><p>javax.net.ssl.trustStorePassword</p></li><li class="listitem"><p>javax.net.ssl.trustStoreType</p></li><li class="listitem"><p>com.sun.management.jmxremote</p></li></ul></div><p>The following JVM attributes, controlled by startup arguments, are also effectively immutable. The corresponding attributes of the requested build environment and the Daemon&rsquo;s environment must match exactly in order for a Daemon to be compatible.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The maximum heap size (i.e. the -Xmx JVM argument)</p></li><li class="listitem"><p>The minimum heap size (i.e. the -Xms JVM argument)</p></li><li class="listitem"><p>The boot classpath (i.e. the -Xbootclasspath argument)</p></li><li class="listitem"><p>The &ldquo;assertion&rdquo; status (i.e. the -ea argument)</p></li></ul></div><p>The required Gradle version is another aspect of the requested build environment. Daemon processes are coupled to a specific Gradle runtime. Working on multiple Gradle projects during a session that use different Gradle versions is a common reason for having more than one running Daemon process.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:how_much_memory_does_the_daemon_use_and_can_i_give_it_more" class="section-anchor" href="#sec:how_much_memory_does_the_daemon_use_and_can_i_give_it_more"></a>How much memory does the Daemon use and can I give it more?</h3></div></div></div><p>If the requested build environment does not specify a maximum heap size, the Daemon will use up to 1GB of heap. It will use the JVM&rsquo;s default minimum heap size. 1GB is more than enough for most builds. Larger builds with hundreds of subprojects, lots of configuration, and source code may require, or perform better, with more memory.</p><p>To increase the amount of memory the Daemon can use, specify the appropriate flags as part of the requested build environment. Please see <a class="xref" href="#build_environment"><i>Build Environment</i></a> for details.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:how_can_i_stop_a_daemon" class="section-anchor" href="#sec:how_can_i_stop_a_daemon"></a>How can I stop a Daemon?</h3></div></div></div><p>Daemon processes will automatically terminate themselves after 3 hours of inactivity or less. If you wish to stop a Daemon process before this, you can either kill the process via your operating system or run the <code class="literal">gradle --stop</code> command. The <code class="literal">--stop</code> switch causes Gradle to request that <span class="emphasis"><em>all</em></span> running Daemon processes, <span class="emphasis"><em>of the same Gradle version used to run the command</em></span>, terminate themselves.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:what_can_go_wrong_with_daemon" class="section-anchor" href="#sec:what_can_go_wrong_with_daemon"></a>What can go wrong with Daemon?</h3></div></div></div><p>Considerable engineering effort has gone into making the Daemon robust, transparent and unobtrusive during day to day development. However, Daemon processes can occasionally be corrupted or exhausted. A Gradle build executes arbitrary code from multiple sources. While Gradle itself is designed for and heavily tested with the Daemon, user build scripts and third party plugins can destabilize the Daemon process through defects such as memory leaks or global state corruption.</p><p>It is also possible to destabilize the Daemon (and build environment in general) by running builds that do not release resources correctly. This is a particularly poignant problem when using Microsoft Windows as it is less forgiving of programs that fail to close files after reading or writing.</p><p>Gradle actively monitors heap usage and attempts to detect when a leak is starting to exhaust the available heap space in the daemon. When it detects a problem, the Gradle daemon will finish the currently running build and proactively restart the daemon on the next build. This monitoring is enabled by default, but can be disabled by setting the <code class="literal">org.gradle.daemon.performance.enable-monitoring</code> system property to false.</p><p>If it is suspected that the Daemon process has become unstable, it can simply be killed. Recall that the <code class="literal">--no-daemon</code> switch can be specified for a build to prevent use of the Daemon. This can be useful to diagnose whether or not the Daemon is actually the culprit of a problem.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:tools_and_ides" class="section-anchor" href="#sec:tools_and_ides"></a>Tools &amp; IDEs</h2></div></div></div><p>The Gradle Tooling API (see <a class="xref" href="#embedding"><i>Embedding Gradle using the Tooling API</i></a>), that is used by IDEs and other tools to integrate with Gradle, <span class="emphasis"><em>always</em></span> use the Gradle Daemon to execute builds. If you are executing Gradle builds from within you&rsquo;re IDE you are using the Gradle Daemon and do not need to enable it for your environment.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:how_does_the_gradle_daemon_make_builds_faster" class="section-anchor" href="#sec:how_does_the_gradle_daemon_make_builds_faster"></a>How does the Gradle Daemon make builds faster?</h2></div></div></div><p>The Gradle Daemon is a <span class="emphasis"><em>long lived</em></span> build process. In between builds it waits idly for the next build. This has the obvious benefit of only requiring Gradle to be loaded into memory once for multiple builds, as opposed to once for each build. This in itself is a significant performance optimization, but that&rsquo;s not where it stops.</p><p>A significant part of the story for modern JVM performance is runtime code optimization. For example, HotSpot (the JVM implementation provided by Oracle and used as the basis of OpenJDK) applies optimization to code while it is running. The optimization is progressive and not instantaneous. That is, the code is progressively optimized during execution which means that subsequent builds can be faster purely due to this optimization process. Experiments with HotSpot have shown that it takes somewhere between 5 and 10 builds for optimization to stabilize. The difference in perceived build time between the first build and the 10th for a Daemon can be quite dramatic.</p><p>The Daemon also allows more effective in memory caching across builds. For example, the classes needed by the build (e.g. plugins, build scripts) can be held in memory between builds. Similarly, Gradle can maintain in-memory caches of build data such as the hashes of task inputs and outputs, used for incremental building.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="artifact_dependencies_tutorial"></a>Dependency Management for Java Projects</h1></div></div></div><p>This chapter introduces some of the basics of dependency management in Gradle.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:what_is_dependency_management" class="section-anchor" href="#sec:what_is_dependency_management"></a>What is dependency management?</h2></div></div></div><p>Very roughly, dependency management is made up of two pieces. Firstly, Gradle needs to know about the things that your project needs to build or run, in order to find them. We call these incoming files the <span class="emphasis"><em>dependencies</em></span> of the project. Secondly, Gradle needs to build and upload the things that your project produces. We call these outgoing files the <span class="emphasis"><em>publications</em></span> of the project. Let&rsquo;s look at these two pieces in more detail:</p><p>Most projects are not completely self-contained. They need files built by other projects in order to be compiled or tested and so on. For example, in order to use Hibernate in my project, I need to include some Hibernate jars in the classpath when I compile my source. To run my tests, I might also need to include some additional jars in the test classpath, such as a particular JDBC driver or the Ehcache jars.</p><p>These incoming files form the dependencies of the project. Gradle allows you to tell it what the dependencies of your project are, so that it can take care of finding these dependencies, and making them available in your build. The dependencies might need to be downloaded from a remote Maven or Ivy repository, or located in a local directory, or may need to be built by another project in the same multi-project build. We call this process <span class="emphasis"><em>dependency resolution</em></span>.</p><p>Note that this feature provides a major advantage over Ant. With Ant, you only have the ability to specify absolute or relative paths to specific jars to load. With Gradle, you simply declare the &ldquo;names&rdquo; of your dependencies, and other layers determine where to get those dependencies from. You can get similar behavior from Ant by adding Apache Ivy, but Gradle does it better.</p><p>Often, the dependencies of a project will themselves have dependencies. For example, Hibernate core requires several other libraries to be present on the classpath with it runs. So, when Gradle runs the tests for your project, it also needs to find these dependencies and make them available. We call these <span class="emphasis"><em>transitive dependencies</em></span>.</p><p>The main purpose of most projects is to build some files that are to be used outside the project. For example, if your project produces a Java library, you need to build a jar, and maybe a source jar and some documentation, and publish them somewhere.</p><p>These outgoing files form the publications of the project. Gradle also takes care of this important work for you. You declare the publications of your project, and Gradle take care of building them and publishing them somewhere. Exactly what &ldquo;publishing&rdquo; means depends on what you want to do. You might want to copy the files to a local directory, or upload them to a remote Maven or Ivy repository. Or you might use the files in another project in the same multi-project build. We call this process <span class="emphasis"><em>publication</em></span>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_your_dependencies" class="section-anchor" href="#sec:declaring_your_dependencies"></a>Declaring your dependencies</h2></div></div></div><p>Let&rsquo;s look at some dependency declarations. Here&rsquo;s a basic build script:</p><div class="example"><a name="basicDependencyDeclarations"></a><p class="title"><b>Example&nbsp;17.&nbsp;Declaring dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>

repositories {
    mavenCentral()
}

dependencies {
    compile group: <span class="hl-string">'org.hibernate'</span>, name: <span class="hl-string">'hibernate-core'</span>, version: <span class="hl-string">'3.6.7.Final'</span>
    testCompile group: <span class="hl-string">'junit'</span>, name: <span class="hl-string">'junit'</span>, version: <span class="hl-string">'4.+'</span>
}
</pre></div></div><br class="example-break"><p>What&rsquo;s going on here? This build script says a few things about the project. Firstly, it states that Hibernate core 3.6.7.Final is required to compile the project&rsquo;s production source. By implication, Hibernate core and its dependencies are also required at runtime. The build script also states that any junit &gt;= 4.0 is required to compile the project&rsquo;s tests. It also tells Gradle to look in the Maven central repository for any dependencies that are required. The following sections go into the details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="configurations" class="section-anchor" href="#configurations"></a>Dependency configurations</h2></div></div></div><p>A Configuration is a named set of dependencies and artifacts. There are three main purposes for a Configuration:</p><div class="variablelist"><dl><dt><span class="term">Declaring Dependencies</span></dt><dd><p>The plugin uses configurations to make it easy for build authors to declare what other subprojects or external artifacts are needed for various purposes during the execution of tasks defined by the plugin.</p></dd><dt><span class="term">Resolving Dependencies</span></dt><dd><p>The plugin uses configurations to find (and possibly download) inputs to the tasks it defines.</p></dd><dt><span class="term">Exposing Artifacts for Consumption</span></dt><dd><p>The plugin uses configurations to define what <span class="emphasis"><em>artifacts</em></span> it generates for other projects to consume.</p></dd></dl></div><p>With those three purposes in mind, let&rsquo;s take a look at a few of the standard configurations defined by the Java Library Plugin. You can find more details in <a class="xref" href="#sec:java_library_configurations_graph">the section called &ldquo;The Java Library plugin configurations&rdquo;</a>.</p><div class="variablelist"><dl><dt><span class="term">implementation</span></dt><dd><p>The dependencies required to compile the production source of the project, but which are not part of the api exposed by the project. This configuration is an example of a configuration used for Declaring Dependencies.</p></dd><dt><span class="term">runtimeClasspath</span></dt><dd><p>The dependencies required by the production classes at runtime. By default, this includes the dependencies declared in the <code class="literal">api</code>, <code class="literal">implementation</code>, and <code class="literal">runtimeOnly</code> configurations. This configuration is an example of a configuration used for Resolving Dependencies, and as such, users should never declare dependencies directly in the <code class="literal">runtimeClasspath</code> configuration.</p></dd><dt><span class="term">apiElements</span></dt><dd><p>The dependencies which are part of this project&rsquo;s externally consumable API as well as the classes which are defined in this project which should be consumable by other projects. This configuration is an example of Exposing Artifacts for Consumption.</p></dd></dl></div><p>Various plugins add further standard configurations. You can also define your own custom configurations to use in your build. Please see <a class="xref" href="#sub:scope_of_dependency_configurations">the section called &ldquo;Defining the scope of a dependency with configurations&rdquo;</a> for the details of defining and customizing dependency configurations.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:external_dependencies_tutorial" class="section-anchor" href="#sec:external_dependencies_tutorial"></a>External dependencies</h2></div></div></div><p>There are various types of dependencies that you can declare. One such type is an <span class="emphasis"><em>external dependency</em></span>. This is a dependency on some files built outside the current build, and stored in a repository of some kind, such as Maven central, or a corporate Maven or Ivy repository, or a directory in the local file system.</p><p>To define an external dependency, you add it to a dependency configuration:</p><div class="example"><a name="externalDependencies"></a><p class="title"><b>Example&nbsp;18.&nbsp;Definition of an external dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile group: <span class="hl-string">'org.hibernate'</span>, name: <span class="hl-string">'hibernate-core'</span>, version: <span class="hl-string">'3.6.7.Final'</span>
}
</pre></div></div><br class="example-break"><p>An external dependency is identified using <code class="literal">group</code>, <code class="literal">name</code> and <code class="literal">version</code> attributes. Depending on which kind of repository you are using, <code class="literal">group</code> and <code class="literal">version</code> may be optional.</p><p>The shortcut form for declaring external dependencies looks like &ldquo;<code class="literal"><span class="emphasis"><em>group</em></span>:<span class="emphasis"><em>name</em></span>:<span class="emphasis"><em>version</em></span></code>&rdquo;.</p><div class="example"><a name="externalDependencies"></a><p class="title"><b>Example&nbsp;19.&nbsp;Shortcut definition of an external dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile <span class="hl-string">'org.hibernate:hibernate-core:3.6.7.Final'</span>
}
</pre></div></div><br class="example-break"><p>To find out more about defining dependencies, have a look at <a class="xref" href="#declaring_dependencies"><i>Declaring Dependencies</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:repositories_tutorial" class="section-anchor" href="#sec:repositories_tutorial"></a>Repositories</h2></div></div></div><p>How does Gradle find the files for external dependencies? Gradle looks for them in a <span class="emphasis"><em>repository</em></span>. A repository is really just a collection of files, organized by <code class="literal">group</code>, <code class="literal">name</code> and <code class="literal">version</code>. Gradle understands several different repository formats, such as Maven and Ivy, and several different ways of accessing the repository, such as using the local file system or HTTP.</p><p>By default, Gradle does not define any repositories. You need to define at least one before you can use external dependencies. One option is use the Maven central repository:</p><div class="example"><a name="defineMavenCentral"></a><p class="title"><b>Example&nbsp;20.&nbsp;Usage of Maven central repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}
</pre></div></div><br class="example-break"><p>Or Bintray&rsquo;s JCenter:</p><div class="example"><a name="defineJCenter"></a><p class="title"><b>Example&nbsp;21.&nbsp;Usage of JCenter repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}
</pre></div></div><br class="example-break"><p>Or any other remote Maven repository:</p><div class="example"><a name="defineRemoteMavenRepo"></a><p class="title"><b>Example&nbsp;22.&nbsp;Usage of a remote Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Or a remote Ivy repository:</p><div class="example"><a name="defineRemoteIvyRepo"></a><p class="title"><b>Example&nbsp;23.&nbsp;Usage of a remote Ivy directory</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}
</pre></div></div><br class="example-break"><p>You can also have repositories on the local file system. This works for both Maven and Ivy repositories.</p><div class="example"><a name="defineRemoteIvyRepo"></a><p class="title"><b>Example&nbsp;24.&nbsp;Usage of a local Ivy directory</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        <span class="hl-comment">// URL can refer to a local directory</span>
        url <span class="hl-string">"../local-repo"</span>
    }
}
</pre></div></div><br class="example-break"><p>A project can have multiple repositories. Gradle will look for a dependency in each repository in the order they are specified, stopping at the first repository that contains the requested module.</p><p>To find out more about defining repositories, have a look at <a class="xref" href="#declaring_repositories"><i>Declaring Repositories</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:publishing_artifacts_tutorial" class="section-anchor" href="#sec:publishing_artifacts_tutorial"></a>Publishing artifacts</h2></div></div></div><p>Dependency configurations are also used to publish files.<sup>[<a href="#ftn.N10A9D" name="N10A9D" class="footnote">2</a>]</sup> We call these files <span class="emphasis"><em>publication artifacts</em></span>, or usually just <span class="emphasis"><em>artifacts</em></span>.</p><p>The plugins do a pretty good job of defining the artifacts of a project, so you usually don&rsquo;t need to do anything special to tell Gradle what needs to be published. However, you do need to tell Gradle where to publish the artifacts. You do this by attaching repositories to the <code class="literal">uploadArchives</code> task. Here&rsquo;s an example of publishing to a remote Ivy repository:</p><div class="example"><a name="publishIvyRepository"></a><p class="title"><b>Example&nbsp;25.&nbsp;Publishing to an Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
        ivy {
            credentials {
                username <span class="hl-string">"username"</span>
                password <span class="hl-string">"pw"</span>
            }
            url <span class="hl-string">"http://repo.mycompany.com"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>Now, when you run <code class="literal">gradle uploadArchives</code>, Gradle will build and upload your Jar. Gradle will also generate and upload an <code class="literal">ivy.xml</code> as well.</p><p>You can also publish to Maven repositories. The syntax is slightly different.<sup>[<a href="#ftn.N10AC0" name="N10AC0" class="footnote">3</a>]</sup> Note that you also need to apply the Maven plugin in order to publish to a Maven repository. when this is in place, Gradle will generate and upload a <code class="literal">pom.xml</code>.</p><div class="example"><a name="publishMavenRepository"></a><p class="title"><b>Example&nbsp;26.&nbsp;Publishing to a Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'maven'</span>

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://localhost/tmp/myRepo/"</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>To find out more about publication, have a look at <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:artifacts_tutorial_where_to_next" class="section-anchor" href="#sec:artifacts_tutorial_where_to_next"></a>Where to next?</h2></div></div></div><p>For all the details of dependency resolution, see <a class="xref" href="#introduction_dependency_management"><i>Introduction to Dependency Management</i></a>, and for artifact publication see <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p><p>If you are interested in the DSL elements mentioned here, have a look at <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:configurations(groovy.lang.Closure)" target="_top"><code class="classname">Project.configurations{}</code></a>, <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:repositories(groovy.lang.Closure)" target="_top"><code class="classname">Project.repositories{}</code></a> and <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:dependencies(groovy.lang.Closure)" target="_top"><code class="classname">Project.dependencies{}</code></a>.</p><p>Otherwise, continue on to some <a class="ulink" href="https://guides.gradle.org" target="_top">guides</a>.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N10A9D" name="ftn.N10A9D" class="para">2</a>] </sup>We think this is confusing, and we are gradually teasing apart the two concepts in the Gradle DSL.</p></div><div class="footnote"><p><sup>[<a href="#N10AC0" name="ftn.N10AC0" class="para">3</a>] </sup>We are working to make the syntax consistent for resolving from and publishing to Maven repositories.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="intro_multi_project_builds"></a>Executing Multi-Project Builds</h1></div></div></div><p>Only the smallest of projects has a single build file and source tree, unless it happens to be a massive, monolithic application. It&rsquo;s often much easier to digest and understand a project that has been split into smaller, inter-dependent modules. The word &ldquo;inter-dependent&rdquo; is important, though, and is why you typically want to link the modules together through a single build.</p><p>Gradle supports this scenario through <span class="emphasis"><em>multi-project</em></span> builds.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:structure_of_a_multiproject_build" class="section-anchor" href="#sec:structure_of_a_multiproject_build"></a>Structure of a multi-project build</h2></div></div></div><p>Such builds come in all shapes and sizes, but they do have some common characteristics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <code class="literal">settings.gradle</code> file in the root or <code class="literal">master</code> directory of the project</p></li><li class="listitem"><p>A <code class="literal">build.gradle</code> file in the root or <code class="literal">master</code> directory</p></li><li class="listitem"><p>Child directories that have their own <code class="literal">*.gradle</code> build files (some multi-project builds may omit child project build scripts)</p></li></ul></div><p>The <code class="literal">settings.gradle</code> file tells Gradle how the project and subprojects are structured. Fortunately, you don&rsquo;t have to read this file simply to learn what the project structure is as you can run the command <code class="literal">gradle projects</code>. Here&rsquo;s the output from using that command on the Java <span class="emphasis"><em>multiproject</em></span> build in the Gradle samples:</p><div class="example"><a name="listProjects"></a><p class="title"><b>Example&nbsp;27.&nbsp;Listing the projects in a build</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q projects</code></strong></p><pre class="screen">&gt; gradle -q projects

------------------------------------------------------------
Root project
------------------------------------------------------------

Root project 'multiproject'
+--- Project ':api'
+--- Project ':services'
|    +--- Project ':services:shared'
|    \--- Project ':services:webservice'
\--- Project ':shared'

To see a list of the tasks of a project, run gradle &lt;project-path&gt;:tasks
For example, try running gradle :api:tasks
</pre></div></div><br class="example-break"><p>This tells you that <span class="emphasis"><em>multiproject</em></span> has three immediate child projects: <span class="emphasis"><em>api</em></span>, <span class="emphasis"><em>services</em></span> and <span class="emphasis"><em>shared</em></span>. The <span class="emphasis"><em>services</em></span> project then has its own children, <span class="emphasis"><em>shared</em></span> and <span class="emphasis"><em>webservice</em></span>. These map to the directory structure, so it&rsquo;s easy to find them. For example, you can find <span class="emphasis"><em>webservice</em></span> in <code class="literal">&lt;root&gt;/services/webservice</code>.</p><p>By default, Gradle uses the name of the directory it finds the <code class="literal">settings.gradle</code> as the name of the root project. This usually doesn&rsquo;t cause problems since all developers check out the same directory name when working on a project. On Continuous Integration servers, like Jenkins, the directory name may be auto-generated and not match the name in your VCS. For that reason, it&rsquo;s recommended that you always set the root project name to something predictable, even in single project builds. You can configure the root project name by setting <code class="literal">rootProject.name</code>.</p><p>Each project will usually have its own build file, but that&rsquo;s not necessarily the case. In the above example, the <span class="emphasis"><em>services</em></span> project is just a container or grouping of other subprojects. There is no build file in the corresponding directory. However, <span class="emphasis"><em>multiproject</em></span> does have one for the root project.</p><p>The root <code class="literal">build.gradle</code> is often used to share common configuration between the child projects, for example by applying the same sets of plugins and dependencies to all the child projects. It can also be used to configure individual subprojects when it is preferable to have all the configuration in one place. This means you should always check the root build file when discovering how a particular subproject is being configured.</p><p>Another thing to bear in mind is that the build files might not be called <code class="literal">build.gradle</code>. Many projects will name the build files after the subproject names, such as <code class="literal">api.gradle</code> and <code class="literal">services.gradle</code> from the previous example. Such an approach helps a lot in IDEs because it&rsquo;s tough to work out which <code class="literal">build.gradle</code> file out of twenty possibilities is the one you want to open. This little piece of magic is handled by the <code class="literal">settings.gradle</code> file, but as a build user you don&rsquo;t need to know the details of how it&rsquo;s done. Just have a look through the child project directories to find the files with the <code class="literal">.gradle</code> suffix.</p><p>Once you know what subprojects are available, the key question for a build user is how to execute the tasks within the project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:executing_a_multiproject_build" class="section-anchor" href="#sec:executing_a_multiproject_build"></a>Executing a multi-project build</h2></div></div></div><p>From a user&rsquo;s perspective, multi-project builds are still collections of tasks you can run. The difference is that you may want to control <span class="emphasis"><em>which</em></span> project&rsquo;s tasks get executed. You have two options here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Change to the directory corresponding to the subproject you&rsquo;re interested in and just execute <code class="literal">gradle &lt;task&gt;</code> as normal.</p></li><li class="listitem"><p>Use a qualified task name from any directory, although this is usually done from the root. For example: <code class="literal">gradle :services:webservice:build</code> will build the <span class="emphasis"><em>webservice</em></span> subproject and any subprojects it depends on.</p></li></ul></div><p>The first approach is similar to the single-project use case, but Gradle works slightly differently in the case of a multi-project build. The command <code class="literal">gradle test</code> will execute the <code class="literal">test</code> task in any subprojects, relative to the current working directory, that have that task. So if you run the command from the root project directory, you&rsquo;ll run <code class="literal">test</code> in <span class="emphasis"><em>api</em></span>, <span class="emphasis"><em>shared</em></span>, <span class="emphasis"><em>services:shared</em></span> and <span class="emphasis"><em>services:webservice</em></span>. If you run the command from the services project directory, you&rsquo;ll only execute the task in <span class="emphasis"><em>services:shared</em></span> and <span class="emphasis"><em>services:webservice</em></span>.</p><p>For more control over what gets executed, use qualified names (the second approach mentioned). These are paths just like directory paths, but use &lsquo;:&rsquo; instead of &lsquo;/&rsquo; or &lsquo;\&rsquo;. If the path begins with a &lsquo;:&rsquo;, then the path is resolved relative to the root project. In other words, the leading &lsquo;:&rsquo; represents the root project itself. All other colons are path separators.</p><p>This approach works for any task, so if you want to know what tasks are in a particular subproject, just use the <code class="literal">tasks</code> task, e.g. <code class="literal">gradle :services:webservice:tasks</code> .</p><p>Regardless of which technique you use to execute tasks, Gradle will take care of building any subprojects that the target depends on. You don&rsquo;t have to worry about the inter-project dependencies yourself. If you&rsquo;re interested in how this is configured, you can read about writing multi-project builds <a class="link" href="#multi_project_builds">later in the user guide</a>.</p><p>There&rsquo;s one last thing to note. When you&rsquo;re using the Gradle wrapper, the first approach doesn&rsquo;t work well because you have to specify the path to the wrapper script if you&rsquo;re not in the project root. For example, if you&rsquo;re in the <span class="emphasis"><em>webservice</em></span> subproject directory, you would have to run <code class="literal">../../gradlew build</code>.</p><p>That&rsquo;s all you really need to know about multi-project builds as a build user. You can now identify whether a build is a multi-project one and you can discover its structure. And finally, you can execute tasks within specific subprojects.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="continuous_build"></a>Continuous build</h1></div></div></div><div class="note"><p>Continuous build is an <a class="link" href="#feature_lifecycle">incubating</a> feature. This means that it is incomplete and not yet at regular Gradle production quality. This also means that this Gradle User Guide chapter is a work in progress.</p></div><p>Typically, you ask Gradle to perform a single build by way of specifying tasks that Gradle should execute. Gradle will determine the actual set of tasks that need to be executed to satisfy the request, execute them all, and then stop doing work until the next request. A continuous build differs in that Gradle will keep satisfying the initial build request (until instructed to stop) by executing the build when it is detected that the result of the previous build is now out of date. For example, if your build compiles Java source files to Java class files, a continuous build would automatically initiate a compile when the source files change. Continuous build is useful for many scenarios.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="continuous_build_start_stop" class="section-anchor" href="#continuous_build_start_stop"></a>How do I start and stop a continuous build?</h2></div></div></div><p>A continuous build can be started by supplying either the <code class="literal">--continuous</code> or <code class="literal">-t</code> switches to Gradle, along with the list of tasks, switches and arguments that define the work to do. For example, <code class="literal">gradle build --continuous</code>. This will have the same effect as running <code class="literal">gradle build</code>, but instead of Gradle exiting when done, it will wait for changes to the build inputs. When a change occurs, <code class="literal">gradle build</code> will be automatically executed again and the process repeats.</p><p>If Gradle is attached to an interactive input source, such as a terminal, the continuous build can be exited by pressing <code class="literal">CTRL-D</code> (On Microsoft Windows, it is required to also press <code class="literal">ENTER</code> or <code class="literal">RETURN</code> after <code class="literal">CTRL-D</code>). If Gradle is not attached to an interactive input source (e.g. is running as part of a script), the build process must be terminated (e.g. using the <code class="literal">kill</code> command or similar). If the build is being executed via the Tooling API, the build can be cancelled using the Tooling API&rsquo;s cancellation mechanism.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="continuous_build_causes" class="section-anchor" href="#continuous_build_causes"></a>What will cause a subsequent build?</h2></div></div></div><div class="tip"><h3 class="title">Task file inputs</h3><p>Task implementations declare their file system inputs by annotating their properties with <a class="ulink" href="../javadoc/org/gradle/api/tasks/InputFiles.html" target="_top"><code class="classname">InputFiles</code></a> and other similar annotations. Please see <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a> for more information.</p></div><p>At this time, only changes to task inputs are noticed. Gradle will start watching for changes just before the task starts to execute. No other changes will initiate a build. For example, changes to build scripts and build logic will not initiate build. Likewise, changes to files that are read during the configuration of the build, not the execution, will not initiate a build. In order to incorporate such changes, the continuous build must be restarted manually.</p><p>Consider a typical build using the <a class="link" href="#java_plugin">Java plugin</a>, using the conventional filesystem layout. The following diagram visualizes the task graph for <code class="literal">gradle build</code>:</p><div class="figure"><a name="N10C21"></a><p class="title"><b>Figure&nbsp;4.&nbsp;Java plugin task graph</b></p><div class="figure-contents"><img src="img/javaPluginTasks.png" alt="Java plugin task graph"></div></div><br class="figure-break"><p>The following key tasks of the graph use files in the corresponding directories as inputs:</p><div class="variablelist"><dl><dt><span class="term">compileJava</span></dt><dd><p><code class="literal">src/main/java</code></p></dd><dt><span class="term">processResources</span></dt><dd><p><code class="literal">src/main/resources</code></p></dd><dt><span class="term">compileTestJava</span></dt><dd><p><code class="literal">src/test/java</code></p></dd><dt><span class="term">processTestResources</span></dt><dd><p><code class="literal">src/test/resources</code></p></dd></dl></div><p>Assuming that the initial build is successful (i.e. the <code class="literal">build</code> task and its dependencies complete without error), changes to files in, or the addition/remove of files from, the locations listed above will initiate a new build. If a change is made to a Java source file in <code class="literal">src/main/java</code>, the build will fire and all tasks will be scheduled. Gradle&rsquo;s incremental build support ensures that only the tasks that are actually affected by the change are executed.</p><p>If the change to the main Java source causes compilation to fail, subsequent changes to the test source in <code class="literal">src/test/java</code> will not initiate a new build. As the test source depends on the main source, there is no point building until the main source has changed, potentially fixing the compilation error. After each build, only the inputs of the tasks that actually executed will be monitored for changes.</p><p>Continuous build is in no way coupled to compilation. It works for all types of tasks. For example, the <code class="literal">processResources</code> task copies and processes the files from <code class="literal">src/main/resources</code> for inclusion in the built JAR. As such, a change to any file in this directory will also initiate a build.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="continuous_build_limitations" class="section-anchor" href="#continuous_build_limitations"></a>Limitations and quirks</h2></div></div></div><p>There are several issues to be aware with the current implementation of continuous build. These are likely to be addressed in future Gradle releases.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_cycles" class="section-anchor" href="#sec:build_cycles"></a>Build cycles</h3></div></div></div><p>Gradle starts watching for changes just before a task executes. If a task modifies its own inputs while executing, Gradle will detect the change and trigger a new build. If every time the task executes, the inputs are modified again, the build will be triggered again. This isn&rsquo;t unique to continuous build. A task that modifies its own inputs will never be considered up-to-date when run "normally" without continuous build.</p><p>If your build enters a build cycle like this, you can track down the task by looking at the list of files reported changed by Gradle. After identifying the file(s) that are changed during each build, you should look for a task that has that file as an input. In some cases, it may be obvious (e.g., a Java file is compiled with <code class="literal">compileJava</code>). In other cases, you can use <code class="literal">--info</code> logging to find the task that is out-of-date due to the identified files.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:continuous_build_limitations_jdk9" class="section-anchor" href="#sec:continuous_build_limitations_jdk9"></a>Restrictions with Java 9</h3></div></div></div><p>Due to class access restrictions related to Java 9, Gradle cannot set some operating system specific options, which means that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>On macOS, Gradle will poll for file changes every 10 seconds instead of every 2 seconds.</p></li><li class="listitem"><p>On Windows, Gradle must use individual file watches (like on Linux/Mac OS), which may cause continuous build to no longer work on very large projects.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:performance_and_stability" class="section-anchor" href="#sec:performance_and_stability"></a>Performance and stability</h3></div></div></div><p>The JDK file watching facility relies on inefficient file system polling on macOS (see: <a class="ulink" href="https://bugs.openjdk.java.net/browse/JDK-7133447" target="_top">JDK-7133447</a>). This can significantly delay notification of changes on large projects with many source files.</p><p>Additionally, the watching mechanism may deadlock under <span class="emphasis"><em>heavy</em></span> load on macOS (see: <a class="ulink" href="https://bugs.openjdk.java.net/browse/JDK-8079620" target="_top">JDK-8079620</a>). This will manifest as Gradle appearing not to notice file changes. If you suspect this is occurring, exit continuous build and start again.</p><p>On Linux, OpenJDK&rsquo;s implementation of the file watch service can sometimes miss file system events (see: <a class="ulink" href="https://bugs.openjdk.java.net/browse/JDK-8145981" target="_top">JDK-8145981</a>).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:changes_to_symbolic_links" class="section-anchor" href="#sec:changes_to_symbolic_links"></a>Changes to symbolic links</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Creating or removing symbolic link to files will initiate a build.</p></li><li class="listitem"><p>Modifying the target of a symbolic link will not cause a rebuild.</p></li><li class="listitem"><p>Creating or removing symbolic links to directories will not cause rebuilds.</p></li><li class="listitem"><p>Creating new files in the target directory of a symbolic link will not cause a rebuild.</p></li><li class="listitem"><p>Deleting the target directory will not cause a rebuild.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:changes_to_build_logic_are_not_considered" class="section-anchor" href="#sec:changes_to_build_logic_are_not_considered"></a>Changes to build logic are not considered</h3></div></div></div><p>The current implementation does not recalculate the build model on subsequent builds. This means that changes to task configuration, or any other change to the build model, are effectively ignored.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="composite_builds"></a>Composite builds</h1></div></div></div><div class="note"><p>Composite build is an <a class="link" href="#feature_lifecycle">incubating</a> feature. While useful for many use cases, there are bugs to be discovered, rough edges to smooth, and enhancements we plan to make. Thanks for trying it out!</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="composite_build_intro" class="section-anchor" href="#composite_build_intro"></a>What is a composite build?</h2></div></div></div><p>A composite build is simply a build that includes other builds. In many ways a composite build is similar to a Gradle multi-project build, except that instead of including single <code class="literal">projects</code>, complete <code class="literal">builds</code> are included.</p><p>Composite builds allow you to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>combine builds that are usually developed independently, for instance when trying out a bug fix in a library that your application uses</p></li><li class="listitem"><p>decompose a large multi-project build into smaller, more isolated chunks that can be worked in independently or together as needed</p></li></ul></div><p>A build that is included in a composite build is referred to, naturally enough, as an "included build". Included builds do not share any configuration with the composite build, or the other included builds. Each included build is configured and executed in isolation.</p><p>Included builds interact with other builds via <code class="literal">dependency substitution</code>. If any build in the composite has a dependency that can be satisfied by the included build, then that dependency will be replaced by a project dependency on the included build.</p><p>By default, Gradle will attempt to determine the dependencies that can be substituted by an included build. However for more flexibility, it is possible to explicitly declare these substitutions if the default ones determined by Gradle are not correct for the composite. See <a class="xref" href="#included_build_declaring_substitutions">the section called &ldquo;Declaring the dependencies substituted by an included build&rdquo;</a>.</p><p>As well as consuming outputs via project dependencies, a composite build can directly declare task dependencies on included builds. Included builds are isolated, and are not able to declare task dependencies on the composite build or on other included builds. See <a class="xref" href="#included_build_task_dependencies">the section called &ldquo;Depending on tasks in an included build&rdquo;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="defining_composite_builds" class="section-anchor" href="#defining_composite_builds"></a>Defining a composite build</h2></div></div></div><p>The following examples demonstrate the various ways that 2 Gradle builds that are normally developed separately can be combined into a composite build. For these examples, the <code class="literal">my-utils</code> multi-project build produces 2 different java libraries (<code class="literal">number-utils</code> and <code class="literal">string-utils</code>), and the <code class="literal">my-app</code> build produces an executable using functions from those libraries.</p><p>The <code class="literal">my-app</code> build does not have direct dependencies on <code class="literal">my-utils</code>. Instead, it declares binary dependencies on the libraries produced by <code class="literal">my-utils</code>.</p><div class="example"><a name="compositeBuilds_basic"></a><p class="title"><b>Example&nbsp;28.&nbsp;Dependencies of my-app</b></p><div class="example-contents"><p><code class="filename">my-app/build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
apply plugin: <span class="hl-string">'application'</span>
apply plugin: <span class="hl-string">'idea'</span>

group <span class="hl-string">"org.sample"</span>
version <span class="hl-string">"1.0"</span>

mainClassName = <span class="hl-string">"org.sample.myapp.Main"</span>

dependencies {
    compile <span class="hl-string">"org.sample:number-utils:1.0"</span>
    compile <span class="hl-string">"org.sample:string-utils:1.0"</span>
}

repositories {
    jcenter()
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/compositeBuilds/basic</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command_line_composite" class="section-anchor" href="#command_line_composite"></a>Defining a composite build via <code class="literal">--include-build</code></h3></div></div></div><p>The <code class="literal">--include-build</code> command-line argument turns the executed build into a composite, substituting dependencies from the included build into the executed build.</p><div class="example"><a name="compositeBuilds_basic_cli"></a><p class="title"><b>Example&nbsp;29.&nbsp;Declaring a command-line composite</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle --include-build ../my-utils run</code></strong></p><pre class="screen">&gt; gradle --include-build ../my-utils run
:processResources NO-SOURCE
:my-utils:string-utils:compileJava
:my-utils:string-utils:processResources NO-SOURCE
:my-utils:string-utils:classes
:my-utils:string-utils:jar
:my-utils:number-utils:compileJava
:my-utils:number-utils:processResources NO-SOURCE
:my-utils:number-utils:classes
:my-utils:number-utils:jar
:compileJava
:classes
:run
The answer is 42

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="settings_defined_composite" class="section-anchor" href="#settings_defined_composite"></a>Defining a composite build via <code class="literal">settings.gradle</code></h3></div></div></div><p>It&rsquo;s possible to make the above arrangement persistent, by using <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:includeBuild(java.lang.Object)" target="_top"><code class="classname">Settings.includeBuild(java.lang.Object)</code></a> to declare the included build in the <code class="literal">settings.gradle</code> file. The <code class="literal">settings.gradle</code> file can be used to add subprojects and included builds at the same time. Included builds are added by location. See the examples below for more details.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="separate_composite" class="section-anchor" href="#separate_composite"></a>Defining a separate composite build</h3></div></div></div><p>One downside of the above approach is that it requires you to modify an existing build, rendering it less useful as a standalone build. One way to avoid this is to define a separate composite build, whose only purpose is to combine otherwise separate builds.</p><div class="example"><a name="compositeBuilds_basic_composite"></a><p class="title"><b>Example&nbsp;30.&nbsp;Declaring a separate composite</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">rootProject.name=<span class="hl-string">'adhoc'</span>

includeBuild <span class="hl-string">'../my-app'</span>
includeBuild <span class="hl-string">'../my-utils'</span>
</pre></div></div><br class="example-break"><p>In this scenario, the 'main' build that is executed is the composite, and it doesn&rsquo;t define any useful tasks to execute itself. In order to execute the 'run' task in the 'my-app' build, the composite build must define a delegating task.</p><div class="example"><a name="compositeBuilds_basic_composite_run"></a><p class="title"><b>Example&nbsp;31.&nbsp;Depending on task from included build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task run {
    dependsOn gradle.includedBuild(<span class="hl-string">'my-app'</span>).task(<span class="hl-string">':run'</span>)
}
</pre></div></div><br class="example-break"><p>More details tasks that depend on included build tasks below.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="included_builds" class="section-anchor" href="#included_builds"></a>Restrictions on included builds</h3></div></div></div><p>Most builds can be included into a composite, however there are some limitations.</p><p>Every included build:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>must have a <code class="literal">settings.gradle</code> file.</p></li><li class="listitem"><p>must not itself be a composite build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as another included build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as a top-level project of the composite build.</p></li><li class="listitem"><p>must not have a <code class="literal">rootProject.name</code> the same as the composite build <code class="literal">rootProject.name</code>.</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="interacting_with_composite_builds" class="section-anchor" href="#interacting_with_composite_builds"></a>Interacting with a composite build</h2></div></div></div><p>In general, interacting with a composite build is much the same as a regular multi-project build. Tasks can be executed, tests can be run, and builds can be imported into the IDE.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="composite_build_executing_tasks" class="section-anchor" href="#composite_build_executing_tasks"></a>Executing tasks</h3></div></div></div><p>Tasks from the composite build can be executed from the command line, or from you IDE. Executing a task will result in direct task dependencies being executed, as well as those tasks required to build dependency artifacts from included builds.</p><div class="note"><p>There is not (yet) any means to directly execute a task from an included build via the command line. Included build tasks are automatically executed in order to generate required dependency artifacts, or the <a class="link" href="#included_build_task_dependencies">including build can declare a dependency on a task from an included build</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="composite_build_ide_integration" class="section-anchor" href="#composite_build_ide_integration"></a>Importing into the IDE</h3></div></div></div><p>One of the most useful features of composite builds is IDE integration. By applying the <a class="link" href="#idea_plugin">idea</a> or <a class="link" href="#eclipse_plugin">eclipse</a> plugin to your build, it is possible to generate a single IDEA or Eclipse project that permits all builds in the composite to be developed together.</p><p>In addition to these Gradle plugins, recent versions of <a class="ulink" href="https://www.jetbrains.com/idea/" target="_top">IntelliJ IDEA</a> and <a class="ulink" href="https://projects.eclipse.org/projects/tools.buildship" target="_top">Eclipse Buildship</a> support direct import of a composite build.</p><p>Importing a composite build permits sources from separate Gradle builds to be easily developed together. For every included build, each sub-project is included as an IDEA Module or Eclipse Project. Source dependencies are configured, providing cross-build navigation and refactoring.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="included_build_declaring_substitutions" class="section-anchor" href="#included_build_declaring_substitutions"></a>Declaring the dependencies substituted by an included build</h2></div></div></div><p>By default, Gradle will configure each included build in order to determine the dependencies it can provide. The algorithm for doing this is very simple: Gradle will inspect the group and name for the projects in the included build, and substitute project dependencies for any external dependency matching <code class="literal">${project.group}:${project.name}</code>.</p><p>There are cases when the default substitutions determined by Gradle are not sufficient, or they are not correct for a particular composite. For these cases it is possible to explicitly declare the substitutions for an included build. Take for example a single-project build 'unpublished', that produces a java utility library but does not declare a value for the group attribute:</p><div class="example"><a name="compositeBuilds_declared_unpublished"></a><p class="title"><b>Example&nbsp;32.&nbsp;Build that does not declare group attribute</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
</pre></div></div><br class="example-break"><p>When this build is included in a composite, it will attempt to substitute for the dependency module "undefined:unpublished" ("undefined" being the default value for <code class="literal">project.group</code>, and 'unpublished' being the root project name). Clearly this isn&rsquo;t going to be very useful in a composite build. To use the unpublished library unmodified in a composite build, the composing build can explicitly declare the substitutions that it provides:</p><div class="example"><a name="compositeBuilds_declared_unpublished"></a><p class="title"><b>Example&nbsp;33.&nbsp;Declaring the substitutions for an included build</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">rootProject.name = <span class="hl-string">'app'</span>

includeBuild(<span class="hl-string">'../anonymous-library'</span>) {
    dependencySubstitution {
        substitute module(<span class="hl-string">'org.sample:number-utils'</span>) with project(<span class="hl-string">':'</span>)
    }
}
</pre></div></div><br class="example-break"><p>With this configuration, the "my-app" composite build will substitute any dependency on <code class="literal">org.sample:number-utils</code> with a dependency on the root project of "unpublished".</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="included_build_substitution_requirements" class="section-anchor" href="#included_build_substitution_requirements"></a>Cases where included build substitutions must be declared</h3></div></div></div><p>Many builds that use the <code class="literal">uploadArchives</code> task to publish artifacts will function automatically as an included build, without declared substitutions. Here are some common cases where declared substitutions are required:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When the <code class="literal">archivesBaseName</code> property is used to set the name of the published artifact.</p></li><li class="listitem"><p>When a configuration other than <code class="literal">default</code> is published: this usually means a task other than <code class="literal">uploadArchives</code> is used.</p></li><li class="listitem"><p>When the <code class="literal">MavenPom.addFilter()</code> is used to publish artifacts that don&rsquo;t match the project name.</p></li><li class="listitem"><p>When the <code class="literal">maven-publish</code> or <code class="literal">ivy-publish</code> plugins are used for publishing, and the publication coordinates don&rsquo;t match <code class="literal">${project.group}:${project.name}</code>.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="included_build_substitution_limitations" class="section-anchor" href="#included_build_substitution_limitations"></a>Cases where composite build substitutions won&rsquo;t work</h3></div></div></div><p>Some builds won&rsquo;t function correctly when included in a composite, even when dependency substitutions are explicitly declared. This limitation is due to the fact that a project dependency that is substituted will always point to the <code class="literal">default</code> configuration of the target project. Any time that the artifacts and dependencies specified for the default configuration of a project don&rsquo;t match what is actually published to a repository, then the composite build may exhibit different behaviour.</p><p>Here are some cases where the publish module metadata may be different from the project default configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>When a configuration other than <code class="literal">default</code> is published.</p></li><li class="listitem"><p>When the <code class="literal">maven-publish</code> or <code class="literal">ivy-publish</code> plugins are used.</p></li><li class="listitem"><p>When the <code class="literal">POM</code> or <code class="literal">ivy.xml</code> file is tweaked as part of publication.</p></li></ul></div><p>Builds using these features function incorrectly when included in a composite build. We plan to improve this in the future.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="included_build_task_dependencies" class="section-anchor" href="#included_build_task_dependencies"></a>Depending on tasks in an included build</h2></div></div></div><p>While included builds are isolated from one another and cannot declare direct dependencies, a composite build is able to declare task dependencies on its included builds. The included builds are accessed using <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuilds" target="_top"><code class="classname">Gradle.getIncludedBuilds()</code></a> or <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:includedBuild(java.lang.String)" target="_top"><code class="classname">Gradle.includedBuild(java.lang.String)</code></a>, and a task reference is obtained via the <a class="ulink" href="../dsl/org.gradle.api.initialization.IncludedBuild.html#org.gradle.api.initialization.IncludedBuild:task(java.lang.String)" target="_top"><code class="classname">IncludedBuild.task(java.lang.String)</code></a> method.</p><p>Using these APIs, it is possible to declare a dependency on a task in a particular included build, or tasks with a certain path in all or some of the included builds.</p><div class="example"><a name="compositeBuilds_tasks_single"></a><p class="title"><b>Example&nbsp;34.&nbsp;Depending on a single task from an included build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task run {
    dependsOn gradle.includedBuild(<span class="hl-string">'my-app'</span>).task(<span class="hl-string">':run'</span>)
}
</pre></div></div><br class="example-break"><div class="example"><a name="compositeBuilds_tasks_multiple"></a><p class="title"><b>Example&nbsp;35.&nbsp;Depending on a tasks with path in all included builds</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task publishDeps {
    dependsOn gradle.includedBuilds*.task(<span class="hl-string">':uploadArchives'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="current_limitations_and_future_work" class="section-anchor" href="#current_limitations_and_future_work"></a>Current limitations and future plans for composite builds</h2></div></div></div><p>We think composite builds are pretty useful already. However, there are some things that don&rsquo;t yet work the way we&rsquo;d like, and other improvements that we think will make things work even better.</p><p>Limitations of the current implementation include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>No support for included builds that have publications that don&rsquo;t mirror the project default configuration. See <a class="xref" href="#included_build_substitution_limitations">the section called &ldquo;Cases where composite build substitutions won&rsquo;t work&rdquo;</a>.</p></li><li class="listitem"><p>Native builds are not supported. (Binary dependencies are not yet supported for native builds).</p></li><li class="listitem"><p>Substituting plugins only works with the <code class="literal">buildscript</code> block but not with the <code class="literal">plugins</code> block.</p></li></ul></div><p>Improvements we have planned for upcoming releases include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Better detection of dependency substitution, for build that publish with custom coordinates, builds that produce multiple components, etc. This will reduce the cases where dependency substitution needs to be explicitly declared for an included build.</p></li><li class="listitem"><p>The ability to target a task or tasks in an included build directly from the command line. We are currently exploring syntax options for allowing this functionality, which will remove many cases where a delegating task is required in the composite.</p></li><li class="listitem"><p>Making the implicit <code class="literal">buildSrc</code> project an included build.</p></li><li class="listitem"><p>Supporting composite-of-composite builds.</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_environment"></a>Build Environment</h1></div></div></div><p>Gradle provides multiple mechanisms for configuring behavior of Gradle itself and specific projects. The following is a reference for using these mechanisms.</p><p>When configuring Gradle behavior you can use these methods, listed in order of highest to lowest precedence (first one wins):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="#command_line_interface">Command-line flags</a> such as <code class="literal">--build-cache</code>. These have precedence over properties and environment variables.</p></li><li class="listitem"><p><a class="link" href="#sec:gradle_system_properties">System properties</a> such as <code class="literal">systemProp.http.proxyHost=somehost.org</code> stored in a <code class="literal">gradle.properties</code> file.</p></li><li class="listitem"><p><a class="link" href="#sec:gradle_configuration_properties">Gradle properties</a> such as <code class="literal">org.gradle.caching=true</code> that are typically stored in a <code class="literal">gradle.properties</code> file in a project root directory or <code class="literal">GRADLE_USER_HOME</code> environment variable.</p></li><li class="listitem"><p><a class="link" href="#sec:gradle_environment_variables">Environment variables</a> such as <code class="literal">GRADLE_OPTS</code> sourced by the environment that executes Gradle.</p></li></ul></div><p>Aside from configuring the build environment, you can configure a given project build using <a class="link" href="#sec:project_properties">Project properties</a> such as <code class="literal">-PreleaseType=final</code>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:gradle_configuration_properties" class="section-anchor" href="#sec:gradle_configuration_properties"></a>Gradle properties</h2></div></div></div><p>Gradle provides several options that make it easy to configure the Java process that will be used to execute your build. While it&rsquo;s possible to configure these in your local environment via <code class="literal">GRADLE_OPTS</code> or <code class="literal">JAVA_OPTS</code>, it is useful to store certain settings like JVM memory configuration and Java home location in version control so that an entire team can work with a consistent environment.</p><p>Setting up a consistent environment for your build is as simple as placing these settings into a <code class="literal">gradle.properties</code> file. The configuration is applied in following order (if an option is configured in multiple locations the <span class="emphasis"><em>last one wins</em></span>):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gradle.properties</code> in project root directory.</p></li><li class="listitem"><p><code class="literal">gradle.properties</code> in <code class="literal">GRADLE_USER_HOME</code> directory.</p></li><li class="listitem"><p>system properties, e.g. when <code class="literal">-Dgradle.user.home</code> is set on the command line.</p></li></ul></div><p>The following properties can be used to configure the Gradle build environment:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">org.gradle.caching=(true,false)</code></span></dt><dd><p>When set to true, Gradle will reuse task outputs from any previous build, when possible, resulting is much faster builds. Learn more about <a class="link" href="#build_cache">using the build cache</a>.</p></dd><dt><span class="term"><code class="literal">org.gradle.configureondemand=(true,false)</code></span></dt><dd><p>Enables incubating <a class="link" href="#sec:configuration_on_demand">configuration on demand</a>, where Gradle will attempt to configure only necessary projects.</p></dd><dt><span class="term"><code class="literal">org.gradle.console=(auto,plain,rich,verbose)</code></span></dt><dd><p>Customize console output coloring or verbosity. Default depends on how Gradle is invoked. See <a class="link" href="#sec:command_line_logging">command-line logging</a> for additional details.</p></dd><dt><span class="term"><code class="literal">org.gradle.daemon=(true,false)</code></span></dt><dd><p>When set to <code class="literal">true</code> the <a class="link" href="#gradle_daemon">Gradle Daemon</a> is used to run the build. Default is <code class="literal">true</code>.</p></dd><dt><span class="term"><code class="literal">org.gradle.daemon.idletimeout=(# of idle millis)</code></span></dt><dd><p>Gradle Daemon will terminate itself after specified number of idle milliseconds. Default is <code class="literal">10800000</code> (3 hours).</p></dd><dt><span class="term"><code class="literal">org.gradle.debug=(true,false)</code></span></dt><dd><p>When set to <code class="literal">true</code>, Gradle will run the build with remote debugging enabled, listening on port 5005. Note that this is the equivalent of adding <code class="literal">-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005</code> to the JVM command line and will suspend the virtual machine until a debugger is attached. Default is <code class="literal">false</code>.</p></dd><dt><span class="term"><code class="literal">org.gradle.java.home=(path to JDK home)</code></span></dt><dd><p>Specifies the Java home for the Gradle build process. The value can be set to either a <code class="literal">jdk</code> or <code class="literal">jre</code> location, however, depending on what your build does, using a JDK is safer. A reasonable default is used if the setting is unspecified.</p></dd><dt><span class="term"><code class="literal">org.gradle.jvmargs=(JVM arguments)</code></span></dt><dd><p>Specifies the JVM arguments used for the Gradle Daemon. The setting is particularly useful for <a class="link" href="#sec:configuring_jvm_memory">configuring JVM memory settings</a> for build performance.</p></dd><dt><span class="term"><code class="literal">org.gradle.logging.level=(quiet,warn,lifecycle,info,debug)</code></span></dt><dd><p>When set to quiet, warn, lifecycle, info, or debug, Gradle will use this log level. The values are not case sensitive. The <code class="literal">lifecycle</code> level is the default. See <a class="xref" href="#sec:choosing_a_log_level">the section called &ldquo;Choosing a log level&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">org.gradle.parallel=(true,false)</code></span></dt><dd><p>When configured, Gradle will fork up to <code class="literal">org.gradle.workers.max</code> JVMs to execute projects in parallel. To learn more about parallel task execution, see <a class="ulink" href="https://guides.gradle.org/performance/#parallel_execution" target="_top">the Gradle performance guide</a>.</p></dd><dt><span class="term"><code class="literal">org.gradle.warning.mode=(all,none,summary)</code></span></dt><dd><p>When set to <code class="literal">all</code>, <code class="literal">summary</code> or <code class="literal">none</code>, Gradle will use different warning type display. See <a class="xref" href="#sec:command_line_logging">the section called &ldquo;Logging options&rdquo;</a> for details.</p></dd><dt><span class="term"><code class="literal">org.gradle.workers.max=(max # of worker processes)</code></span></dt><dd><p>When configured, Gradle will use a maximum of the given number of workers. Default is number of CPU processors. See also <a class="link" href="#sec:command_line_performance">performance command-line options</a>.</p></dd></dl></div><p>The following example demonstrates usage of various properties.</p><div class="example"><a name="properties"></a><p class="title"><b>Example&nbsp;36.&nbsp;Setting properties with a gradle.properties file</b></p><div class="example-contents"><p><code class="filename">gradle.properties</code></p><pre class="programlisting">gradlePropertiesProp=gradlePropertiesValue
sysProp=shouldBeOverWrittenBySysProp
envProjectProp=shouldBeOverWrittenByEnvProp
systemProp.system=systemValue
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">task printProps {
    doLast {
        println commandLineProjectProp
        println gradlePropertiesProp
        println systemProjectProp
        println envProjectProp
        println System.properties[<span class="hl-string">'system'</span>]
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printProps</code></strong></p><pre class="screen">&gt; gradle -q -PcommandLineProjectProp=commandLineProjectPropValue -Dorg.gradle.project.systemProjectProp=systemPropertyValue printProps
commandLineProjectPropValue
gradlePropertiesValue
systemPropertyValue
envPropertyValue
systemValue
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:gradle_system_properties" class="section-anchor" href="#sec:gradle_system_properties"></a>System properties</h2></div></div></div><p>Using the <code class="literal">-D</code> command-line option, you can pass a system property to the JVM which runs Gradle. The <code class="literal">-D</code> option of the <code class="literal">gradle</code> command has the same effect as the <code class="literal">-D</code> option of the <code class="literal">java</code> command.</p><p>You can also set system properties in <code class="literal">gradle.properties</code> files with the prefix <code class="literal">systemProp.</code></p><div class="example"><a name="N10FB8"></a><p class="title"><b>Example&nbsp;37.&nbsp;Specifying system properties in <code class="literal">gradle.properties</code></b></p><div class="example-contents"><pre class="programlisting">systemProp.gradle.wrapperUser=myuser
systemProp.gradle.wrapperPassword=mypassword</pre></div></div><br class="example-break"><p>The following system properties are available. Note that command-line options take precedence over system properties.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">gradle.wrapperUser=(myuser)</code></span></dt><dd><p>Specify user name to download Gradle distributions from servers using HTTP Basic Authentication. Learn more in <a class="xref" href="#sec:authenticated_download">the section called &ldquo;Authenticated Gradle distribution download&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">gradle.wrapperPassword=(mypassword)</code></span></dt><dd><p>Specify password for downloading a Gradle distribution using the Gradle wrapper.</p></dd><dt><span class="term"><code class="literal">gradle.user.home=(path to directory)</code></span></dt><dd><p>Specify the Gradle user home directory.</p></dd></dl></div><p>In a multi project build, &ldquo;<code class="literal">systemProp.</code>&rdquo; properties set in any project except the root will be ignored. That is, only the root project&rsquo;s <code class="literal">gradle.properties</code> file will be checked for properties that begin with the &ldquo;<code class="literal">systemProp.</code>&rdquo; prefix.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:gradle_environment_variables" class="section-anchor" href="#sec:gradle_environment_variables"></a>Environment variables</h2></div></div></div><p>The following environment variables are available for the <code class="literal">gradle</code> command. Note that command-line options and system properties take precedence over environment variables.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">GRADLE_OPTS</code></span></dt><dd><p>Specifies <a class="link" href="#command_line_interface">command-line arguments</a> to use when starting the Gradle client. This can be useful for setting the properties to use when running Gradle.</p></dd><dt><span class="term"><code class="literal">GRADLE_USER_HOME</code></span></dt><dd><p>Specifies the Gradle user home directory (which defaults to <code class="literal">$USER_HOME/.gradle</code> if not set).</p></dd><dt><span class="term"><code class="literal">JAVA_HOME</code></span></dt><dd><p>Specifies the JDK installation directory to use.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_properties" class="section-anchor" href="#sec:project_properties"></a>Project properties</h2></div></div></div><p>You can add properties directly to your <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> object via the <code class="literal">-P</code> command line option.</p><p>Gradle can also set project properties when it sees specially-named system properties or environment variables. If the environment variable name looks like <code class="literal">ORG_GRADLE_PROJECT<span class="emphasis"><em>_prop</em></span>=somevalue</code>, then Gradle will set a <code class="literal">prop</code> property on your project object, with the value of <code class="literal">somevalue</code>. Gradle also supports this for system properties, but with a different naming pattern, which looks like <code class="literal">org.gradle.project.<span class="emphasis"><em>prop</em></span></code>. Both of the following will set the <code class="literal">foo</code> property on your Project object to <code class="literal">"bar"</code>.</p><div class="example"><a name="N11034"></a><p class="title"><b>Example&nbsp;38.&nbsp;Setting a project property via gradle.properties</b></p><div class="example-contents"><pre class="programlisting">org.gradle.project.foo=bar</pre></div></div><br class="example-break"><div class="example"><a name="N1103B"></a><p class="title"><b>Example&nbsp;39.&nbsp;Setting a project property via environment variable</b></p><div class="example-contents"><pre class="programlisting">ORG_GRADLE_PROJECT_foo=bar</pre></div></div><br class="example-break"><div class="note"><p>The properties file in the user&rsquo;s home directory has precedence over property files in the project directories.</p></div><p>This feature is very useful when you don&rsquo;t have admin rights to a continuous integration server and you need to set property values that should not be easily visible. Since you cannot use the <code class="literal">-P</code> option in that scenario, nor change the system-level configuration files, the correct strategy is to change the configuration of your continuous integration build job, adding an environment variable setting that matches an expected pattern. This won&rsquo;t be visible to normal users on the system.</p><p>You can access a project property in your build script simply by using its name as you would use a variable.</p><div class="note"><p>If a project property is referenced but does not exist, an exception will be thrown and the build will fail.</p><p>You should check for existence of optional project properties before you access them using the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:hasProperty(java.lang.String)" target="_top"><code class="classname">Project.hasProperty(java.lang.String)</code></a> method.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_jvm_memory" class="section-anchor" href="#sec:configuring_jvm_memory"></a>Configuring JVM memory</h2></div></div></div><p>Gradle defaults to 1024 megabytes maximum heap per JVM process (<code class="literal">-Xmx1024m</code>), however, that may be too much or too little depending on the size of your project. There are many JVM options (this <a class="ulink" href="https://dzone.com/articles/java-performance-tuning" target="_top">blog post on Java performance tuning</a> and <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_top">this reference</a> may be helpful).</p><p>You can adjust JVM options for Gradle in the following ways:</p><p>The <code class="literal">JAVA_OPTS</code> environment variable is used for the Gradle client, but not forked JVMs.</p><div class="example"><a name="N1106E"></a><p class="title"><b>Example&nbsp;40.&nbsp;Changing JVM settings for Gradle client JVM</b></p><div class="example-contents"><pre class="programlisting">JAVA_OPTS="-Xmx2g -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8"</pre></div></div><br class="example-break"><p>You need to use the <code class="literal">org.gradle.jvmargs</code> Gradle property to configure JVM settings for the <a class="link" href="#gradle_daemon">Gradle Daemon</a>.</p><div class="example"><a name="N1107E"></a><p class="title"><b>Example&nbsp;41.&nbsp;Changing JVM settings for forked Gradle JVMs</b></p><div class="example-contents"><pre class="programlisting">org.gradle.jvmargs=-Xmx2g -XX:MaxPermSize=256m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</pre></div></div><br class="example-break"><div class="note"><p>Many settings (like the Java version and maximum heap size) can only be specified when launching a new JVM for the build process. This means that Gradle must launch a separate JVM process to execute the build after parsing the various <code class="literal">gradle.properties</code> files.</p><p>When running with the <a class="link" href="#gradle_daemon">Gradle Daemon</a>, a JVM with the correct parameters is started once and reused for each daemon build execution. When Gradle is executed without the daemon, then a new JVM must be launched for every build execution, unless the JVM launched by the Gradle start script happens to have the same parameters.</p></div><p>Certain tasks in Gradle also fork additional JVM processes, like the <code class="literal">test</code> task when using <a class="ulink" href="../javadoc/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks-int-" target="_top"><code class="classname">Test.setMaxParallelForks(int)</code></a> for JUnit or TestNG tests. You must configure these through the tasks themselves.</p><div class="example"><a name="N1109B"></a><p class="title"><b>Example&nbsp;42.&nbsp;Set Java compile options for <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a> tasks</b></p><div class="example-contents"><pre class="programlisting">apply plugin: "java"

tasks.withType(JavaCompile) {
    options.compilerArgs += ["-Xdoclint:none", "-Xlint:none", "-nowarn"]
}</pre></div></div><br class="example-break"><p>See other examples in the <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a> API documentation and <a class="link" href="#sec:test_execution">test execution in the Java plugin reference</a>.</p><p><a class="ulink" href="https://scans.gradle.com" target="_top">Build scans</a> will tell you information about the JVM that executed the build when you use the <code class="literal">--scan</code> option.</p><p><a class="ulink" href="https://scans.gradle.com/s/sample/cpp-parallel/infrastructure" target="_top"><span class="inlinemediaobject"><img src="img/build-scan-infrastructure.png" alt="Build Environment in build scan"></span></a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_task_using_project_properties" class="section-anchor" href="#sec:configuring_task_using_project_properties"></a>Configuring a task using project properties</h2></div></div></div><p>It&rsquo;s possible to change the behavior of a task based on project properties specified at invocation time.</p><p>Suppose you&rsquo;d like to ensure release builds are only triggered by CI. A simple way to handle this is through an <code class="literal">isCI</code> project property.</p><div class="example"><a name="configureTaskUsingProjectProperty"></a><p class="title"><b>Example&nbsp;43.&nbsp;Prevent releasing outside of CI</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task performRelease {
    doLast {
        <span class="hl-keyword">if</span> (project.hasProperty(<span class="hl-string">"isCI"</span>)) {
            println(<span class="hl-string">"Performing release actions"</span>)
        } <span class="hl-keyword">else</span> {
            <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> InvalidUserDataException(<span class="hl-string">"Cannot perform release outside of CI"</span>)
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle performRelease -PisCI=true --quiet</code></strong></p><pre class="screen">&gt; gradle performRelease -PisCI=true --quiet
Performing release actions
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:accessing_the_web_via_a_proxy" class="section-anchor" href="#sec:accessing_the_web_via_a_proxy"></a>Accessing the web through a HTTP proxy</h2></div></div></div><p>Configuring an HTTP or HTTPS proxy (for downloading dependencies, for example) is done via standard JVM system properties. These properties can be set directly in the build script; for example, setting the HTTP proxy host would be done with <code class="literal">System.setProperty('http.proxyHost', 'www.somehost.org')</code>. Alternatively, the properties can be <a class="link" href="#sec:gradle_configuration_properties">specified in gradle.properties</a>.</p><div class="example"><a name="N110EC"></a><p class="title"><b>Example&nbsp;44.&nbsp;Configuring an HTTP proxy using <code class="literal">gradle.properties</code></b></p><div class="example-contents"><pre class="programlisting">systemProp.http.proxyHost=www.somehost.org
systemProp.http.proxyPort=8080
systemProp.http.proxyUser=userid
systemProp.http.proxyPassword=password
systemProp.http.nonProxyHosts=*.nonproxyrepos.com|localhost</pre></div></div><br class="example-break"><p>There are separate settings for HTTPS.</p><div class="example"><a name="N110F7"></a><p class="title"><b>Example&nbsp;45.&nbsp;Configuring an HTTPS proxy using <code class="literal">gradle.properties</code></b></p><div class="example-contents"><pre class="programlisting">systemProp.https.proxyHost=www.somehost.org
systemProp.https.proxyPort=8080
systemProp.https.proxyUser=userid
systemProp.https.proxyPassword=password
systemProp.https.nonProxyHosts=*.nonproxyrepos.com|localhost</pre></div></div><br class="example-break"><p>You may need to set other properties to access other networks. Here are 2 references that may be helpful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="https://git-wip-us.apache.org/repos/asf?p=ant.git;a=blob;f=src/main/org/apache/tools/ant/util/ProxySetup.java;hb=HEAD" target="_top">ProxySetup.java in the Ant codebase</a></p></li><li class="listitem"><p><a class="ulink" href="http://download.oracle.com/javase/7/docs/technotes/guides/net/properties.html" target="_top">JDK 7 Networking Properties</a></p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_ntlm_authentication" class="section-anchor" href="#_ntlm_authentication"></a>NTLM Authentication</h3></div></div></div><p>If your proxy requires NTLM authentication, you may need to provide the authentication domain as well as the username and password. There are 2 ways that you can provide the domain for authenticating to a NTLM proxy:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Set the <code class="literal">http.proxyUser</code> system property to a value like <code class="literal"><span class="emphasis"><em>domain</em></span>/<span class="emphasis"><em>username</em></span></code>.</p></li><li class="listitem"><p>Provide the authentication domain via the <code class="literal">http.auth.ntlm.domain</code> system property.</p></li></ul></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="troubleshooting"></a>Troubleshooting</h1></div></div></div><div class="note"><p>This chapter is currently a work in progress.</p></div><p>When using Gradle (or any software package), you can run into problems. You may not understand how to use a particular feature, or you may encounter a defect. Or, you may have a general question about Gradle.</p><p>This chapter gives some advice for troubleshooting problems and explains how to get help with your problems.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_through_problems" class="section-anchor" href="#sec:working_through_problems"></a>Working through problems</h2></div></div></div><p>If you are encountering problems, one of the first things to try is using the very latest release of Gradle. New versions of Gradle are released frequently with bug fixes and new features. The problem you are having may have been fixed in a new release.</p><p>If you are using the Gradle Daemon, try temporarily disabling the daemon (you can pass the command line switch <code class="literal">--no-daemon</code>). More information about troubleshooting the daemon process is located in <a class="xref" href="#gradle_daemon"><i>The Gradle Daemon</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:troubleshooting_getting_help" class="section-anchor" href="#sec:troubleshooting_getting_help"></a>Getting help</h2></div></div></div><p>The place to go for help with Gradle is <a class="ulink" href="http://forums.gradle.org" target="_top">http://forums.gradle.org</a>. The Gradle Forums is the place where you can report problems and ask questions of the Gradle developers and other community members.</p><p>If something&rsquo;s not working for you, posting a question or problem report to the forums is the fastest way to get help. It&rsquo;s also the place to post improvement suggestions or new ideas. The development team frequently posts news items and announces releases via the forum, making it a great way to stay up to date with the latest Gradle developments.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="embedding"></a>Embedding Gradle using the Tooling API</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:embedding_introduction" class="section-anchor" href="#sec:embedding_introduction"></a>Introduction to the Tooling API</h2></div></div></div><p>Gradle provides a programmatic API called the Tooling API, which you can use for embedding Gradle into your own software. This API allows you to execute and monitor builds and to query Gradle about the details of a build. The main audience for this API is IDE, CI server, other UI authors; however, the API is open for anyone who needs to embed Gradle in their application.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="link" href="#test_kit">Gradle TestKit</a> uses the Tooling API for functional testing of your Gradle plugins.</p></li><li class="listitem"><p><a class="ulink" href="http://projects.eclipse.org/projects/tools.buildship" target="_top">Eclipse Buildship</a> uses the Tooling API for importing your Gradle project and running tasks.</p></li><li class="listitem"><p><a class="ulink" href="https://www.jetbrains.com/idea/" target="_top">IntelliJ IDEA</a> uses the Tooling API for importing your Gradle project and running tasks.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:embedding_features" class="section-anchor" href="#sec:embedding_features"></a>Tooling API Features</h2></div></div></div><p>A fundamental characteristic of the Tooling API is that it operates in a version independent way. This means that you can use the same API to work with builds that use different versions of Gradle, including versions that are newer or older than the version of the Tooling API that you are using. The Tooling API is Gradle wrapper aware and, by default, uses the same Gradle version as that used by the wrapper-powered build.</p><p>Some features that the Tooling API provides:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Query the details of a build, including the project hierarchy and the project dependencies, external dependencies (including source and Javadoc jars), source directories and tasks of each project.</p></li><li class="listitem"><p>Execute a build and listen to stdout and stderr logging and progress messages (e.g. the messages shown in the 'status bar' when you run on the command line).</p></li><li class="listitem"><p>Execute a specific test class or test method.</p></li><li class="listitem"><p>Receive interesting events as a build executes, such as project configuration, task execution or test execution.</p></li><li class="listitem"><p>Cancel a build that is running.</p></li><li class="listitem"><p>Combine multiple separate Gradle builds into a single composite build.</p></li><li class="listitem"><p>The Tooling API can download and install the appropriate Gradle version, similar to the wrapper.</p></li><li class="listitem"><p>The implementation is lightweight, with only a small number of dependencies. It is also a well-behaved library, and makes no assumptions about your classloader structure or logging configuration. This makes the API easy to embed in your application.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:embedding_daemon" class="section-anchor" href="#sec:embedding_daemon"></a>Tooling API and the Gradle Build Daemon</h2></div></div></div><p>The Tooling API always uses the Gradle daemon. This means that subsequent calls to the Tooling API, be it model building requests or task executing requests will be executed in the same long-living process. <a class="xref" href="#gradle_daemon"><i>The Gradle Daemon</i></a> contains more details about the daemon, specifically information on situations when new daemons are forked.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:embedding_quickstart" class="section-anchor" href="#sec:embedding_quickstart"></a>Quickstart</h2></div></div></div><p>As the Tooling API is an interface for developers, the Javadoc is the main documentation for it. We provide several <span class="emphasis"><em>samples</em></span> that live in <code class="literal">samples/toolingApi</code> in your Gradle distribution. These samples specify all of the required dependencies for the Tooling API with examples for querying information from Gradle builds and executing tasks from the Tooling API.</p><p>To use the Tooling API, add the following repository and dependency declarations to your build script:</p><div class="example"><a name="useToolingApi"></a><p class="title"><b>Example&nbsp;46.&nbsp;Using the tooling API</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven { url <span class="hl-string">'https://repo.gradle.org/gradle/libs-releases'</span> }
}

dependencies {
    compile <span class="hl-string">"org.gradle:gradle-tooling-api:${toolingApiVersion}"</span>
    <span class="hl-comment">// The tooling API need an SLF4J implementation available at runtime, replace this with any other implementation</span>
    runtime <span class="hl-string">'org.slf4j:slf4j-simple:1.7.10'</span>
}
</pre></div></div><br class="example-break"><p>The main entry point to the Tooling API is the <a class="ulink" href="../javadoc/org/gradle/tooling/GradleConnector.html" target="_top"><code class="classname">GradleConnector</code></a>. You can navigate from there to find code samples and explore the available Tooling API models. You can use <a class="ulink" href="../javadoc/org/gradle/tooling/GradleConnector.html#connect--" target="_top"><code class="classname">GradleConnector.connect()</code></a> to create a <a class="ulink" href="../javadoc/org/gradle/tooling/ProjectConnection.html" target="_top"><code class="classname">ProjectConnection</code></a>. A <code class="literal">ProjectConnection</code> connects to a single Gradle project. Using the connection you can execute tasks, tests and retrieve models relative to this project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:embedding_compatibility" class="section-anchor" href="#sec:embedding_compatibility"></a>Gradle version and Java version compatibility</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_provider_side" class="section-anchor" href="#_provider_side"></a>Provider side</h3></div></div></div><p>The current version of Tooling API supports running builds using Gradle versions 1.2 and later. However, support for running builds with Gradle versions older than 2.6 is deprecated and will be removed in Tooling API version 5.0.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_consumer_side" class="section-anchor" href="#_consumer_side"></a>Consumer side</h3></div></div></div><p>The current version of Gradle supports running builds via Tooling API versions 2.0 and later. However, support for running builds via Tooling API versions older than 3.0 is deprecated and will be removed in Gradle 5.0.</p><p>You should note that not all features of the Tooling API are available for all versions of Gradle. For example, build cancellation is only available when a build uses Gradle 2.1 and later. Refer to the documentation for each class and method for more details.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="_java_version" class="section-anchor" href="#_java_version"></a>Java version</h2></div></div></div><p>The Tooling API requires Java 8 or later. Java 7 is currently still supported but will be removed in Gradle 5.0. The Gradle version used by builds may have additional Java version requirements.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_cache"></a>Build Cache</h1></div></div></div><div class="note"><p>The build cache feature is ready to be used for Java, Groovy and Scala projects. Work continues to make it available in more areas.</p></div><div class="note"><p>The build cache feature described here is different from the <a class="ulink" href="http://tools.android.com/tech-docs/build-cache" target="_top">Android plugin build cache</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_cache_intro" class="section-anchor" href="#sec:build_cache_intro"></a>Overview</h2></div></div></div><p>The Gradle <span class="emphasis"><em>build cache</em></span> is a cache mechanism that aims to save time by reusing outputs produced by other builds.
The build cache works by storing (locally or remotely) build outputs and allowing builds to fetch these outputs from the cache when it is determined that inputs have not changed, avoiding the expensive work of regenerating them.</p><p>A first feature using the build cache is <span class="emphasis"><em>task output caching</em></span>.
Essentially, task output caching leverages the same intelligence as <a class="link" href="#sec:up_to_date_checks">up-to-date checks</a> that Gradle uses to avoid work when a previous local build has already produced a set of task outputs.
But instead of being limited to the previous build in the same workspace, task output caching allows Gradle to reuse task outputs from any earlier build in any location on the local machine.
When using a shared build cache for task output caching this even works across developer machines and build agents.</p><p>Apart from task output caching, we expect other features to use the build cache in the future.</p><div class="note"><p>A complete guide is available about <a class="ulink" href="https://guides.gradle.org/using-build-cache/" target="_top">using the build cache</a>. It covers the different scenarios caching can improve, and detailed discussions of the different caveats you need to be aware of when enabling caching for a build.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_cache_enable" class="section-anchor" href="#sec:build_cache_enable"></a>Enable the Build Cache</h2></div></div></div><p>By default, the build cache is not enabled. You can enable the build cache in a couple of ways:</p><div class="variablelist"><dl><dt><span class="term">Run with <code class="literal">--build-cache</code> on the command-line</span></dt><dd><p>Gradle will use the build cache for this build only.</p></dd><dt><span class="term">Put <code class="literal">org.gradle.caching=true</code> in your <code class="literal">gradle.properties</code></span></dt><dd><p>Gradle will try to reuse outputs from previous builds for all builds, unless explicitly disabled with <code class="literal">--no-build-cache</code>.</p></dd></dl></div><p>When the build cache is enabled, it will store build outputs in the Gradle user home.
For configuring this directory or different kinds of build caches see <a class="xref" href="#sec:build_cache_configure">the section called &ldquo;Configure the Build Cache&rdquo;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:task_output_caching" class="section-anchor" href="#sec:task_output_caching"></a>Task Output Caching</h2></div></div></div><p>Beyond incremental builds described in <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>, Gradle can save time by reusing outputs from previous executions of a task by matching inputs to the task.
Task outputs can be reused between builds on one computer or even between builds running on different computers via a build cache.</p><p>We have focused on the use case where users have an organization-wide remote build cache that is populated regularly by continuous integration builds.
Developers and other continuous integration agents should pull cache entries from the remote build cache.
We expect that developers will not be allowed to populate the remote build cache, and all continuous integration builds populate the build cache after running the <code class="literal">clean</code> task.</p><p>For your build to play well with task output caching it must work well with the <a class="link" href="#sec:up_to_date_checks">incremental build</a> feature.
For example, when running your build twice in a row all tasks with outputs should be <code class="literal">UP-TO-DATE</code>.
You cannot expect faster builds or correct builds when enabling task output caching when this prerequisite is not met.</p><p>Task output caching is automatically enabled when you enable the build cache, see <a class="xref" href="#sec:build_cache_enable">the section called &ldquo;Enable the Build Cache&rdquo;</a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_output_caching_example" class="section-anchor" href="#sec:task_output_caching_example"></a>What does it look like</h3></div></div></div><p>Let us start with a project using the Java plugin which has a few Java source files. We run the build the first time.</p><pre class="screen">$&gt; gradle --build-cache compileJava
Build cache is an incubating feature.
Using local directory build cache for the root build (location = /home/user/.gradle/caches/build-cache-1).
:compileJava
:processResources
:classes
:jar
:assemble

BUILD SUCCESSFUL</pre><p>We see the directory used by the local build cache in the output. Apart from that the build was the same as without the build cache.
Let&rsquo;s clean and run the build again.</p><pre class="screen">$&gt; gradle clean
:clean

BUILD SUCCESSFUL</pre><pre class="screen">$&gt; gradle --build-cache assemble
Build cache is an incubating feature.
Using local directory build cache for the root build (location = /home/user/.gradle/caches/build-cache-1).
:compileJava FROM-CACHE
:processResources
:classes
:jar
:assemble

BUILD SUCCESSFUL</pre><p>Now we see that, instead of executing the <code class="literal">:compileJava</code> task, the outputs of the task have been loaded from the build cache.
The other tasks have not been loaded from the build cache since they are not cacheable. This is due to
<code class="literal">:classes</code> and <code class="literal">:assemble</code> being <a class="link" href="#sec:lifecycle_tasks">lifecycle tasks</a> and <code class="literal">:processResources</code>
and <code class="literal">:jar</code> being Copy-like tasks which are not cacheable since it is generally faster to execute them.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_output_caching_details" class="section-anchor" href="#sec:task_output_caching_details"></a>Cacheable tasks</h3></div></div></div><p>Since a task describes all of its inputs and outputs, Gradle can compute a <span class="emphasis"><em>build cache key</em></span> that uniquely defines the task&rsquo;s outputs based on its inputs.
That build cache key is used to request previous outputs from a build cache or push new outputs to the build cache. If the previous build is already populated by someone else, e.g. your
continuous integration server or other developers, you can avoid executing most tasks locally.</p><p>The following inputs contribute to the build cache key for a task in the same way that they do for <a class="link" href="#sec:how_does_it_work">up-to-date checks</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The task type and its classpath</p></li><li class="listitem"><p>The names of the output properties</p></li><li class="listitem"><p>The names and values of properties annotated as described in <a class="xref" href="#sec:task_input_output_annotations">the section called &ldquo;Custom task types&rdquo;</a></p></li><li class="listitem"><p>The names and values of properties added by the DSL via <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top"><code class="classname">TaskInputs</code></a></p></li><li class="listitem"><p>The classpath of the Gradle distribution, buildSrc and plugins</p></li><li class="listitem"><p>The content of the build script when it affects execution of the task</p></li></ul></div><p>Task types need to opt-in to task output caching using the <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/CacheableTask.html" target="_top"><code class="classname">CacheableTask</code></a></code> annotation.
Note that <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/CacheableTask.html" target="_top"><code class="classname">CacheableTask</code></a></code> is not inherited by subclasses.
Custom task types are <span class="emphasis"><em>not</em></span> cacheable by default.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_output_caching_cacheable_tasks" class="section-anchor" href="#sec:task_output_caching_cacheable_tasks"></a>Built-in cacheable tasks</h4></div></div></div><p>Currently, the following built-in Gradle tasks are cacheable:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Java toolchain:
<a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.tasks.javadoc.Javadoc.html" target="_top"><code class="classname">Javadoc</code></a></p></li><li class="listitem"><p>Groovy toolchain:
<a class="ulink" href="../dsl/org.gradle.api.tasks.compile.GroovyCompile.html" target="_top"><code class="classname">GroovyCompile</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.tasks.javadoc.Groovydoc.html" target="_top"><code class="classname">Groovydoc</code></a></p></li><li class="listitem"><p>Scala toolchain:
<a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaCompile.html" target="_top"><code class="classname">ScalaCompile</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaDoc.html" target="_top"><code class="classname">ScalaDoc</code></a></p></li><li class="listitem"><p>Native toolchain:
<a class="ulink" href="../dsl/org.gradle.language.cpp.tasks.CppCompile.html" target="_top"><code class="classname">CppCompile</code></a>,
<a class="ulink" href="../dsl/org.gradle.language.c.tasks.CCompile.html" target="_top"><code class="classname">CCompile</code></a></p></li><li class="listitem"><p>Testing:
<a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a></p></li><li class="listitem"><p>Code quality tasks:
<a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Checkstyle.html" target="_top"><code class="classname">Checkstyle</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CodeNarc.html" target="_top"><code class="classname">CodeNarc</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugs.html" target="_top"><code class="classname">FindBugs</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.plugins.quality.JDepend.html" target="_top"><code class="classname">JDepend</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Pmd.html" target="_top"><code class="classname">Pmd</code></a></p></li><li class="listitem"><p>Jacoco:
<a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoMerge.html" target="_top"><code class="classname">JacocoMerge</code></a>,
<a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html" target="_top"><code class="classname">JacocoReport</code></a></p></li><li class="listitem"><p>Other tasks:
<a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a>
<a class="ulink" href="../javadoc/org/gradle/plugin/devel/tasks/ValidateTaskProperties.html" target="_top"><code class="classname">ValidateTaskProperties</code></a>,
<a class="ulink" href="../dsl/org.gradle.api.tasks.WriteProperties.html" target="_top"><code class="classname">WriteProperties</code></a></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_output_caching_non_cacheable_tasks" class="section-anchor" href="#sec:task_output_caching_non_cacheable_tasks"></a>Non-cacheable tasks</h4></div></div></div><p>All other tasks are currently not cacheable, but this may change in the future for other languages (Kotlin) or domains (native, Android, Play).
Some tasks, like <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a> or <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>, usually do not make sense to make cacheable because Gradle is only copying files from one location to another.
It also doesn&rsquo;t make sense to make tasks cacheable that do not produce outputs or have no task actions.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_output_caching_inputs" class="section-anchor" href="#sec:task_output_caching_inputs"></a>Declaring task inputs and outputs</h3></div></div></div><p>It is very important that a cacheable task has a complete picture of its inputs and outputs, so that the results from one build can be safely re-used somewhere else.</p><p>Missing task inputs can cause incorrect cache hits, where different results are treated as identical because the same cache key is used by both executions.
Missing task outputs can cause build failures if Gradle does not completely capture all outputs for a given task.
Wrongly declared task inputs can lead to cache misses especially when containing volatile data or absolute paths.
(See <a class="xref" href="#sec:task_inputs_outputs">the section called &ldquo;Task inputs and outputs&rdquo;</a> on what should be declared as inputs and outputs.)</p><div class="note"><p>The task path is <span class="emphasis"><em>not</em></span> an input to the build cache key.
This means that tasks with different task paths can re-use each other&rsquo;s outputs as long as Gradle determines that executing them yields the same result.</p></div><p>In order to ensure that the inputs and outputs are properly declared use integration tests (for example using TestKit) to check that a task produces the same outputs for identical inputs and captures all output files for the task.
We suggest adding tests to ensure that the task inputs are relocatable, i.e. that the task can be loaded from the cache into a different build directory (see <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/PathSensitive.html" target="_top"><code class="classname">PathSensitive</code></a></code>).</p><p>In order to handle volatile inputs for your tasks consider <a class="link" href="#sec:configure_input_normalization">configuring input normalization</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_output_caching_known_issues" class="section-anchor" href="#sec:task_output_caching_known_issues"></a>Known issues with task output caching</h3></div></div></div><p>The task output caching feature has known issues that may impact the correctness of your build when using the build cache,
and there are some caveats to keep in mind which may reduce the number of cache hits you get between machines.
These issues will be corrected as this feature becomes stable.</p><p>Note that task output caching relies on <a class="link" href="#sec:up_to_date_checks">incremental build</a>.
Problems that affect incremental builds can also affect task output caching even if the affected tasks are not cacheable.
Most issues only cause problems if your build cache is populated by non-clean builds or if caching has been enabled for unsupported tasks.
For a current list of open problems with incremental builds see these
<a class="ulink" href="https://github.com/gradle/gradle/issues?utf8=%E2%9C%93&amp;q=is%3Aopen%20label%3Aa%3Abug%20label%3Ain%3Aincremental-build%20" target="_top">Github issues</a>.</p><div class="note"><p>When <a class="ulink" href="https://github.com/gradle/gradle/issues/new?labels=in:build-cache" target="_top">reporting issues with the build cache</a>, please check if your issue is a known issue or related to a known issue.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_output_caching_known_issues_correctness" class="section-anchor" href="#sec:task_output_caching_known_issues_correctness"></a>Correctness issues</h4></div></div></div><p>These issues may affect the correctness of your build when using the build cache. Please consider these issues carefully.</p><div class="table"><p class="title"><b>Table&nbsp;1.&nbsp;Correctness issues</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N11364"><thead><tr>
<td>Description</td>
<td>Impact</td>
<td>Workaround</td>
</tr></thead><tbody><tr>
<td><p>Tracking the Java vendor implementation</p></td>
<td><p>Gradle currently tracks the major version of Java that is used for compilation and test execution. If your build uses several Java implementations (IBM, OpenJDK, Oracle, etc) that are the same major version, Gradle will treat them all as equivalent and re-use outputs from any implementation.</p></td>
<td><p>Only enable caching for builds that all use the same Java implementation or manually add the Java vendor as an input to compilation and test execution tasks by using <a class="link" href="#sec:task_input_output_runtime_api">the runtime api</a> for adding task inputs.</p></td>
</tr><tr>
<td><p>Tracking the Java version</p></td>
<td><p>Gradle currently tracks the major version of Java (6 vs 7 vs 8) that is used for compilation and test execution. If your build expects to use several minor releases (1.8.0_102 vs 1.8.0_25), Gradle will treat all of these as equivalent and re-use outputs from any minor version. In our experience, bytecode produced by each major version is functionally equivalent.</p></td>
<td><p>Manually add the full Java version as an input to compilation and test execution tasks by using <a class="link" href="#sec:task_input_output_runtime_api">the runtime api</a> for adding task inputs.</p></td>
</tr><tr>
<td><p>Environment variables are not tracked as inputs.</p></td>
<td><p>For tasks that fork processes (like <code class="literal">Test</code>), Gradle does not track any of the environment variables visible to the process. This can allow undeclared inputs to affect the outputs of the task.</p></td>
<td><p>Declare environment variables as inputs to the task with <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html#property-java.lang.String, java.lang.Object-" target="_top"><code class="classname">TaskInputs.property(java.lang.String, java.lang.Object)</code></a>.</p></td>
</tr><tr>
<td><p>Changes in Gradle&rsquo;s file encoding that affect the build script</p></td>
<td><p>Gradle can produce different task output based on the file encoding used by the JVM. Gradle will use a default file encoding based on the operating system if <code class="literal">file.encoding</code> is not explicitly set.</p></td>
<td><p>Set the UTF-8 file encoding on all tasks which allow setting the encoding. Use UTF-8 file encoding everywhere by setting <code class="literal">file.encoding</code> to <code class="literal">UTF-8</code> for the Gradle JVM.</p></td>
</tr><tr>
<td><p>Javadoc ignores custom command-line options</p></td>
<td><p>Gradle&rsquo;s Javadoc task does not take into account any changes to custom command-line options.</p></td>
<td><p>You can add your custom options as input properties or disable caching of Javadoc.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_output_caching_known_issues_caveats" class="section-anchor" href="#sec:task_output_caching_known_issues_caveats"></a>Caveats</h4></div></div></div><p>These issues may affect the number of cache hits you get between machines.</p><div class="table"><p class="title"><b>Table&nbsp;2.&nbsp;Caveats</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N113DC"><thead><tr>
<td>Description</td>
<td>Impact</td>
<td>Workaround</td>
</tr></thead><tbody><tr>
<td><p>Overlapping outputs between tasks</p></td>
<td><p>If two or more tasks share an output directory or files, Gradle will disable caching for these tasks when it detects an overlap.</p></td>
<td><p>Use separate output directories for each task.</p></td>
</tr><tr>
<td><p>Using cached C/C++ object files with absolute paths</p></td>
<td><p>When Gradle compiles C/C++ code, object files tend to have absolute paths embedded inside them. This doesn&rsquo;t affect their correctness, but it can interfere with debuggers that search for source code at those absolute paths.</p></td>
<td><p>Build the project from the same absolute path on every machine.</p></td>
</tr><tr>
<td><p>Line endings in build scripts files.</p></td>
<td><p>Gradle calculates the build cache key based on the MD5 hash of the build script contents. If the line endings are different between developers and the CI servers, Gradle will calculate different build cache keys even when all other inputs to a task are the same.</p></td>
<td><p>Check if your VCS will change source file line endings and configure it to have a consistent line ending across all platforms.</p></td>
</tr><tr>
<td><p>Absolute paths in command-line arguments and system properties.</p></td>
<td><p>Gradle provides ways of specifying the path sensitivity for individual task properties (see <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/PathSensitive.html" target="_top"><code class="classname">PathSensitive</code></a></code>);
however, it is common to need to pass absolute paths to tools or to tests via system properties or command line arguments.
These kinds of inputs will cause cache misses because not every developer or CI server uses an identical absolute path to the root of a build.
Tasks like <code class="literal">Test</code> include system properties and JVM arguments as inputs to the build cache key.</p></td>
<td><p>If possible, use relative paths (via <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:relativePath(java.lang.Object)" target="_top"><code class="classname">Project.relativePath(java.lang.Object)</code></a>). Further tooling will be provided later.</p></td>
</tr><tr>
<td><p>Using JaCoCo disables caching of the Test task.</p></td>
<td><p>The JaCoCo agent relies on appending to a shared output file that may be left over from a different test execution. If Gradle allowed Test tasks to be cacheable with the JaCoCo plugin, it could not guarantee the same results each time.</p></td>
<td><p>None.</p></td>
</tr><tr>
<td><p>Adding new actions to cacheable tasks in a build file makes that task sensitive to unrelated changes to the build file.</p></td>
<td><p>Actions added by a plugin (from buildSrc or externally) do not have this problem because their classloader is restricted to the classpath of the plugin.</p></td>
<td><p>Avoid adding actions to cacheable tasks in a build file.</p></td>
</tr><tr>
<td><p>Modifying inputs or outputs during task execution.</p></td>
<td><p>It&rsquo;s possible to modify a task&rsquo;s inputs or outputs during execution in ways that change the output of a task. This breaks incremental builds and can cause problems with the build cache.</p></td>
<td><p>Use a configure task to finalize configuration for a given task. A configure task configures another task as part of its execution.</p></td>
</tr><tr>
<td><p>Order of input files affects outputs.</p></td>
<td><p>Some tools are sensitive to the order of its inputs and will produce slightly different output. Gradle will usually provide the order of files from the filesystem, which will be different across operating systems.</p></td>
<td><p>Provide a stable order for tools affected by order.</p></td>
</tr><tr>
<td><p>ANTLR3 produces output with a timestamp.</p></td>
<td><p>When generating Java source code with ANTLR3 and the <a class="xref" href="#antlr_plugin"><i>The ANTLR Plugin</i></a>, the generated sources contain a timestamp that reduces how often Java compilation will be cached. ANTLR2 and ANTLR4 are not affected.</p></td>
<td><p>If you cannot upgrade to ANLTR4 use a custom template or remove the timestamp in a <code class="literal">doLast</code> action.</p></td>
</tr></tbody></table></div></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_cache_configure" class="section-anchor" href="#sec:build_cache_configure"></a>Configure the Build Cache</h2></div></div></div><p>You can configure the build cache by using the <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:buildCache(org.gradle.api.Action)" target="_top"><code class="classname">Settings.buildCache(org.gradle.api.Action)</code></a> block in <code class="literal">settings.gradle</code>.</p><p>Gradle supports a <code class="literal">local</code> and a <code class="literal">remote</code> build cache that can be configured separately.
When both build caches are enabled, Gradle tries to load build outputs from the local build cache first, and then tries the remote build cache if no build outputs are found.
If outputs are found in the remote cache, they are also stored in the local cache, so next time they will be found locally.
Gradle pushes build outputs to any build cache that is enabled and has <a class="ulink" href="../javadoc/org/gradle/caching/configuration/BuildCache.html#isPush--" target="_top"><code class="classname">BuildCache.isPush()</code></a> set to <code class="literal">true</code>.</p><p>By default, the local build cache has push enabled, and the remote build cache has push disabled.</p><p>The local build cache is pre-configured to be a <a class="ulink" href="../dsl/org.gradle.caching.local.DirectoryBuildCache.html" target="_top"><code class="classname">DirectoryBuildCache</code></a> and enabled by default.
The remote build cache can be configured by specifying the type of build cache to connect to (<a class="ulink" href="../dsl/org.gradle.caching.configuration.BuildCacheConfiguration.html#org.gradle.caching.configuration.BuildCacheConfiguration:remote(java.lang.Class)" target="_top"><code class="classname">BuildCacheConfiguration.remote(java.lang.Class)</code></a>).</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_cache_configure_local" class="section-anchor" href="#sec:build_cache_configure_local"></a>Built-in local build cache</h3></div></div></div><p>The built-in local build cache, <a class="ulink" href="../dsl/org.gradle.caching.local.DirectoryBuildCache.html" target="_top"><code class="classname">DirectoryBuildCache</code></a>, uses a directory to store build cache artifacts.
By default, this directory resides in the Gradle user home directory, but its location is configurable.</p><p>Gradle will periodically clean-up the local cache directory to reduce it to a configurable target size.
This means that the local build cache directory may temporarily grow over the target size until the next clean-up is scheduled.</p><p>For more details on the configuration options refer to the DSL documentation of <a class="ulink" href="../dsl/org.gradle.caching.local.DirectoryBuildCache.html" target="_top"><code class="classname">DirectoryBuildCache</code></a>.
Here is an example of the configuration.</p><div class="example"><a name="directoryBuildCacheConfiguration"></a><p class="title"><b>Example&nbsp;47.&nbsp;Configure the local cache</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">buildCache {
    local(DirectoryBuildCache) {
        directory = <span class="hl-keyword">new</span> File(rootDir, <span class="hl-string">'build-cache'</span>)
        targetSizeInMB = <span class="hl-number">1024</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_cache_configure_remote" class="section-anchor" href="#sec:build_cache_configure_remote"></a>Remote HTTP build cache</h3></div></div></div><p>Gradle has built-in support for connecting to a remote build cache backend via HTTP.
For more details on what the protocol looks like see <a class="ulink" href="../dsl/org.gradle.caching.http.HttpBuildCache.html" target="_top"><code class="classname">HttpBuildCache</code></a>.
Note that by using the following configuration the local build cache will be used for storing build outputs while the local and the remote build cache will be used for retrieving build outputs.</p><div class="example"><a name="httpBuildCache"></a><p class="title"><b>Example&nbsp;48.&nbsp;Pull from HttpBuildCache</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">buildCache {
    remote(HttpBuildCache) {
        url = <span class="hl-string">'https://example.com:8123/cache/'</span>
    }
}
</pre></div></div><br class="example-break"><p>You can configure the credentials the <a class="ulink" href="../dsl/org.gradle.caching.http.HttpBuildCache.html" target="_top"><code class="classname">HttpBuildCache</code></a> uses to access the build cache server as shown in the following example.</p><div class="example"><a name="httpBuildCacheConfiguration"></a><p class="title"><b>Example&nbsp;49.&nbsp;Configure remote HTTP cache</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">buildCache {
    remote(HttpBuildCache) {
        url = <span class="hl-string">'http://example.com:8123/cache/'</span>
        credentials {
            username = <span class="hl-string">'build-cache-user'</span>
            password = <span class="hl-string">'some-complicated-password'</span>
        }
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>You may encounter problems with an untrusted SSL certificate when you try to use a build cache backend with an HTTPS URL.
The ideal solution is for someone to add a valid SSL certificate to the build cache backend, but we recognize that you may not be able to do that.
In that case, set <a class="ulink" href="../dsl/org.gradle.caching.http.HttpBuildCache.html#org.gradle.caching.http.HttpBuildCache:allowUntrustedServer" target="_top"><code class="classname">HttpBuildCache.isAllowUntrustedServer()</code></a> to <code class="literal">true</code>:</p><div class="example"><a name="httpBuildCacheAllowUntrustedServer"></a><p class="title"><b>Example&nbsp;50.&nbsp;Allow untrusted SSL certificate for HttpBuildCache</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">buildCache {
    remote(HttpBuildCache) {
        url = <span class="hl-string">'https://example.com:8123/cache/'</span>
        allowUntrustedServer = true
    }
}
</pre></div></div><br class="example-break"><p>This is a convenient workaround, but you shouldn&rsquo;t use it as a long-term solution.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_cache_configure_use_cases" class="section-anchor" href="#sec:build_cache_configure_use_cases"></a>Configuration use cases</h3></div></div></div><p>The recommended use case for the build cache is that your continuous integration server populates the remote build cache with clean builds while developers pull
from the remote build cache and push to a local build cache. The configuration would then look as follows.</p><div class="example"><a name="developerCiSetup"></a><p class="title"><b>Example&nbsp;51.&nbsp;Recommended setup for CI push use case</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">ext.isCiServer = System.getenv().containsKey(<span class="hl-string">"CI"</span>)

buildCache {
    local {
        enabled = !isCiServer
    }
    remote(HttpBuildCache) {
        url = <span class="hl-string">'https://example.com:8123/cache/'</span>
        push = isCiServer
    }
}
</pre></div></div><br class="example-break"><p>If you use a <code class="literal">buildSrc</code> directory, you should make sure that it uses the same build cache configuration as the main build.
This can be achieved by applying the same script to <code class="literal">buildSrc/settings.gradle</code> and <code class="literal">settings.gradle</code> as shown in the following example.</p><div class="example"><a name="buildCacheBuildSrc"></a><p class="title"><b>Example&nbsp;52.&nbsp;Consistent setup for buildSrc and main build</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">apply from: <span class="hl-keyword">new</span> File(settingsDir, <span class="hl-string">'gradle/buildCacheSettings.gradle'</span>)
</pre><p><code class="filename">buildSrc/settings.gradle</code></p><pre class="programlisting">apply from: <span class="hl-keyword">new</span> File(settingsDir, <span class="hl-string">'../gradle/buildCacheSettings.gradle'</span>)
</pre><p><code class="filename">gradle/buildCacheSettings.gradle</code></p><pre class="programlisting">ext.isCiServer = System.getenv().containsKey(<span class="hl-string">"CI"</span>)

buildCache {
    local {
        enabled = !isCiServer
    }
    remote(HttpBuildCache) {
        url = <span class="hl-string">'https://example.com:8123/cache/'</span>
        push = isCiServer
    }
}
</pre></div></div><br class="example-break"><p>It is also possible to configure the build cache from an <a class="link" href="#sec:using_an_init_script">init script</a>, which can be used from the command line, added to your Gradle user home or be a part of your custom Gradle distribution.</p><div class="example"><a name="buildCacheConfigurationInitScript"></a><p class="title"><b>Example&nbsp;53.&nbsp;Init script to configure the build cache</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting">gradle.settingsEvaluated { settings -&gt;
    settings.buildCache {
        <span class="hl-comment">// vvv Your custom configuration goes here</span>
        remote(HttpBuildCache) {
            url = <span class="hl-string">'https://example.com:8123/cache/'</span>
        }
        <span class="hl-comment">// ^^^ Your custom configuration goes here</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_cache_composite" class="section-anchor" href="#sec:build_cache_composite"></a>Build cache and composite builds</h3></div></div></div><p>Gradle&rsquo;s <a class="link" href="#composite_builds">composite build feature</a> allows including other complete Gradle builds into another.
Such included builds will inherit the build cache configuration from the top level build,
regardless of whether the included builds define build cache configuration themselves or not.</p><p>The build cache configuration present for any included build is effectively ignored, in favour of the top level build&rsquo;s configuration.
This also applies to any <code class="literal">buildSrc</code> projects of any included builds.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_cache_setup_http_backend" class="section-anchor" href="#sec:build_cache_setup_http_backend"></a>How to set up an HTTP build cache backend</h2></div></div></div><p>Gradle provides a Docker image for a <a class="ulink" href="https://hub.docker.com/r/gradle/build-cache-node/" target="_top">build cache node</a>, which can connect with Gradle Enterprise for centralized management.
The cache node can also be used without a Gradle Enterprise installation with restricted functionality.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_cache_implement" class="section-anchor" href="#sec:build_cache_implement"></a>Implement your own Build Cache</h2></div></div></div><p>Using a different build cache backend to store build outputs (which is not covered by the built-in support for connecting to an HTTP backend) requires implementing
your own logic for connecting to your custom build cache backend.
To this end, custom build cache types can be registered via <a class="ulink" href="../javadoc/org/gradle/caching/configuration/BuildCacheConfiguration.html#registerBuildCacheService-java.lang.Class, java.lang.Class-" target="_top"><code class="classname">BuildCacheConfiguration.registerBuildCacheService(java.lang.Class, java.lang.Class)</code></a>.
For an example of what this could look like see the <a class="ulink" href="https://github.com/gradle/gradle-hazelcast-plugin" target="_top">Gradle Hazelcast plugin</a>.</p><p><a class="ulink" href="https://gradle.com/build-cache" target="_top">Gradle Enterprise</a> includes a high-performance, easy to install and operate, shared build cache backend.</p></div></div></div><div class="part" title="Writing Gradle build scripts"><div class="titlepage"><div><div><h1 class="title"><a name="N11577"></a>Writing Gradle build scripts</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="tutorial_using_tasks"></a>Build Script Basics</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:projects_and_tasks" class="section-anchor" href="#sec:projects_and_tasks"></a>Projects and tasks</h2></div></div></div><p>Everything in Gradle sits on top of two basic concepts: <span class="emphasis"><em>projects</em></span> and <span class="emphasis"><em>tasks</em></span>.</p><p>Every Gradle build is made up of one or more <span class="emphasis"><em>projects</em></span>. What a project represents depends on what it is that you are doing with Gradle. For example, a project might represent a library JAR or a web application. It might represent a distribution ZIP assembled from the JARs produced by other projects. A project does not necessarily represent a thing to be built. It might represent a thing to be done, such as deploying your application to staging or production environments. Don&rsquo;t worry if this seems a little vague for now. Gradle&rsquo;s build-by-convention support adds a more concrete definition for what a project is.</p><p>Each project is made up of one or more <span class="emphasis"><em>tasks</em></span>. A task represents some atomic piece of work which a build performs. This might be compiling some classes, creating a JAR, generating Javadoc, or publishing some archives to a repository.</p><p>For now, we will look at defining some simple tasks in a build with one project. Later chapters will look at working with multiple projects and more about working with projects and tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:hello_world" class="section-anchor" href="#sec:hello_world"></a>Hello world</h2></div></div></div><p>You run a Gradle build using the <code class="literal">gradle</code> command. The <code class="literal">gradle</code> command looks for a file called <code class="literal">build.gradle</code> in the current directory.<sup>[<a href="#ftn.N115A6" name="N115A6" class="footnote">4</a>]</sup> We call this <code class="literal">build.gradle</code> file a <span class="emphasis"><em>build script</em></span>, although strictly speaking it is a build configuration script, as we will see later. The build script defines a project and its tasks.</p><p>To try this out, create the following build script named <code class="literal">build.gradle</code>.</p><div class="example"><a name="hello"></a><p class="title"><b>Example&nbsp;54.&nbsp;Your first build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">'Hello world!'</span>
    }
}
</pre></div></div><br class="example-break"><p>In a command-line shell, move to the containing directory and execute the build script with <code class="literal">gradle -q hello</code>:</p><div class="tip"><h3 class="title">What does <code class="literal">-q</code> do?</h3><p>Most of the examples in this user guide are run with the <code class="literal">-q</code> command-line option. This suppresses Gradle&rsquo;s log messages, so that only the output of the tasks is shown. This keeps the example output in this user guide a little clearer. You don&rsquo;t need to use this option if you don&rsquo;t want to. See <a class="xref" href="#logging"><i>Logging</i></a> for more details about the command-line options which affect Gradle&rsquo;s output.</p></div><div class="example"><a name="hello"></a><p class="title"><b>Example&nbsp;55.&nbsp;Execution of a build script</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hello world!
</pre></div></div><br class="example-break"><p>What&rsquo;s going on here? This build script defines a single task, called <code class="literal">hello</code>, and adds an action to it. When you run <code class="literal">gradle hello</code>, Gradle executes the <code class="literal">hello</code> task, which in turn executes the action you&rsquo;ve provided. The action is simply a closure containing some Groovy code to execute.</p><p>If you think this looks similar to Ant&rsquo;s targets, you would be right. Gradle tasks are the equivalent to Ant targets, but as you will see, they are much more powerful. We have used a different terminology than Ant as we think the word <span class="emphasis"><em>task</em></span> is more expressive than the word <span class="emphasis"><em>target</em></span>. Unfortunately this introduces a terminology clash with Ant, as Ant calls its commands, such as <code class="literal">javac</code> or <code class="literal">copy</code>, tasks. So when we talk about tasks, we <span class="emphasis"><em>always</em></span> mean Gradle tasks, which are the equivalent to Ant&rsquo;s targets. If we talk about Ant tasks (Ant commands), we explicitly say <span class="emphasis"><em>Ant task</em></span>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:a_shortcut_task_definition" class="section-anchor" href="#sec:a_shortcut_task_definition"></a>A shortcut task definition</h2></div></div></div><div class="note"><p>This functionality is deprecated and will be removed in Gradle 5.0 without replacement. Use the methods <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:doFirst(org.gradle.api.Action)" target="_top"><code class="classname">Task.doFirst(org.gradle.api.Action)</code></a> and <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:doLast(org.gradle.api.Action)" target="_top"><code class="classname">Task.doLast(org.gradle.api.Action)</code></a> to define an action instead, as demonstrated by the rest of the examples in this chapter.</p></div><p>There is a shorthand way to define a task like our <code class="literal">hello</code> task above, which is more concise.</p><div class="example"><a name="helloShortcut"></a><p class="title"><b>Example&nbsp;56.&nbsp;A task definition shortcut</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello &lt;&lt; {
    println <span class="hl-string">'Hello world!'</span>
}
</pre></div></div><br class="example-break"><p>Again, this defines a task called <code class="literal">hello</code> with a single closure to execute. The <code class="literal">&lt;&lt;</code> operator is simply an alias for <code class="literal">doLast</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_scripts_are_code" class="section-anchor" href="#sec:build_scripts_are_code"></a>Build scripts are code</h2></div></div></div><p>Gradle&rsquo;s build scripts give you the full power of Groovy. As an appetizer, have a look at this:</p><div class="example"><a name="upper"></a><p class="title"><b>Example&nbsp;57.&nbsp;Using Groovy in Gradle's tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task upper {
    doLast {
        String someString = <span class="hl-string">'mY_nAmE'</span>
        println <span class="hl-string">"Original: "</span> + someString
        println <span class="hl-string">"Upper case: "</span> + someString.toUpperCase()
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q upper</code></strong></p><pre class="screen">&gt; gradle -q upper
Original: mY_nAmE
Upper case: MY_NAME
</pre></div></div><br class="example-break"><p>or</p><div class="example"><a name="count"></a><p class="title"><b>Example&nbsp;58.&nbsp;Using Groovy in Gradle's tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task count {
    doLast {
        4.times { print <span class="hl-string">"$it "</span> }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q count</code></strong></p><pre class="screen">&gt; gradle -q count
0 1 2 3 
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:task_dependencies" class="section-anchor" href="#sec:task_dependencies"></a>Task dependencies</h2></div></div></div><p>As you probably have guessed, you can declare tasks that depend on other tasks.</p><div class="example"><a name="intro"></a><p class="title"><b>Example&nbsp;59.&nbsp;Declaration of task that depends on other task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">'Hello world!'</span>
    }
}
task intro(dependsOn: hello) {
    doLast {
        println <span class="hl-string">"I'm Gradle"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q intro</code></strong></p><pre class="screen">&gt; gradle -q intro
Hello world!
I'm Gradle
</pre></div></div><br class="example-break"><p>To add a dependency, the corresponding task does not need to exist.</p><div class="example"><a name="lazyDependsOn"></a><p class="title"><b>Example&nbsp;60.&nbsp;Lazy dependsOn - the other task does not exist (yet)</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX(dependsOn: <span class="hl-string">'taskY'</span>) {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>The dependency of <code class="literal">taskX</code> to <code class="literal">taskY</code> is declared before <code class="literal">taskY</code> is defined. This is very important for multi-project builds. Task dependencies are discussed in more detail in <a class="xref" href="#sec:adding_dependencies_to_tasks">the section called &ldquo;Adding dependencies to a task&rdquo;</a>.</p><p>Please notice that you can&rsquo;t use shortcut notation (see <a class="xref" href="#sec:shortcut_notations">the section called &ldquo;Shortcut notations&rdquo;</a>) when referring to a task that is not yet defined.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dynamic_tasks" class="section-anchor" href="#sec:dynamic_tasks"></a>Dynamic tasks</h2></div></div></div><p>The power of Groovy can be used for more than defining what a task does. For example, you can also use it to dynamically create tasks.</p><div class="example"><a name="dynamic"></a><p class="title"><b>Example&nbsp;61.&nbsp;Dynamic creation of a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">4.times { counter -&gt;
    task <span class="hl-string">"task$counter"</span> {
        doLast {
            println <span class="hl-string">"I'm task number $counter"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q task1</code></strong></p><pre class="screen">&gt; gradle -q task1
I'm task number 1
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:manipulating_existing_tasks" class="section-anchor" href="#sec:manipulating_existing_tasks"></a>Manipulating existing tasks</h2></div></div></div><p>Once tasks are created they can be accessed via an <span class="emphasis"><em>API</em></span>. For instance, you could use this to dynamically add dependencies to a task, at runtime. Ant doesn&rsquo;t allow anything like this.</p><div class="example"><a name="dynamicDepends"></a><p class="title"><b>Example&nbsp;62.&nbsp;Accessing a task via API - adding a dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">4.times { counter -&gt;
    task <span class="hl-string">"task$counter"</span> {
        doLast {
            println <span class="hl-string">"I'm task number $counter"</span>
        }
    }
}
task0.dependsOn task2, task3
</pre><p>Output of <strong class="userinput"><code>gradle -q task0</code></strong></p><pre class="screen">&gt; gradle -q task0
I'm task number 2
I'm task number 3
I'm task number 0
</pre></div></div><br class="example-break"><p>Or you can add behavior to an existing task.</p><div class="example"><a name="helloEnhanced"></a><p class="title"><b>Example&nbsp;63.&nbsp;Accessing a task via API - adding behaviour</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">'Hello Earth'</span>
    }
}
hello.doFirst {
    println <span class="hl-string">'Hello Venus'</span>
}
hello.doLast {
    println <span class="hl-string">'Hello Mars'</span>
}
hello {
    doLast {
        println <span class="hl-string">'Hello Jupiter'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hello Venus
Hello Earth
Hello Mars
Hello Jupiter
</pre></div></div><br class="example-break"><p>The calls <code class="literal">doFirst</code> and <code class="literal">doLast</code> can be executed multiple times. They add an action to the beginning or the end of the task&rsquo;s actions list. When the task executes, the actions in the action list are executed in order.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:shortcut_notations" class="section-anchor" href="#sec:shortcut_notations"></a>Shortcut notations</h2></div></div></div><p>There is a convenient notation for accessing an <span class="emphasis"><em>existing</em></span> task. Each task is available as a property of the build script:</p><div class="example"><a name="helloWithShortCut"></a><p class="title"><b>Example&nbsp;64.&nbsp;Accessing task as a property of the build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">'Hello world!'</span>
    }
}
hello.doLast {
    println <span class="hl-string">"Greetings from the $hello.name task."</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hello world!
Greetings from the hello task.
</pre></div></div><br class="example-break"><p>This enables very readable code, especially when using the tasks provided by the plugins, like the <code class="literal">compile</code> task.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:extra_task_properties" class="section-anchor" href="#sec:extra_task_properties"></a>Extra task properties</h2></div></div></div><p>You can add your own properties to a task. To add a property named <code class="literal">myProperty</code>, set <code class="literal">ext.myProperty</code> to an initial value. From that point on, the property can be read and set like a predefined task property.</p><div class="example"><a name="extraTaskProperties"></a><p class="title"><b>Example&nbsp;65.&nbsp;Adding extra properties to a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myTask {
    ext.myProperty = <span class="hl-string">"myValue"</span>
}

task printTaskProperties {
    doLast {
        println myTask.myProperty
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q printTaskProperties</code></strong></p><pre class="screen">&gt; gradle -q printTaskProperties
myValue
</pre></div></div><br class="example-break"><p>Extra properties aren&rsquo;t limited to tasks. You can read more about them in <a class="xref" href="#sec:extra_properties">the section called &ldquo;Extra properties&rdquo;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_ant_tasks_tutorial" class="section-anchor" href="#sec:using_ant_tasks_tutorial"></a>Using Ant Tasks</h2></div></div></div><p>Ant tasks are first-class citizens in Gradle. Gradle provides excellent integration for Ant tasks by simply relying on Groovy. Groovy is shipped with the fantastic <code class="literal">AntBuilder</code>. Using Ant tasks from Gradle is as convenient and more powerful than using Ant tasks from a <code class="literal">build.xml</code> file. From the example below, you can learn how to execute Ant tasks and how to access Ant properties:</p><div class="example"><a name="antLoadfile"></a><p class="title"><b>Example&nbsp;66.&nbsp;Using AntBuilder to execute ant.loadfile target</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task loadfile {
    doLast {
        def files = file(<span class="hl-string">'../antLoadfileResources'</span>).listFiles().sort()
        files.each { File file -&gt;
            <span class="hl-keyword">if</span> (file.isFile()) {
                ant.loadfile(srcFile: file, property: file.name)
                println <span class="hl-string">" *** $file.name ***"</span>
                println <span class="hl-string">"${ant.properties[file.name]}"</span>
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q loadfile</code></strong></p><pre class="screen">&gt; gradle -q loadfile
 *** agile.manifesto.txt ***
Individuals and interactions over processes and tools
Working software over comprehensive documentation
Customer collaboration  over contract negotiation
Responding to change over following a plan
 *** gradle.manifesto.txt ***
Make the impossible possible, make the possible easy and make the easy elegant.
(inspired by Moshe Feldenkrais)</pre></div></div><br class="example-break"><p>There is lots more you can do with Ant in your build scripts. You can find out more in <a class="xref" href="#ant"><i>Using Ant from Gradle</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_methods" class="section-anchor" href="#sec:using_methods"></a>Using methods</h2></div></div></div><p>Gradle scales in how you can organize your build logic. The first level of organizing your build logic for the example above, is extracting a method.</p><div class="example"><a name="antLoadfileWithMethod"></a><p class="title"><b>Example&nbsp;67.&nbsp;Using methods to organize your build logic</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task checksum {
    doLast {
        fileList(<span class="hl-string">'../antLoadfileResources'</span>).each { File file -&gt;
            ant.checksum(file: file, property: <span class="hl-string">"cs_$file.name"</span>)
            println <span class="hl-string">"$file.name Checksum: ${ant.properties["</span>cs_$file.name<span class="hl-string">"]}"</span>
        }
    }
}

task loadfile {
    doLast {
        fileList(<span class="hl-string">'../antLoadfileResources'</span>).each { File file -&gt;
            ant.loadfile(srcFile: file, property: file.name)
            println <span class="hl-string">"I'm fond of $file.name"</span>
        }
    }
}

File[] fileList(String dir) {
    file(dir).listFiles({file -&gt; file.isFile() } as FileFilter).sort()
}
</pre><p>Output of <strong class="userinput"><code>gradle -q loadfile</code></strong></p><pre class="screen">&gt; gradle -q loadfile
I'm fond of agile.manifesto.txt
I'm fond of gradle.manifesto.txt</pre></div></div><br class="example-break"><p>Later you will see that such methods can be shared among subprojects in multi-project builds. If your build logic becomes more complex, Gradle offers you other very convenient ways to organize it. We have devoted a whole chapter to this. See <a class="xref" href="#organizing_build_logic"><i>Organizing Build Logic</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:default_tasks" class="section-anchor" href="#sec:default_tasks"></a>Default tasks</h2></div></div></div><p>Gradle allows you to define one or more default tasks that are executed if no other tasks are specified.</p><div class="example"><a name="defaultTasks"></a><p class="title"><b>Example&nbsp;68.&nbsp;Defining a default task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">defaultTasks <span class="hl-string">'clean'</span>, <span class="hl-string">'run'</span>

task clean {
    doLast {
        println <span class="hl-string">'Default Cleaning!'</span>
    }
}

task run {
    doLast {
        println <span class="hl-string">'Default Running!'</span>
    }
}

task other {
    doLast {
        println <span class="hl-string">"I'm not a default task!"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q</code></strong></p><pre class="screen">&gt; gradle -q
Default Cleaning!
Default Running!
</pre></div></div><br class="example-break"><p>This is equivalent to running <code class="literal">gradle clean run</code>. In a multi-project build every subproject can have its own specific default tasks. If a subproject does not specify default tasks, the default tasks of the parent project are used (if defined).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="configure-by-dag" class="section-anchor" href="#configure-by-dag"></a>Configure by DAG</h2></div></div></div><p>As we later describe in full detail (see <a class="xref" href="#build_lifecycle"><i>Build Lifecycle</i></a>), Gradle has a configuration phase and an execution phase. After the configuration phase, Gradle knows all tasks that should be executed. Gradle offers you a hook to make use of this information. A use-case for this would be to check if the release task is among the tasks to be executed. Depending on this, you can assign different values to some variables.</p><p>In the following example, execution of the <code class="literal">distribution</code> and <code class="literal">release</code> tasks results in different value of the <code class="literal">version</code> variable.</p><div class="example"><a name="configByDagNoRelease"></a><p class="title"><b>Example&nbsp;69.&nbsp;Different outcomes of build depending on chosen tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task distribution {
    doLast {
        println <span class="hl-string">"We build the zip with version=$version"</span>
    }
}

task release(dependsOn: <span class="hl-string">'distribution'</span>) {
    doLast {
        println <span class="hl-string">'We release now'</span>
    }
}

gradle.taskGraph.whenReady {taskGraph -&gt;
    <span class="hl-keyword">if</span> (taskGraph.hasTask(release)) {
        version = <span class="hl-string">'1.0'</span>
    } <span class="hl-keyword">else</span> {
        version = <span class="hl-string">'1.0-SNAPSHOT'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q distribution</code></strong></p><pre class="screen">&gt; gradle -q distribution
We build the zip with version=1.0-SNAPSHOT
</pre><p>Output of <strong class="userinput"><code>gradle -q release</code></strong></p><pre class="screen">&gt; gradle -q release
We build the zip with version=1.0
We release now
</pre></div></div><br class="example-break"><p>The important thing is that <code class="literal">whenReady</code> affects the release task <span class="emphasis"><em>before</em></span> the release task is executed. This works even when the release task is not the <span class="emphasis"><em>primary</em></span> task (i.e., the task passed to the <code class="literal">gradle</code> command).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:tasks_tutorial_where_to_next" class="section-anchor" href="#sec:tasks_tutorial_where_to_next"></a>Where to next?</h2></div></div></div><p>In this chapter, we have had a first look at tasks. But this is not the end of the story for tasks. If you want to jump into more of the details, have a look at <a class="xref" href="#more_about_tasks"><i>Authoring Tasks</i></a>.</p><p>Otherwise, continue on to the tutorials in <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a> and <a class="xref" href="#artifact_dependencies_tutorial"><i>Dependency Management for Java Projects</i></a>.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N115A6" name="ftn.N115A6" class="para">4</a>] </sup>There are command line switches to change this behavior. See <a class="xref" href="#command_line_interface"><i>Command-Line Interface</i></a>)</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_init_plugin"></a>Build Init Plugin</h1></div></div></div><div class="note"><p>The Build Init plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The Gradle Build Init plugin can be used to bootstrap the process of creating a new Gradle build. It supports creating brand new projects of different types as well as converting existing builds (e.g. An Apache Maven build) to be Gradle builds.</p><p>Gradle plugins typically need to be <span class="emphasis"><em>applied</em></span> to a project before they can be used (see <a class="xref" href="#sec:using_plugins">the section called &ldquo;Using plugins&rdquo;</a>). The Build Init plugin is an automatically applied plugin, which means you do not need to apply it explicitly. To use the plugin, simply execute the task named <code class="literal">init</code> where you would like to create the Gradle build. There is no need to create a &ldquo;stub&rdquo; <code class="literal">build.gradle</code> file in order to apply the plugin.</p><p>It also leverages the <code class="literal">wrapper</code> task to <a class="link" href="#sec:adding_wrapper">generate the Gradle Wrapper files</a> for the project.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_init_tasks" class="section-anchor" href="#sec:build_init_tasks"></a>Tasks</h2></div></div></div><p>The plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;3.&nbsp;Build Init plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N117DF"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">init</code></p></td>
<td><p><code class="literal">wrapper</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.buildinit.tasks.InitBuild.html" target="_top"><code class="classname">InitBuild</code></a></p></td>
<td><p>Generates a Gradle project.</p></td>
</tr><tr>
<td><p><code class="literal">wrapper</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.wrapper.Wrapper.html" target="_top"><code class="classname">Wrapper</code></a></p></td>
<td><p>Generates Gradle wrapper files.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:what_to_set_up" class="section-anchor" href="#sec:what_to_set_up"></a>What to set up</h2></div></div></div><p>The <code class="literal">init</code> supports different build setup <span class="emphasis"><em>types</em></span>. The type is specified by supplying a <code class="literal">--type</code> argument value. For example, to create a Java library project simply execute: <code class="literal">gradle init --type java-library</code>.</p><p>If a <code class="literal">--type</code> parameter is not supplied, Gradle will attempt to infer the type from the environment. For example, it will infer a type value of &ldquo;<code class="literal">pom</code>&rdquo; if it finds a <code class="literal">pom.xml</code> to convert to a Gradle build.</p><p>If the type could not be inferred, the type &ldquo;<code class="literal">basic</code>&rdquo; will be used.</p><p>The <code class="literal">init</code> plugin also supports generating build scripts using either the Gradle Groovy DSL or the Gradle Kotlin DSL. The build script DSL to use defaults to the Groovy DSL and is specified by supplying a <code class="literal">--dsl</code> argument value. For example, to create a Java library project with Kotlin DSL build scripts simply execute: <code class="literal">gradle init --type java-library --dsl kotlin</code>.</p><p>All build setup types include the setup of the Gradle Wrapper.</p><p>Note that the migration from Maven builds only supports the Groovy DSL for generated build scripts.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_init_types" class="section-anchor" href="#sec:build_init_types"></a>Build init types</h2></div></div></div><div class="note"><p>As this plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>, only a few build init types are currently supported. More types will be added in future Gradle releases.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:pom_maven_conversion_" class="section-anchor" href="#sec:pom_maven_conversion_"></a>&ldquo;<code class="literal">pom</code>&rdquo; (Maven conversion)</h3></div></div></div><p>The &ldquo;<code class="literal">pom</code>&rdquo; type can be used to convert an Apache Maven build to a Gradle build. This works by converting the POM to one or more Gradle files. It is only able to be used if there is a valid &ldquo;<code class="literal">pom.xml</code>&rdquo; file in the directory that the <code class="literal">init</code> task is invoked in or, if invoked via the &ldquo;-p&rdquo; <a class="link" href="#">command line option</a>, in the specified project directory. This &ldquo;<code class="literal">pom</code>&rdquo; type will be automatically inferred if such a file exists.</p><p>The Maven conversion implementation was inspired by the <a class="ulink" href="https://github.com/jbaruch/maven2gradle" target="_top">maven2gradle tool</a> that was originally developed by Gradle community members.</p><p>The conversion process has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses effective POM and effective settings (support for POM inheritance, dependency management, properties)</p></li><li class="listitem"><p>Supports both single module and multimodule projects</p></li><li class="listitem"><p>Supports custom module names (that differ from directory names)</p></li><li class="listitem"><p>Generates general metadata - id, description and version</p></li><li class="listitem"><p>Applies maven, java and war plugins (as needed)</p></li><li class="listitem"><p>Supports packaging war projects as jars if needed</p></li><li class="listitem"><p>Generates dependencies (both external and inter-module)</p></li><li class="listitem"><p>Generates download repositories (inc. local Maven repository)</p></li><li class="listitem"><p>Adjusts Java compiler settings</p></li><li class="listitem"><p>Supports packaging of sources and tests</p></li><li class="listitem"><p>Supports TestNG runner</p></li><li class="listitem"><p>Generates global exclusions from Maven enforcer plugin settings</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:javaapplication_" class="section-anchor" href="#sec:javaapplication_"></a>&ldquo;<code class="literal">java-application</code>&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">java-application</code>&rdquo; build init type is not inferable. It must be explicitly specified.</p><p>It has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses the &ldquo;<code class="literal">application</code>&rdquo; plugin to produce a command-line application implemented using Java</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">jcenter</code>&rdquo; dependency repository</p></li><li class="listitem"><p>Uses <a class="ulink" href="http://junit.org" target="_top">JUnit</a> for testing</p></li><li class="listitem"><p>Has directories in the conventional locations for source code</p></li><li class="listitem"><p>Contains a sample class and unit test, if there are no existing source or test files</p></li></ul></div><p>Alternative test framework can be specified by supplying a <code class="literal">--test-framework</code> argument value. To use a different test framework, execute one of the following commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gradle init --type java-application --test-framework spock</code>: Uses <a class="ulink" href="http://code.google.com/p/spock/" target="_top">Spock</a> for testing instead of JUnit</p></li><li class="listitem"><p><code class="literal">gradle init --type java-application --test-framework testng</code>: Uses <a class="ulink" href="http://testng.org/doc/index.html" target="_top">TestNG</a> for testing instead of JUnit</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:javalibrary_" class="section-anchor" href="#sec:javalibrary_"></a>&ldquo;<code class="literal">java-library</code>&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">java-library</code>&rdquo; build init type is not inferable. It must be explicitly specified.</p><p>It has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses the &ldquo;<code class="literal">java</code>&rdquo; plugin to produce a library Jar</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">jcenter</code>&rdquo; dependency repository</p></li><li class="listitem"><p>Uses <a class="ulink" href="http://junit.org" target="_top">JUnit</a> for testing</p></li><li class="listitem"><p>Has directories in the conventional locations for source code</p></li><li class="listitem"><p>Contains a sample class and unit test, if there are no existing source or test files</p></li></ul></div><p>Alternative test framework can be specified by supplying a <code class="literal">--test-framework</code> argument value. To use a different test framework, execute one of the following commands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gradle init --type java-library --test-framework spock</code>: Uses <a class="ulink" href="http://code.google.com/p/spock/" target="_top">Spock</a> for testing instead of JUnit</p></li><li class="listitem"><p><code class="literal">gradle init --type java-library --test-framework testng</code>: Uses <a class="ulink" href="http://testng.org/doc/index.html" target="_top">TestNG</a> for testing instead of JUnit</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:scalalibrary_" class="section-anchor" href="#sec:scalalibrary_"></a>&ldquo;<code class="literal">scala-library</code>&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">scala-library</code>&rdquo; build init type is not inferable. It must be explicitly specified.</p><p>It has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses the &ldquo;<code class="literal">scala</code>&rdquo; plugin to produce a library Jar</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">jcenter</code>&rdquo; dependency repository</p></li><li class="listitem"><p>Uses Scala 2.10</p></li><li class="listitem"><p>Uses <a class="ulink" href="http://www.scalatest.org" target="_top">ScalaTest</a> for testing</p></li><li class="listitem"><p>Has directories in the conventional locations for source code</p></li><li class="listitem"><p>Contains a sample scala class and an associated ScalaTest test suite, if there are no existing source or test files</p></li><li class="listitem"><p>Uses the Zinc Scala compiler by default</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:groovylibrary_" class="section-anchor" href="#sec:groovylibrary_"></a>&ldquo;<code class="literal">groovy-library</code>&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">groovy-library</code>&rdquo; build init type is not inferable. It must be explicitly specified.</p><p>It has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses the &ldquo;<code class="literal">groovy</code>&rdquo; plugin to produce a library Jar</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">jcenter</code>&rdquo; dependency repository</p></li><li class="listitem"><p>Uses Groovy 2.x</p></li><li class="listitem"><p>Uses <a class="ulink" href="http://spockframework.org" target="_top">Spock testing framework</a> for testing</p></li><li class="listitem"><p>Has directories in the conventional locations for source code</p></li><li class="listitem"><p>Contains a sample Groovy class and an associated Spock specification, if there are no existing source or test files</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:groovyapplication_" class="section-anchor" href="#sec:groovyapplication_"></a>&ldquo;<code class="literal">groovy-application</code>&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">groovy-application</code>&rdquo; build init type is not inferable. It must be explicitly specified.</p><p>It has the following features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Uses the &ldquo;<code class="literal">groovy</code>&rdquo; plugin</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">application</code>&rdquo; plugin to produce a command-line application implemented using Groovy</p></li><li class="listitem"><p>Uses the &ldquo;<code class="literal">jcenter</code>&rdquo; dependency repository</p></li><li class="listitem"><p>Uses Groovy 2.x</p></li><li class="listitem"><p>Uses <a class="ulink" href="http://spockframework.org" target="_top">Spock testing framework</a> for testing</p></li><li class="listitem"><p>Has directories in the conventional locations for source code</p></li><li class="listitem"><p>Contains a sample Groovy class and an associated Spock specification, if there are no existing source or test files</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:basic" class="section-anchor" href="#sec:basic"></a>&ldquo;basic&rdquo;</h3></div></div></div><p>The &ldquo;<code class="literal">basic</code>&rdquo; build init type is useful for creating a fresh new Gradle project. It creates a sample <code class="literal">build.gradle</code> file, with comments and links to help get started.</p><p>This type is used when no type was explicitly specified, and no type could be inferred.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="writing_build_scripts"></a>Writing Build Scripts</h1></div></div></div><p>This chapter looks at some of the details of writing a build script.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:the_gradle_build_language" class="section-anchor" href="#sec:the_gradle_build_language"></a>The Gradle build language</h2></div></div></div><p>Gradle provides a <span class="emphasis"><em>domain specific language</em></span>, or DSL, for describing builds. This build language is based on Groovy, with some additions to make it easier to describe a build.</p><p>A build script can contain any Groovy language element.<sup>[<a href="#ftn.N119CE" name="N119CE" class="footnote">5</a>]</sup> Gradle assumes that each build script is encoded using UTF-8.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_api" class="section-anchor" href="#sec:project_api"></a>The Project API</h2></div></div></div><p>In the tutorial in <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a> we used, for example, the <code class="literal">apply()</code> method. Where does this method come from? We said earlier that the build script defines a project in Gradle. For each project in the build, Gradle creates an object of type <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> and associates this <code class="literal">Project</code> object with the build script. As the build script executes, it configures this <code class="literal">Project</code> object:</p><div class="tip"><h3 class="title">Getting help writing build scripts</h3><p>Don&rsquo;t forget that your build script is simply Groovy code that drives the Gradle API. And the <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> interface is your starting point for accessing everything in the Gradle API. So, if you&rsquo;re wondering what 'tags' are available in your build script, you can start with the documentation for the <code class="literal">Project</code> interface.</p></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Any method you call in your build script which <span class="emphasis"><em>is not defined</em></span> in the build script, is delegated to the <code class="literal">Project</code> object.</p></li><li class="listitem"><p>Any property you access in your build script, which <span class="emphasis"><em>is not defined</em></span> in the build script, is delegated to the <code class="literal">Project</code> object.</p></li></ul></div><p>Let&rsquo;s try this out and try to access the <code class="literal">name</code> property of the <code class="literal">Project</code> object.</p><div class="example"><a name="projectApi"></a><p class="title"><b>Example&nbsp;70.&nbsp;Accessing property of the Project object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">println name
println project.name
</pre><p>Output of <strong class="userinput"><code>gradle -q check</code></strong></p><pre class="screen">&gt; gradle -q check
projectApi
projectApi
</pre></div></div><br class="example-break"><p>Both <code class="literal">println</code> statements print out the same property. The first uses auto-delegation to the <code class="literal">Project</code> object, for properties not defined in the build script. The other statement uses the <code class="literal">project</code> property available to any build script, which returns the associated <code class="literal">Project</code> object. Only if you define a property or a method which has the same name as a member of the <code class="literal">Project</code> object, would you need to use the <code class="literal">project</code> property.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:standard_project_properties" class="section-anchor" href="#sec:standard_project_properties"></a>Standard project properties</h3></div></div></div><p>The <code class="literal">Project</code> object provides some standard properties, which are available in your build script. The following table lists a few of the commonly used ones.</p><div class="table"><p class="title"><b>Table&nbsp;4.&nbsp;Project Properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N11A3E"><thead><tr>
<td>Name</td>
<td>Type</td>
<td>Default Value</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">project</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a></p></td>
<td><p>The <code class="literal">Project</code> instance</p></td>
</tr><tr>
<td><p><code class="literal">name</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p>The name of the project directory.</p></td>
</tr><tr>
<td><p><code class="literal">path</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p>The absolute path of the project.</p></td>
</tr><tr>
<td><p><code class="literal">description</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p>A description for the project.</p></td>
</tr><tr>
<td><p><code class="literal">projectDir</code></p></td>
<td><p><code class="literal">File</code></p></td>
<td><p>The directory containing the build script.</p></td>
</tr><tr>
<td><p><code class="literal">buildDir</code></p></td>
<td><p><code class="literal">File</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>projectDir</em></span>/build</code></p></td>
</tr><tr>
<td><p><code class="literal">group</code></p></td>
<td><p><code class="literal">Object</code></p></td>
<td><p><code class="literal">unspecified</code></p></td>
</tr><tr>
<td><p><code class="literal">version</code></p></td>
<td><p><code class="literal">Object</code></p></td>
<td><p><code class="literal">unspecified</code></p></td>
</tr><tr>
<td><p><code class="literal">ant</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/AntBuilder.html" target="_top"><code class="classname">AntBuilder</code></a></p></td>
<td><p>An <code class="literal">AntBuilder</code> instance</p></td>
</tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:the_script_api" class="section-anchor" href="#sec:the_script_api"></a>The Script API</h2></div></div></div><p>When Gradle executes a script, it compiles the script into a class which implements <a class="ulink" href="../dsl/org.gradle.api.Script.html" target="_top"><code class="classname">Script</code></a>. This means that all of the properties and methods declared by the <code class="literal">Script</code> interface are available in your script.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_variables" class="section-anchor" href="#sec:declaring_variables"></a>Declaring variables</h2></div></div></div><p>There are two kinds of variables that can be declared in a build script: local variables and extra properties.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:local_variables" class="section-anchor" href="#sec:local_variables"></a>Local variables</h3></div></div></div><p>Local variables are declared with the <code class="literal">def</code> keyword. They are only visible in the scope where they have been declared. Local variables are a feature of the underlying Groovy language.</p><div class="example"><a name="localVariables"></a><p class="title"><b>Example&nbsp;71.&nbsp;Using local variables</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">def dest = <span class="hl-string">"dest"</span>

task copy(type: Copy) {
    from <span class="hl-string">"source"</span>
    into dest
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:extra_properties" class="section-anchor" href="#sec:extra_properties"></a>Extra properties</h3></div></div></div><p>All enhanced objects in Gradle&rsquo;s domain model can hold extra user-defined properties. This includes, but is not limited to, projects, tasks, and source sets. Extra properties can be added, read and set via the owning object&rsquo;s <code class="literal">ext</code> property. Alternatively, an <code class="literal">ext</code> block can be used to add multiple properties at once.</p><div class="example"><a name="extraProperties"></a><p class="title"><b>Example&nbsp;72.&nbsp;Using extra properties</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"java"</span>

ext {
    springVersion = <span class="hl-string">"3.1.0.RELEASE"</span>
    emailNotification = <span class="hl-string">"build@master.org"</span>
}

sourceSets.all { ext.purpose = null }

sourceSets {
    main {
        purpose = <span class="hl-string">"production"</span>
    }
    test {
        purpose = <span class="hl-string">"test"</span>
    }
    plugin {
        purpose = <span class="hl-string">"production"</span>
    }
}

task printProperties {
    doLast {
        println springVersion
        println emailNotification
        sourceSets.matching { it.purpose == <span class="hl-string">"production"</span> }.each { println it.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q printProperties</code></strong></p><pre class="screen">&gt; gradle -q printProperties
3.1.0.RELEASE
build@master.org
main
plugin</pre></div></div><br class="example-break"><p>In this example, an <code class="literal">ext</code> block adds two extra properties to the <code class="literal">project</code> object. Additionally, a property named <code class="literal">purpose</code> is added to each source set by setting <code class="literal">ext.purpose</code> to <code class="literal">null</code> (<code class="literal">null</code> is a permissible value). Once the properties have been added, they can be read and set like predefined properties.</p><p>By requiring special syntax for adding a property, Gradle can fail fast when an attempt is made to set a (predefined or extra) property but the property is misspelled or does not exist. Extra properties can be accessed from anywhere their owning object can be accessed, giving them a wider scope than local variables. Extra properties on a project are visible from its subprojects.</p><p>For further details on extra properties and their API, see the <a class="ulink" href="../dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html" target="_top"><code class="classname">ExtraPropertiesExtension</code></a> class in the API documentation.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_arbitrary_objects" class="section-anchor" href="#sec:configuring_arbitrary_objects"></a>Configuring arbitrary objects</h2></div></div></div><p>You can configure arbitrary objects in the following very readable way.</p><div class="example"><a name="configureObject"></a><p class="title"><b>Example&nbsp;73.&nbsp;Configuring arbitrary objects</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task configure {
    doLast {
        def pos = configure(<span class="hl-keyword">new</span> java.text.FieldPosition(<span class="hl-number">10</span>)) {
            beginIndex = <span class="hl-number">1</span>
            endIndex = <span class="hl-number">5</span>
        }
        println pos.beginIndex
        println pos.endIndex
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q configure</code></strong></p><pre class="screen">&gt; gradle -q configure
1
5
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_arbitrary_objects_using_an_external_script" class="section-anchor" href="#sec:configuring_arbitrary_objects_using_an_external_script"></a>Configuring arbitrary objects using an external script</h2></div></div></div><p>You can also configure arbitrary objects using an external script.</p><div class="example"><a name="configureObjectUsingScript"></a><p class="title"><b>Example&nbsp;74.&nbsp;Configuring arbitrary objects using a script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task configure {
    doLast {
        def pos = <span class="hl-keyword">new</span> java.text.FieldPosition(<span class="hl-number">10</span>)
        <span class="hl-comment">// Apply the script</span>
        apply from: <span class="hl-string">'other.gradle'</span>, to: pos
        println pos.beginIndex
        println pos.endIndex
    }
}
</pre><p><code class="filename">other.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Set properties.</span>
beginIndex = <span class="hl-number">1</span>
endIndex = <span class="hl-number">5</span>
</pre><p>Output of <strong class="userinput"><code>gradle -q configure</code></strong></p><pre class="screen">&gt; gradle -q configure
1
5
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="groovy-dsl-basics" class="section-anchor" href="#groovy-dsl-basics"></a>Some Groovy basics</h2></div></div></div><p>The <a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html" target="_top">Groovy language</a> provides plenty of features for creating DSLs, and the Gradle build language takes advantage of these. Understanding how the build language works will help you when you write your build script, and in particular, when you start to write custom plugins and tasks.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:groovy_jdk" class="section-anchor" href="#sec:groovy_jdk"></a>Groovy JDK</h3></div></div></div><p>Groovy adds lots of useful methods to the standard Java classes. For example, <code class="literal">Iterable</code> gets an <code class="literal">each</code> method, which iterates over the elements of the <code class="literal">Iterable</code>:</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;75.&nbsp;Groovy JDK methods</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Iterable gets an each() method</span>
configurations.runtime.each { File f -&gt; println f }
</pre></div></div><br class="example-break"><p>Have a look at <a class="ulink" href="http://groovy-lang.org/gdk.html" target="_top">http://groovy-lang.org/gdk.html</a> for more details.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:property_accessors" class="section-anchor" href="#sec:property_accessors"></a>Property accessors</h3></div></div></div><p>Groovy automatically converts a property reference into a call to the appropriate getter or setter method.</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;76.&nbsp;Property accessors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Using a getter method</span>
println project.buildDir
println getProject().getBuildDir()

<span class="hl-comment">// Using a setter method</span>
project.buildDir = <span class="hl-string">'target'</span>
getProject().setBuildDir(<span class="hl-string">'target'</span>)
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:optional_parentheses_on_method_calls" class="section-anchor" href="#sec:optional_parentheses_on_method_calls"></a>Optional parentheses on method calls</h3></div></div></div><p>Parentheses are optional for method calls.</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;77.&nbsp;Method call without parentheses</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test.systemProperty <span class="hl-string">'some.prop'</span>, <span class="hl-string">'value'</span>
test.systemProperty(<span class="hl-string">'some.prop'</span>, <span class="hl-string">'value'</span>)
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:list_and_map_literals" class="section-anchor" href="#sec:list_and_map_literals"></a>List and map literals</h3></div></div></div><p>Groovy provides some shortcuts for defining <code class="literal">List</code> and <code class="literal">Map</code> instances. Both kinds of literals are straightforward, but map literals have some interesting twists.</p><p>For instance, the &ldquo;<code class="literal">apply</code>&rdquo; method (where you typically apply plugins) actually takes a map parameter. However, when you have a line like &ldquo;<code class="literal">apply plugin:'java'</code>&rdquo;, you aren&rsquo;t actually using a map literal, you&rsquo;re actually using &ldquo;named parameters&rdquo;, which have almost exactly the same syntax as a map literal (without the wrapping brackets). That named parameter list gets converted to a map when the method is called, but it doesn&rsquo;t start out as a map.</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;78.&nbsp;List and map literals</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// List literal</span>
test.includes = [<span class="hl-string">'org/gradle/api/**'</span>, <span class="hl-string">'org/gradle/internal/**'</span>]

List&lt;String&gt; list = <span class="hl-keyword">new</span> ArrayList&lt;String&gt;()
list.add(<span class="hl-string">'org/gradle/api/**'</span>)
list.add(<span class="hl-string">'org/gradle/internal/**'</span>)
test.includes = list

<span class="hl-comment">// Map literal.</span>
Map&lt;String, String&gt; map = [key1:<span class="hl-string">'value1'</span>, key2: <span class="hl-string">'value2'</span>]

<span class="hl-comment">// Groovy will coerce named arguments</span>
<span class="hl-comment">// into a single map argument</span>
apply plugin: <span class="hl-string">'java'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:closures_as_the_last_parameter_in_a_method" class="section-anchor" href="#sec:closures_as_the_last_parameter_in_a_method"></a>Closures as the last parameter in a method</h3></div></div></div><p>The Gradle DSL uses closures in many places. You can find out more about closures <a class="ulink" href="http://docs.groovy-lang.org/latest/html/documentation/index.html#_closures" target="_top">here</a>. When the last parameter of a method is a closure, you can place the closure after the method call:</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;79.&nbsp;Closure as method parameter</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    println <span class="hl-string">"in a closure"</span>
}
repositories() { println <span class="hl-string">"in a closure"</span> }
repositories({ println <span class="hl-string">"in a closure"</span> })
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:closure_delegate" class="section-anchor" href="#sec:closure_delegate"></a>Closure delegate</h3></div></div></div><p>Each closure has a <code class="literal">delegate</code> object, which Groovy uses to look up variable and method references which are not local variables or parameters of the closure. Gradle uses this for <span class="emphasis"><em>configuration closures</em></span>, where the <code class="literal">delegate</code> object is set to the object to be configured.</p><div class="example"><a name="groovyBasics"></a><p class="title"><b>Example&nbsp;80.&nbsp;Closure delegates</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    assert delegate == project.dependencies
    testCompile(<span class="hl-string">'junit:junit:4.12'</span>)
    delegate.testCompile(<span class="hl-string">'junit:junit:4.12'</span>)
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="script-default-imports" class="section-anchor" href="#script-default-imports"></a>Default imports</h2></div></div></div><p>To make build scripts more concise, Gradle automatically adds a set of import statements to the Gradle scripts. This means that instead of using <code class="literal">throw new org.gradle.api.tasks.StopExecutionException()</code> you can just type <code class="literal">throw new StopExecutionException()</code> instead.</p><p>Listed below are the imports added to each script:</p><p title="Gradle default imports"><b>Gradle default imports.&nbsp;</b>
</p><pre class="programlisting">import org.gradle.*
import org.gradle.api.*
import org.gradle.api.artifacts.*
import org.gradle.api.artifacts.cache.*
import org.gradle.api.artifacts.component.*
import org.gradle.api.artifacts.dsl.*
import org.gradle.api.artifacts.ivy.*
import org.gradle.api.artifacts.maven.*
import org.gradle.api.artifacts.query.*
import org.gradle.api.artifacts.repositories.*
import org.gradle.api.artifacts.result.*
import org.gradle.api.artifacts.transform.*
import org.gradle.api.artifacts.type.*
import org.gradle.api.attributes.*
import org.gradle.api.component.*
import org.gradle.api.credentials.*
import org.gradle.api.distribution.*
import org.gradle.api.distribution.plugins.*
import org.gradle.api.dsl.*
import org.gradle.api.execution.*
import org.gradle.api.file.*
import org.gradle.api.initialization.*
import org.gradle.api.initialization.dsl.*
import org.gradle.api.invocation.*
import org.gradle.api.java.archives.*
import org.gradle.api.logging.*
import org.gradle.api.logging.configuration.*
import org.gradle.api.model.*
import org.gradle.api.plugins.*
import org.gradle.api.plugins.announce.*
import org.gradle.api.plugins.antlr.*
import org.gradle.api.plugins.buildcomparison.gradle.*
import org.gradle.api.plugins.osgi.*
import org.gradle.api.plugins.quality.*
import org.gradle.api.plugins.scala.*
import org.gradle.api.provider.*
import org.gradle.api.publish.*
import org.gradle.api.publish.ivy.*
import org.gradle.api.publish.ivy.plugins.*
import org.gradle.api.publish.ivy.tasks.*
import org.gradle.api.publish.maven.*
import org.gradle.api.publish.maven.plugins.*
import org.gradle.api.publish.maven.tasks.*
import org.gradle.api.publish.plugins.*
import org.gradle.api.publish.tasks.*
import org.gradle.api.reflect.*
import org.gradle.api.reporting.*
import org.gradle.api.reporting.components.*
import org.gradle.api.reporting.dependencies.*
import org.gradle.api.reporting.dependents.*
import org.gradle.api.reporting.model.*
import org.gradle.api.reporting.plugins.*
import org.gradle.api.resources.*
import org.gradle.api.specs.*
import org.gradle.api.tasks.*
import org.gradle.api.tasks.ant.*
import org.gradle.api.tasks.application.*
import org.gradle.api.tasks.bundling.*
import org.gradle.api.tasks.compile.*
import org.gradle.api.tasks.diagnostics.*
import org.gradle.api.tasks.incremental.*
import org.gradle.api.tasks.javadoc.*
import org.gradle.api.tasks.scala.*
import org.gradle.api.tasks.testing.*
import org.gradle.api.tasks.testing.junit.*
import org.gradle.api.tasks.testing.testng.*
import org.gradle.api.tasks.util.*
import org.gradle.api.tasks.wrapper.*
import org.gradle.authentication.*
import org.gradle.authentication.aws.*
import org.gradle.authentication.http.*
import org.gradle.buildinit.plugins.*
import org.gradle.buildinit.tasks.*
import org.gradle.caching.*
import org.gradle.caching.configuration.*
import org.gradle.caching.http.*
import org.gradle.caching.local.*
import org.gradle.concurrent.*
import org.gradle.external.javadoc.*
import org.gradle.ide.visualstudio.*
import org.gradle.ide.visualstudio.plugins.*
import org.gradle.ide.visualstudio.tasks.*
import org.gradle.ide.xcode.*
import org.gradle.ide.xcode.plugins.*
import org.gradle.ide.xcode.tasks.*
import org.gradle.ivy.*
import org.gradle.jvm.*
import org.gradle.jvm.application.scripts.*
import org.gradle.jvm.application.tasks.*
import org.gradle.jvm.platform.*
import org.gradle.jvm.plugins.*
import org.gradle.jvm.tasks.*
import org.gradle.jvm.tasks.api.*
import org.gradle.jvm.test.*
import org.gradle.jvm.toolchain.*
import org.gradle.language.*
import org.gradle.language.assembler.*
import org.gradle.language.assembler.plugins.*
import org.gradle.language.assembler.tasks.*
import org.gradle.language.base.*
import org.gradle.language.base.artifact.*
import org.gradle.language.base.compile.*
import org.gradle.language.base.plugins.*
import org.gradle.language.base.sources.*
import org.gradle.language.c.*
import org.gradle.language.c.plugins.*
import org.gradle.language.c.tasks.*
import org.gradle.language.coffeescript.*
import org.gradle.language.cpp.*
import org.gradle.language.cpp.plugins.*
import org.gradle.language.cpp.tasks.*
import org.gradle.language.java.*
import org.gradle.language.java.artifact.*
import org.gradle.language.java.plugins.*
import org.gradle.language.java.tasks.*
import org.gradle.language.javascript.*
import org.gradle.language.jvm.*
import org.gradle.language.jvm.plugins.*
import org.gradle.language.jvm.tasks.*
import org.gradle.language.nativeplatform.*
import org.gradle.language.nativeplatform.tasks.*
import org.gradle.language.objectivec.*
import org.gradle.language.objectivec.plugins.*
import org.gradle.language.objectivec.tasks.*
import org.gradle.language.objectivecpp.*
import org.gradle.language.objectivecpp.plugins.*
import org.gradle.language.objectivecpp.tasks.*
import org.gradle.language.plugins.*
import org.gradle.language.rc.*
import org.gradle.language.rc.plugins.*
import org.gradle.language.rc.tasks.*
import org.gradle.language.routes.*
import org.gradle.language.scala.*
import org.gradle.language.scala.plugins.*
import org.gradle.language.scala.tasks.*
import org.gradle.language.scala.toolchain.*
import org.gradle.language.swift.*
import org.gradle.language.swift.plugins.*
import org.gradle.language.swift.tasks.*
import org.gradle.language.twirl.*
import org.gradle.maven.*
import org.gradle.model.*
import org.gradle.nativeplatform.*
import org.gradle.nativeplatform.platform.*
import org.gradle.nativeplatform.plugins.*
import org.gradle.nativeplatform.tasks.*
import org.gradle.nativeplatform.test.*
import org.gradle.nativeplatform.test.cpp.*
import org.gradle.nativeplatform.test.cpp.plugins.*
import org.gradle.nativeplatform.test.cunit.*
import org.gradle.nativeplatform.test.cunit.plugins.*
import org.gradle.nativeplatform.test.cunit.tasks.*
import org.gradle.nativeplatform.test.googletest.*
import org.gradle.nativeplatform.test.googletest.plugins.*
import org.gradle.nativeplatform.test.plugins.*
import org.gradle.nativeplatform.test.tasks.*
import org.gradle.nativeplatform.test.xctest.*
import org.gradle.nativeplatform.test.xctest.plugins.*
import org.gradle.nativeplatform.test.xctest.tasks.*
import org.gradle.nativeplatform.toolchain.*
import org.gradle.nativeplatform.toolchain.plugins.*
import org.gradle.normalization.*
import org.gradle.platform.base.*
import org.gradle.platform.base.binary.*
import org.gradle.platform.base.component.*
import org.gradle.platform.base.plugins.*
import org.gradle.play.*
import org.gradle.play.distribution.*
import org.gradle.play.platform.*
import org.gradle.play.plugins.*
import org.gradle.play.plugins.ide.*
import org.gradle.play.tasks.*
import org.gradle.play.toolchain.*
import org.gradle.plugin.devel.*
import org.gradle.plugin.devel.plugins.*
import org.gradle.plugin.devel.tasks.*
import org.gradle.plugin.management.*
import org.gradle.plugin.use.*
import org.gradle.plugins.ear.*
import org.gradle.plugins.ear.descriptor.*
import org.gradle.plugins.ide.api.*
import org.gradle.plugins.ide.eclipse.*
import org.gradle.plugins.ide.idea.*
import org.gradle.plugins.javascript.base.*
import org.gradle.plugins.javascript.coffeescript.*
import org.gradle.plugins.javascript.envjs.*
import org.gradle.plugins.javascript.envjs.browser.*
import org.gradle.plugins.javascript.envjs.http.*
import org.gradle.plugins.javascript.envjs.http.simple.*
import org.gradle.plugins.javascript.jshint.*
import org.gradle.plugins.javascript.rhino.*
import org.gradle.plugins.signing.*
import org.gradle.plugins.signing.signatory.*
import org.gradle.plugins.signing.signatory.pgp.*
import org.gradle.plugins.signing.type.*
import org.gradle.plugins.signing.type.pgp.*
import org.gradle.process.*
import org.gradle.testing.base.*
import org.gradle.testing.base.plugins.*
import org.gradle.testing.jacoco.plugins.*
import org.gradle.testing.jacoco.tasks.*
import org.gradle.testing.jacoco.tasks.rules.*
import org.gradle.testkit.runner.*
import org.gradle.vcs.*
import org.gradle.vcs.git.*
import org.gradle.workers.*</pre><p title="Gradle default imports">
</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N119CE" name="ftn.N119CE" class="para">5</a>] </sup>Any language element except for statement labels.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="more_about_tasks"></a>Authoring Tasks</h1></div></div></div><p>In the introductory tutorial (<a class="xref" href="#tutorial_using_tasks"><i>Build Script Basics</i></a>) you learned how to create simple tasks. You also learned how to add additional behavior to these tasks later on, and you learned how to create dependencies between tasks. This was all about simple tasks, but Gradle takes the concept of tasks further. Gradle supports <span class="emphasis"><em>enhanced tasks</em></span>, which are tasks that have their own properties and methods. This is really different from what you are used to with Ant targets. Such enhanced tasks are either provided by you or built into Gradle.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:task_outcomes" class="section-anchor" href="#sec:task_outcomes"></a>Task outcomes</h2></div></div></div><p>When Gradle executes a task, it can label the task with different outcomes in the console UI and via the Tooling API (see <a class="xref" href="#embedding"><i>Embedding Gradle using the Tooling API</i></a>). These labels are based on if a task has actions to execute, if it should execute those actions, if it did execute those actions and if those actions made any changes.</p><div class="table"><p class="title"><b>Table&nbsp;5.&nbsp;Details about task outcomes</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N11C44"><thead><tr>
<td>Outcome label</td>
<td>Description of outcome</td>
<td>Situations that have this outcome</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">(no label)</code> or <code class="literal">EXECUTED</code></p></td>
<td><p>Task executed its actions.</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Used whenever a task has actions and Gradle has determined they should be executed as part of a build.</p></li><li class="listitem"><p>Used whenever a task has no actions and some dependencies, and any of the dependencies are executed. See also <a class="xref" href="#sec:lifecycle_tasks">the section called &ldquo;Lifecycle tasks&rdquo;</a>.</p></li></ul></div></td>
</tr><tr>
<td><p><code class="literal">UP-TO-DATE</code></p></td>
<td><p>Task&rsquo;s outputs did not change.</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Used when a task has outputs and inputs and they have not changed. See <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>.</p></li><li class="listitem"><p>Used when a task has actions, but the task tells Gradle it did not change its outputs.</p></li><li class="listitem"><p>Used when a task has no actions and some dependencies, but all of the dependencies are up-to-date, skipped or from cache. See also <a class="xref" href="#sec:lifecycle_tasks">the section called &ldquo;Lifecycle tasks&rdquo;</a>.</p></li><li class="listitem"><p>Used when a task has no actions and no dependencies.</p></li></ul></div></td>
</tr><tr>
<td><p><code class="literal">FROM-CACHE</code></p></td>
<td><p>Task&rsquo;s outputs could be found from a previous execution.</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Used when a task has outputs restored from the build cache. See <a class="xref" href="#build_cache"><i>Build Cache</i></a>.</p></li></ul></div></td>
</tr><tr>
<td><p><code class="literal">SKIPPED</code></p></td>
<td><p>Task did not execute its actions.</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Used when a task has been explicitly excluded from the command-line. See <a class="xref" href="#sec:excluding_tasks_from_the_command_line">the section called &ldquo;Excluding tasks from execution&rdquo;</a>.</p></li><li class="listitem"><p>Used when a task has an <code class="literal">onlyIf</code> predicate return false. See <a class="xref" href="#sec:using_a_predicate">the section called &ldquo;Using a predicate&rdquo;</a>.</p></li></ul></div></td>
</tr><tr>
<td><p><code class="literal">NO-SOURCE</code></p></td>
<td><p>Task did not need to execute its actions.</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Used when a task has inputs and outputs, but <a class="link" href="#skip-when-empty">no sources</a>. For example, source files are <code class="literal">.java</code> files for <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>.</p></li></ul></div></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:defining_tasks" class="section-anchor" href="#sec:defining_tasks"></a>Defining tasks</h2></div></div></div><p>We have already seen how to define tasks using a keyword style in <a class="xref" href="#tutorial_using_tasks"><i>Build Script Basics</i></a>. There are a few variations on this style, which you may need to use in certain situations. For example, the keyword style does not work in expressions.</p><div class="example"><a name="defineAsExpression"></a><p class="title"><b>Example&nbsp;81.&nbsp;Defining tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(hello) {
    doLast {
        println <span class="hl-string">"hello"</span>
    }
}

task(copy, type: Copy) {
    from(file(<span class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>You can also use strings for the task names:</p><div class="example"><a name="defineUsingStringTaskNames"></a><p class="title"><b>Example&nbsp;82.&nbsp;Defining tasks - using strings for task names</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task(<span class="hl-string">'hello'</span>) {
    doLast {
        println <span class="hl-string">"hello"</span>
    }
}

task(<span class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>There is an alternative syntax for defining tasks, which you may prefer to use:</p><div class="example"><a name="addToTaskContainer"></a><p class="title"><b>Example&nbsp;83.&nbsp;Defining tasks with alternative syntax</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.create(name: <span class="hl-string">'hello'</span>) {
    doLast {
        println <span class="hl-string">"hello"</span>
    }
}

tasks.create(name: <span class="hl-string">'copy'</span>, type: Copy) {
    from(file(<span class="hl-string">'srcDir'</span>))
    into(buildDir)
}
</pre></div></div><br class="example-break"><p>Here we add tasks to the <code class="literal">tasks</code> collection. Have a look at <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more variations of the <code class="literal">create()</code> method.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:locating_tasks" class="section-anchor" href="#sec:locating_tasks"></a>Locating tasks</h2></div></div></div><p>You often need to locate the tasks that you have defined in the build file, for example, to configure them or use them for dependencies. There are a number of ways of doing this. Firstly, each task is available as a property of the project, using the task name as the property name:</p><div class="example"><a name="accessAsProperty"></a><p class="title"><b>Example&nbsp;84.&nbsp;Accessing tasks as properties</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println hello.name
println project.hello.name
</pre></div></div><br class="example-break"><p>Tasks are also available through the <code class="literal">tasks</code> collection.</p><div class="example"><a name="accessFromTaskContainer"></a><p class="title"><b>Example&nbsp;85.&nbsp;Accessing tasks via tasks collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello

println tasks.hello.name
println tasks[<span class="hl-string">'hello'</span>].name
</pre></div></div><br class="example-break"><p>You can access tasks from any project using the task&rsquo;s path using the <code class="literal">tasks.getByPath()</code> method. You can call the <code class="literal">getByPath()</code> method with a task name, or a relative path, or an absolute path.</p><div class="example"><a name="accessUsingPath"></a><p class="title"><b>Example&nbsp;86.&nbsp;Accessing tasks by path</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span class="hl-string">':projectA'</span>) {
    task hello
}

task hello

println tasks.getByPath(<span class="hl-string">'hello'</span>).path
println tasks.getByPath(<span class="hl-string">':hello'</span>).path
println tasks.getByPath(<span class="hl-string">'projectA:hello'</span>).path
println tasks.getByPath(<span class="hl-string">':projectA:hello'</span>).path
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
:hello
:hello
:projectA:hello
:projectA:hello</pre></div></div><br class="example-break"><p>Have a look at <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> for more options for locating tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_tasks" class="section-anchor" href="#sec:configuring_tasks"></a>Configuring tasks</h2></div></div></div><p>As an example, let&rsquo;s look at the <code class="literal">Copy</code> task provided by Gradle. To create a <code class="literal">Copy</code> task for your build, you can declare in your build script:</p><div class="example"><a name="declareTask"></a><p class="title"><b>Example&nbsp;87.&nbsp;Creating a copy task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)
</pre></div></div><br class="example-break"><p>This creates a copy task with no default behavior. The task can be configured using its API (see <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>). The following examples show several different ways to achieve the same configuration.</p><p>Just to be clear, realize that the name of this task is &ldquo;<code class="literal">myCopy</code>&rdquo;, but it is of <span class="emphasis"><em>type</em></span> &ldquo;<code class="literal">Copy</code>&rdquo;. You can have multiple tasks of the same <span class="emphasis"><em>type</em></span>, but with different names. You&rsquo;ll find this gives you a lot of power to implement cross-cutting concerns across all tasks of a particular type.</p><div class="example"><a name="configureUsingVar"></a><p class="title"><b>Example&nbsp;88.&nbsp;Configuring a task - various ways</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">Copy myCopy = task(myCopy, type: Copy)
myCopy.from <span class="hl-string">'resources'</span>
myCopy.into <span class="hl-string">'target'</span>
myCopy.include(<span class="hl-string">'**/*.txt'</span>, <span class="hl-string">'**/*.xml'</span>, <span class="hl-string">'**/*.properties'</span>)
</pre></div></div><br class="example-break"><p>This is similar to the way we would configure objects in Java. You have to repeat the context (<code class="literal">myCopy</code>) in the configuration statement every time. This is a redundancy and not very nice to read.</p><p>There is another way of configuring a task. It also preserves the context and it is arguably the most readable. It is usually our favorite.</p><div class="example"><a name="configureUsingClosure"></a><p class="title"><b>Example&nbsp;89.&nbsp;Configuring a task - with closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myCopy(type: Copy)

myCopy {
   from <span class="hl-string">'resources'</span>
   into <span class="hl-string">'target'</span>
   include(<span class="hl-string">'**/*.txt'</span>, <span class="hl-string">'**/*.xml'</span>, <span class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><p>This works for <span class="emphasis"><em>any</em></span> task. Line 3 of the example is just a shortcut for the <code class="literal">tasks.getByName()</code> method. It is important to note that if you pass a closure to the <code class="literal">getByName()</code> method, this closure is applied to <span class="emphasis"><em>configure</em></span> the task, not when the task executes.</p><p>You can also use a configuration closure when you define a task.</p><div class="example"><a name="defineAndConfigure"></a><p class="title"><b>Example&nbsp;90.&nbsp;Defining a task with closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   from <span class="hl-string">'resources'</span>
   into <span class="hl-string">'target'</span>
   include(<span class="hl-string">'**/*.txt'</span>, <span class="hl-string">'**/*.xml'</span>, <span class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"><div class="tip"><h3 class="title">Don&rsquo;t forget about the build phases</h3><p>A task has both configuration and actions. When using the <code class="literal">doLast</code>, you are simply using a shortcut to define an action. Code defined in the configuration section of your task will get executed during the configuration phase of the build regardless of what task was targeted. See <a class="xref" href="#build_lifecycle"><i>Build Lifecycle</i></a> for more details about the build lifecycle.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:adding_dependencies_to_tasks" class="section-anchor" href="#sec:adding_dependencies_to_tasks"></a>Adding dependencies to a task</h2></div></div></div><p>There are several ways you can define the dependencies of a task. In <a class="xref" href="#sec:task_dependencies">the section called &ldquo;Task dependencies&rdquo;</a> you were introduced to defining dependencies using task names. Task names can refer to tasks in the same project as the task, or to tasks in other projects. To refer to a task in another project, you prefix the name of the task with the path of the project it belongs to. The following is an example which adds a dependency from <code class="literal">projectA:taskX</code> to <code class="literal">projectB:taskY</code>:</p><div class="example"><a name="addDependencyUsingPath"></a><p class="title"><b>Example&nbsp;91.&nbsp;Adding dependency on task from another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span class="hl-string">'projectA'</span>) {
    task taskX(dependsOn: <span class="hl-string">':projectB:taskY'</span>) {
        doLast {
            println <span class="hl-string">'taskX'</span>
        }
    }
}

project(<span class="hl-string">'projectB'</span>) {
    task taskY {
        doLast {
            println <span class="hl-string">'taskY'</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>Instead of using a task name, you can define a dependency using a <code class="literal">Task</code> object, as shown in this example:</p><div class="example"><a name="addDependencyUsingTask"></a><p class="title"><b>Example&nbsp;92.&nbsp;Adding dependency using task object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}

task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}

taskX.dependsOn taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskY
taskX
</pre></div></div><br class="example-break"><p>For more advanced uses, you can define a task dependency using a closure. When evaluated, the closure is passed the task whose dependencies are being calculated. The closure should return a single <code class="literal">Task</code> or collection of <code class="literal">Task</code> objects, which are then treated as dependencies of the task. The following example adds a dependency from <code class="literal">taskX</code> to all the tasks in the project whose name starts with <code class="literal">lib</code>:</p><div class="example"><a name="addDependencyUsingClosure"></a><p class="title"><b>Example&nbsp;93.&nbsp;Adding dependency using closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}

taskX.dependsOn {
    tasks.findAll { task -&gt; task.name.startsWith(<span class="hl-string">'lib'</span>) }
}

task lib1 {
    doLast {
        println <span class="hl-string">'lib1'</span>
    }
}

task lib2 {
    doLast {
        println <span class="hl-string">'lib2'</span>
    }
}

task notALib {
    doLast {
        println <span class="hl-string">'notALib'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
lib1
lib2
taskX
</pre></div></div><br class="example-break"><p>For more information about task dependencies, see the <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a> API.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ordering_tasks" class="section-anchor" href="#sec:ordering_tasks"></a>Ordering tasks</h2></div></div></div><div class="note"><p>Task ordering is an <a class="link" href="#feature_lifecycle">incubating</a> feature. Please be aware that this feature may change in later Gradle versions.</p></div><p>In some cases it is useful to control the <span class="emphasis"><em>order</em></span> in which 2 tasks will execute, without introducing an explicit dependency between those tasks. The primary difference between a task <span class="emphasis"><em>ordering</em></span> and a task <span class="emphasis"><em>dependency</em></span> is that an ordering rule does not influence which tasks will be executed, only the order in which they will be executed.</p><p>Task ordering can be useful in a number of scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Enforce sequential ordering of tasks: e.g. 'build' never runs before 'clean'.</p></li><li class="listitem"><p>Run build validations early in the build: e.g. validate I have the correct credentials before starting the work for a release build.</p></li><li class="listitem"><p>Get feedback faster by running quick verification tasks before long verification tasks: e.g. unit tests should run before integration tests.</p></li><li class="listitem"><p>A task that aggregates the results of all tasks of a particular type: e.g. test report task combines the outputs of all executed test tasks.</p></li></ul></div><p>There are two ordering rules available: &ldquo;<span class="emphasis"><em>must run after</em></span>&rdquo; and &ldquo;<span class="emphasis"><em>should run after</em></span>&rdquo;.</p><p>When you use the &ldquo;must run after&rdquo; ordering rule you specify that <code class="literal">taskB</code> must always run after <code class="literal">taskA</code>, whenever both <code class="literal">taskA</code> and <code class="literal">taskB</code> will be run. This is expressed as <code class="literal">taskB.mustRunAfter(taskA)</code>. The &ldquo;should run after&rdquo; ordering rule is similar but less strict as it will be ignored in two situations. Firstly if using that rule introduces an ordering cycle. Secondly when using parallel execution and all dependencies of a task have been satisfied apart from the &ldquo;should run after&rdquo; task, then this task will be run regardless of whether its &ldquo;should run after&rdquo; dependencies have been run or not. You should use &ldquo;should run after&rdquo; where the ordering is helpful but not strictly required.</p><p>With these rules present it is still possible to execute <code class="literal">taskA</code> without <code class="literal">taskB</code> and vice-versa.</p><div class="example"><a name="mustRunAfter"></a><p class="title"><b>Example&nbsp;94.&nbsp;Adding a 'must run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}
taskY.mustRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><div class="example"><a name="shouldRunAfter"></a><p class="title"><b>Example&nbsp;95.&nbsp;Adding a 'should run after' task ordering</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}
taskY.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskY taskX</code></strong></p><pre class="screen">&gt; gradle -q taskY taskX
taskX
taskY</pre></div></div><br class="example-break"><p>In the examples above, it is still possible to execute <code class="literal">taskY</code> without causing <code class="literal">taskX</code> to run:</p><div class="example"><a name="mustRunAfterSingleTask"></a><p class="title"><b>Example&nbsp;96.&nbsp;Task ordering does not imply task execution</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q taskY</code></strong></p><pre class="screen">&gt; gradle -q taskY
taskY</pre></div></div><br class="example-break"><p>To specify a &ldquo;must run after&rdquo; or &ldquo;should run after&rdquo; ordering between 2 tasks, you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:mustRunAfter(java.lang.Object[])" target="_top"><code class="classname">Task.mustRunAfter(java.lang.Object[])</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/Task.html#shouldRunAfter-java.lang.Object[]-" target="_top"><code class="classname">Task.shouldRunAfter(java.lang.Object[])</code></a> methods. These methods accept a task instance, a task name or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.</p><p>Note that &ldquo;<code class="literal">B.mustRunAfter(A)</code>&rdquo; or &ldquo;<code class="literal">B.shouldRunAfter(A)</code>&rdquo; does not imply any execution dependency between the tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It is possible to execute tasks <code class="literal">A</code> and <code class="literal">B</code> independently. The ordering rule only has an effect when both tasks are scheduled for execution.</p></li><li class="listitem"><p>When run with <code class="literal">--continue</code>, it is possible for <code class="literal">B</code> to execute in the event that <code class="literal">A</code> fails.</p></li></ul></div><p>As mentioned before, the &ldquo;should run after&rdquo; ordering rule will be ignored if it introduces an ordering cycle:</p><div class="example"><a name="shouldRunAfterWithCycle"></a><p class="title"><b>Example&nbsp;97.&nbsp;A 'should run after' task ordering is ignored if it introduces an ordering cycle</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}
task taskZ {
    doLast {
        println <span class="hl-string">'taskZ'</span>
    }
}
taskX.dependsOn taskY
taskY.dependsOn taskZ
taskZ.shouldRunAfter taskX
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskZ
taskY
taskX</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:adding_a_description_to_a_task" class="section-anchor" href="#sec:adding_a_description_to_a_task"></a>Adding a description to a task</h2></div></div></div><p>You can add a description to your task. This description is displayed when executing <code class="literal">gradle tasks</code>.</p><div class="example"><a name="describeTask"></a><p class="title"><b>Example&nbsp;98.&nbsp;Adding a description to a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy) {
   description <span class="hl-string">'Copies the resource directory to the target directory.'</span>
   from <span class="hl-string">'resources'</span>
   into <span class="hl-string">'target'</span>
   include(<span class="hl-string">'**/*.txt'</span>, <span class="hl-string">'**/*.xml'</span>, <span class="hl-string">'**/*.properties'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:replacing_tasks" class="section-anchor" href="#sec:replacing_tasks"></a>Replacing tasks</h2></div></div></div><p>Sometimes you want to replace a task. For example, if you want to exchange a task added by the Java plugin with a custom task of a different type. You can achieve this with:</p><div class="example"><a name="replaceTask"></a><p class="title"><b>Example&nbsp;99.&nbsp;Overwriting a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy(type: Copy)

task copy(overwrite: true) {
    doLast {
        println(<span class="hl-string">'I am the new one.'</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p><pre class="screen">&gt; gradle -q copy
I am the new one.
</pre></div></div><br class="example-break"><p>This will replace a task of type <code class="literal">Copy</code> with the task you&rsquo;ve defined, because it uses the same name. When you define the new task, you have to set the <code class="literal">overwrite</code> property to true. Otherwise Gradle throws an exception, saying that a task with that name already exists.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:skipping_tasks" class="section-anchor" href="#sec:skipping_tasks"></a>Skipping tasks</h2></div></div></div><p>Gradle offers multiple ways to skip the execution of a task.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_a_predicate" class="section-anchor" href="#sec:using_a_predicate"></a>Using a predicate</h3></div></div></div><p>You can use the <code class="literal">onlyIf()</code> method to attach a predicate to a task. The task&rsquo;s actions are only executed if the predicate evaluates to true. You implement the predicate as a closure. The closure is passed the task as a parameter, and should return true if the task should execute and false if the task should be skipped. The predicate is evaluated just before the task is due to be executed.</p><div class="example"><a name="taskOnlyIf"></a><p class="title"><b>Example&nbsp;100.&nbsp;Skipping a task using a predicate</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">'hello world'</span>
    }
}

hello.onlyIf { !project.hasProperty(<span class="hl-string">'skipHello'</span>) }
</pre><p>Output of <strong class="userinput"><code>gradle hello -PskipHello</code></strong></p><pre class="screen">&gt; gradle hello -PskipHello
:hello SKIPPED

BUILD SUCCESSFUL in 0s
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_stopexecutionexception" class="section-anchor" href="#sec:using_stopexecutionexception"></a>Using StopExecutionException</h3></div></div></div><p>If the logic for skipping a task can&rsquo;t be expressed with a predicate, you can use the <a class="ulink" href="../javadoc/org/gradle/api/tasks/StopExecutionException.html" target="_top"><code class="classname">StopExecutionException</code></a>. If this exception is thrown by an action, the further execution of this action as well as the execution of any following action of this task is skipped. The build continues with executing the next task.</p><div class="example"><a name="stopExecutionException"></a><p class="title"><b>Example&nbsp;101.&nbsp;Skipping tasks with StopExecutionException</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task compile {
    doLast {
        println <span class="hl-string">'We are doing the compile.'</span>
    }
}

compile.doFirst {
    <span class="hl-comment">// Here you would put arbitrary conditions in real life.</span>
    <span class="hl-comment">// But this is used in an integration test so we want defined behavior.</span>
    <span class="hl-keyword">if</span> (true) { <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> StopExecutionException() }
}
task myTask(dependsOn: <span class="hl-string">'compile'</span>) {
    doLast {
        println <span class="hl-string">'I am not affected'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q myTask</code></strong></p><pre class="screen">&gt; gradle -q myTask
I am not affected
</pre></div></div><br class="example-break"><p>This feature is helpful if you work with tasks provided by Gradle. It allows you to add <span class="emphasis"><em>conditional</em></span> execution of the built-in actions of such a task.<sup>[<a href="#ftn.N11F42" name="N11F42" class="footnote">6</a>]</sup></p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:enabling_and_disabling_tasks" class="section-anchor" href="#sec:enabling_and_disabling_tasks"></a>Enabling and disabling tasks</h3></div></div></div><p>Every task has an <code class="literal">enabled</code> flag which defaults to <code class="literal">true</code>. Setting it to <code class="literal">false</code> prevents the execution of any of the task&rsquo;s actions. A disabled task will be labelled SKIPPED.</p><div class="example"><a name="disableTask"></a><p class="title"><b>Example&nbsp;102.&nbsp;Enabling and disabling tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task disableMe {
    doLast {
        println <span class="hl-string">'This should not be printed if the task is disabled.'</span>
    }
}
disableMe.enabled = false
</pre><p>Output of <strong class="userinput"><code>gradle disableMe</code></strong></p><pre class="screen">&gt; gradle disableMe
:disableMe SKIPPED

BUILD SUCCESSFUL in 0s
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:up_to_date_checks" class="section-anchor" href="#sec:up_to_date_checks"></a>Up-to-date checks (AKA Incremental Build)</h2></div></div></div><p>An important part of any build tool is the ability to avoid doing work that has already been done. Consider the process of compilation. Once your source files have been compiled, there should be no need to recompile them unless something has changed that affects the output, such as the modification of a source file or the removal of an output file. And compilation can take a significant amount of time, so skipping the step when it&rsquo;s not needed saves a lot of time.</p><p>Gradle supports this behavior out of the box through a feature it calls incremental build. You have almost certainly already seen it in action: it&rsquo;s active nearly every time the <code class="literal">UP-TO-DATE</code> text appears next to the name of a task when you run a build. Task outcomes are described in <a class="xref" href="#sec:task_outcomes">the section called &ldquo;Task outcomes&rdquo;</a>.</p><p>How does incremental build work? And what does it take to make use of it in your own tasks? Let&rsquo;s take a look.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_inputs_outputs" class="section-anchor" href="#sec:task_inputs_outputs"></a>Task inputs and outputs</h3></div></div></div><p>In the most common case, a task takes some inputs and generates some outputs. If we use the compilation example from earlier, we can see that the source files are the inputs and, in the case of Java, the generated class files are the outputs. Other inputs might include things like whether debug information should be included.</p><div class="figure"><a name="N11F80"></a><p class="title"><b>Figure&nbsp;5.&nbsp;Example task inputs and outputs</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="567"><tr><td><img src="img/taskInputsOutputs.png" width="567" alt="Example task inputs and outputs"></td></tr></table></div></div><br class="figure-break"><p>An important characteristic of an input is that it affects one or more outputs, as you can see from the previous figure. Different bytecode is generated depending on the content of the source files and the minimum version of the Java runtime you want to run the code on. That makes them task inputs. But whether compilation has 500MB or 600MB of maximum memory available, determined by the <code class="literal">memoryMaximumSize</code> property, has no impact on what bytecode gets generated. In Gradle terminology, <code class="literal">memoryMaximumSize</code> is just an internal task property.</p><p>As part of incremental build, Gradle tests whether any of the task inputs or outputs have changed since the last build. If they haven&rsquo;t, Gradle can consider the task up to date and therefore skip executing its actions. Also note that incremental build won&rsquo;t work unless a task has at least one task output, although tasks usually have at least one input as well.</p><p>What this means for build authors is simple: you need to tell Gradle which task properties are inputs and which are outputs. If a task property affects the output, be sure to register it as an input, otherwise the task will be considered up to date when it&rsquo;s not. Conversely, don&rsquo;t register properties as inputs if they don&rsquo;t affect the output, otherwise the task will potentially execute when it doesn&rsquo;t need to. Also be careful of non-deterministic tasks that may generate different output for exactly the same inputs: these should not be configured for incremental build as the up-to-date checks won&rsquo;t work.</p><p>Let&rsquo;s now look at how you can register task properties as inputs and outputs.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_input_output_annotations" class="section-anchor" href="#sec:task_input_output_annotations"></a>Custom task types</h4></div></div></div><p>If you&rsquo;re implementing a custom task as a class, then it takes just two steps to make it work with incremental build:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Create typed properties (via getter methods) for each of your task inputs and outputs</p></li><li class="listitem"><p>Add the appropriate annotation to each of those properties</p></li></ol></div><div class="note"><p>Annotations must be placed on getters or on Groovy properties. Annotations placed on setters, or on a Java field without a corresponding annotated getter are ignored.</p></div><p>Gradle supports three main categories of inputs and outputs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Simple values</p><p>Things like strings and numbers. More generally, a simple value can have any type that implements <code class="literal">Serializable</code>.</p></li><li class="listitem"><p>Filesystem types</p><p>These consist of the standard <code class="literal">File</code> class but also derivatives of Gradle&rsquo;s <a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> type and anything else that can be passed to either the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a> method - for single file/directory properties - or the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])" target="_top"><code class="classname">Project.files(java.lang.Object[])</code></a> method.</p></li><li class="listitem"><p>Nested values</p><p>Custom types that don&rsquo;t conform to the other two categories but have their own properties that are inputs or outputs. In effect, the task inputs or outputs are nested inside these custom types.</p></li></ul></div><p>As an example, imagine you have a task that processes templates of varying types, such as FreeMarker, Velocity, Moustache, etc. It takes template source files and combines them with some model data to generate populated versions of the template files.</p><p>This task will have three inputs and one output:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Template source files</p></li><li class="listitem"><p>Model data</p></li><li class="listitem"><p>Template engine</p></li><li class="listitem"><p>Where the output files are written</p></li></ul></div><p>When you&rsquo;re writing a custom task class, it&rsquo;s easy to register properties as inputs or outputs via annotations. To demonstrate, here is a skeleton task implementation with some suitable inputs and outputs, along with their annotations:</p><div class="example"><a name="customTaskClassWithInputOutputAnnotations"></a><p class="title"><b>Example&nbsp;103.&nbsp;Custom task class</b></p><div class="example-contents"><p><code class="filename">buildSrc/src/main/java/org/example/ProcessTemplates.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.example;

<span class="hl-keyword">import</span> java.io.File;
<span class="hl-keyword">import</span> java.util.HashMap;
<span class="hl-keyword">import</span> org.gradle.api.*;
<span class="hl-keyword">import</span> org.gradle.api.file.*;
<span class="hl-keyword">import</span> org.gradle.api.tasks.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProcessTemplates <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-keyword">private</span> TemplateEngineType templateEngine;
    <span class="hl-keyword">private</span> FileCollection sourceFiles;
    <span class="hl-keyword">private</span> TemplateData templateData;
    <span class="hl-keyword">private</span> File outputDir;

    <span class="hl-annotation">@Input</span>
    <span class="hl-keyword">public</span> TemplateEngineType getTemplateEngine() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.templateEngine;
    }

    <span class="hl-annotation">@InputFiles</span>
    <span class="hl-keyword">public</span> FileCollection getSourceFiles() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.sourceFiles;
    }

    <span class="hl-annotation">@Nested</span>
    <span class="hl-keyword">public</span> TemplateData getTemplateData() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.templateData;
    }

    <span class="hl-annotation">@OutputDirectory</span>
    <span class="hl-keyword">public</span> File getOutputDir() { <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.outputDir; }

    <span class="hl-comment">// + setter methods for the above - assume we&rsquo;ve defined them</span>

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> processTemplates() {
        <span class="hl-comment">// ...</span>
    }
}
</pre><p><code class="filename">buildSrc/src/main/java/org/example/TemplateData.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.example;

<span class="hl-keyword">import</span> java.util.HashMap;
<span class="hl-keyword">import</span> java.util.Map;
<span class="hl-keyword">import</span> org.gradle.api.tasks.Input;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> TemplateData {
    <span class="hl-keyword">private</span> String name;
    <span class="hl-keyword">private</span> Map&lt;String, String&gt; variables;

    <span class="hl-keyword">public</span> TemplateData(String name, Map&lt;String, String&gt; variables) {
        <span class="hl-keyword">this</span>.name = name;
        <span class="hl-keyword">this</span>.variables = <span class="hl-keyword">new</span> HashMap&lt;&gt;(variables);
    }

    <span class="hl-annotation">@Input</span>
    <span class="hl-keyword">public</span> String getName() { <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.name; }

    <span class="hl-annotation">@Input</span>
    <span class="hl-keyword">public</span> Map&lt;String, String&gt; getVariables() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.variables;
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle processTemplates</code></strong></p><pre class="screen">&gt; gradle processTemplates
:processTemplates

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre><p>Output of <strong class="userinput"><code>gradle processTemplates</code></strong></p><pre class="screen">&gt; gradle processTemplates
:processTemplates UP-TO-DATE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
</pre></div></div><br class="example-break"><p>There&rsquo;s plenty to talk about in this example, so let&rsquo;s work through each of the input and output properties in turn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">templateEngine</code></p><p>Represents which engine to use when processing the source templates, e.g. FreeMarker, Velocity, etc. You could implement this as a string, but in this case we have gone for a custom enum as it provides greater type information and safety. Since enums implement <code class="literal">Serializable</code> automatically, we can treat this as a simple value and use the <code class="literal">@Input</code> annotation, just as we would with a <code class="literal">String</code> property.</p></li><li class="listitem"><p><code class="literal">sourceFiles</code></p><p>The source templates that the task will be processing. Single files and collections of files need their own special annotations. In this case, we&rsquo;re dealing with a collection of input files and so we use the <code class="literal">@InputFiles</code> annotation. You&rsquo;ll see more file-oriented annotations in a table later.</p></li><li class="listitem"><p><code class="literal">templateData</code></p><p>For this example, we&rsquo;re using a custom class to represent the model data. However, it does not implement <code class="literal">Serializable</code>, so we can&rsquo;t use the <code class="literal">@Input</code> annotation. That&rsquo;s not a problem as the properties within <code class="literal">TemplateData</code> - a string and a hash map with serializable type parameters - are serializable and can be annotated with <code class="literal">@Input</code>. We use <code class="literal">@Nested</code> on <code class="literal">templateData</code> to let Gradle know that this is a value with nested input properties.</p></li><li class="listitem"><p><code class="literal">outputDir</code></p><p>The directory where the generated files go. As with input files, there are several annotations for output files and directories. A property representing a single directory requires <code class="literal">@OutputDirectory</code>. You&rsquo;ll learn about the others soon.</p></li></ul></div><p>These annotated properties mean that Gradle will skip the task if none of the source files, template engine, model data or generated files have changed since the previous time Gradle executed the task. This will often save a significant amount of time. You can learn how Gradle detects <a class="link" href="#sec:how_does_it_work">changes later</a>.</p><p>This example is particularly interesting because it works with collections of source files. What happens if only one source file changes? Does the task process all the source files again or just the modified one? That depends on the task implementation. If the latter, then the task itself is incremental, but that&rsquo;s a different feature to the one we&rsquo;re discussing here. Gradle does help task implementers with this via its <a class="link" href="#incremental_tasks">incremental task inputs</a> feature.</p><p>Now that you have seen some of the input and output annotations in practice, let&rsquo;s take a look at all the annotations available to you and when you should use them. The table below lists the available annotations and the corresponding property type you can use with each one.</p><div class="table"><p class="title"><b>Table&nbsp;6.&nbsp;Incremental build property type annotations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N12046"><thead><tr>
<td>Annotation</td>
<td>Expected property type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Input.html" target="_top"><code class="classname">Input</code></a></code></p></td>
<td><p>Any serializable type</p></td>
<td><p>A simple input value</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/InputFile.html" target="_top"><code class="classname">InputFile</code></a></code></p></td>
<td><p><code class="literal">File</code>*</p></td>
<td><p>A single input file (not directory)</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/InputDirectory.html" target="_top"><code class="classname">InputDirectory</code></a></code></p></td>
<td><p><code class="literal">File</code>*</p></td>
<td><p>A single input directory (not file)</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/InputFiles.html" target="_top"><code class="classname">InputFiles</code></a></code></p></td>
<td><p><code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>An iterable of input files and directories</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Classpath.html" target="_top"><code class="classname">Classpath</code></a></code></p></td>
<td><p><code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>An iterable of input files and directories that represent a Java classpath. This allows the task to ignore irrelevant changes to the property, such as different names for the same files. It is similar to annotating the property <code class="literal">@PathSensitive(RELATIVE)</code> but it will ignore the names of JAR files directly added to the classpath, and it will consider changes in the order of the files as a change in the classpath. Gradle will inspect the contents of jar files on the classpath and ignore changes that do not affect the semantics of the classpath (such as file dates and entry order). See also <a class="xref" href="#sec:task_input_using_classpath_annotations">the section called &ldquo;Using the classpath annotations&rdquo;</a>.</p>
<div class="note"><p>The <code class="literal">@Classpath</code> annotation was introduced in Gradle 3.2. To stay compatible with earlier Gradle versions, classpath properties should also be annotated with <code class="literal">@InputFiles</code>.</p></div></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/CompileClasspath.html" target="_top"><code class="classname">CompileClasspath</code></a></code></p></td>
<td><p><code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>An iterable of input files and directories that represent a Java compile classpath. This allows the task to ignore irrelevant changes that do not affect the API of the classes in classpath. See also <a class="xref" href="#sec:task_input_using_classpath_annotations">the section called &ldquo;Using the classpath annotations&rdquo;</a>.</p>
<p>The following kinds of changes to the classpath will be ignored:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changes to the path of jar or top level directories.</p></li><li class="listitem"><p>Changes to timestamps and the order of entries in Jars.</p></li><li class="listitem"><p>Changes to resources and Jar manifests, including adding or removing resources.</p></li><li class="listitem"><p>Changes to private class elements, such as private fields, methods and inner classes.</p></li><li class="listitem"><p>Changes to code, such as method bodies, static initializers and field initializers (except for constants).</p></li><li class="listitem"><p>Changes to debug information, for example when a change to a comment affects the line numbers in class debug information.</p></li><li class="listitem"><p>Changes to directories, including directory entries in Jars.</p></li></ul></div>
<div class="note"><p>The <code class="literal">@CompileClasspath</code> annotation was introduced in Gradle 3.4. To stay compatible with Gradle 3.3 and 3.2, compile classpath properties should also be annotated with <code class="literal">@Classpath</code>. For compatibility with Gradle versions before 3.2 the property should also be annotated with <code class="literal">@InputFiles</code>.</p></div></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/OutputFile.html" target="_top"><code class="classname">OutputFile</code></a></code></p></td>
<td><p><code class="literal">File</code>*</p></td>
<td><p>A single output file (not directory)</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/OutputDirectory.html" target="_top"><code class="classname">OutputDirectory</code></a></code></p></td>
<td><p><code class="literal">File</code>*</p></td>
<td><p>A single output directory (not file)</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/OutputFiles.html" target="_top"><code class="classname">OutputFiles</code></a></code></p></td>
<td><p><code class="literal">Map&lt;String, File&gt;</code>** or <code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>An iterable of output files (no directories). The task outputs can only be <a class="link" href="#sec:task_output_caching">cached</a> if a <code class="literal">Map</code> is provided.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/OutputDirectories.html" target="_top"><code class="classname">OutputDirectories</code></a></code></p></td>
<td><p><code class="literal">Map&lt;String, File&gt;</code>** or <code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>An iterable of output directories (no files). The task outputs can only be <a class="link" href="#sec:task_output_caching">cached</a> if a <code class="literal">Map</code> is provided.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Destroys.html" target="_top"><code class="classname">Destroys</code></a></code></p></td>
<td><p><code class="literal">File</code> or <code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>Specifies one or more files that are removed by this task.  Note that a task can define either inputs/outputs or destroyables, but not both.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/LocalState.html" target="_top"><code class="classname">LocalState</code></a></code></p></td>
<td><p><code class="literal">File</code> or <code class="literal">Iterable&lt;File&gt;</code>*</p></td>
<td><p>Specifies one or more files that represent the <a class="link" href="#sec:storing_incremental_task_state">local state of the task</a>. These files are removed when the task is loaded from cache.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Nested.html" target="_top"><code class="classname">Nested</code></a></code></p></td>
<td><p>Any custom type</p></td>
<td><p>A custom type that may not implement <code class="literal">Serializable</code> but does have at least one field or property marked with one of the annotations in this table. It could even be another <code class="literal">@Nested</code>.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Console.html" target="_top"><code class="classname">Console</code></a></code></p></td>
<td><p>Any type</p></td>
<td><p>Indicates that the property is neither an input nor an output. It simply affects the console output of the task in some way, such as increasing or decreasing the verbosity of the task.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Internal.html" target="_top"><code class="classname">Internal</code></a></code></p></td>
<td><p>Any type</p></td>
<td><p>Indicates that the property is used internally but is neither an input nor an output.</p></td>
</tr></tbody></table></div></div><div class="variablelist"><dl><dt><span class="term">*</span></dt><dd><p>In fact, <code class="literal">File</code> can be any type accepted by <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a> and <code class="literal">Iterable&lt;File&gt;</code> can be any type accepted by <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])" target="_top"><code class="classname">Project.files(java.lang.Object[])</code></a>. This includes instances of <code class="literal">Callable</code>, such as closures, allowing for lazy evaluation of the property values. Be aware that the types <code class="literal">FileCollection</code> and <code class="literal">FileTree</code> are <code class="literal">Iterable&lt;File&gt;</code>s.</p></dd><dt><span class="term">**</span></dt><dd><p>Similar to the above, <code class="literal">File</code> can be any type accepted by <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a>. The <code class="literal">Map</code> itself can be wrapped in <code class="literal">Callable</code>s, such as closures.</p></dd></dl></div><div class="table"><p class="title"><b>Table&nbsp;7.&nbsp;Additional annotations used to further qualifying property type annotations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N12221"><thead><tr>
<td>Annotation</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a name="skip-when-empty"></a><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/SkipWhenEmpty.html" target="_top"><code class="classname">SkipWhenEmpty</code></a></code></p></td>
<td><p>Used with <code class="literal">@InputFiles</code> or <code class="literal">@InputDirectory</code> to tell Gradle to skip the task if the corresponding files or directory are empty, along with all other input files declared with this annotation. Tasks that have been skipped due to all of their input files that were declared with this annotation being empty will result in a distinct &ldquo;no source&rdquo; outcome. For example, <code class="literal">NO-SOURCE</code> will be emitted in the console output.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Optional.html" target="_top"><code class="classname">Optional</code></a></code></p></td>
<td><p>Used with any of the property type annotations listed in the <a class="ulink" href="../javadoc/org/gradle/api/tasks/Optional.html" target="_top"><code class="classname">Optional</code></a> API documentation. This annotation disables validation checks on the corresponding property. See <a class="link" href="#sec:task_input_output_validation">the section on validation</a> for more details.</p></td>
</tr><tr>
<td><p><code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/PathSensitive.html" target="_top"><code class="classname">PathSensitive</code></a></code></p></td>
<td><p><a name="inputs_path_sensitivity"></a>Used with any input file property to tell Gradle to only consider the given part of the file paths as important. For example, if a property is annotated with <code class="literal">@PathSensitive(PathSensitivity.NAME_ONLY)</code>, then moving the files around without changing their contents will not make the task out-of-date.</p></td>
</tr></tbody></table></div></div><p>Annotations are inherited from all parent types including implemented interfaces. Property type annotations override any other property type annotation declared in a parent type. This way an <code class="literal">@InputFile</code> property can be turned into an <code class="literal">@InputDirectory</code> property in a child task type.</p><p>Annotations on a property declared in a type override similar annotations declared by the superclass and in any implemented interfaces. Superclass annotations take precedence over annotations declared in implemented interfaces.</p><p>The <a class="ulink" href="../javadoc/org/gradle/api/tasks/Console.html" target="_top"><code class="classname">Console</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/tasks/Internal.html" target="_top"><code class="classname">Internal</code></a> annotations in the table are special cases as they don&rsquo;t declare either task inputs or task outputs. So why use them? It&rsquo;s so that you can take advantage of the <a class="link" href="#">Java Gradle Plugin Development plugin</a> to help you develop and publish your own plugins. This plugin checks whether any properties of your custom task classes lack an incremental build annotation. This protects you from forgetting to add an appropriate annotation during development.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:task_input_using_classpath_annotations" class="section-anchor" href="#sec:task_input_using_classpath_annotations"></a>Using the classpath annotations</h5></div></div></div><p>Besides <code class="literal">@InputFiles</code>, for JVM-related tasks Gradle understands the concept of classpath inputs. Both runtime and compile classpaths are treated differently when Gradle is looking for changes.</p><p>As opposed to input properties annotated with <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/InputFiles.html" target="_top"><code class="classname">InputFiles</code></a></code>, for classpath properties the order of the entries in the file collection matter.
On the other hand, the names and paths of the directories and jar files on the classpath itself are ignored.
Timestamps and the order of class files and resources inside jar files on a classpath are ignored, too, thus recreating a jar file with different file dates will not make the task out of date.</p><p>Runtime classpaths are marked with <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Classpath.html" target="_top"><code class="classname">Classpath</code></a></code>, and they offer further customization via <a class="link" href="#sec:configure_input_normalization">classpath normalization</a>.</p><p>Input properties annotated with <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/CompileClasspath.html" target="_top"><code class="classname">CompileClasspath</code></a></code> are considered Java compile classpaths.
Additionally to the aforementioned general classpath rules, compile classpaths ignore changes to everything but class files. Gradle uses the same class analysis described in <a class="xref" href="#sec:java_compile_avoidance">the section called &ldquo;Compile avoidance&rdquo;</a> to further filter changes that don&rsquo;t affect the class' ABIs.
This means that changes which only touch the implementation of classes do not make the task out of date.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:task_input_nested_inputs" class="section-anchor" href="#sec:task_input_nested_inputs"></a>Nested inputs</h5></div></div></div><p>When analyzing <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Nested.html" target="_top"><code class="classname">Nested</code></a></code> task properties for declared input and output sub-properties Gradle uses the type of the actual value.
Hence it can discover all sub-properties declared by a runtime sub-type.</p><p>When adding <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Nested.html" target="_top"><code class="classname">Nested</code></a></code> to an iterable, each element is treated as a separate nested input.</p><p>This allows richer modeling and extensibility for tasks, as e.g. shown by <code class="literal"><a class="ulink" href="../dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:compilerArgumentProviders" target="_top"><code class="classname">CompileOptions.getCompilerArgumentProviders()</code></a></code>.</p><p>For example, to declare annotation processor arguments, it is possible to do the following:</p><pre class="programlisting">class MyAnnotationProcessor implements CompilerArgumentProvider {
    @InputFile
    @PathSensitivite(NONE)
    File inputFile

    @OutputFile
    File outputFile

    MyAnnotationProcessor(File inputFile, File outputFile) {
        this.inputFile = inputFile
        this.outputFile = outputFile
    }

    @Override
    List&lt;String&gt; asArguments() {
        [
            "-AinputFile=${inputFile.absolutePath}",
            "-AoutputFile=${outputFile.absolutePath}"
        ]
    }
}

compileJava.options.compilerArgumentProviders &lt;&lt; new MyAnnotationProcessor(inputFile, outputFile)</pre><p>This models an annotation processor which requires an input file and generates an output file.</p><p>The approach works for Java compiler arguments, since <code class="literal"><a class="ulink" href="../dsl/org.gradle.api.tasks.compile.CompileOptions.html#org.gradle.api.tasks.compile.CompileOptions:compilerArgumentProviders" target="_top"><code class="classname">CompileOptions.getCompilerArgumentProviders()</code></a></code> is an <code class="literal">Iterable</code> annotated with <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Nested.html" target="_top"><code class="classname">Nested</code></a></code>. In the same way, this kind of modelling is available to custom tasks.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_input_output_runtime_api" class="section-anchor" href="#sec:task_input_output_runtime_api"></a>Runtime API</h4></div></div></div><p>Custom task classes are an easy way to bring your own build logic into the arena of incremental build, but you don&rsquo;t always have that option. That&rsquo;s why Gradle also provides an alternative API that can be used with any tasks, which we look at next.</p><p>When you don&rsquo;t have access to the source for a custom task class, there is no way to add any of the annotations we covered in the previous section. Fortunately, Gradle provides a runtime API for scenarios just like that. It can also be used for ad-hoc tasks, as you&rsquo;ll see next.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:runtime_api_for_adhoc" class="section-anchor" href="#sec:runtime_api_for_adhoc"></a>Using it for ad-hoc tasks</h5></div></div></div><p>This runtime API is provided through a couple of aptly named properties that are available on every Gradle task:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:inputs" target="_top"><code class="classname">Task.getInputs()</code></a> of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputs.html" target="_top"><code class="classname">TaskInputs</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:outputs" target="_top"><code class="classname">Task.getOutputs()</code></a> of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html" target="_top"><code class="classname">TaskOutputs</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:destroyables" target="_top"><code class="classname">Task.getDestroyables()</code></a> of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskDestroyables.html" target="_top"><code class="classname">TaskDestroyables</code></a></p></li></ul></div><p>These objects have methods that allow you to specify files, directories and values which constitute the task&rsquo;s inputs and outputs. In fact, the runtime API has almost feature parity with the annotations. All it lacks is validation of whether declared files are actually files and declared directories are directories. Nor will it create output directories if they don&rsquo;t exist. But that&rsquo;s it.</p><p>Let&rsquo;s take the template processing example from before and see how it would look as an ad-hoc task that uses the runtime API:</p><div class="example"><a name="incrementalAdHocTask"></a><p class="title"><b>Example&nbsp;104.&nbsp;Ad-hoc task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task processTemplatesAdHoc {
    inputs.property(<span class="hl-string">"engine"</span>, TemplateEngineType.FREEMARKER)
    inputs.files(fileTree(<span class="hl-string">"src/templates"</span>))
    inputs.property(<span class="hl-string">"templateData.name"</span>, <span class="hl-string">"docs"</span>)
    inputs.property(<span class="hl-string">"templateData.variables"</span>, [year: <span class="hl-number">2013</span>])
    outputs.dir(<span class="hl-string">"$buildDir/genOutput2"</span>)

    doLast {
        <span class="hl-comment">// Process the templates here</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle processTemplatesAdHoc</code></strong></p><pre class="screen">&gt; gradle processTemplatesAdHoc
:processTemplatesAdHoc

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>As before, there&rsquo;s much to talk about. To begin with, you should really write a custom task class for this as it&rsquo;s a non-trivial implementation that has several configuration options. In this case, there are no task properties to store the root source folder, the location of the output directory or any of the other settings. That&rsquo;s deliberate to highlight the fact that the runtime API doesn&rsquo;t require the task to have any state. In terms of incremental build, the above ad-hoc task will behave the same as the custom task class.</p><p>All the input and output definitions are done through the methods on <code class="literal">inputs</code> and <code class="literal">outputs</code>, such as <code class="literal">property()</code>, <code class="literal">files()</code>, and <code class="literal">dir()</code>. Gradle performs up-to-date checks on the argument values to determine whether the task needs to run again or not. Each method corresponds to one of the incremental build annotations, for example <code class="literal">inputs.property()</code> maps to <code class="literal">@Input</code> and <code class="literal">outputs.dir()</code> maps to <code class="literal">@OutputDirectory</code>. The only difference is that the <code class="literal">file()</code>, <code class="literal">files()</code>, <code class="literal">dir()</code> and <code class="literal">dirs()</code> methods don&rsquo;t validate the type of file object at the given path (file or directory), unlike the annotations.</p><p>The files that a task removes can be specified through <code class="literal">destroyables.register()</code>.</p><div class="example"><a name="destroyableAdHocTask"></a><p class="title"><b>Example&nbsp;105.&nbsp;Ad-hoc task declaring a destroyable</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task removeTempDir {
    destroyables.register(<span class="hl-string">"$projectDir/tmpDir"</span>)
    doLast {
        delete(<span class="hl-string">"$projectDir/tmpDir"</span>)
    }
}
</pre></div></div><br class="example-break"><p>One notable difference between the runtime API and the annotations is the lack of a method that corresponds directly to <code class="literal">@Nested</code>. That&rsquo;s why the example uses two <code class="literal">property()</code> declarations for the template data, one for each <code class="literal">TemplateData</code> property. You should utilize the same technique when using the runtime API with nested values.  Any given task can either declare destroyables or inputs/outputs, but cannot declare both.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:runtime_api_for_custom_tasks" class="section-anchor" href="#sec:runtime_api_for_custom_tasks"></a>Using it for custom task types</h5></div></div></div><p>Another type of example involves adding input and output definitions to instances of a custom task class that lacks the requisite annotations. For example, imagine that the <code class="literal">ProcessTemplates</code> task is provided by a plugin and that it&rsquo;s missing the incremental build annotations. In order to make up for that deficiency, you can use the runtime API:</p><div class="example"><a name="runtimeIncrementalApi"></a><p class="title"><b>Example&nbsp;106.&nbsp;Using runtime API with custom task type</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task processTemplatesRuntime(type: ProcessTemplatesNoAnnotations) {
    templateEngine = TemplateEngineType.FREEMARKER
    sourceFiles = fileTree(<span class="hl-string">"src/templates"</span>)
    templateData = <span class="hl-keyword">new</span> TemplateData(<span class="hl-string">"test"</span>, [year: <span class="hl-number">2014</span>])
    outputDir = file(<span class="hl-string">"$buildDir/genOutput3"</span>)

    inputs.property(<span class="hl-string">"engine"</span>,templateEngine)
    inputs.files(sourceFiles)
    inputs.property(<span class="hl-string">"templateData.name"</span>, templateData.name)
    inputs.property(<span class="hl-string">"templateData.variables"</span>, templateData.variables)
    outputs.dir(outputDir)
}
</pre><p>Output of <strong class="userinput"><code>gradle processTemplatesRuntime</code></strong></p><pre class="screen">&gt; gradle processTemplatesRuntime
:processTemplatesRuntime

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre><p>Output of <strong class="userinput"><code>gradle processTemplatesRuntime</code></strong></p><pre class="screen">&gt; gradle processTemplatesRuntime
:processTemplatesRuntime UP-TO-DATE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
</pre></div></div><br class="example-break"><p>As you can see, we can both configure the tasks properties and use those properties as arguments to the incremental build runtime API. Using the runtime API like this is a little like using <code class="literal">doLast()</code> and <code class="literal">doFirst()</code> to attach extra actions to a task, except in this case we&rsquo;re attaching information about inputs and outputs. Note that if the task type is already using the incremental build annotations, the runtime API will add inputs and outputs rather than replace them.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:runtime_api_configuration" class="section-anchor" href="#sec:runtime_api_configuration"></a>Fine-grained configuration</h5></div></div></div><p>The runtime API methods only allow you to declare your inputs and outputs in themselves. However, the file-oriented ones return a builder - of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskInputFilePropertyBuilder.html" target="_top"><code class="classname">TaskInputFilePropertyBuilder</code></a> - that lets you provide additional information about those inputs and outputs.</p><p>You can learn about all the options provided by the builder in its API documentation, but we&rsquo;ll show you a simple example here to give you an idea of what you can do.</p><p>Let&rsquo;s say we don&rsquo;t want to run the <code class="literal">processTemplates</code> task if there are no source files, regardless of whether it&rsquo;s a clean build or not. After all, if there are no source files, there&rsquo;s nothing for the task to do. The builder allows us to configure this like so:</p><div class="example"><a name="runtimeIncrementalApiConfiguration"></a><p class="title"><b>Example&nbsp;107.&nbsp;Using skipWhenEmpty() via the runtime API</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task processTemplatesRuntimeConf(type: ProcessTemplatesNoAnnotations) {
    <span class="hl-comment">// ...</span>
    sourceFiles = fileTree(<span class="hl-string">"src/templates"</span>) {
        include <span class="hl-string">"**/*.fm"</span>
    }

    inputs.files(sourceFiles).skipWhenEmpty()
    <span class="hl-comment">// ...</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle clean processTemplatesRuntimeConf</code></strong></p><pre class="screen">&gt; gradle clean processTemplatesRuntimeConf
:processTemplatesRuntimeConf NO-SOURCE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
</pre></div></div><br class="example-break"><p>The <code class="literal">TaskInputs.files()</code> method returns a builder that has a <code class="literal">skipWhenEmpty()</code> method. Invoking this method is equivalent to annotating to the property with <a class="link" href="#skip-when-empty"><code class="literal">@SkipWhenEmpty</code></a>.</p><p>Prior to Gradle 3.0, you had to use the <code class="literal">TaskInputs.source()</code> and <code class="literal">TaskInputs.sourceDir()</code> methods to get the same behavior as with <code class="literal">skipWhenEmpty()</code>. These methods are now deprecated and should not be used with Gradle 3.0 and above.</p><p>Now that you have seen both the annotations and the runtime API, you may be wondering which API you should be using. Our recommendation is to use the annotations wherever possible, and it&rsquo;s sometimes worth creating a custom task class just so that you can make use of them. The runtime API is more for situations in which you can&rsquo;t use the annotations.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:task_input_output_side_effects" class="section-anchor" href="#sec:task_input_output_side_effects"></a>Important beneficial side effects</h4></div></div></div><p>Once you declare a task&rsquo;s formal inputs and outputs, Gradle can then infer things about those properties. For example, if an input of one task is set to the output of another, that means the first task depends on the second, right? Gradle knows this and can act upon it.</p><p>We&rsquo;ll look at this feature next and also some other features that come from Gradle knowing things about inputs and outputs.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:inferred_task_dependencies" class="section-anchor" href="#sec:inferred_task_dependencies"></a>Inferred task dependencies</h5></div></div></div><p>Consider an archive task that packages the output of the <code class="literal">processTemplates</code> task. A build author will see that the archive task obviously requires <code class="literal">processTemplates</code> to run first and so may add an explicit <code class="literal">dependsOn</code>. However, if you define the archive task like so:</p><div class="example"><a name="inferredTaskDep"></a><p class="title"><b>Example&nbsp;108.&nbsp;Inferred task dependency via task outputs</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task packageFiles(type: Zip) {
    from processTemplates.outputs
}
</pre><p>Output of <strong class="userinput"><code>gradle clean packageFiles</code></strong></p><pre class="screen">&gt; gradle clean packageFiles
:processTemplates
:packageFiles

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>Gradle will automatically make <code class="literal">packageFiles</code> depend on <code class="literal">processTemplates</code>. It can do this because it&rsquo;s aware that one of the inputs of packageFiles requires the output of the processTemplates task. We call this an inferred task dependency.</p><p>The above example can also be written as</p><div class="example"><a name="inferredTaskDep2"></a><p class="title"><b>Example&nbsp;109.&nbsp;Inferred task dependency via a task argument</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task packageFiles2(type: Zip) {
    from processTemplates
}
</pre><p>Output of <strong class="userinput"><code>gradle clean packageFiles2</code></strong></p><pre class="screen">&gt; gradle clean packageFiles2
:processTemplates
:packageFiles2

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>This is because the <code class="literal">from()</code> method can accept a task object as an argument. Behind the scenes, <code class="literal">from()</code> uses the <code class="literal">project.files()</code> method to wrap the argument, which in turn exposes the task&rsquo;s formal outputs as a file collection. In other words, it&rsquo;s a special case!</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:task_input_output_validation" class="section-anchor" href="#sec:task_input_output_validation"></a>Input and output validation</h5></div></div></div><p>The incremental build annotations provide enough information for Gradle to perform some basic validation on the annotated properties. In particular, it does the following for each property before the task executes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">@InputFile</code> - verifies that the property has a value and that the path corresponds to a file (not a directory) that exists.</p></li><li class="listitem"><p><code class="literal">@InputDirectory</code> - same as for <code class="literal">@InputFile</code>, except the path must correspond to a directory.</p></li><li class="listitem"><p><code class="literal">@OutputDirectory</code> - verifies that the path doesn&rsquo;t match a file and also creates the directory if it doesn&rsquo;t already exist.</p></li></ul></div><p>Such validation improves the robustness of the build, allowing you to identify issues related to inputs and outputs quickly.</p><p>You will occasionally want to disable some of this validation, specifically when an input file may validly not exist. That&rsquo;s why Gradle provides the <code class="literal">@Optional</code> annotation: you use it to tell Gradle that a particular input is optional and therefore the build should not fail if the corresponding file or directory doesn&rsquo;t exist.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:task_input_output_continuous_build" class="section-anchor" href="#sec:task_input_output_continuous_build"></a>Continuous build</h5></div></div></div><p>Another benefit of defining task inputs and outputs is continuous build. Since Gradle knows what files a task depends on, it can automatically run a task again if any of its inputs change. By activating continuous build when you run Gradle - through the <code class="literal">--continuous</code> or <code class="literal">-t</code> options - you will put Gradle into a state in which it continually checks for changes and executes the requested tasks when it encounters such changes.</p><p>You can find out more about this feature in <a class="xref" href="#continuous_build"><i>Continuous build</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:task_input_output_parallelism" class="section-anchor" href="#sec:task_input_output_parallelism"></a>Task parallelism</h5></div></div></div><p>One last benefit of defining task inputs and outputs is that Gradle can use this information to make decisions about how to run tasks when the "--parallel" option is used.  For instance, Gradle will inspect the outputs of tasks when selecting the  next task to run and will avoid concurrent execution of tasks that write to the same output directory.  Similarly, Gradle will use the information about what files a task destroys (e.g. specified by the <code class="literal">Destroys</code> annotation) and avoid running a task that removes a set of files while another task is running that consumes or creates those same files (and vice versa).  It can also determine that a task that creates a set of files has already run and that a task that consumes those files has yet to run and will avoid running a task that removes those files in between.  By providing task input and output information in this way, Gradle can infer creation/consumption/destruction relationships between tasks and can ensure that task execution does not violate those relationships.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:how_does_it_work" class="section-anchor" href="#sec:how_does_it_work"></a>How does it work?</h3></div></div></div><p>Before a task is executed for the first time, Gradle takes a snapshot of the inputs. This snapshot contains the paths of input files and a hash of the contents of each file. Gradle then executes the task. If the task completes successfully, Gradle takes a snapshot of the outputs. This snapshot contains the set of output files and a hash of the contents of each file. Gradle persists both snapshots for the next time the task is executed.</p><p>Each time after that, before the task is executed, Gradle takes a new snapshot of the inputs and outputs. If the new snapshots are the same as the previous snapshots, Gradle assumes that the outputs are up to date and skips the task. If they are not the same, Gradle executes the task. Gradle persists both snapshots for the next time the task is executed.</p><p>Gradle also considers the <span class="emphasis"><em>code</em></span> of the task as part of the inputs to the task. When a task, its actions, or its dependencies change between executions, Gradle considers the task as out-of-date.</p><p>Gradle understands if a file property (e.g. one holding a Java classpath) is order-sensitive. When comparing the snapshot of such a property, even a change in the order of the files will result in the task becoming out-of-date.</p><p>Note that if a task has an output directory specified, any files added to that directory since the last time it was executed are ignored and will NOT cause the task to be out of date. This is so unrelated tasks may share an output directory without interfering with each other. If this is not the behaviour you want for some reason, consider using <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskOutputs.html#upToDateWhen-groovy.lang.Closure-" target="_top"><code class="classname">TaskOutputs.upToDateWhen(groovy.lang.Closure)</code></a></p><p>The inputs for the task are also used to calculate the <a class="link" href="#build_cache">build cache</a> key used to load task outputs when enabled. For more details see <a class="xref" href="#sec:task_output_caching">the section called &ldquo;Task Output Caching&rdquo;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:advanced_inc_build" class="section-anchor" href="#sec:advanced_inc_build"></a>Advanced techniques</h3></div></div></div><p>Everything you&rsquo;ve seen so far in this section will cover most of the use cases you&rsquo;ll encounter, but there are some scenarios that need special treatment. We&rsquo;ll present a few of those next with the appropriate solutions.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:add_cached_input_output_methods" class="section-anchor" href="#sec:add_cached_input_output_methods"></a>Adding your own cached input/output methods</h4></div></div></div><p>Have you ever wondered how the <code class="literal">from()</code> method of the <code class="literal">Copy</code> task works? It&rsquo;s not annotated with <code class="literal">@InputFiles</code> and yet any files passed to it are treated as formal inputs of the task. What&rsquo;s happening?</p><p>The implementation is quite simple and you can use the same technique for your own tasks to improve their APIs. Write your methods so that they add files directly to the appropriate annotated property. As an example, here&rsquo;s how to add a <code class="literal">sources()</code> method to the custom <code class="literal">ProcessTemplates</code> class we introduced earlier:</p><div class="example"><a name="incrementalBuildCustomMethods"></a><p class="title"><b>Example&nbsp;110.&nbsp;Declaring a method to add task inputs</b></p><div class="example-contents"><p><code class="filename">buildSrc/src/main/java/org/example/ProcessTemplates.java</code></p><pre class="programlisting"><span class="hl-keyword">public</span> <span class="hl-keyword">class</span> ProcessTemplates <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-comment">// ...</span>
    <span class="hl-keyword">private</span> FileCollection sourceFiles = getProject().files();

    <span class="hl-annotation">@SkipWhenEmpty</span>
    <span class="hl-annotation">@InputFiles</span>
    <span class="hl-annotation">@PathSensitive(PathSensitivity.NONE)</span>
    <span class="hl-keyword">public</span> FileCollection getSourceFiles() {
        <span class="hl-keyword">return</span> <span class="hl-keyword">this</span>.sourceFiles;
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sources(FileCollection sourceFiles) {
        <span class="hl-keyword">this</span>.sourceFiles = <span class="hl-keyword">this</span>.sourceFiles.plus(sourceFiles);
    }

    <span class="hl-comment">// ...</span>
}
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">task processTemplates(type: ProcessTemplates) {
    templateEngine = TemplateEngineType.FREEMARKER
    templateData = <span class="hl-keyword">new</span> TemplateData(<span class="hl-string">"test"</span>, [year: <span class="hl-number">2012</span>])
    outputDir = file(<span class="hl-string">"$buildDir/genOutput"</span>)

    sources fileTree(<span class="hl-string">"src/templates"</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle processTemplates</code></strong></p><pre class="screen">&gt; gradle processTemplates
:processTemplates

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>In other words, as long as you add values and files to formal task inputs and outputs during the configuration phase, they will be treated as such regardless from where in the build you add them.</p><p>If we want to support tasks as arguments as well and treat their outputs as the inputs, we can use the <code class="literal">project.files()</code> method like so:</p><div class="example"><a name="incrementalBuildCustomMethodsWithTaskArg"></a><p class="title"><b>Example&nbsp;111.&nbsp;Declaring a method to add a task as an input</b></p><div class="example-contents"><p><code class="filename">buildSrc/src/main/java/org/example/ProcessTemplates.java</code></p><pre class="programlisting"><span class="hl-comment">// ...</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">void</span> sources(Task inputTask) {
    <span class="hl-keyword">this</span>.sourceFiles = <span class="hl-keyword">this</span>.sourceFiles.plus(getProject().files(inputTask));
}
<span class="hl-comment">// ...</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyTemplates(type: Copy) {
    into <span class="hl-string">"$buildDir/tmp"</span>
    from <span class="hl-string">"src/templates"</span>
}

task processTemplates2(type: ProcessTemplates) {
    <span class="hl-comment">// ...</span>
    sources copyTemplates
}
</pre><p>Output of <strong class="userinput"><code>gradle processTemplates2</code></strong></p><pre class="screen">&gt; gradle processTemplates2
:copyTemplates
:processTemplates2

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>This technique can make your custom task easier to use and result in cleaner build files. As an added benefit, our use of <code class="literal">getProject().files()</code> means that our custom method can set up an inferred task dependency.</p><p>One last thing to note: if you are developing a task that takes collections of source files as inputs, like this example, consider using the built-in <a class="ulink" href="../dsl/org.gradle.api.tasks.SourceTask.html" target="_top"><code class="classname">SourceTask</code></a>. It will save you having to implement some of the plumbing that we put into <code class="literal">ProcessTemplates</code>.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:link_output_dir_to_input_files" class="section-anchor" href="#sec:link_output_dir_to_input_files"></a>Linking an <code class="literal">@OutputDirectory</code> to an <code class="literal">@InputFiles</code></h4></div></div></div><p>When you want to link the output of one task to the input of another, the types often match and a simple property assignment will provide that link. For example, a <code class="literal">File</code> output property can be assigned to a <code class="literal">File</code> input.</p><p>Unfortunately, this approach breaks down when you want the files in a task&rsquo;s <code class="literal">@OutputDirectory</code> (of type <code class="literal">File</code>) to become the source for another task&rsquo;s <code class="literal">@InputFiles</code> property (of type <code class="literal">FileCollection</code>). Since the two have different types, property assignment won&rsquo;t work.</p><p>As an example, imagine you want to use the output of a Java compilation task - via the <code class="literal">destinationDir</code> property - as the input of a custom task that instruments a set of files containing Java bytecode. This custom task, which we&rsquo;ll call <code class="literal">Instrument</code>, has a <code class="literal">classFiles</code> property annotated with <code class="literal">@InputFiles</code>. You might initially try to configure the task like so:</p><div class="example"><a name="incrementalBuildBadInputFilesConfig"></a><p class="title"><b>Example&nbsp;112.&nbsp;Failed attempt at setting up an inferred task dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"java"</span>

task badInstrumentClasses(type: Instrument) {
    classFiles = fileTree(compileJava.destinationDir)
    destinationDir = file(<span class="hl-string">"$buildDir/instrumented"</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle clean badInstrumentClasses</code></strong></p><pre class="screen">&gt; gradle clean badInstrumentClasses
:clean UP-TO-DATE
:badInstrumentClasses NO-SOURCE

BUILD SUCCESSFUL in 0s
1 actionable task: 1 up-to-date
</pre></div></div><br class="example-break"><p>There&rsquo;s nothing obviously wrong with this code, but you can see from the console output that the compilation task is missing. In this case you would need to add an explicit task dependency between <code class="literal">instrumentClasses</code> and <code class="literal">compileJava</code> via <code class="literal">dependsOn</code>. The use of <code class="literal">fileTree()</code> means that Gradle can&rsquo;t infer the task dependency itself.</p><p>One solution is to use the <code class="literal">TaskOutputs.files</code> property, as demonstrated by the following example:</p><div class="example"><a name="incrementalBuildInputFilesConfig"></a><p class="title"><b>Example&nbsp;113.&nbsp;Setting up an inferred task dependency between output dir and input files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task instrumentClasses(type: Instrument) {
    classFiles = compileJava.outputs.files
    destinationDir = file(<span class="hl-string">"$buildDir/instrumented"</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle clean instrumentClasses</code></strong></p><pre class="screen">&gt; gradle clean instrumentClasses
:clean UP-TO-DATE
:compileJava
:instrumentClasses

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>Alternatively, you can get Gradle to access the appropriate property itself by using the <code class="literal">project.files()</code> method in place of <code class="literal">project.fileTree()</code>:</p><div class="example"><a name="incrementalBuildInputFilesConfigUsingTask"></a><p class="title"><b>Example&nbsp;114.&nbsp;Setting up an inferred task dependency with files()</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task instrumentClasses2(type: Instrument) {
    classFiles = files(compileJava)
    destinationDir = file(<span class="hl-string">"$buildDir/instrumented"</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle clean instrumentClasses2</code></strong></p><pre class="screen">&gt; gradle clean instrumentClasses2
:clean UP-TO-DATE
:compileJava
:instrumentClasses2

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>Remember that <code class="literal">files()</code> can take tasks as arguments, whereas <code class="literal">fileTree()</code> cannot.</p><p>The downside of this approach is that all file outputs of the source task become the input files of the target - <code class="literal">instrumentClasses</code> in this case. That&rsquo;s fine as long as the source task only has a single file-based output, like the <code class="literal">JavaCompile</code> task. But if you have to link just one output property among several, then you need to explicitly tell Gradle which task generates the input files using the <code class="literal">builtBy</code> method:</p><div class="example"><a name="inferredTaskDependencyWithBuiltBy"></a><p class="title"><b>Example&nbsp;115.&nbsp;Setting up an inferred task dependency with builtBy()</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task instrumentClassesBuiltBy(type: Instrument) {
    classFiles = fileTree(compileJava.destinationDir) {
        builtBy compileJava
    }
    destinationDir = file(<span class="hl-string">"$buildDir/instrumented"</span>)
}
</pre><p>Output of <strong class="userinput"><code>gradle clean instrumentClassesBuiltBy</code></strong></p><pre class="screen">&gt; gradle clean instrumentClassesBuiltBy
:clean UP-TO-DATE
:compileJava
:instrumentClassesBuiltBy

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>You can of course just add an explicit task dependency via <code class="literal">dependsOn</code>, but the above approach provides more semantic meaning, explaining why <code class="literal">compileJava</code> has to run beforehand.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:custom_up_to_date_logic" class="section-anchor" href="#sec:custom_up_to_date_logic"></a>Providing custom up-to-date logic</h4></div></div></div><p>Gradle automatically handles up-to-date checks for output files and directories, but what if the task output is something else entirely? Perhaps it&rsquo;s an update to a web service or a database table. Gradle has no way of knowing how to check whether the task is up to date in such cases.</p><p>That&rsquo;s where the <code class="literal">upToDateWhen()</code> method on <code class="literal">TaskOutputs</code> comes in. This takes a predicate function that is used to determine whether a task is up to date or not. One use case is to disable up-to-date checks completely for a task, like so:</p><div class="example"><a name="incrementalBuildUpToDateWhen"></a><p class="title"><b>Example&nbsp;116.&nbsp;Ignoring up-to-date checks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task alwaysInstrumentClasses(type: Instrument) {
    classFiles = files(compileJava)
    destinationDir = file(<span class="hl-string">"$buildDir/instrumented"</span>)
    outputs.upToDateWhen { false }
}
</pre><p>Output of <strong class="userinput"><code>gradle clean alwaysInstrumentClasses</code></strong></p><pre class="screen">&gt; gradle clean alwaysInstrumentClasses
:compileJava
:alwaysInstrumentClasses

BUILD SUCCESSFUL in 0s
3 actionable tasks: 2 executed, 1 up-to-date
</pre><p>Output of <strong class="userinput"><code>gradle alwaysInstrumentClasses</code></strong></p><pre class="screen">&gt; gradle alwaysInstrumentClasses
:compileJava UP-TO-DATE
:alwaysInstrumentClasses

BUILD SUCCESSFUL in 0s
2 actionable tasks: 1 executed, 1 up-to-date
</pre></div></div><br class="example-break"><p>The <code class="literal">{ false }</code> closure ensures that <code class="literal">copyResources</code> will always perform the copy, irrespective of whether there is no change in the inputs or outputs.</p><p>You can of course put more complex logic into the closure. You could check whether a particular record in a database table exists or has changed for example. Just be aware that up-to-date checks should <span class="emphasis"><em>save</em></span> you time. Don&rsquo;t add checks that cost as much or more time than the standard execution of the task. In fact, if a task ends up running frequently anyway, because it&rsquo;s rarely up to date, then it may not be worth having an up-to-date check at all. Remember that your checks will always run if the task is in the execution task graph.</p><p>One common mistake is to use <code class="literal">upToDateWhen()</code> instead of <code class="literal">Task.onlyIf()</code>. If you want to skip a task on the basis of some condition unrelated to the task inputs and outputs, then you should use <code class="literal">onlyIf()</code>. For example, in cases where you want to skip a task when a particular property is set or not set.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:configure_input_normalization" class="section-anchor" href="#sec:configure_input_normalization"></a>Configure input normalization</h4></div></div></div><p>For up to date checks and the <a class="link" href="#build_cache">build cache</a> Gradle needs to determine if two task input properties have the same value.
In order to do so, Gradle first normalizes both inputs and then compares the result.
For example, for a compile classpath, Gradle extracts the ABI signature from the classes on the classpath and then compares signatures between the last Gradle run and the current Gradle run as described in <a class="xref" href="#sec:java_compile_avoidance">the section called &ldquo;Compile avoidance&rdquo;</a>.</p><p>It is possible to customize Gradle&rsquo;s built-in strategy for runtime classpath normalization.
All inputs annotated with <code class="literal">@<a class="ulink" href="../javadoc/org/gradle/api/tasks/Classpath.html" target="_top"><code class="classname">Classpath</code></a></code> are considered to be runtime classpaths.</p><p>Let&rsquo;s say you want to add a file <code class="literal">build-info.properties</code> to all your produced jar files which contains information about the build, e.g. the timestamp when the build started or some ID to identify the CI job that published the artifact.
This file is only for auditing purposes, and has no effect on the outcome of running tests.
Nonetheless, this file is part of the runtime classpath for the <code class="literal">test</code> task and changes on every build invocation.
Therefore, the <code class="literal">test</code> would be never up-to-date or pulled from the build cache.
In order to benefit from incremental builds again, you are able tell Gradle to ignore this file on the runtime classpath at the project level by using <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:normalization(org.gradle.api.Action)" target="_top"><code class="classname">Project.normalization(org.gradle.api.Action)</code></a>:</p><div class="example"><a name="runtimeClasspathNormalization"></a><p class="title"><b>Example&nbsp;117.&nbsp;Runtime classpath normalization</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">normalization {
    runtimeClasspath {
        ignore <span class="hl-string">'build-info.properties'</span>
    }
}
</pre></div></div><br class="example-break"><p>The effect of this configuration would be that changes to <code class="literal">build-info.properties</code> would be ignored for up-to-date checks and <a class="link" href="#build_cache">build cache</a> key calculations.
Note that this will not change the runtime behavior of the <code class="literal">test</code> task - i.e. any test is still able to load <code class="literal">build-info.properties</code> and the runtime classpath is still the same as before.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:stale_task_outputs" class="section-anchor" href="#sec:stale_task_outputs"></a>Stale task outputs</h3></div></div></div><p>When the Gradle version changes, Gradle detects that outputs from tasks that ran with older versions of Gradle need to be removed to ensure that the newest version of the tasks are starting from a known clean state.</p><div class="note"><p>Automatic clean-up of stale output directories has only been implemented for the output of source sets (Java/Groovy/Scala compilation).</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:task_rules" class="section-anchor" href="#sec:task_rules"></a>Task rules</h2></div></div></div><p>Sometimes you want to have a task whose behavior depends on a large or infinite number value range of parameters. A very nice and expressive way to provide such tasks are task rules:</p><div class="example"><a name="taskRule"></a><p class="title"><b>Example&nbsp;118.&nbsp;Task rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span class="hl-keyword">if</span> (taskName.startsWith(<span class="hl-string">"ping"</span>)) {
        task(taskName) {
            doLast {
                println <span class="hl-string">"Pinging: "</span> + (taskName - <span class="hl-string">'ping'</span>)
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q pingServer1</code></strong></p><pre class="screen">&gt; gradle -q pingServer1
Pinging: Server1
</pre></div></div><br class="example-break"><p>The String parameter is used as a description for the rule, which is shown with <code class="literal">gradle tasks</code>.</p><p>Rules are not only used when calling tasks from the command line. You can also create dependsOn relations on rule based tasks:</p><div class="example"><a name="taskRuleDependsOn"></a><p class="title"><b>Example&nbsp;119.&nbsp;Dependency on rule based tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.addRule(<span class="hl-string">"Pattern: ping&lt;ID&gt;"</span>) { String taskName -&gt;
    <span class="hl-keyword">if</span> (taskName.startsWith(<span class="hl-string">"ping"</span>)) {
        task(taskName) {
            doLast {
                println <span class="hl-string">"Pinging: "</span> + (taskName - <span class="hl-string">'ping'</span>)
            }
        }
    }
}

task groupPing {
    dependsOn pingServer1, pingServer2
}
</pre><p>Output of <strong class="userinput"><code>gradle -q groupPing</code></strong></p><pre class="screen">&gt; gradle -q groupPing
Pinging: Server1
Pinging: Server2
</pre></div></div><br class="example-break"><p>If you run &ldquo;<code class="literal">gradle -q tasks</code>&rdquo; you won&rsquo;t find a task named &ldquo;<code class="literal">pingServer1</code>&rdquo; or &ldquo;<code class="literal">pingServer2</code>&rdquo;, but this script is executing logic based on the request to run those tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:finalizer_tasks" class="section-anchor" href="#sec:finalizer_tasks"></a>Finalizer tasks</h2></div></div></div><div class="note"><p>Finalizers tasks are an <span class="emphasis"><em>incubating</em></span> feature (see <a class="xref" href="#sec:incubating_state">the section called &ldquo;Incubating&rdquo;</a>).</p></div><p>Finalizer tasks are automatically added to the task graph when the finalized task is scheduled to run.</p><div class="example"><a name="taskFinalizers"></a><p class="title"><b>Example&nbsp;120.&nbsp;Adding a task finalizer</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>Finalizer tasks will be executed even if the finalized task fails.</p><div class="example"><a name="taskFinalizersWithFailure"></a><p class="title"><b>Example&nbsp;121.&nbsp;Task finalizer for a failing task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task taskX {
    doLast {
        println <span class="hl-string">'taskX'</span>
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException()
    }
}
task taskY {
    doLast {
        println <span class="hl-string">'taskY'</span>
    }
}

taskX.finalizedBy taskY
</pre><p>Output of <strong class="userinput"><code>gradle -q taskX</code></strong></p><pre class="screen">&gt; gradle -q taskX
taskX
taskY</pre></div></div><br class="example-break"><p>On the other hand, finalizer tasks are not executed if the finalized task didn&rsquo;t do any work, for example if it is considered up to date or if a dependent task fails.</p><p>Finalizer tasks are useful in situations where the build creates a resource that has to be cleaned up regardless of the build failing or succeeding. An example of such a resource is a web container that is started before an integration test task and which should be always shut down, even if some of the tests fail.</p><p>To specify a finalizer task you use the <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:finalizedBy(java.lang.Object[])" target="_top"><code class="classname">Task.finalizedBy(java.lang.Object[])</code></a> method. This method accepts a task instance, a task name, or any other input accepted by <a class="ulink" href="../dsl/org.gradle.api.Task.html#org.gradle.api.Task:dependsOn(java.lang.Object[])" target="_top"><code class="classname">Task.dependsOn(java.lang.Object[])</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:lifecycle_tasks" class="section-anchor" href="#sec:lifecycle_tasks"></a>Lifecycle tasks</h2></div></div></div><p>Lifecycle tasks are tasks that do not do work themselves. They typically do not have any task actions. Lifecycle tasks can represent several concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a work-flow step (e.g., run all checks with <code class="literal">check</code>)</p></li><li class="listitem"><p>a buildable thing (e.g., create a debug 32-bit executable for native components with <code class="literal">debug32MainExecutable</code>)</p></li><li class="listitem"><p>a convenience task to execute many of the same logical tasks (e.g., run all compilation tasks with <code class="literal">compileAll</code>)</p></li></ul></div><p>Many Gradle plug-ins define their own lifecycle tasks to make it convenient to do specific things. When developing your own plugins, you should consider using your own lifecycle tasks or hooking into some of the tasks already provided by Gradle. See the Java plugin <a class="xref" href="#sec:java_tasks">the section called &ldquo;Tasks&rdquo;</a> for an example.</p><p>Unless a lifecycle task has actions, its outcome is determined by its dependencies. If any of the task&rsquo;s dependencies are executed, the lifecycle task will be considered executed. If all of the task&rsquo;s dependencies are up-to-date, skipped or from cache, the lifecycle task will be considered up-to-date.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:the_idea_behind_gradle_tasks" class="section-anchor" href="#sec:the_idea_behind_gradle_tasks"></a>Summary</h2></div></div></div><p>If you are coming from Ant, an enhanced Gradle task like <span class="emphasis"><em>Copy</em></span> seems like a cross between an Ant target and an Ant task. Although Ant&rsquo;s tasks and targets are really different entities, Gradle combines these notions into a single entity. Simple Gradle tasks are like Ant&rsquo;s targets, but enhanced Gradle tasks also include aspects of Ant tasks. All of Gradle&rsquo;s tasks share a common API and you can create dependencies between them. These tasks are much easier to configure than an Ant task. They make full use of the type system, and are more expressive and easier to maintain.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N11F42" name="ftn.N11F42" class="para">6</a>] </sup>You might be wondering why there is neither an import for the <code class="literal">StopExecutionException</code> nor do we access it via its fully qualified name. The reason is, that Gradle adds a set of default imports to your script (see <a class="xref" href="#script-default-imports">the section called &ldquo;Default imports&rdquo;</a>).</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="working_with_files"></a>Working With Files</h1></div></div></div><p>Most builds work with files. Gradle adds some concepts and APIs to help you achieve this.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:locating_files" class="section-anchor" href="#sec:locating_files"></a>Locating files</h2></div></div></div><p>You can locate a file relative to the project directory using the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a> method.</p><div class="example"><a name="resolveFile"></a><p class="title"><b>Example&nbsp;122.&nbsp;Locating files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Using a relative path</span>
File configFile = file(<span class="hl-string">'src/config.xml'</span>)

<span class="hl-comment">// Using an absolute path</span>
configFile = file(configFile.absolutePath)

<span class="hl-comment">// Using a File object with a relative path</span>
configFile = file(<span class="hl-keyword">new</span> File(<span class="hl-string">'src/config.xml'</span>))

<span class="hl-comment">// Using a java.nio.file.Path object with a relative path</span>
configFile = file(Paths.get(<span class="hl-string">'src'</span>, <span class="hl-string">'config.xml'</span>))

<span class="hl-comment">// Using an absolute java.nio.file.Path object</span>
configFile = file(Paths.get(System.getProperty(<span class="hl-string">'user.home'</span>)).resolve(<span class="hl-string">'global-config.xml'</span>))
</pre></div></div><br class="example-break"><p>You can pass any object to the <code class="literal">file()</code> method, and it will attempt to convert the value to an absolute <code class="literal">File</code> object. Usually, you would pass it a <code class="literal">String</code>, <code class="literal">File</code> or <code class="literal">Path</code> instance. If this path is an absolute path, it is used to construct a <code class="literal">File</code> instance. Otherwise, a <code class="literal">File</code> instance is constructed by prepending the project directory path to the supplied path. The <code class="literal">file()</code> method also understands URLs, such as <code class="literal">file:/some/path.xml</code>.</p><p>Using this method is a useful way to convert some user provided value into an absolute <code class="literal">File</code>. It is preferable to using <code class="literal">new File(somePath)</code>, as <code class="literal">file()</code> always evaluates the supplied path relative to the project directory, which is fixed, rather than the current working directory, which can change depending on how the user runs Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:file_collections" class="section-anchor" href="#sec:file_collections"></a>File collections</h2></div></div></div><p>A <span class="emphasis"><em>file collection</em></span> is simply a set of files. It is represented by the <a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> interface. Many objects in the Gradle API implement this interface. For example, <a class="link" href="#">dependency configurations</a> implement <code class="literal">FileCollection</code>.</p><p>One way to obtain a <code class="literal">FileCollection</code> instance is to use the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])" target="_top"><code class="classname">Project.files(java.lang.Object[])</code></a> method. You can pass this method any number of objects, which are then converted into a set of <code class="literal">File</code> objects. The <code class="literal">files()</code> method accepts any type of object as its parameters. These are evaluated relative to the project directory, as per the <code class="literal">file()</code> method, described in <a class="xref" href="#sec:locating_files">the section called &ldquo;Locating files&rdquo;</a>. You can also pass collections, iterables, maps and arrays to the <code class="literal">files()</code> method. These are flattened and the contents converted to <code class="literal">File</code> instances.</p><div class="example"><a name="fileCollections"></a><p class="title"><b>Example&nbsp;123.&nbsp;Creating a file collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">FileCollection collection = files(<span class="hl-string">'src/file1.txt'</span>,
                                  <span class="hl-keyword">new</span> File(<span class="hl-string">'src/file2.txt'</span>),
                                  [<span class="hl-string">'src/file3.txt'</span>, <span class="hl-string">'src/file4.txt'</span>],
                                  Paths.get(<span class="hl-string">'src'</span>, <span class="hl-string">'file5.txt'</span>))
</pre></div></div><br class="example-break"><p>A file collection is iterable, and can be converted to a number of other types using the <code class="literal">as</code> operator. You can also add 2 file collections together using the <code class="literal">+</code> operator, or subtract one file collection from another using the <code class="literal">-</code> operator. Here are some examples of what you can do with a file collection.</p><div class="example"><a name="fileCollections"></a><p class="title"><b>Example&nbsp;124.&nbsp;Using a file collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Iterate over the files in the collection</span>
collection.each { File file -&gt;
    println file.name
}

<span class="hl-comment">// Convert the collection to various types</span>
Set set = collection.files
Set set2 = collection as Set
List list = collection as List
String path = collection.asPath
File file = collection.singleFile
File file2 = collection as File

<span class="hl-comment">// Add and subtract collections</span>
def union = collection + files(<span class="hl-string">'src/file3.txt'</span>)
def different = collection - files(<span class="hl-string">'src/file3.txt'</span>)

</pre></div></div><br class="example-break"><p>You can also pass the <code class="literal">files()</code> method a closure or a <code class="literal">Callable</code> instance. This is called when the contents of the collection are queried, and its return value is converted to a set of <code class="literal">File</code> instances. The return value can be an object of any of the types supported by the <code class="literal">files()</code> method. This is a simple way to 'implement' the <code class="literal">FileCollection</code> interface.</p><div class="example"><a name="fileCollections"></a><p class="title"><b>Example&nbsp;125.&nbsp;Implementing a file collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task list {
    doLast {
        File srcDir

        <span class="hl-comment">// Create a file collection using a closure</span>
        collection = files { srcDir.listFiles() }

        srcDir = file(<span class="hl-string">'src'</span>)
        println <span class="hl-string">"Contents of $srcDir.name"</span>
        collection.collect { relativePath(it) }.sort().each { println it }

        srcDir = file(<span class="hl-string">'src2'</span>)
        println <span class="hl-string">"Contents of $srcDir.name"</span>
        collection.collect { relativePath(it) }.sort().each { println it }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q list</code></strong></p><pre class="screen">&gt; gradle -q list
Contents of src
src/dir1
src/file1.txt
Contents of src2
src2/dir1
src2/dir2
</pre></div></div><br class="example-break"><p>Some other types of things you can pass to <code class="literal">files()</code>:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">FileCollection</code></span></dt><dd><p>These are flattened and the contents included in the file collection.</p></dd><dt><span class="term"><code class="literal">Task</code></span></dt><dd><p>The output files of the task are included in the file collection.</p></dd><dt><span class="term"><code class="literal">TaskOutputs</code></span></dt><dd><p>The output files of the TaskOutputs are included in the file collection.</p></dd></dl></div><p>It is important to note that the content of a file collection is evaluated lazily, when it is needed. This means you can, for example, create a <code class="literal">FileCollection</code> that represents files which will be created in the future by, say, some task.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:file_trees" class="section-anchor" href="#sec:file_trees"></a>File trees</h2></div></div></div><p>A <span class="emphasis"><em>file tree</em></span> is a collection of files arranged in a hierarchy. For example, a file tree might represent a directory tree or the contents of a ZIP file. It is represented by the <a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a> interface. The <code class="literal">FileTree</code> interface extends <code class="literal">FileCollection</code>, so you can treat a file tree exactly the same way as you would a file collection. Several objects in Gradle implement the <code class="literal">FileTree</code> interface, such as <a class="link" href="#sec:source_sets">source sets</a>.</p><p>One way to obtain a <code class="literal">FileTree</code> instance is to use the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.util.Map)" target="_top"><code class="classname">Project.fileTree(java.util.Map)</code></a> method. This creates a <code class="literal">FileTree</code> defined with a base directory, and optionally some Ant-style include and exclude patterns.</p><div class="example"><a name="fileTrees"></a><p class="title"><b>Example&nbsp;126.&nbsp;Creating a file tree</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Create a file tree with a base directory</span>
FileTree tree = fileTree(dir: <span class="hl-string">'src/main'</span>)

<span class="hl-comment">// Add include and exclude patterns to the tree</span>
tree.include <span class="hl-string">'**/*.java'</span>
tree.exclude <span class="hl-string">'**/Abstract*'</span>

<span class="hl-comment">// Create a tree using path</span>
tree = fileTree(<span class="hl-string">'src'</span>).include(<span class="hl-string">'**/*.java'</span>)

<span class="hl-comment">// Create a tree using closure</span>
tree = fileTree(<span class="hl-string">'src'</span>) {
    include <span class="hl-string">'**/*.java'</span>
}

<span class="hl-comment">// Create a tree using a map</span>
tree = fileTree(dir: <span class="hl-string">'src'</span>, include: <span class="hl-string">'**/*.java'</span>)
tree = fileTree(dir: <span class="hl-string">'src'</span>, includes: [<span class="hl-string">'**/*.java'</span>, <span class="hl-string">'**/*.xml'</span>])
tree = fileTree(dir: <span class="hl-string">'src'</span>, include: <span class="hl-string">'**/*.java'</span>, exclude: <span class="hl-string">'**/*test*/**'</span>)
</pre></div></div><br class="example-break"><p>You use a file tree in the same way you use a file collection. You can also visit the contents of the tree, and select a sub-tree using Ant-style patterns:</p><div class="example"><a name="fileTrees"></a><p class="title"><b>Example&nbsp;127.&nbsp;Using a file tree</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Iterate over the contents of a tree</span>
tree.each {File file -&gt;
    println file
}

<span class="hl-comment">// Filter a tree</span>
FileTree filtered = tree.matching {
    include <span class="hl-string">'org/gradle/api/**'</span>
}

<span class="hl-comment">// Add trees together</span>
FileTree sum = tree + fileTree(dir: <span class="hl-string">'src/test'</span>)

<span class="hl-comment">// Visit the elements of the tree</span>
tree.visit {element -&gt;
    println <span class="hl-string">"$element.relativePath =&gt; $element.file"</span>
}
</pre></div></div><br class="example-break"><div class="note"><p>By default, the <code class="literal">FileTree</code> instance <code class="literal">fileTree()</code> returns will apply some Ant-style default exclude patterns for convenience. For the complete default exclusion list, see <a class="ulink" href="http://ant.apache.org/manual/dirtasks.html#defaultexcludes" target="_top">Default Excludes</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:archive_contents" class="section-anchor" href="#sec:archive_contents"></a>Using the contents of an archive as a file tree</h2></div></div></div><p>You can use the contents of an archive, such as a ZIP or TAR file, as a file tree. You do this using the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:zipTree(java.lang.Object)" target="_top"><code class="classname">Project.zipTree(java.lang.Object)</code></a> and <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:tarTree(java.lang.Object)" target="_top"><code class="classname">Project.tarTree(java.lang.Object)</code></a> methods. These methods return a <code class="literal">FileTree</code> instance which you can use like any other file tree or file collection. For example, you can use it to expand the archive by copying the contents, or to merge some archives into another.</p><div class="example"><a name="fileTrees"></a><p class="title"><b>Example&nbsp;128.&nbsp;Using an archive as a file tree</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Create a ZIP file tree using path</span>
FileTree zip = zipTree(<span class="hl-string">'someFile.zip'</span>)

<span class="hl-comment">// Create a TAR file tree using path</span>
FileTree tar = tarTree(<span class="hl-string">'someFile.tar'</span>)

<span class="hl-comment">//tar tree attempts to guess the compression based on the file extension</span>
<span class="hl-comment">//however if you must specify the compression explicitly you can:</span>
FileTree someTar = tarTree(resources.gzip(<span class="hl-string">'someTar.ext'</span>))

</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:specifying_multiple_files" class="section-anchor" href="#sec:specifying_multiple_files"></a>Specifying a set of input files</h2></div></div></div><p>Many objects in Gradle have properties which accept a set of input files. For example, the <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a> task has a <code class="literal">source</code> property, which defines the source files to compile. You can set the value of this property using any of the types supported by the <a class="link" href="#sec:file_collections">files()</a> method, which was shown above. This means you can set the property using, for example, a <code class="literal">File</code>, <code class="literal">String</code>, collection, <code class="literal">FileCollection</code> or even a closure. Here are some examples:</p><div class="example"><a name="inputFiles"></a><p class="title"><b>Example&nbsp;129.&nbsp;Specifying a set of files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task compile(type: JavaCompile)

<span class="hl-comment">// Use a File object to specify the source directory</span>
compile {
    source = file(<span class="hl-string">'src/main/java'</span>)
}

<span class="hl-comment">// Use a String path to specify the source directory</span>
compile {
    source = <span class="hl-string">'src/main/java'</span>
}

<span class="hl-comment">// Use a collection to specify multiple source directories</span>
compile {
    source = [<span class="hl-string">'src/main/java'</span>, <span class="hl-string">'../shared/java'</span>]
}

<span class="hl-comment">// Use a FileCollection (or FileTree in this case) to specify the source files</span>
compile {
    source = fileTree(dir: <span class="hl-string">'src/main/java'</span>).matching { include <span class="hl-string">'org/gradle/api/**'</span> }
}

<span class="hl-comment">// Using a closure to specify the source files.</span>
compile {
    source = {
        <span class="hl-comment">// Use the contents of each zip file in the src dir</span>
        file(<span class="hl-string">'src'</span>).listFiles().findAll {it.name.endsWith(<span class="hl-string">'.zip'</span>)}.collect { zipTree(it) }
    }
}
</pre></div></div><br class="example-break"><p>Usually, there is a method with the same name as the property, which appends to the set of files. Again, this method accepts any of the types supported by the <a class="link" href="#sec:file_collections">files()</a> method.</p><div class="example"><a name="inputFiles"></a><p class="title"><b>Example&nbsp;130.&nbsp;Appending a set of files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">compile {
    <span class="hl-comment">// Add some source directories use String paths</span>
    source <span class="hl-string">'src/main/java'</span>, <span class="hl-string">'src/main/groovy'</span>

    <span class="hl-comment">// Add a source directory using a File object</span>
    source file(<span class="hl-string">'../shared/java'</span>)

    <span class="hl-comment">// Add some source directories using a closure</span>
    source { file(<span class="hl-string">'src/test/'</span>).listFiles() }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:copying_files" class="section-anchor" href="#sec:copying_files"></a>Copying files</h2></div></div></div><p>You can use the <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a> task to copy files. The copy task is very flexible, and allows you to, for example, filter the contents of the files as they are copied, and map to the file names.</p><p>To use the <code class="literal">Copy</code> task, you must provide a set of source files to copy, and a destination directory to copy the files to. You may also specify how to transform the files as they are copied. You do all this using a <span class="emphasis"><em>copy spec</em></span>. A copy spec is represented by the <a class="ulink" href="../javadoc/org/gradle/api/file/CopySpec.html" target="_top"><code class="classname">CopySpec</code></a> interface. The <code class="literal">Copy</code> task implements this interface. You specify the source files using the <a class="ulink" href="../javadoc/org/gradle/api/file/CopySpec.html#from-java.lang.Object[]-" target="_top"><code class="classname">CopySpec.from(java.lang.Object[])</code></a> method. To specify the destination directory, use the <a class="ulink" href="../javadoc/org/gradle/api/file/CopySpec.html#into-java.lang.Object-" target="_top"><code class="classname">CopySpec.into(java.lang.Object)</code></a> method.</p><div class="example"><a name="copy"></a><p class="title"><b>Example&nbsp;131.&nbsp;Copying files using the copy task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyTask(type: Copy) {
    from <span class="hl-string">'src/main/webapp'</span>
    into <span class="hl-string">'build/explodedWar'</span>
}
</pre></div></div><br class="example-break"><p>The <code class="literal">from()</code> method accepts any of the arguments that the <a class="link" href="#sec:file_collections">files()</a> method does. When an argument resolves to a directory, everything under that directory (but not the directory itself) is recursively copied into the destination directory. When an argument resolves to a file, that file is copied into the destination directory. When an argument resolves to a non-existing file, that argument is ignored. If the argument is a task, the output files (i.e. the files the task creates) of the task are copied and the task is automatically added as a dependency of the <code class="literal">Copy</code> task. The <code class="literal">into()</code> accepts any of the arguments that the <a class="link" href="#sec:locating_files">file()</a> method does. Here is another example:</p><div class="example"><a name="copy"></a><p class="title"><b>Example&nbsp;132.&nbsp;Specifying copy task source files and destination directory</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task anotherCopyTask(type: Copy) {
    <span class="hl-comment">// Copy everything under src/main/webapp</span>
    from <span class="hl-string">'src/main/webapp'</span>
    <span class="hl-comment">// Copy a single file</span>
    from <span class="hl-string">'src/staging/index.html'</span>
    <span class="hl-comment">// Copy the output of a task</span>
    from copyTask
    <span class="hl-comment">// Copy the output of a task using Task outputs explicitly.</span>
    from copyTaskWithPatterns.outputs
    <span class="hl-comment">// Copy the contents of a Zip file</span>
    from zipTree(<span class="hl-string">'src/main/assets.zip'</span>)
    <span class="hl-comment">// Determine the destination directory later</span>
    into { getDestDir() }
}
</pre></div></div><br class="example-break"><p>You can select the files to copy using Ant-style include or exclude patterns, or using a closure:</p><div class="example"><a name="copy"></a><p class="title"><b>Example&nbsp;133.&nbsp;Selecting the files to copy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyTaskWithPatterns(type: Copy) {
    from <span class="hl-string">'src/main/webapp'</span>
    into <span class="hl-string">'build/explodedWar'</span>
    include <span class="hl-string">'**/*.html'</span>
    include <span class="hl-string">'**/*.jsp'</span>
    exclude { details -&gt; details.file.name.endsWith(<span class="hl-string">'.html'</span>) &amp;&amp;
                         details.file.text.contains(<span class="hl-string">'staging'</span>) }
}
</pre></div></div><br class="example-break"><p>You can also use the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)" target="_top"><code class="classname">Project.copy(org.gradle.api.Action)</code></a> method to copy files. It works the same way as the task with some major limitations though. First, the <code class="literal">copy()</code> is not incremental (see <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>).</p><div class="example"><a name="copy"></a><p class="title"><b>Example&nbsp;134.&nbsp;Copying files using the copy() method without up-to-date check</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyMethod {
    doLast {
        copy {
            from <span class="hl-string">'src/main/webapp'</span>
            into <span class="hl-string">'build/explodedWar'</span>
            include <span class="hl-string">'**/*.html'</span>
            include <span class="hl-string">'**/*.jsp'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>Secondly, the <code class="literal">copy()</code> method cannot honor task dependencies when a task is used as a copy source (i.e. as an argument to <code class="literal">from()</code>) because it&rsquo;s a method and not a task. As such, if you are using the <code class="literal">copy()</code> method as part of a task action, you must explicitly declare all inputs and outputs in order to get the correct behavior.</p><div class="example"><a name="copy"></a><p class="title"><b>Example&nbsp;135.&nbsp;Copying files using the copy() method with up-to-date check</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyMethodWithExplicitDependencies{
    <span class="hl-comment">// up-to-date check for inputs, plus add copyTask as dependency</span>
    inputs.files copyTask
    outputs.dir <span class="hl-string">'some-dir'</span> <span class="hl-comment">// up-to-date check for outputs</span>
    doLast{
        copy {
            <span class="hl-comment">// Copy the output of copyTask</span>
            from copyTask
            into <span class="hl-string">'some-dir'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>It is preferable to use the <code class="literal">Copy</code> task wherever possible, as it supports incremental building and task dependency inference without any extra effort on your part. The <code class="literal">copy()</code> method can be used to copy files as <span class="emphasis"><em>part</em></span> of a task&rsquo;s implementation. That is, the copy method is intended to be used by custom tasks (see <a class="xref" href="#custom_tasks"><i>Writing Custom Task Classes</i></a>) that need to copy files as part of their function. In such a scenario, the custom task should sufficiently declare the inputs/outputs relevant to the copy action.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:renaming_files" class="section-anchor" href="#sec:renaming_files"></a>Renaming files</h3></div></div></div><div class="example"><a name="renameOnCopy"></a><p class="title"><b>Example&nbsp;136.&nbsp;Renaming files as they are copied</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task rename(type: Copy) {
    from <span class="hl-string">'src/main/webapp'</span>
    into <span class="hl-string">'build/explodedWar'</span>
    <span class="hl-comment">// Use a closure to map the file name</span>
    rename { String fileName -&gt;
        fileName.replace(<span class="hl-string">'-staging-'</span>, <span class="hl-string">''</span>)
    }
    <span class="hl-comment">// Use a regular expression to map the file name</span>
    rename <span class="hl-string">'(.+)-staging-(.+)'</span>, <span class="hl-string">'$1$2'</span>
    rename(/(.+)-staging-(.+)/, <span class="hl-string">'$1$2'</span>)
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:filtering_files" class="section-anchor" href="#sec:filtering_files"></a>Filtering files</h3></div></div></div><div class="example"><a name="filterOnCopy"></a><p class="title"><b>Example&nbsp;137.&nbsp;Filtering files as they are copied</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.apache.tools.ant.filters.FixCrLfFilter
<span class="hl-keyword">import</span> org.apache.tools.ant.filters.ReplaceTokens

task filter(type: Copy) {
    from <span class="hl-string">'src/main/webapp'</span>
    into <span class="hl-string">'build/explodedWar'</span>
    <span class="hl-comment">// Substitute property tokens in files</span>
    expand(copyright: <span class="hl-string">'2009'</span>, version: <span class="hl-string">'2.3.1'</span>)
    expand(project.properties)
    <span class="hl-comment">// Use some of the filters provided by Ant</span>
    filter(FixCrLfFilter)
    filter(ReplaceTokens, tokens: [copyright: <span class="hl-string">'2009'</span>, version: <span class="hl-string">'2.3.1'</span>])
    <span class="hl-comment">// Use a closure to filter each line</span>
    filter { String line -&gt;
        <span class="hl-string">"[$line]"</span>
    }
    <span class="hl-comment">// Use a closure to remove lines</span>
    filter { String line -&gt;
        line.startsWith(<span class="hl-string">'-'</span>) ? null : line
    }
    filteringCharset = <span class="hl-string">'UTF-8'</span>
}
</pre></div></div><br class="example-break"><p>When you use the <code class="literal">ReplaceTokens</code> class with the &ldquo;filter&rdquo; operation, the result is a template engine that replaces tokens of the form &ldquo;@tokenName@&rdquo; (the Apache Ant-style token) with a set of given values. The &ldquo;expand&rdquo; operation does the same thing except it treats the source files as <a class="ulink" href="http://docs.groovy-lang.org/latest/html/api/groovy/text/SimpleTemplateEngine.html" target="_top">Groovy templates</a> in which tokens take the form &ldquo;${tokenName}&rdquo;. Be aware that you may need to escape parts of your source files when using this option, for example if it contains literal &ldquo;$&rdquo; or &ldquo;&lt;%&rdquo; strings.</p><p>It&rsquo;s a good practice to specify the charset when reading and writing the file, using the <code class="literal">filteringCharset</code> property. If not specified, the JVM default charset is used, which might not match with the actual charset of the files to filter, and might be different from one machine to another.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_the_copyspec_class" class="section-anchor" href="#sec:using_the_copyspec_class"></a>Using the <code class="literal">CopySpec</code> class</h3></div></div></div><p>Copy specs form a hierarchy. A copy spec inherits its destination path, include patterns, exclude patterns, copy actions, name mappings and filters.</p><div class="example"><a name="nestedCopySpecs"></a><p class="title"><b>Example&nbsp;138.&nbsp;Nested copy specs</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task nestedSpecs(type: Copy) {
    into <span class="hl-string">'build/explodedWar'</span>
    exclude <span class="hl-string">'**/*staging*'</span>
    from(<span class="hl-string">'src/dist'</span>) {
        include <span class="hl-string">'**/*.html'</span>
    }
    into(<span class="hl-string">'libs'</span>) {
        from configurations.runtime
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:sync_task" class="section-anchor" href="#sec:sync_task"></a>Using the <code class="literal">Sync</code> task</h2></div></div></div><p>The <a class="ulink" href="../dsl/org.gradle.api.tasks.Sync.html" target="_top"><code class="classname">Sync</code></a> task extends the <code class="literal">Copy</code> task. When it executes, it copies the source files into the destination directory, and then removes any files from the destination directory which it did not copy. This can be useful for doing things such as installing your application, creating an exploded copy of your archives, or maintaining a copy of the project&rsquo;s dependencies.</p><p>Here is an example which maintains a copy of the project&rsquo;s runtime dependencies in the <code class="literal">build/libs</code> directory.</p><div class="example"><a name="syncDependencies"></a><p class="title"><b>Example&nbsp;139.&nbsp;Using the Sync task to copy dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task libs(type: Sync) {
    from configurations.runtime
    into <span class="hl-string">"$buildDir/libs"</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:archives" class="section-anchor" href="#sec:archives"></a>Creating archives</h2></div></div></div><p>A project can have as many JAR archives as you want. You can also add WAR, ZIP and TAR archives to your project. Archives are created using the various archive tasks: <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.War.html" target="_top"><code class="classname">War</code></a>, and <a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a>. They all work the same way, so let&rsquo;s look at how you create a ZIP file.</p><div class="example"><a name="createZip"></a><p class="title"><b>Example&nbsp;140.&nbsp;Creating a ZIP archive</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>

task zip(type: Zip) {
    from <span class="hl-string">'src/dist'</span>
    into(<span class="hl-string">'libs'</span>) {
        from configurations.runtime
    }
}
</pre></div></div><br class="example-break"><div class="tip"><h3 class="title">Why are you using the Java plugin?</h3><p>The Java plugin adds a number of default values for the archive tasks. You can use the archive tasks without using the Java plugin, if you like. You will need to provide values for some additional properties.</p></div><p>The archive tasks all work exactly the same way as the <code class="literal">Copy</code> task, and implement the same <code class="literal">CopySpec</code> interface. As with the <code class="literal">Copy</code> task, you specify the input files using the <code class="literal">from()</code> method, and can optionally specify where they end up in the archive using the <code class="literal">into()</code> method. You can filter the contents of file, rename files, and all the other things you can do with a copy spec.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:archive_naming" class="section-anchor" href="#sec:archive_naming"></a>Archive naming</h3></div></div></div><p>The format of <code class="literal"><span class="emphasis"><em>projectName</em></span>-<span class="emphasis"><em>version</em></span>.<span class="emphasis"><em>type</em></span></code> is used for generated archive file names. For example:</p><div class="example"><a name="archiveNaming"></a><p class="title"><b>Example&nbsp;141.&nbsp;Creation of ZIP archive</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>

version = <span class="hl-number">1.0</span>

task myZip(type: Zip) {
    from <span class="hl-string">'somedir'</span>
}

println myZip.archiveName
println relativePath(myZip.destinationDir)
println relativePath(myZip.archivePath)
</pre><p>Output of <strong class="userinput"><code>gradle -q myZip</code></strong></p><pre class="screen">&gt; gradle -q myZip
zipProject-1.0.zip
build/distributions
build/distributions/zipProject-1.0.zip
</pre></div></div><br class="example-break"><p>This adds a <code class="literal">Zip</code> archive task with the name <code class="literal">myZip</code> which produces ZIP file <code class="literal">zipProject-1.0.zip</code>. It is important to distinguish between the name of the archive task and the name of the archive generated by the archive task. The default name for archives can be changed with the <code class="literal">archivesBaseName</code> project property. The name of the archive can also be changed at any time later on.</p><p>There are a number of properties which you can set on an archive task. These are listed below in <a class="xref" href="#archiveTasksNamingProperties" title="Table&nbsp;8.&nbsp;Archive tasks - naming properties">Table&nbsp;8</a>. You can, for example, change the name of the archive:</p><div class="example"><a name="zipWithCustomName"></a><p class="title"><b>Example&nbsp;142.&nbsp;Configuration of archive task - custom archive name</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
version = <span class="hl-number">1.0</span>

task myZip(type: Zip) {
    from <span class="hl-string">'somedir'</span>
    baseName = <span class="hl-string">'customName'</span>
}

println myZip.archiveName
</pre><p>Output of <strong class="userinput"><code>gradle -q myZip</code></strong></p><pre class="screen">&gt; gradle -q myZip
customName-1.0.zip
</pre></div></div><br class="example-break"><p>You can further customize the archive names:</p><div class="example"><a name="zipWithArguments"></a><p class="title"><b>Example&nbsp;143.&nbsp;Configuration of archive task - appendix &amp; classifier</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
archivesBaseName = <span class="hl-string">'gradle'</span>
version = <span class="hl-number">1.0</span>

task myZip(type: Zip) {
    appendix = <span class="hl-string">'wrapper'</span>
    classifier = <span class="hl-string">'src'</span>
    from <span class="hl-string">'somedir'</span>
}

println myZip.archiveName
</pre><p>Output of <strong class="userinput"><code>gradle -q myZip</code></strong></p><pre class="screen">&gt; gradle -q myZip
gradle-wrapper-1.0-src.zip
</pre></div></div><br class="example-break"><div class="table"><p class="title"><b>Table&nbsp;8.&nbsp;Archive tasks - naming properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="archiveTasksNamingProperties"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">archiveName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>baseName</em></span>-<span class="emphasis"><em>appendix</em></span>-<span class="emphasis"><em>version</em></span>-<span class="emphasis"><em>classifier</em></span>.<span class="emphasis"><em>extension</em></span></code></p>
<p>If any of these properties is empty the trailing <code class="literal">-</code> is not added to the name.</p></td>
<td><p>The base file name of the generated archive</p></td>
</tr><tr>
<td><p><code class="literal">archivePath</code></p></td>
<td><p><code class="literal">File</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>destinationDir</em></span>/<span class="emphasis"><em>archiveName</em></span></code></p></td>
<td><p>The absolute path of the generated archive.</p></td>
</tr><tr>
<td><p><code class="literal">destinationDir</code></p></td>
<td><p><code class="literal">File</code></p></td>
<td><p>Depends on the archive type. JARs and WARs go into <code class="literal"><span class="emphasis"><em>project.buildDir</em></span>/libraries</code>. ZIPs and TARs go into <code class="literal"><span class="emphasis"><em>project.buildDir</em></span>/distributions</code>.</p></td>
<td><p>The directory to generate the archive into</p></td>
</tr><tr>
<td><p><code class="literal">baseName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>project.name</em></span></code></p></td>
<td><p>The base name portion of the archive file name.</p></td>
</tr><tr>
<td><p><code class="literal">appendix</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">null</code></p></td>
<td><p>The appendix portion of the archive file name.</p></td>
</tr><tr>
<td><p><code class="literal">version</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>project.version</em></span></code></p></td>
<td><p>The version portion of the archive file name.</p></td>
</tr><tr>
<td><p><code class="literal">classifier</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">null</code></p></td>
<td><p>The classifier portion of the archive file name,</p></td>
</tr><tr>
<td><p><code class="literal">extension</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p>Depends on the archive type, and for TAR files, the compression type as well: <code class="literal">zip</code>, <code class="literal">jar</code>, <code class="literal">war</code>, <code class="literal">tar</code>, <code class="literal">tgz</code> or <code class="literal">tbz2</code>.</p></td>
<td><p>The extension of the archive file name.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:sharing_content_between_multiple_archives" class="section-anchor" href="#sec:sharing_content_between_multiple_archives"></a>Sharing content between multiple archives</h3></div></div></div><p>You can use the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:copySpec(org.gradle.api.Action)" target="_top"><code class="classname">Project.copySpec(org.gradle.api.Action)</code></a> method to share content between archives.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:reproducible_archives" class="section-anchor" href="#sec:reproducible_archives"></a>Reproducible archives</h3></div></div></div><p>Sometimes it can be desirable to recreate archives in a byte for byte way on different machines. You want to be sure that building an artifact from source code produces the same result, byte for byte, no matter when and where it is built. This is necessary for projects like <a class="ulink" href="https://reproducible-builds.org/" target="_top">reproducible-builds.org</a>.</p><p>Reproducing the same archive byte for byte poses some challenges since the order of the files in an archive is influenced by the underlying filesystem. Each time a zip, tar, jar, war or ear is built from source, the order of the files inside the archive may change. Files that only have a different timestamp also causes archives to be slightly different between builds. All <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html" target="_top"><code class="classname">AbstractArchiveTask</code></a> (e.g. Jar, Zip) tasks shipped with Gradle include <a class="link" href="#feature_lifecycle">incubating</a> support producing reproducible archives.</p><p>For example, to make a <code class="literal">Zip</code> task reproducible you need to set <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:reproducibleFileOrder" target="_top"><code class="classname">Zip.isReproducibleFileOrder()</code></a> to <code class="literal">true</code> and <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html#org.gradle.api.tasks.bundling.Zip:preserveFileTimestamps" target="_top"><code class="classname">Zip.isPreserveFileTimestamps()</code></a> to <code class="literal">false</code>. In order to make all archive tasks in your build reproducible, consider adding the following configuration to your build file:</p><div class="example"><a name="createZip"></a><p class="title"><b>Example&nbsp;144.&nbsp;Activating reproducible archives</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.withType(AbstractArchiveTask) {
    preserveFileTimestamps = false
    reproducibleFileOrder = true
}
</pre></div></div><br class="example-break"><p>Often you will want to publish an archive, so that it is usable from another project. This process is described in <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a></p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:properties_files" class="section-anchor" href="#sec:properties_files"></a>Properties files</h2></div></div></div><p>Properties files are used in many places during Java development. Gradle makes it easy to create properties files as a normal part of the build. You can use the <a class="ulink" href="../dsl/org.gradle.api.tasks.WriteProperties.html" target="_top"><code class="classname">WriteProperties</code></a> task to create properties files.</p><p>The <code class="literal">WriteProperties</code> task also fixes a well-known problem with <code class="literal">Properties.store()</code> that can reduce the usefulness of incremental builds (see <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>). The standard Java way to write a properties file produces a unique file every time, even when the same properties and values are used, because it includes a timestamp in the comments. Gradle&rsquo;s <code class="literal">WriteProperties</code> task generates exactly the same output byte-for-byte if none of the properties have changed. This is achieved by a few tweaks to how a properties file is generated:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>no timestamp comment is added to the output</p></li><li class="listitem"><p>the line separator is system independent, but can be configured explicitly (it defaults to <code class="literal">'\n'</code>)</p></li><li class="listitem"><p>the properties are sorted alphabetically</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="ant"></a>Using Ant from Gradle</h1></div></div></div><p>Gradle provides excellent integration with Ant. You can use individual Ant tasks or entire Ant builds in your Gradle builds. In fact, you will find that it&rsquo;s far easier and more powerful using Ant tasks in a Gradle build script, than it is to use Ant&rsquo;s XML format. You could even use Gradle simply as a powerful Ant task scripting tool.</p><p>Ant can be divided into two layers. The first layer is the Ant language. It provides the syntax for the <code class="literal">build.xml</code> file, the handling of the targets, special constructs like macrodefs, and so on. In other words, everything except the Ant tasks and types. Gradle understands this language, and allows you to import your Ant <code class="literal">build.xml</code> directly into a Gradle project. You can then use the targets of your Ant build as if they were Gradle tasks.</p><p>The second layer of Ant is its wealth of Ant tasks and types, like <code class="literal">javac</code>, <code class="literal">copy</code> or <code class="literal">jar</code>. For this layer Gradle provides integration simply by relying on Groovy, and the fantastic <code class="literal">AntBuilder</code>.</p><p>Finally, since build scripts are Groovy scripts, you can always execute an Ant build as an external process. Your build script may contain statements like: <code class="literal">"ant clean compile".execute()</code>.<sup>[<a href="#ftn.N12B20" name="N12B20" class="footnote">7</a>]</sup></p><p>You can use Gradle&rsquo;s Ant integration as a path for migrating your build from Ant to Gradle. For example, you could start by importing your existing Ant build. Then you could move your dependency declarations from the Ant script to your build file. Finally, you could move your tasks across to your build file, or replace them with some of Gradle&rsquo;s plugins. This process can be done in parts over time, and you can have a working Gradle build during the entire process.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_ant_tasks" class="section-anchor" href="#sec:using_ant_tasks"></a>Using Ant tasks and types in your build</h2></div></div></div><p>In your build script, a property called <code class="literal">ant</code> is provided by Gradle. This is a reference to an <a class="ulink" href="../javadoc/org/gradle/api/AntBuilder.html" target="_top"><code class="classname">AntBuilder</code></a> instance. This <code class="literal">AntBuilder</code> is used to access Ant tasks, types and properties from your build script. There is a very simple mapping from Ant&rsquo;s <code class="literal">build.xml</code> format to Groovy, which is explained below.</p><p>You execute an Ant task by calling a method on the <code class="literal">AntBuilder</code> instance. You use the task name as the method name. For example, you execute the Ant <code class="literal">echo</code> task by calling the <code class="literal">ant.echo()</code> method. The attributes of the Ant task are passed as Map parameters to the method. Below is an example of the <code class="literal">echo</code> task. Notice that we can also mix Groovy code and the Ant task markup. This can be extremely powerful.</p><div class="example"><a name="useAntTask"></a><p class="title"><b>Example&nbsp;145.&nbsp;Using an Ant task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        String greeting = <span class="hl-string">'hello from Ant'</span>
        ant.echo(message: greeting)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
[ant:echo] hello from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>You pass nested text to an Ant task by passing it as a parameter of the task method call. In this example, we pass the message for the <code class="literal">echo</code> task as nested text:</p><div class="example"><a name="taskWithNestedText"></a><p class="title"><b>Example&nbsp;146.&nbsp;Passing nested text to an Ant task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        ant.echo(<span class="hl-string">'hello from Ant'</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
[ant:echo] hello from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>You pass nested elements to an Ant task inside a closure. Nested elements are defined in the same way as tasks, by calling a method with the same name as the element we want to define.</p><div class="example"><a name="taskWithNestedElements"></a><p class="title"><b>Example&nbsp;147.&nbsp;Passing nested elements to an Ant task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task zip {
    doLast {
        ant.zip(destfile: <span class="hl-string">'archive.zip'</span>) {
            fileset(dir: <span class="hl-string">'src'</span>) {
                include(name: <span class="hl-string">'**.xml'</span>)
                exclude(name: <span class="hl-string">'**.java'</span>)
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>You can access Ant types in the same way that you access tasks, using the name of the type as the method name. The method call returns the Ant data type, which you can then use directly in your build script. In the following example, we create an Ant <code class="literal">path</code> object, then iterate over the contents of it.</p><div class="example"><a name="useAntType"></a><p class="title"><b>Example&nbsp;148.&nbsp;Using an Ant type</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task list {
    doLast {
        def path = ant.path {
            fileset(dir: <span class="hl-string">'libs'</span>, includes: <span class="hl-string">'*.jar'</span>)
        }
        path.list().each {
            println it
        }
    }
}
</pre></div></div><br class="example-break"><p>More information about <code class="literal">AntBuilder</code> can be found in 'Groovy in Action' 8.4 or at the <a class="ulink" href="http://groovy-lang.org/scripting-ant.html" target="_top">Groovy Wiki</a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_custom_ant_tasks" class="section-anchor" href="#sec:using_custom_ant_tasks"></a>Using custom Ant tasks in your build</h3></div></div></div><p>To make custom tasks available in your build, you can use the <code class="literal">taskdef</code> (usually easier) or <code class="literal">typedef</code> Ant task, just as you would in a <code class="literal">build.xml</code> file. You can then refer to the custom Ant task as you would a built-in Ant task.</p><div class="example"><a name="useExternalAntTask"></a><p class="title"><b>Example&nbsp;149.&nbsp;Using a custom Ant task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task check {
    doLast {
        ant.taskdef(resource: <span class="hl-string">'checkstyletask.properties'</span>) {
            classpath {
                fileset(dir: <span class="hl-string">'libs'</span>, includes: <span class="hl-string">'*.jar'</span>)
            }
        }
        ant.checkstyle(config: <span class="hl-string">'checkstyle.xml'</span>) {
            fileset(dir: <span class="hl-string">'src'</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>You can use Gradle&rsquo;s dependency management to assemble the classpath to use for the custom tasks. To do this, you need to define a custom configuration for the classpath, then add some dependencies to the configuration. This is described in more detail in <a class="xref" href="#sec:declaring_dependencies">the section called &ldquo;Declaring dependencies&rdquo;</a>.</p><div class="example"><a name="useExternalAntTaskWithConfig"></a><p class="title"><b>Example&nbsp;150.&nbsp;Declaring the classpath for a custom Ant task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    pmd
}

dependencies {
    pmd group: <span class="hl-string">'pmd'</span>, name: <span class="hl-string">'pmd'</span>, version: <span class="hl-string">'4.2.5'</span>
}
</pre></div></div><br class="example-break"><p>To use the classpath configuration, use the <code class="literal">asPath</code> property of the custom configuration.</p><div class="example"><a name="useExternalAntTaskWithConfig"></a><p class="title"><b>Example&nbsp;151.&nbsp;Using a custom Ant task and dependency management together</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task check {
    doLast {
        ant.taskdef(name: <span class="hl-string">'pmd'</span>,
                    classname: <span class="hl-string">'net.sourceforge.pmd.ant.PMDTask'</span>,
                    classpath: configurations.pmd.asPath)
        ant.pmd(shortFilenames: <span class="hl-string">'true'</span>,
                failonruleviolation: <span class="hl-string">'true'</span>,
                rulesetfiles: file(<span class="hl-string">'pmd-rules.xml'</span>).toURI().toString()) {
            formatter(type: <span class="hl-string">'text'</span>, toConsole: <span class="hl-string">'true'</span>)
            fileset(dir: <span class="hl-string">'src'</span>)
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:import_ant_build" class="section-anchor" href="#sec:import_ant_build"></a>Importing an Ant build</h2></div></div></div><p>You can use the <code class="literal">ant.importBuild()</code> method to import an Ant build into your Gradle project. When you import an Ant build, each Ant target is treated as a Gradle task. This means you can manipulate and execute the Ant targets in exactly the same way as Gradle tasks.</p><div class="example"><a name="antHello"></a><p class="title"><b>Example&nbsp;152.&nbsp;Importing an Ant build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.importBuild <span class="hl-string">'build.xml'</span>
</pre><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;project&gt;</span>
    <span class="hl-tag">&lt;target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hello"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;echo&gt;</span>Hello, from Ant<span class="hl-tag">&lt;/echo&gt;</span>
    <span class="hl-tag">&lt;/target&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>You can add a task which depends on an Ant target:</p><div class="example"><a name="dependsOnAntTarget"></a><p class="title"><b>Example&nbsp;153.&nbsp;Task that depends on Ant target</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.importBuild <span class="hl-string">'build.xml'</span>

task intro(dependsOn: hello) {
    doLast {
        println <span class="hl-string">'Hello, from Gradle'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle intro</code></strong></p><pre class="screen">&gt; gradle intro
:hello
[ant:echo] Hello, from Ant
:intro
Hello, from Gradle

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>Or, you can add behaviour to an Ant target:</p><div class="example"><a name="addBehaviourToAntTarget"></a><p class="title"><b>Example&nbsp;154.&nbsp;Adding behaviour to an Ant target</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.importBuild <span class="hl-string">'build.xml'</span>

hello {
    doLast {
        println <span class="hl-string">'Hello, from Gradle'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
[ant:echo] Hello, from Ant
Hello, from Gradle

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>It is also possible for an Ant target to depend on a Gradle task:</p><div class="example"><a name="dependsOnTask"></a><p class="title"><b>Example&nbsp;155.&nbsp;Ant target that depends on Gradle task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.importBuild <span class="hl-string">'build.xml'</span>

task intro {
    doLast {
        println <span class="hl-string">'Hello, from Gradle'</span>
    }
}
</pre><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;project&gt;</span>
    <span class="hl-tag">&lt;target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hello"</span> <span class="hl-attribute">depends</span>=<span class="hl-value">"intro"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;echo&gt;</span>Hello, from Ant<span class="hl-tag">&lt;/echo&gt;</span>
    <span class="hl-tag">&lt;/target&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:intro
Hello, from Gradle
:hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>Sometimes it may be necessary to &ldquo;rename&rdquo; the task generated for an Ant target to avoid a naming collision with existing Gradle tasks. To do this, use the <a class="ulink" href="../javadoc/org/gradle/api/AntBuilder.html#importBuild-java.lang.Object, org.gradle.api.Transformer-" target="_top"><code class="classname">AntBuilder.importBuild(java.lang.Object, org.gradle.api.Transformer)</code></a> method.</p><div class="example"><a name="renameAntDelegate"></a><p class="title"><b>Example&nbsp;156.&nbsp;Renaming imported Ant targets</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.importBuild(<span class="hl-string">'build.xml'</span>) { antTargetName -&gt;
    <span class="hl-string">'a-'</span> + antTargetName
}
</pre><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;project&gt;</span>
    <span class="hl-tag">&lt;target</span> <span class="hl-attribute">name</span>=<span class="hl-value">"hello"</span><span class="hl-tag">&gt;</span>
        <span class="hl-tag">&lt;echo&gt;</span>Hello, from Ant<span class="hl-tag">&lt;/echo&gt;</span>
    <span class="hl-tag">&lt;/target&gt;</span>
<span class="hl-tag">&lt;/project&gt;</span>
</pre><p>Output of <strong class="userinput"><code>gradle a-hello</code></strong></p><pre class="screen">&gt; gradle a-hello
:a-hello
[ant:echo] Hello, from Ant

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Note that while the second argument to this method should be a <a class="ulink" href="../javadoc/org/gradle/api/Transformer.html" target="_top"><code class="classname">Transformer</code></a>, when programming in Groovy we can simply use a closure instead of an anonymous inner class (or similar) due to <a class="ulink" href="http://mrhaki.blogspot.ie/2013/11/groovy-goodness-implicit-closure.html" target="_top">Groovy&rsquo;s support for automatically coercing closures to single-abstract-method types</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ant_properties" class="section-anchor" href="#sec:ant_properties"></a>Ant properties and references</h2></div></div></div><p>There are several ways to set an Ant property, so that the property can be used by Ant tasks. You can set the property directly on the <code class="literal">AntBuilder</code> instance. The Ant properties are also available as a Map which you can change. You can also use the Ant <code class="literal">property</code> task. Below are some examples of how to do this.</p><div class="example"><a name="antProperties"></a><p class="title"><b>Example&nbsp;157.&nbsp;Setting an Ant property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.buildDir = buildDir
ant.properties.buildDir = buildDir
ant.properties[<span class="hl-string">'buildDir'</span>] = buildDir
ant.property(name: <span class="hl-string">'buildDir'</span>, location: buildDir)
</pre><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;echo&gt;</span>buildDir = ${buildDir}<span class="hl-tag">&lt;/echo&gt;</span>
</pre></div></div><br class="example-break"><p>Many Ant tasks set properties when they execute. There are several ways to get the value of these properties. You can get the property directly from the <code class="literal">AntBuilder</code> instance. The Ant properties are also available as a Map. Below are some examples.</p><div class="example"><a name="antProperties"></a><p class="title"><b>Example&nbsp;158.&nbsp;Getting an Ant property</b></p><div class="example-contents"><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"antProp"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"a property defined in an Ant build"</span><span class="hl-tag">/&gt;</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">println ant.antProp
println ant.properties.antProp
println ant.properties[<span class="hl-string">'antProp'</span>]
</pre></div></div><br class="example-break"><p>There are several ways to set an Ant reference:</p><div class="example"><a name="antProperties"></a><p class="title"><b>Example&nbsp;159.&nbsp;Setting an Ant reference</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.path(id: <span class="hl-string">'classpath'</span>, location: <span class="hl-string">'libs'</span>)
ant.references.classpath = ant.path(location: <span class="hl-string">'libs'</span>)
ant.references[<span class="hl-string">'classpath'</span>] = ant.path(location: <span class="hl-string">'libs'</span>)
</pre><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;path</span> <span class="hl-attribute">refid</span>=<span class="hl-value">"classpath"</span><span class="hl-tag">/&gt;</span>
</pre></div></div><br class="example-break"><p>There are several ways to get an Ant reference:</p><div class="example"><a name="antProperties"></a><p class="title"><b>Example&nbsp;160.&nbsp;Getting an Ant reference</b></p><div class="example-contents"><p><code class="filename">build.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;path</span> <span class="hl-attribute">id</span>=<span class="hl-value">"antPath"</span> <span class="hl-attribute">location</span>=<span class="hl-value">"libs"</span><span class="hl-tag">/&gt;</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">println ant.references.antPath
println ant.references[<span class="hl-string">'antPath'</span>]
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ant_logging" class="section-anchor" href="#sec:ant_logging"></a>Ant logging</h2></div></div></div><p>Gradle maps Ant message priorities to Gradle log levels so that messages logged from Ant appear in the Gradle output. By default, these are mapped as follows:</p><div class="table"><p class="title"><b>Table&nbsp;9.&nbsp;Ant message priority mapping</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N12CA4"><thead><tr>
<td>Ant Message Priority</td>
<td>Gradle Log Level</td>
</tr></thead><tbody><tr>
<td><p><span class="emphasis"><em>VERBOSE</em></span></p></td>
<td><p><code class="literal">DEBUG</code></p></td>
</tr><tr>
<td><p><span class="emphasis"><em>DEBUG</em></span></p></td>
<td><p><code class="literal">DEBUG</code></p></td>
</tr><tr>
<td><p><span class="emphasis"><em>INFO</em></span></p></td>
<td><p><code class="literal">INFO</code></p></td>
</tr><tr>
<td><p><span class="emphasis"><em>WARN</em></span></p></td>
<td><p><code class="literal">WARN</code></p></td>
</tr><tr>
<td><p><span class="emphasis"><em>ERROR</em></span></p></td>
<td><p><code class="literal">ERROR</code></p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:fine_tuning_ant_logging" class="section-anchor" href="#sec:fine_tuning_ant_logging"></a>Fine tuning Ant logging</h3></div></div></div><p>The default mapping of Ant message priority to Gradle log level can sometimes be problematic. For example, there is no message priority that maps directly to the <code class="literal">LIFECYCLE</code> log level, which is the default for Gradle. Many Ant tasks log messages at the <span class="emphasis"><em>INFO</em></span> priority, which means to expose those messages from Gradle, a build would have to be run with the log level set to <code class="literal">INFO</code>, potentially logging much more output than is desired.</p><p>Conversely, if an Ant task logs messages at too high of a level, to suppress those messages would require the build to be run at a higher log level, such as <code class="literal">QUIET</code>. However, this could result in other, desirable output being suppressed.</p><p>To help with this, Gradle allows the user to fine tune the Ant logging and control the mapping of message priority to Gradle log level. This is done by setting the priority that should map to the default Gradle <code class="literal">LIFECYCLE</code> log level using the <a class="ulink" href="../javadoc/org/gradle/api/AntBuilder.html#setLifecycleLogLevel-java.lang.String-" target="_top"><code class="classname">AntBuilder.setLifecycleLogLevel(java.lang.String)</code></a> method. When this value is set, any Ant message logged at the configured priority or above will be logged at least at <code class="literal">LIFECYCLE</code>. Any Ant message logged below this priority will be logged at most at <code class="literal">INFO</code>.</p><p>For example, the following changes the mapping such that Ant <span class="emphasis"><em>INFO</em></span> priority messages are exposed at the <code class="literal">LIFECYCLE</code> log level.</p><div class="example"><a name="antLogging"></a><p class="title"><b>Example&nbsp;161.&nbsp;Fine tuning Ant logging</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ant.lifecycleLogLevel = <span class="hl-string">"INFO"</span>

task hello {
    doLast {
        ant.echo(level: <span class="hl-string">"info"</span>, message: <span class="hl-string">"hello from info priority!"</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
[ant:echo] hello from info priority!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>On the other hand, if the <code class="literal">lifecycleLogLevel</code> was set to <span class="emphasis"><em>ERROR</em></span>, Ant messages logged at the <span class="emphasis"><em>WARN</em></span> priority would no longer be logged at the <code class="literal">WARN</code> log level. They would now be logged at the <code class="literal">INFO</code> level and would be suppressed by default.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ant_api" class="section-anchor" href="#sec:ant_api"></a>API</h2></div></div></div><p>The Ant integration is provided by <a class="ulink" href="../javadoc/org/gradle/api/AntBuilder.html" target="_top"><code class="classname">AntBuilder</code></a>.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N12B20" name="ftn.N12B20" class="para">7</a>] </sup>In Groovy you can execute Strings. To learn more about executing external processes with Groovy have a look in 'Groovy in Action' 9.3.2 or at the Groovy wiki</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_lifecycle"></a>Build Lifecycle</h1></div></div></div><p>We said earlier that the core of Gradle is a language for dependency based programming. In Gradle terms this means that you can define tasks and dependencies between tasks. Gradle guarantees that these tasks are executed in the order of their dependencies, and that each task is executed only once. These tasks form a <a class="ulink" href="http://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_top">Directed Acyclic Graph</a>. There are build tools that build up such a dependency graph as they execute their tasks. Gradle builds the complete dependency graph <span class="emphasis"><em>before</em></span> any task is executed. This lies at the heart of Gradle and makes many things possible which would not be possible otherwise.</p><p>Your build scripts configure this dependency graph. Therefore they are strictly speaking <span class="emphasis"><em>build configuration scripts</em></span>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_phases" class="section-anchor" href="#sec:build_phases"></a>Build phases</h2></div></div></div><p>A Gradle build has three distinct phases.</p><div class="variablelist"><dl><dt><span class="term">Initialization</span></dt><dd><p>Gradle supports single and multi-project builds. During the initialization phase, Gradle determines which projects are going to take part in the build, and creates a <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> instance for each of these projects.</p></dd><dt><span class="term">Configuration</span></dt><dd><p>During this phase the project objects are configured. The build scripts of <span class="emphasis"><em>all</em></span> projects which are part of the build are executed. Gradle 1.4 introduced an <a class="link" href="#feature_lifecycle">incubating</a> opt-in feature called <span class="emphasis"><em>configuration on demand</em></span>. In this mode, Gradle configures only relevant projects (see <a class="xref" href="#sec:configuration_on_demand">the section called &ldquo;Configuration on demand&rdquo;</a>).</p></dd><dt><span class="term">Execution</span></dt><dd><p>Gradle determines the subset of the tasks, created and configured during the configuration phase, to be executed. The subset is determined by the task name arguments passed to the <code class="literal">gradle</code> command and the current directory. Gradle then executes each of the selected tasks.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:settings_file" class="section-anchor" href="#sec:settings_file"></a>Settings file</h2></div></div></div><p>Beside the build script files, Gradle defines a settings file. The settings file is determined by Gradle via a naming convention. The default name for this file is <code class="literal">settings.gradle</code>. Later in this chapter we explain how Gradle looks for a settings file.</p><p>The settings file is executed during the initialization phase. A multiproject build must have a <code class="literal">settings.gradle</code> file in the root project of the multiproject hierarchy. It is required because the settings file defines which projects are taking part in the multi-project build (see <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>). For a single-project build, a settings file is optional. Besides defining the included projects, you might need it to add libraries to your build script classpath (see <a class="xref" href="#organizing_build_logic"><i>Organizing Build Logic</i></a>). Let&rsquo;s first do some introspection with a single project build:</p><div class="example"><a name="buildlifecycle"></a><p class="title"><b>Example&nbsp;162.&nbsp;Single project build</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">println <span class="hl-string">'This is executed during the initialization phase.'</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">println <span class="hl-string">'This is executed during the configuration phase.'</span>

task configured {
    println <span class="hl-string">'This is also executed during the configuration phase.'</span>
}

task test {
    doLast {
        println <span class="hl-string">'This is executed during the execution phase.'</span>
    }
}

task testBoth {
    doFirst {
      println <span class="hl-string">'This is executed first during the execution phase.'</span>
    }
    doLast {
      println <span class="hl-string">'This is executed last during the execution phase.'</span>
    }
    println <span class="hl-string">'This is executed during the configuration phase as well.'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle test testBoth</code></strong></p><pre class="screen">&gt; gradle test testBoth
This is executed during the initialization phase.
This is executed during the configuration phase.
This is also executed during the configuration phase.
This is executed during the configuration phase as well.
:test
This is executed during the execution phase.
:testBoth
This is executed first during the execution phase.
This is executed last during the execution phase.

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>For a build script, the property access and method calls are delegated to a project object. Similarly property access and method calls within the settings file is delegated to a settings object. Look at the <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html" target="_top"><code class="classname">Settings</code></a> class in the API documentation for more information.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:multi_project_builds" class="section-anchor" href="#sec:multi_project_builds"></a>Multi-project builds</h2></div></div></div><p>A multi-project build is a build where you build more than one project during a single execution of Gradle. You have to declare the projects taking part in the multiproject build in the settings file. There is much more to say about multi-project builds in the chapter dedicated to this topic (see <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>).</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:project_locations" class="section-anchor" href="#sub:project_locations"></a>Project locations</h3></div></div></div><p>Multi-project builds are always represented by a tree with a single root. Each element in the tree represents a project. A project has a path which denotes the position of the project in the multi-project build tree. In most cases the project path is consistent with the physical location of the project in the file system. However, this behavior is configurable. The project tree is created in the <code class="literal">settings.gradle</code> file. By default it is assumed that the location of the settings file is also the location of the root project. But you can redefine the location of the root project in the settings file.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:building_the_tree" class="section-anchor" href="#sub:building_the_tree"></a>Building the tree</h3></div></div></div><p>In the settings file you can use a set of methods to build the project tree. Hierarchical and flat physical layouts get special support.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:hierarchical_layouts" class="section-anchor" href="#sec:hierarchical_layouts"></a>Hierarchical layouts</h4></div></div></div><div class="example"><a name="standardLayouts"></a><p class="title"><b>Example&nbsp;163.&nbsp;Hierarchical layout</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'project1'</span>, <span class="hl-string">'project2:child'</span>, <span class="hl-string">'project3:child1'</span>
</pre></div></div><br class="example-break"><p>The <code class="literal">include</code> method takes project paths as arguments. The project path is assumed to be equal to the relative physical file system path. For example, a path 'services:api' is mapped by default to a folder 'services/api' (relative from the project root). You only need to specify the leaves of the tree. This means that the inclusion of the path 'services:hotels:api' will result in creating 3 projects: 'services', 'services:hotels' and 'services:hotels:api'.
More examples of how to work with the project path can be found in the DSL documentation of <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])" target="_top"><code class="classname">Settings.include(java.lang.String[])</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:flat_layouts" class="section-anchor" href="#sec:flat_layouts"></a>Flat layouts</h4></div></div></div><div class="example"><a name="standardLayouts"></a><p class="title"><b>Example&nbsp;164.&nbsp;Flat layout</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">includeFlat <span class="hl-string">'project3'</span>, <span class="hl-string">'project4'</span>
</pre></div></div><br class="example-break"><p>The <code class="literal">includeFlat</code> method takes directory names as an argument. These directories need to exist as siblings of the root project directory. The location of these directories are considered as child projects of the root project in the multi-project tree.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:modifying_element_of_the_project_tree" class="section-anchor" href="#sub:modifying_element_of_the_project_tree"></a>Modifying elements of the project tree</h3></div></div></div><p>The multi-project tree created in the settings file is made up of so called <span class="emphasis"><em>project descriptors</em></span>. You can modify these descriptors in the settings file at any time. To access a descriptor you can do:</p><div class="example"><a name="customLayout"></a><p class="title"><b>Example&nbsp;165.&nbsp;Lookup of elements of the project tree</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">println rootProject.name
println project(<span class="hl-string">':projectA'</span>).name
</pre></div></div><br class="example-break"><p>Using this descriptor you can change the name, project directory and build file of a project.</p><div class="example"><a name="customLayout"></a><p class="title"><b>Example&nbsp;166.&nbsp;Modification of elements of the project tree</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">rootProject.name = <span class="hl-string">'main'</span>
project(<span class="hl-string">':projectA'</span>).projectDir = <span class="hl-keyword">new</span> File(settingsDir, <span class="hl-string">'../my-project-a'</span>)
project(<span class="hl-string">':projectA'</span>).buildFileName = <span class="hl-string">'projectA.gradle'</span>
</pre></div></div><br class="example-break"><p>Look at the <a class="ulink" href="../javadoc/org/gradle/api/initialization/ProjectDescriptor.html" target="_top"><code class="classname">ProjectDescriptor</code></a> class in the API documentation for more information.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:initialization" class="section-anchor" href="#sec:initialization"></a>Initialization</h2></div></div></div><p>How does Gradle know whether to do a single or multiproject build? If you trigger a multiproject build from a directory with a settings file, things are easy. But Gradle also allows you to execute the build from within any subproject taking part in the build.<sup>[<a href="#ftn.N12E29" name="N12E29" class="footnote">8</a>]</sup> If you execute Gradle from within a project with no <code class="literal">settings.gradle</code> file, Gradle looks for a <code class="literal">settings.gradle</code> file in the following way:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>It looks in a directory called <code class="literal">master</code> which has the same nesting level as the current dir.</p></li><li class="listitem"><p>If not found yet, it searches parent directories.</p></li><li class="listitem"><p>If not found yet, the build is executed as a single project build.</p></li><li class="listitem"><p>If a <code class="literal">settings.gradle</code> file is found, Gradle checks if the current project is part of the multiproject hierarchy defined in the found <code class="literal">settings.gradle</code> file. If not, the build is executed as a single project build. Otherwise a multiproject build is executed.</p></li></ul></div><p>What is the purpose of this behavior? Gradle needs to determine whether the project you are in is a subproject of a multiproject build or not. Of course, if it is a subproject, only the subproject and its dependent projects are built, but Gradle needs to create the build configuration for the whole multiproject build (see <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>). You can use the <code class="literal">-u</code> command line option to tell Gradle not to look in the parent hierarchy for a <code class="literal">settings.gradle</code> file. The current project is then always built as a single project build. If the current project contains a <code class="literal">settings.gradle</code> file, the <code class="literal">-u</code> option has no meaning. Such a build is always executed as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a single project build, if the <code class="literal">settings.gradle</code> file does not define a multiproject hierarchy</p></li><li class="listitem"><p>a multiproject build, if the <code class="literal">settings.gradle</code> file does define a multiproject hierarchy.</p></li></ul></div><p>The automatic search for a <code class="literal">settings.gradle</code> file only works for multi-project builds with a physical hierarchical or flat layout. For a flat layout you must additionally follow the naming convention described above (&ldquo;<code class="literal">master</code>&rdquo;). Gradle supports arbitrary physical layouts for a multiproject build, but for such arbitrary layouts you need to execute the build from the directory where the settings file is located. For information on how to run partial builds from the root see <a class="xref" href="#sec:running_partial_build_from_the_root">the section called &ldquo;Running tasks by their absolute path&rdquo;</a>.</p><p>Gradle creates a Project object for every project taking part in the build. For a multi-project build these are the projects specified in the Settings object (plus the root project). Each project object has by default a name equal to the name of its top level directory, and every project except the root project has a parent project. Any project may have child projects.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuration_and_execution_of_a_single_project_build" class="section-anchor" href="#sec:configuration_and_execution_of_a_single_project_build"></a>Configuration and execution of a single project build</h2></div></div></div><p>For a single project build, the workflow of the <span class="emphasis"><em>after initialization</em></span> phases are pretty simple. The build script is executed against the project object that was created during the initialization phase. Then Gradle looks for tasks with names equal to those passed as command line arguments. If these task names exist, they are executed as a separate build in the order you have passed them. The configuration and execution for multi-project builds is discussed in <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="build_lifecycle_events" class="section-anchor" href="#build_lifecycle_events"></a>Responding to the lifecycle in the build script</h2></div></div></div><p>Your build script can receive notifications as the build progresses through its lifecycle. These notifications generally take two forms: You can either implement a particular listener interface, or you can provide a closure to execute when the notification is fired. The examples below use closures. For details on how to use the listener interfaces, refer to the API documentation.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:project_evaluation" class="section-anchor" href="#sec:project_evaluation"></a>Project evaluation</h3></div></div></div><p>You can receive a notification immediately before and after a project is evaluated. This can be used to do things like performing additional configuration once all the definitions in a build script have been applied, or for some custom logging or profiling.</p><p>Below is an example which adds a <code class="literal">test</code> task to each project which has a <code class="literal">hasTests</code> property value of true.</p><div class="example"><a name="projectEvaluateEvents"></a><p class="title"><b>Example&nbsp;167.&nbsp;Adding of test task to each project which has certain property set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    afterEvaluate { project -&gt;
        <span class="hl-keyword">if</span> (project.hasTests) {
            println <span class="hl-string">"Adding test task to $project"</span>
            project.task(<span class="hl-string">'test'</span>) {
                doLast {
                    println <span class="hl-string">"Running tests for $project"</span>
                }
            }
        }
    }
}
</pre><p><code class="filename">projectA.gradle</code></p><pre class="programlisting">hasTests = true
</pre><p>Output of <strong class="userinput"><code>gradle -q test</code></strong></p><pre class="screen">&gt; gradle -q test
Adding test task to project ':projectA'
Running tests for project ':projectA'</pre></div></div><br class="example-break"><p>This example uses method <code class="literal">Project.afterEvaluate()</code> to add a closure which is executed after the project is evaluated.</p><p>It is also possible to receive notifications when any project is evaluated. This example performs some custom logging of project evaluation. Notice that the <code class="literal">afterProject</code> notification is received regardless of whether the project evaluates successfully or fails with an exception.</p><div class="example"><a name="buildProjectEvaluateEvents"></a><p class="title"><b>Example&nbsp;168.&nbsp;Notifications</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">gradle.afterProject {project, projectState -&gt;
    <span class="hl-keyword">if</span> (projectState.failure) {
        println <span class="hl-string">"Evaluation of $project FAILED"</span>
    } <span class="hl-keyword">else</span> {
        println <span class="hl-string">"Evaluation of $project succeeded"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q test</code></strong></p><pre class="screen">&gt; gradle -q test
Evaluation of root project 'buildProjectEvaluateEvents' succeeded
Evaluation of project ':projectA' succeeded
Evaluation of project ':projectB' FAILED
</pre></div></div><br class="example-break"><p>You can also add a <a class="ulink" href="../javadoc/org/gradle/api/ProjectEvaluationListener.html" target="_top"><code class="classname">ProjectEvaluationListener</code></a> to the <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html" target="_top"><code class="classname">Gradle</code></a> to receive these events.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_creation" class="section-anchor" href="#sec:task_creation"></a>Task creation</h3></div></div></div><p>You can receive a notification immediately after a task is added to a project. This can be used to set some default values or add behaviour before the task is made available in the build file.</p><p>The following example sets the <code class="literal">srcDir</code> property of each task as it is created.</p><div class="example"><a name="taskCreationEvents"></a><p class="title"><b>Example&nbsp;169.&nbsp;Setting of certain property to all tasks</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.whenTaskAdded { task -&gt;
    task.ext.srcDir = <span class="hl-string">'src/main/java'</span>
}

task a

println <span class="hl-string">"source dir is $a.srcDir"</span>
</pre><p>Output of <strong class="userinput"><code>gradle -q a</code></strong></p><pre class="screen">&gt; gradle -q a
source dir is src/main/java</pre></div></div><br class="example-break"><p>You can also add an <a class="ulink" href="../javadoc/org/gradle/api/Action.html" target="_top"><code class="classname">Action</code></a> to a <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> to receive these events.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_execution_graph_ready" class="section-anchor" href="#sec:task_execution_graph_ready"></a>Task execution graph ready</h3></div></div></div><p>You can receive a notification immediately after the task execution graph has been populated. We have seen this already in <a class="xref" href="#configure-by-dag">the section called &ldquo;Configure by DAG&rdquo;</a>.</p><p>You can also add a <a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionGraphListener.html" target="_top"><code class="classname">TaskExecutionGraphListener</code></a> to the <a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionGraph.html" target="_top"><code class="classname">TaskExecutionGraph</code></a> to receive these events.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:task_execution" class="section-anchor" href="#sec:task_execution"></a>Task execution</h3></div></div></div><p>You can receive a notification immediately before and after any task is executed.</p><p>The following example logs the start and end of each task execution. Notice that the <code class="literal">afterTask</code> notification is received regardless of whether the task completes successfully or fails with an exception.</p><div class="example"><a name="taskExecutionEvents"></a><p class="title"><b>Example&nbsp;170.&nbsp;Logging of start and end of each task execution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task ok

task broken(dependsOn: ok) {
    doLast {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> RuntimeException(<span class="hl-string">'broken'</span>)
    }
}

gradle.taskGraph.beforeTask { Task task -&gt;
    println <span class="hl-string">"executing $task ..."</span>
}

gradle.taskGraph.afterTask { Task task, TaskState state -&gt;
    <span class="hl-keyword">if</span> (state.failure) {
        println <span class="hl-string">"FAILED"</span>
    }
    <span class="hl-keyword">else</span> {
        println <span class="hl-string">"done"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q broken</code></strong></p><pre class="screen">&gt; gradle -q broken
executing task ':ok' ...
done
executing task ':broken' ...
FAILED</pre></div></div><br class="example-break"><p>You can also use a <a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionListener.html" target="_top"><code class="classname">TaskExecutionListener</code></a> to the <a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionGraph.html" target="_top"><code class="classname">TaskExecutionGraph</code></a> to receive these events.</p></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N12E29" name="ftn.N12E29" class="para">8</a>] </sup>Gradle supports partial multiproject builds (see <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>).</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="logging"></a>Logging</h1></div></div></div><p>The log is the main 'UI' of a build tool. If it is too verbose, real warnings and problems are easily hidden by this. On the other hand you need relevant information for figuring out if things have gone wrong. Gradle defines 6 log levels, as shown in <a class="xref" href="#logLevels" title="Table&nbsp;10.&nbsp;Log levels">Table&nbsp;10</a>. There are two Gradle-specific log levels, in addition to the ones you might normally see. Those levels are <span class="emphasis"><em>QUIET</em></span> and <span class="emphasis"><em>LIFECYCLE</em></span>. The latter is the default, and is used to report build progress.</p><div class="table"><p class="title"><b>Table&nbsp;10.&nbsp;Log levels</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="logLevels"><thead><tr>
<td>Level</td>
<td>Used for</td>
</tr></thead><tbody><tr>
<td><p>ERROR</p></td>
<td><p>Error messages</p></td>
</tr><tr>
<td><p>QUIET</p></td>
<td><p>Important information messages</p></td>
</tr><tr>
<td><p>WARNING</p></td>
<td><p>Warning messages</p></td>
</tr><tr>
<td><p>LIFECYCLE</p></td>
<td><p>Progress information messages</p></td>
</tr><tr>
<td><p>INFO</p></td>
<td><p>Information messages</p></td>
</tr><tr>
<td><p>DEBUG</p></td>
<td><p>Debug messages</p></td>
</tr></tbody></table></div></div><div class="note"><p>The rich components of the console (build status and work in progress area) are displayed regardless of the log level used. Before Gradle 4.0 those rich components were only displayed at log level <code class="literal">LIFECYCLE</code> or below.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:choosing_a_log_level" class="section-anchor" href="#sec:choosing_a_log_level"></a>Choosing a log level</h2></div></div></div><p>You can use the command line switches shown in <a class="xref" href="#logLevelCommandLineOptions" title="Table&nbsp;11.&nbsp;Log level command-line options">Table&nbsp;11</a> to choose different log levels. You can also configure the log level using gradle.properties, see <a class="xref" href="#sec:gradle_configuration_properties">the section called &ldquo;Gradle properties&rdquo;</a>. In <a class="xref" href="#stacktraces" title="Table&nbsp;12.&nbsp;Stacktrace command-line options">Table&nbsp;12</a> you find the command line switches which affect stacktrace logging.</p><div class="table"><p class="title"><b>Table&nbsp;11.&nbsp;Log level command-line options</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="logLevelCommandLineOptions"><thead><tr>
<td>Option</td>
<td>Outputs Log Levels</td>
</tr></thead><tbody><tr>
<td><p>no logging options</p></td>
<td><p>LIFECYCLE and higher</p></td>
</tr><tr>
<td><p><code class="literal">-q</code> or <code class="literal">--quiet</code></p></td>
<td><p>QUIET and higher</p></td>
</tr><tr>
<td><p><code class="literal">-w</code> or <code class="literal">--warn</code></p></td>
<td><p>WARN and higher</p></td>
</tr><tr>
<td><p><code class="literal">-i</code> or <code class="literal">--info</code></p></td>
<td><p>INFO and higher</p></td>
</tr><tr>
<td><p><code class="literal">-d</code> or <code class="literal">--debug</code></p></td>
<td><p>DEBUG and higher (that is, all log messages)</p></td>
</tr></tbody></table></div></div><div class="table"><p class="title"><b>Table&nbsp;12.&nbsp;Stacktrace command-line options</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="stacktraces"><thead><tr>
<td>Option</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p>No stacktrace options</p></td>
<td><p>No stacktraces are printed to the console in case of a build error (e.g. a compile error). Only in case of internal exceptions will stacktraces be printed. If the <code class="literal">DEBUG</code> log level is chosen, truncated stacktraces are always printed.</p></td>
</tr><tr>
<td><p><code class="literal">-s</code> or <code class="literal">--stacktrace</code></p></td>
<td><p>Truncated stacktraces are printed. We recommend this over full stacktraces. Groovy full stacktraces are extremely verbose (Due to the underlying dynamic invocation mechanisms. Yet they usually do not contain relevant information for what has gone wrong in <span class="emphasis"><em>your</em></span> code.) This option renders stacktraces for deprecation warnings.</p></td>
</tr><tr>
<td><p><code class="literal">-S</code> or <code class="literal">--full-stacktrace</code></p></td>
<td><p>The full stacktraces are printed out. This option renders stacktraces for deprecation warnings.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:sending_your_own_log_messages" class="section-anchor" href="#sec:sending_your_own_log_messages"></a>Writing your own log messages</h2></div></div></div><p>A simple option for logging in your build file is to write messages to standard output. Gradle redirects anything written to standard output to its logging system at the <code class="literal">QUIET</code> log level.</p><div class="example"><a name="logging_to_stdout"></a><p class="title"><b>Example&nbsp;171.&nbsp;Using stdout to write log messages</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">println <span class="hl-string">'A message which is logged at QUIET level'</span>
</pre></div></div><br class="example-break"><p>Gradle also provides a <code class="literal">logger</code> property to a build script, which is an instance of <a class="ulink" href="../javadoc/org/gradle/api/logging/Logger.html" target="_top"><code class="classname">Logger</code></a>. This interface extends the SLF4J <code class="literal">Logger</code> interface and adds a few Gradle specific methods to it. Below is an example of how this is used in the build script:</p><div class="example"><a name="logging_ex"></a><p class="title"><b>Example&nbsp;172.&nbsp;Writing your own log messages</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">logger.quiet(<span class="hl-string">'An info log message which is always logged.'</span>)
logger.error(<span class="hl-string">'An error log message.'</span>)
logger.warn(<span class="hl-string">'A warning log message.'</span>)
logger.lifecycle(<span class="hl-string">'A lifecycle info log message.'</span>)
logger.info(<span class="hl-string">'An info log message.'</span>)
logger.debug(<span class="hl-string">'A debug log message.'</span>)
logger.trace(<span class="hl-string">'A trace log message.'</span>)
</pre></div></div><br class="example-break"><p>Use the <a class="ulink" href="https://www.slf4j.org/manual.html#typical_usage" target="_top">typical SLF4J pattern</a> to replace a placeholder with an actual value as part of the log message.</p><div class="example"><a name="logging_placeholder"></a><p class="title"><b>Example&nbsp;173.&nbsp;Writing a log message with placeholder</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">logger.info(<span class="hl-string">'A {} log message'</span>, <span class="hl-string">'info'</span>)
</pre></div></div><br class="example-break"><p>You can also hook into Gradle&rsquo;s logging system from within other classes used in the build (classes from the <code class="literal">buildSrc</code> directory for example). Simply use an SLF4J logger. You can use this logger the same way as you use the provided logger in the build script.</p><div class="example"><a name="logging_with_slf4j"></a><p class="title"><b>Example&nbsp;174.&nbsp;Using SLF4J to write log messages</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.slf4j.Logger
<span class="hl-keyword">import</span> org.slf4j.LoggerFactory

Logger slf4jLogger = LoggerFactory.getLogger(<span class="hl-string">'some-logger'</span>)
slf4jLogger.info(<span class="hl-string">'An info log message logged using SLF4j'</span>)
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:external_tools" class="section-anchor" href="#sec:external_tools"></a>Logging from external tools and libraries</h2></div></div></div><p>Internally, Gradle uses Ant and Ivy. Both have their own logging system. Gradle redirects their logging output into the Gradle logging system. There is a 1:1 mapping from the Ant/Ivy log levels to the Gradle log levels, except the Ant/Ivy <code class="literal">TRACE</code> log level, which is mapped to Gradle <code class="literal">DEBUG</code> log level. This means the default Gradle log level will not show any Ant/Ivy output unless it is an error or a warning.</p><p>There are many tools out there which still use standard output for logging. By default, Gradle redirects standard output to the <code class="literal">QUIET</code> log level and standard error to the <code class="literal">ERROR</code> level. This behavior is configurable. The project object provides a <a class="ulink" href="../javadoc/org/gradle/api/logging/LoggingManager.html" target="_top"><code class="classname">LoggingManager</code></a>, which allows you to change the log levels that standard out or error are redirected to when your build script is evaluated.</p><div class="example"><a name="project_stdout_capture"></a><p class="title"><b>Example&nbsp;175.&nbsp;Configuring standard output capture</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">logging.captureStandardOutput LogLevel.INFO
println <span class="hl-string">'A message which is logged at INFO level'</span>
</pre></div></div><br class="example-break"><p>To change the log level for standard out or error during task execution, tasks also provide a <a class="ulink" href="../javadoc/org/gradle/api/logging/LoggingManager.html" target="_top"><code class="classname">LoggingManager</code></a>.</p><div class="example"><a name="task_stdout_capture"></a><p class="title"><b>Example&nbsp;176.&nbsp;Configuring standard output capture for a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task logInfo {
    logging.captureStandardOutput LogLevel.INFO
    doFirst {
        println <span class="hl-string">'A task message which is logged at INFO level'</span>
    }
}
</pre></div></div><br class="example-break"><p>Gradle also provides integration with the Java Util Logging, Jakarta Commons Logging and Log4j logging toolkits. Any log messages which your build classes write using these logging toolkits will be redirected to Gradle&rsquo;s logging system.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:changing_what_gradle_logs" class="section-anchor" href="#sec:changing_what_gradle_logs"></a>Changing what Gradle logs</h2></div></div></div><p>You can replace much of Gradle&rsquo;s logging UI with your own. You might do this, for example, if you want to customize the UI in some way - to log more or less information, or to change the formatting. You replace the logging using the <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html#org.gradle.api.invocation.Gradle:useLogger(java.lang.Object)" target="_top"><code class="classname">Gradle.useLogger(java.lang.Object)</code></a> method. This is accessible from a build script, or an init script, or via the embedding API. Note that this completely disables Gradle&rsquo;s default output. Below is an example init script which changes how task execution and build completion is logged.</p><div class="example"><a name="custom_logging_ui"></a><p class="title"><b>Example&nbsp;177.&nbsp;Customizing what Gradle logs</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting">useLogger(<span class="hl-keyword">new</span> CustomEventLogger())

<span class="hl-keyword">class</span> CustomEventLogger <span class="hl-keyword">extends</span> BuildAdapter <span class="hl-keyword">implements</span> TaskExecutionListener {

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> beforeExecute(Task task) {
        println <span class="hl-string">"[$task.name]"</span>
    }

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> afterExecute(Task task, TaskState state) {
        println()
    }
    
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> buildFinished(BuildResult result) {
        println <span class="hl-string">'build completed'</span>
        <span class="hl-keyword">if</span> (result.failure != null) {
            result.failure.printStackTrace()
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -I init.gradle build</code></strong></p><pre class="screen">&gt; gradle -I init.gradle build
[compile]
compiling source

[testCompile]
compiling test source

[test]
running unit tests

[build]

build completed
3 actionable tasks: 3 executed
</pre></div></div><br class="example-break"><p>Your logger can implement any of the listener interfaces listed below. When you register a logger, only the logging for the interfaces that it implements is replaced. Logging for the other interfaces is left untouched. You can find out more about the listener interfaces in <a class="xref" href="#build_lifecycle_events">the section called &ldquo;Responding to the lifecycle in the build script&rdquo;</a>.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/BuildListener.html" target="_top"><code class="classname">BuildListener</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/ProjectEvaluationListener.html" target="_top"><code class="classname">ProjectEvaluationListener</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionGraphListener.html" target="_top"><code class="classname">TaskExecutionGraphListener</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/execution/TaskExecutionListener.html" target="_top"><code class="classname">TaskExecutionListener</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/execution/TaskActionListener.html" target="_top"><code class="classname">TaskActionListener</code></a></p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="multi_project_builds"></a>Authoring Multi-Project Builds</h1></div></div></div><p>The powerful support for multi-project builds is one of Gradle&rsquo;s unique selling points. This topic is also the most intellectually challenging.</p><p>A multi-project build in gradle consists of one root project, and one or more subprojects that may also have subprojects.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:cross_project_configuration" class="section-anchor" href="#sec:cross_project_configuration"></a>Cross project configuration</h2></div></div></div><p>While each subproject could configure itself in complete isolation of the other subprojects, it is common that subprojects share common traits. It is then usually preferable to share configurations among projects, so the same configuration affects several subprojects.</p><p>Let&rsquo;s start with a very simple multi-project build. Gradle is a general purpose build tool at its core, so the projects don&rsquo;t have to be Java projects. Our first examples are about marine life.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuration_and_execution" class="section-anchor" href="#sec:configuration_and_execution"></a>Configuration and execution</h3></div></div></div><p><a class="xref" href="#sec:build_phases">the section called &ldquo;Build phases&rdquo;</a> describes the phases of every Gradle build. Let&rsquo;s zoom into the configuration and execution phases of a multi-project build. Configuration here means executing the <code class="literal">build.gradle</code> file of a project, which implies e.g. downloading all plugins that were declared using &lsquo;<code class="literal">apply plugin</code>&rsquo;. By default, the configuration of all projects happens before any task is executed. This means that when a single task, from a single project is requested, <span class="emphasis"><em>all</em></span> projects of multi-project build are configured first. The reason every project needs to be configured is to support the flexibility of accessing and changing any part of the Gradle project model.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:configuration_on_demand" class="section-anchor" href="#sec:configuration_on_demand"></a>Configuration on demand</h4></div></div></div><p>The <span class="emphasis"><em>Configuration injection</em></span> feature and access to the complete project model are possible because every project is configured before the execution phase. Yet, this approach may not be the most efficient in a very large multi-project build. There are Gradle builds with a hierarchy of hundreds of subprojects. The configuration time of huge multi-project builds may become noticeable. Scalability is an important requirement for Gradle. Hence, starting from version 1.4 a new incubating 'configuration on demand' mode is introduced.</p><p>Configuration on demand mode attempts to configure only projects that are relevant for requested tasks, i.e. it only executes the <code class="literal">build.gradle</code> file of projects that are participating in the build. This way, the configuration time of a large multi-project build can be reduced. In the long term, this mode will become the default mode, possibly the only mode for Gradle build execution. The configuration on demand feature is incubating so not every build is guaranteed to work correctly. The feature should work very well for multi-project builds that have decoupled projects (<a class="xref" href="#sec:decoupled_projects">the section called &ldquo;Decoupled Projects&rdquo;</a>). In &ldquo;configuration on demand&rdquo; mode, projects are configured as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The root project is always configured. This way the typical common configuration is supported (allprojects or subprojects script blocks).</p></li><li class="listitem"><p>The project in the directory where the build is executed is also configured, but only when Gradle is executed without any tasks. This way the default tasks behave correctly when projects are configured on demand.</p></li><li class="listitem"><p>The standard project dependencies are supported and makes relevant projects configured. If project A has a compile dependency on project B then building A causes configuration of both projects.</p></li><li class="listitem"><p>The task dependencies declared via task path are supported and cause relevant projects to be configured. Example: someTask.dependsOn(":someOtherProject:someOtherTask")</p></li><li class="listitem"><p>A task requested via task path from the command line (or Tooling API) causes the relevant project to be configured. For example, building 'projectA:projectB:someTask' causes configuration of projectB.</p></li></ul></div><p>Eager to try out this new feature? To configure on demand with every build run see <a class="xref" href="#sec:gradle_configuration_properties">the section called &ldquo;Gradle properties&rdquo;</a>. To configure on demand just for a given build, see <a class="xref" href="#sec:command_line_performance">the section called &ldquo;Performance options&rdquo;</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_common_behavior" class="section-anchor" href="#sec:defining_common_behavior"></a>Defining common behavior</h3></div></div></div><p>Let&rsquo;s look at some examples with the following project tree. This is a multi-project build with a root project named <code class="literal">water</code> and a subproject named <code class="literal">bluewhale</code>.</p><div class="example"><a name="multiprojectFirstExample"></a><p class="title"><b>Example&nbsp;178.&nbsp;Multi-project tree - water &amp; bluewhale projects</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/firstExample/water</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'bluewhale'</span>
</pre></div></div><br class="example-break"><p>And where is the build script for the <code class="literal">bluewhale</code> project? In Gradle build scripts are optional. Obviously for a single project build, a project without a build script doesn&rsquo;t make much sense. For multiproject builds the situation is different. Let&rsquo;s look at the build script for the <code class="literal">water</code> project and execute it:</p><div class="example"><a name="multiprojectFirstExample"></a><p class="title"><b>Example&nbsp;179.&nbsp;Build script of water (parent) project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">Closure cl = { task -&gt; println <span class="hl-string">"I'm $task.project.name"</span> }
task(<span class="hl-string">'hello'</span>).doLast(cl)
project(<span class="hl-string">':bluewhale'</span>) {
    task(<span class="hl-string">'hello'</span>).doLast(cl)
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
</pre></div></div><br class="example-break"><p>Gradle allows you to access any project of the multi-project build from any build script. The Project API provides a method called <code class="literal">project()</code>, which takes a path as an argument and returns the Project object for this path. The capability to configure a project build from any build script we call <span class="emphasis"><em>cross project configuration</em></span>. Gradle implements this via <span class="emphasis"><em>configuration injection</em></span>.</p><p>We are not that happy with the build script of the <code class="literal">water</code> project. It is inconvenient to add the task explicitly for every project. We can do better. Let&rsquo;s first add another project called <code class="literal">krill</code> to our multi-project build.</p><div class="example"><a name="multiprojectAddKrill"></a><p class="title"><b>Example&nbsp;180.&nbsp;Multi-project tree - water, bluewhale  &amp; krill projects</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
  krill/
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/addKrill/water</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'bluewhale'</span>, <span class="hl-string">'krill'</span>
</pre></div></div><br class="example-break"><p>Now we rewrite the <code class="literal">water</code> build script and boil it down to a single line.</p><div class="example"><a name="multiprojectAddKrill"></a><p class="title"><b>Example&nbsp;181.&nbsp;Water project build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
I'm krill
</pre></div></div><br class="example-break"><p>Is this cool or is this cool? And how does this work? The Project API provides a property <code class="literal">allprojects</code> which returns a list with the current project and all its subprojects underneath it. If you call <code class="literal">allprojects</code> with a closure, the statements of the closure are delegated to the projects associated with <code class="literal">allprojects</code>. You could also do an iteration via <code class="literal">allprojects.each</code>, but that would be more verbose.</p><p>Other build systems use inheritance as the primary means for defining common behavior. We also offer inheritance for projects as you will see later. But Gradle uses configuration injection as the usual way of defining common behavior. We think it provides a very powerful and flexible way of configuring multiproject builds.</p><p>Another possibility for sharing configuration is to use a common external script. See <a class="xref" href="#sec:configuring_using_external_script">the section called &ldquo;Configuring the project using an external build script&rdquo;</a> for more information.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:subproject_configuration" class="section-anchor" href="#sec:subproject_configuration"></a>Subproject configuration</h2></div></div></div><p>The Project API also provides a property for accessing the subprojects only.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_common_behavior_subprojects" class="section-anchor" href="#sec:defining_common_behavior_subprojects"></a>Defining common behavior</h3></div></div></div><div class="example"><a name="multiprojectUseSubprojects"></a><p class="title"><b>Example&nbsp;182.&nbsp;Defining common behavior of all projects and subprojects</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="hl-string">"- I depend on water"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
I'm krill
- I depend on water
</pre></div></div><br class="example-break"><p>You may notice that there are two code snippets referencing the &ldquo;<code class="literal">hello</code>&rdquo; task. The first one, which uses the &ldquo;<code class="literal">task</code>&rdquo; keyword, constructs the task and provides it&rsquo;s base configuration. The second piece doesn&rsquo;t use the &ldquo;<code class="literal">task</code>&rdquo; keyword, as it is further configuring the existing &ldquo;<code class="literal">hello</code>&rdquo; task. You may only construct a task once in a project, but you may add any number of code blocks providing additional configuration.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:adding_specific_behavior" class="section-anchor" href="#sub:adding_specific_behavior"></a>Adding specific behavior</h3></div></div></div><p>You can add specific behavior on top of the common behavior. Usually we put the project specific behavior in the build script of the project where we want to apply this specific behavior. But as we have already seen, we don&rsquo;t have to do it this way. We could add project specific behavior for the <code class="literal">bluewhale</code> project like this:</p><div class="example"><a name="multiprojectSubprojectsAddFromTop"></a><p class="title"><b>Example&nbsp;183.&nbsp;Defining specific behaviour for particular project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="hl-string">"- I depend on water"</span>
        }
    }
}
project(<span class="hl-string">':bluewhale'</span>).hello {
    doLast {
        println <span class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
</pre></div></div><br class="example-break"><p>As we have said, we usually prefer to put project specific behavior into the build script of this project. Let&rsquo;s refactor and also add some project specific behavior to the <code class="literal">krill</code> project.</p><div class="example"><a name="multiprojectSpreadSpecifics"></a><p class="title"><b>Example&nbsp;184.&nbsp;Defining specific behaviour for project krill</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/spreadSpecifics/water</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'bluewhale'</span>, <span class="hl-string">'krill'</span>
</pre><p><code class="filename">bluewhale/build.gradle</code></p><pre class="programlisting">hello.doLast {
  println <span class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span>
}
</pre><p><code class="filename">krill/build.gradle</code></p><pre class="programlisting">hello.doLast {
  println <span class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span>
}
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="hl-string">"- I depend on water"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:project_filtering" class="section-anchor" href="#sub:project_filtering"></a>Project filtering</h3></div></div></div><p>To show more of the power of configuration injection, let&rsquo;s add another project called <code class="literal">tropicalFish</code> and add more behavior to the build via the build script of the <code class="literal">water</code> project.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ssub:filtering_by_name" class="section-anchor" href="#ssub:filtering_by_name"></a>Filtering by name</h4></div></div></div><div class="example"><a name="multiprojectAddTropical"></a><p class="title"><b>Example&nbsp;185.&nbsp;Adding custom behaviour to some projects (filtered by project name)</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle
  tropicalFish/
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/addTropical/water</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'bluewhale'</span>, <span class="hl-string">'krill'</span>, <span class="hl-string">'tropicalFish'</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
subprojects {
    hello {
        doLast {
            println <span class="hl-string">"- I depend on water"</span>
        }
    }
}
configure(subprojects.findAll {it.name != <span class="hl-string">'tropicalFish'</span>}) {
    hello {
        doLast {
            println <span class="hl-string">'- I love to spend time in the arctic waters.'</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I love to spend time in the arctic waters.
- I'm the largest animal that has ever lived on this planet.
I'm krill
- I depend on water
- I love to spend time in the arctic waters.
- The weight of my species in summer is twice as heavy as all human beings.
I'm tropicalFish
- I depend on water
</pre></div></div><br class="example-break"><p>The <code class="literal">configure()</code> method takes a list as an argument and applies the configuration to the projects in this list.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ssub:filtering_by_properties" class="section-anchor" href="#ssub:filtering_by_properties"></a>Filtering by properties</h4></div></div></div><p>Using the project name for filtering is one option. Using extra project properties is another. (See <a class="xref" href="#sec:extra_properties">the section called &ldquo;Extra properties&rdquo;</a> for more information on extra properties.)</p><div class="example"><a name="multiprojectTropicalWithProperties"></a><p class="title"><b>Example&nbsp;186.&nbsp;Adding custom behaviour to some projects (filtered by project properties)</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">water/
  build.gradle
  settings.gradle
  bluewhale/
    build.gradle
  krill/
    build.gradle
  tropicalFish/
    build.gradle
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/tropicalWithProperties/water</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'bluewhale'</span>, <span class="hl-string">'krill'</span>, <span class="hl-string">'tropicalFish'</span>
</pre><p><code class="filename">bluewhale/build.gradle</code></p><pre class="programlisting">ext.arctic = true
hello.doLast {
  println <span class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span>
}
</pre><p><code class="filename">krill/build.gradle</code></p><pre class="programlisting">ext.arctic = true
hello.doLast {
    println <span class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span>
}
</pre><p><code class="filename">tropicalFish/build.gradle</code></p><pre class="programlisting">ext.arctic = false
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    task hello {
        doLast { task -&gt;
            println <span class="hl-string">"I'm $task.project.name"</span>
        }
    }
}
subprojects {
    hello {
        doLast {println <span class="hl-string">"- I depend on water"</span>}
        afterEvaluate { Project project -&gt;
            <span class="hl-keyword">if</span> (project.arctic) { doLast {
                println <span class="hl-string">'- I love to spend time in the arctic waters.'</span> }
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm water
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water
</pre></div></div><br class="example-break"><p>In the build file of the <code class="literal">water</code> project we use an <code class="literal">afterEvaluate</code> notification. This means that the closure we are passing gets evaluated <span class="emphasis"><em>after</em></span> the build scripts of the subproject are evaluated. As the property <code class="literal">arctic</code> is set in those build scripts, we have to do it this way. You will find more on this topic in <a class="xref" href="#sec:dependencies_which_dependencies">the section called &ldquo;Dependencies - Which dependencies?&rdquo;</a></p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:execution_rules_for_multi_project_builds" class="section-anchor" href="#sec:execution_rules_for_multi_project_builds"></a>Execution rules for multi-project builds</h2></div></div></div><p>When we executed the <code class="literal">hello</code> task from the root project dir, things behaved in an intuitive way. All the <code class="literal">hello</code> tasks of the different projects were executed. Let&rsquo;s switch to the <code class="literal">bluewhale</code> dir and see what happens if we execute Gradle from there.</p><div class="example"><a name="multiprojectSubBuild"></a><p class="title"><b>Example&nbsp;187.&nbsp;Running build from subproject</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
I'm bluewhale
- I depend on water
- I'm the largest animal that has ever lived on this planet.
- I love to spend time in the arctic waters.
</pre></div></div><br class="example-break"><p>The basic rule behind Gradle&rsquo;s behavior is simple. Gradle looks down the hierarchy, starting with the <span class="emphasis"><em>current dir</em></span>, for tasks with the name <code class="literal">hello</code> and executes them. One thing is very important to note. Gradle <span class="emphasis"><em>always</em></span> evaluates <span class="emphasis"><em>every</em></span> project of the multi-project build and creates all existing task objects. Then, according to the task name arguments and the current dir, Gradle filters the tasks which should be executed. Because of Gradle&rsquo;s cross project configuration <span class="emphasis"><em>every</em></span> project has to be evaluated before <span class="emphasis"><em>any</em></span> task gets executed. We will have a closer look at this in the next section. Let&rsquo;s now have our last marine example. Let&rsquo;s add a task to <code class="literal">bluewhale</code> and <code class="literal">krill</code>.</p><div class="example"><a name="multiprojectPartialTasks"></a><p class="title"><b>Example&nbsp;188.&nbsp;Evaluation and execution of projects</b></p><div class="example-contents"><p><code class="filename">bluewhale/build.gradle</code></p><pre class="programlisting">ext.arctic = true
hello {
    doLast {
        println <span class="hl-string">"- I'm the largest animal that has ever lived on this planet."</span>
    }
}

task distanceToIceberg {
    doLast {
        println <span class="hl-string">'20 nautical miles'</span>
    }
}
</pre><p><code class="filename">krill/build.gradle</code></p><pre class="programlisting">ext.arctic = true
hello {
    doLast {
        println <span class="hl-string">"- The weight of my species in summer is twice as heavy as all human beings."</span>
    }
}

task distanceToIceberg {
    doLast {
        println <span class="hl-string">'5 nautical miles'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q distanceToIceberg</code></strong></p><pre class="screen">&gt; gradle -q distanceToIceberg
20 nautical miles
5 nautical miles
</pre></div></div><br class="example-break"><p>Here&rsquo;s the output without the <code class="literal">-q</code> option:</p><div class="example"><a name="multiprojectPartialTasksNotQuiet"></a><p class="title"><b>Example&nbsp;189.&nbsp;Evaluation and execution of projects</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle distanceToIceberg</code></strong></p><pre class="screen">&gt; gradle distanceToIceberg
:bluewhale:distanceToIceberg
20 nautical miles
:krill:distanceToIceberg
5 nautical miles

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>The build is executed from the <code class="literal">water</code> project. Neither <code class="literal">water</code> nor <code class="literal">tropicalFish</code> have a task with the name <code class="literal">distanceToIceberg</code>. Gradle does not care. The simple rule mentioned already above is: Execute all tasks down the hierarchy which have this name. Only complain if there is <span class="emphasis"><em>no</em></span> such task!</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:running_partial_build_from_the_root" class="section-anchor" href="#sec:running_partial_build_from_the_root"></a>Running tasks by their absolute path</h2></div></div></div><p>As we have seen, you can run a multi-project build by entering any subproject dir and execute the build from there. All matching task names of the project hierarchy starting with the current dir are executed. But Gradle also offers to execute tasks by their absolute path (see also <a class="xref" href="#sec:project_and_task_paths">the section called &ldquo;Project and task paths&rdquo;</a>):</p><div class="example"><a name="multiprojectAbsoluteTaskPaths"></a><p class="title"><b>Example&nbsp;190.&nbsp;Running tasks by their absolute path</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q :hello :krill:hello hello</code></strong></p><pre class="screen">&gt; gradle -q :hello :krill:hello hello
I'm water
I'm krill
- I depend on water
- The weight of my species in summer is twice as heavy as all human beings.
- I love to spend time in the arctic waters.
I'm tropicalFish
- I depend on water
</pre></div></div><br class="example-break"><p>The build is executed from the <code class="literal">tropicalFish</code> project. We execute the <code class="literal">hello</code> tasks of the <code class="literal">water</code>, the <code class="literal">krill</code> and the <code class="literal">tropicalFish</code> project. The first two tasks are specified by their absolute path, the last task is executed using the name matching mechanism described above.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_and_task_paths" class="section-anchor" href="#sec:project_and_task_paths"></a>Project and task paths</h2></div></div></div><p>A project path has the following pattern: It starts with an optional colon, which denotes the root project. The root project is the only project in a path that is not specified by its name. The rest of a project path is a colon-separated sequence of project names, where the next project is a subproject of the previous project.</p><p>The path of a task is simply its project path plus the task name, like &ldquo;<code class="literal">:bluewhale:hello</code>&rdquo;. Within a project you can address a task of the same project just by its name. This is interpreted as a relative path.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dependencies_which_dependencies" class="section-anchor" href="#sec:dependencies_which_dependencies"></a>Dependencies - Which dependencies?</h2></div></div></div><p>The examples from the last section were special, as the projects had no <span class="emphasis"><em>Execution Dependencies</em></span>. They had only <span class="emphasis"><em>Configuration Dependencies</em></span>. The following sections illustrate the differences between these two types of dependencies.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:execution_time_dependencies" class="section-anchor" href="#sub:execution_time_dependencies"></a>Execution dependencies</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ssub:dependencies_and_execution_order" class="section-anchor" href="#ssub:dependencies_and_execution_order"></a>Dependencies and execution order</h4></div></div></div><div class="example"><a name="multiprojectFirstMessages"></a><p class="title"><b>Example&nbsp;191.&nbsp;Dependencies and execution order</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">messages/
  build.gradle
  settings.gradle
  consumer/
    build.gradle
  producer/
    build.gradle
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/firstMessages/messages</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">build.gradle</code></p><pre class="programlisting">ext.producerMessage = null
</pre><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'consumer'</span>, <span class="hl-string">'producer'</span>
</pre><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">task action {
    doLast {
        println(<span class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
    }
}
</pre><p><code class="filename">producer/build.gradle</code></p><pre class="programlisting">task action {
    doLast {
        println <span class="hl-string">"Producing message:"</span>
        rootProject.producerMessage = <span class="hl-string">'Watch the order of execution.'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q action</code></strong></p><pre class="screen">&gt; gradle -q action
Consuming message: null
Producing message:
</pre></div></div><br class="example-break"><p>This didn&rsquo;t quite do what we want. If nothing else is defined, Gradle executes the task in alphanumeric order. Therefore, Gradle will execute &ldquo;<code class="literal">:consumer:action</code>&rdquo; before &ldquo;<code class="literal">:producer:action</code>&rdquo;. Let&rsquo;s try to solve this with a hack and rename the producer project to &ldquo;<code class="literal">aProducer</code>&rdquo;.</p><div class="example"><a name="multiprojectMessagesHack"></a><p class="title"><b>Example&nbsp;192.&nbsp;Dependencies and execution order</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">messages/
  build.gradle
  settings.gradle
  aProducer/
    build.gradle
  consumer/
    build.gradle
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">ext.producerMessage = null
</pre><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'consumer'</span>, <span class="hl-string">'aProducer'</span>
</pre><p><code class="filename">aProducer/build.gradle</code></p><pre class="programlisting">task action {
    doLast {
        println <span class="hl-string">"Producing message:"</span>
        rootProject.producerMessage = <span class="hl-string">'Watch the order of execution.'</span>
    }
}
</pre><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">task action {
    doLast {
        println(<span class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q action</code></strong></p><pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.
</pre></div></div><br class="example-break"><p>We can show where this hack doesn&rsquo;t work if we now switch to the <code class="literal">consumer</code> dir and execute the build.</p><div class="example"><a name="multiprojectMessagesHackBroken"></a><p class="title"><b>Example&nbsp;193.&nbsp;Dependencies and execution order</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q action</code></strong></p><pre class="screen">&gt; gradle -q action
Consuming message: null
</pre></div></div><br class="example-break"><p>The problem is that the two &ldquo;<code class="literal">action</code>&rdquo; tasks are unrelated. If you execute the build from the &ldquo;<code class="literal">messages</code>&rdquo; project Gradle executes them both because they have the same name and they are down the hierarchy. In the last example only one &ldquo;<code class="literal">action</code>&rdquo; task was down the hierarchy and therefore it was the only task that was executed. We need something better than this hack.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ssub:declaring_dependencies" class="section-anchor" href="#ssub:declaring_dependencies"></a>Declaring dependencies</h4></div></div></div><div class="example"><a name="multiprojectMessagesDependencies"></a><p class="title"><b>Example&nbsp;194.&nbsp;Declaring dependencies</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">messages/
  build.gradle
  settings.gradle
  consumer/
    build.gradle
  producer/
    build.gradle
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/messagesWithDependencies/messages</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">build.gradle</code></p><pre class="programlisting">ext.producerMessage = null
</pre><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'consumer'</span>, <span class="hl-string">'producer'</span>
</pre><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">task action(dependsOn: <span class="hl-string">":producer:action"</span>) {
    doLast {
        println(<span class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
    }
}
</pre><p><code class="filename">producer/build.gradle</code></p><pre class="programlisting">task action {
    doLast {
        println <span class="hl-string">"Producing message:"</span>
        rootProject.producerMessage = <span class="hl-string">'Watch the order of execution.'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q action</code></strong></p><pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.
</pre></div></div><br class="example-break"><p>Running this from the <code class="literal">consumer</code> directory gives:</p><div class="example"><a name="multiprojectMessagesDependenciesSubBuild"></a><p class="title"><b>Example&nbsp;195.&nbsp;Declaring dependencies</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q action</code></strong></p><pre class="screen">&gt; gradle -q action
Producing message:
Consuming message: Watch the order of execution.
</pre></div></div><br class="example-break"><p>This is now working better because we have declared that the &ldquo;<code class="literal">action</code>&rdquo; task in the &ldquo;<code class="literal">consumer</code>&rdquo; project has an <span class="emphasis"><em>execution dependency</em></span> on the &ldquo;<code class="literal">action</code>&rdquo; task in the &ldquo;<code class="literal">producer</code>&rdquo; project.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ssub:the_nature_of_cross_project_task_dependencies" class="section-anchor" href="#ssub:the_nature_of_cross_project_task_dependencies"></a>The nature of cross project task dependencies</h4></div></div></div><p>Of course, task dependencies across different projects are not limited to tasks with the same name. Let&rsquo;s change the naming of our tasks and execute the build.</p><div class="example"><a name="multiprojectMessagesTaskDependencies"></a><p class="title"><b>Example&nbsp;196.&nbsp;Cross project task dependencies</b></p><div class="example-contents"><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">task consume(dependsOn: <span class="hl-string">':producer:produce'</span>) {
    doLast {
        println(<span class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
    }
}
</pre><p><code class="filename">producer/build.gradle</code></p><pre class="programlisting">task produce {
    doLast {
        println <span class="hl-string">"Producing message:"</span>
        rootProject.producerMessage = <span class="hl-string">'Watch the order of execution.'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p><pre class="screen">&gt; gradle -q consume
Producing message:
Consuming message: Watch the order of execution.
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:configuration_time_dependencies" class="section-anchor" href="#sub:configuration_time_dependencies"></a>Configuration time dependencies</h3></div></div></div><p>Let&rsquo;s see one more example with our producer-consumer build before we enter <span class="emphasis"><em>Java</em></span> land. We add a property to the &ldquo;<code class="literal">producer</code>&rdquo; project and create a configuration time dependency from &ldquo;<code class="literal">consumer</code>&rdquo; to &ldquo;<code class="literal">producer</code>&rdquo;.</p><div class="example"><a name="multiprojectMessagesConfigDependenciesBroken"></a><p class="title"><b>Example&nbsp;197.&nbsp;Configuration time dependencies</b></p><div class="example-contents"><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">def message = rootProject.producerMessage

task consume {
    doLast {
        println(<span class="hl-string">"Consuming message: "</span> + message)
    }
}
</pre><p><code class="filename">producer/build.gradle</code></p><pre class="programlisting">rootProject.producerMessage = <span class="hl-string">'Watch the order of evaluation.'</span>
</pre><p>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p><pre class="screen">&gt; gradle -q consume
Consuming message: null
</pre></div></div><br class="example-break"><p>The default <span class="emphasis"><em>evaluation</em></span> order of projects is alphanumeric (for the same nesting level). Therefore the &ldquo;<code class="literal">consumer</code>&rdquo; project is evaluated before the &ldquo;<code class="literal">producer</code>&rdquo; project and the &ldquo;<code class="literal">producerMessage</code>&rdquo; value is set <span class="emphasis"><em>after</em></span> it is read by the &ldquo;<code class="literal">consumer</code>&rdquo; project. Gradle offers a solution for this.</p><div class="example"><a name="multiprojectMessagesConfigDependencies"></a><p class="title"><b>Example&nbsp;198.&nbsp;Configuration time dependencies - evaluationDependsOn</b></p><div class="example-contents"><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">evaluationDependsOn(<span class="hl-string">':producer'</span>)

def message = rootProject.producerMessage

task consume {
    doLast {
        println(<span class="hl-string">"Consuming message: "</span> + message)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p><pre class="screen">&gt; gradle -q consume
Consuming message: Watch the order of evaluation.
</pre></div></div><br class="example-break"><p>The use of the &ldquo;<code class="literal">evaluationDependsOn</code>&rdquo; command results in the evaluation of the &ldquo;<code class="literal">producer</code>&rdquo; project <span class="emphasis"><em>before</em></span> the &ldquo;<code class="literal">consumer</code>&rdquo; project is evaluated. This example is a bit contrived to show the mechanism. In <span class="emphasis"><em>this</em></span> case there would be an easier solution by reading the key property at execution time.</p><div class="example"><a name="multiprojectMessagesConfigDependenciesAltSolution"></a><p class="title"><b>Example&nbsp;199.&nbsp;Configuration time dependencies</b></p><div class="example-contents"><p><code class="filename">consumer/build.gradle</code></p><pre class="programlisting">task consume {
    doLast {
        println(<span class="hl-string">"Consuming message: ${rootProject.producerMessage}"</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q consume</code></strong></p><pre class="screen">&gt; gradle -q consume
Consuming message: Watch the order of evaluation.
</pre></div></div><br class="example-break"><p>Configuration dependencies are very different from execution dependencies. Configuration dependencies are between projects whereas execution dependencies are always resolved to task dependencies. Also note that all projects are always configured, even when you start the build from a subproject. The default configuration order is top down, which is usually what is needed.</p><p>To change the default configuration order to &ldquo;bottom up&rdquo;, use the &ldquo;<code class="literal">evaluationDependsOnChildren()</code>&rdquo; method instead.</p><p>On the same nesting level the configuration order depends on the alphanumeric position. The most common use case is to have multi-project builds that share a common lifecycle (e.g. all projects use the Java plugin). If you declare with <code class="literal">dependsOn</code> an <span class="emphasis"><em>execution dependency</em></span> between different projects, the default behavior of this method is to also create a <span class="emphasis"><em>configuration</em></span> dependency between the two projects. Therefore it is likely that you don&rsquo;t have to define configuration dependencies explicitly.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:real_life_examples" class="section-anchor" href="#sub:real_life_examples"></a>Real life examples</h3></div></div></div><p>Gradle&rsquo;s multi-project features are driven by real life use cases. One good example consists of two web application projects and a parent project that creates a distribution including the two web applications.<sup>[<a href="#ftn.N134E5" name="N134E5" class="footnote">9</a>]</sup> For the example we use only one build script and do <span class="emphasis"><em>cross project configuration</em></span>.</p><div class="example"><a name="webdist"></a><p class="title"><b>Example&nbsp;200.&nbsp;Dependencies - real life example - crossproject configuration</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">webDist/
  settings.gradle
  build.gradle
  date/
    src/main/java/
      org/gradle/sample/
        DateServlet.java
  hello/
    src/main/java/
      org/gradle/sample/
        HelloServlet.java
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/webDist</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'date'</span>, <span class="hl-string">'hello'</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">allprojects {
    apply plugin: <span class="hl-string">'java'</span>
    group = <span class="hl-string">'org.gradle.sample'</span>
    version = <span class="hl-string">'1.0'</span>
}

subprojects {
    apply plugin: <span class="hl-string">'war'</span>
    repositories {
        mavenCentral()
    }
    dependencies {
        compile <span class="hl-string">"javax.servlet:servlet-api:2.5"</span>
    }
}

task explodedDist(type: Copy) {
    into <span class="hl-string">"$buildDir/explodedDist"</span>
    subprojects {
        from tasks.withType(War)
    }
}
</pre></div></div><br class="example-break"><p>We have an interesting set of dependencies. Obviously the <code class="literal">date</code> and <code class="literal">hello</code> projects have a <span class="emphasis"><em>configuration</em></span> dependency on <code class="literal">webDist</code>, as all the build logic for the webapp projects is injected by <code class="literal">webDist</code>. The <span class="emphasis"><em>execution</em></span> dependency is in the other direction, as <code class="literal">webDist</code> depends on the build artifacts of <code class="literal">date</code> and <code class="literal">hello</code>. There is even a third dependency. <code class="literal">webDist</code> has a <span class="emphasis"><em>configuration</em></span> dependency on <code class="literal">date</code> and <code class="literal">hello</code> because it needs to know the <code class="literal">archivePath</code>. But it asks for this information at <span class="emphasis"><em>execution time</em></span>. Therefore we have no circular dependency.</p><p>Such dependency patterns are daily bread in the problem space of multi-project builds. If a build system does not support these patterns, you either can&rsquo;t solve your problem or you need to do ugly hacks which are hard to maintain and massively impair your productivity as a build master.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_jar_dependencies" class="section-anchor" href="#sec:project_jar_dependencies"></a>Project lib dependencies</h2></div></div></div><p>What if one project needs the jar produced by another project in its compile path, and not just the jar but also the transitive dependencies of this jar? Obviously this is a very common use case for Java multi-project builds. As already mentioned in <a class="xref" href="#sub:project_dependencies">the section called &ldquo;Project dependencies&rdquo;</a>, Gradle offers project lib dependencies for this.</p><div class="example"><a name="javadependencies_1"></a><p class="title"><b>Example&nbsp;201.&nbsp;Project lib dependencies</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">java/
  settings.gradle
  build.gradle
  api/
    src/main/java/
      org/gradle/sample/
        api/
          Person.java
        apiImpl/
          PersonImpl.java
  services/personService/
    src/
      main/java/
        org/gradle/sample/services/
          PersonService.java
      test/java/
        org/gradle/sample/services/
          PersonServiceTest.java
  shared/
    src/main/java/
      org/gradle/sample/shared/
        Helper.java
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/multiproject/dependencies/java</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>We have the projects &ldquo;<code class="literal">shared</code>&rdquo;, &ldquo;<code class="literal">api</code>&rdquo; and &ldquo;<code class="literal">personService</code>&rdquo;. The &ldquo;<code class="literal">personService</code>&rdquo; project has a lib dependency on the other two projects. The &ldquo;<code class="literal">api</code>&rdquo; project has a lib dependency on the &ldquo;<code class="literal">shared</code>&rdquo; project.
&ldquo;<code class="literal">services</code>&rdquo; is also a project, but we use it just as a container. It has no build script and gets nothing injected by another build script. We use the <code class="literal">:</code> separator to define a project path. Consult the DSL documentation of <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html#org.gradle.api.initialization.Settings:include(java.lang.String[])" target="_top"><code class="classname">Settings.include(java.lang.String[])</code></a> for more information about defining project paths.</p><div class="example"><a name="javadependencies_2"></a><p class="title"><b>Example&nbsp;202.&nbsp;Project lib dependencies</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'api'</span>, <span class="hl-string">'shared'</span>, <span class="hl-string">'services:personService'</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    apply plugin: <span class="hl-string">'java'</span>
    group = <span class="hl-string">'org.gradle.sample'</span>
    version = <span class="hl-string">'1.0'</span>
    repositories {
        mavenCentral()
    }
    dependencies {
        testCompile <span class="hl-string">"junit:junit:4.12"</span>
    }
}

project(<span class="hl-string">':api'</span>) {
    dependencies {
        compile project(<span class="hl-string">':shared'</span>)
    }
}

project(<span class="hl-string">':services:personService'</span>) {
    dependencies {
        compile project(<span class="hl-string">':shared'</span>), project(<span class="hl-string">':api'</span>)
    }
}

</pre></div></div><br class="example-break"><p>All the build logic is in the &ldquo;<code class="literal">build.gradle</code>&rdquo; file of the root project.<sup>[<a href="#ftn.N1358C" name="N1358C" class="footnote">10</a>]</sup> A &ldquo;<span class="emphasis"><em>lib</em></span>&rdquo; dependency is a special form of an execution dependency. It causes the other project to be built first and adds the jar with the classes of the other project to the classpath. It also adds the dependencies of the other project to the classpath. So you can enter the &ldquo;<code class="literal">api</code>&rdquo; directory and trigger a &ldquo;<code class="literal">gradle compile</code>&rdquo;. First the &ldquo;<code class="literal">shared</code>&rdquo; project is built and then the &ldquo;<code class="literal">api</code>&rdquo; project is built. Project dependencies enable partial multi-project builds.</p><p>If you come from Maven land you might be perfectly happy with this. If you come from Ivy land, you might expect some more fine grained control. Gradle offers this to you:</p><div class="example"><a name="javaWithCustomConf"></a><p class="title"><b>Example&nbsp;203.&nbsp;Fine grained control over dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    apply plugin: <span class="hl-string">'java'</span>
    group = <span class="hl-string">'org.gradle.sample'</span>
    version = <span class="hl-string">'1.0'</span>
}

project(<span class="hl-string">':api'</span>) {
    configurations {
        spi
    }
    dependencies {
        compile project(<span class="hl-string">':shared'</span>)
    }
    task spiJar(type: Jar) {
        baseName = <span class="hl-string">'api-spi'</span>
        from sourceSets.main.output
        include(<span class="hl-string">'org/gradle/sample/api/**'</span>)
    }
    artifacts {
        spi spiJar
    }
}

project(<span class="hl-string">':services:personService'</span>) {
    dependencies {
        compile project(<span class="hl-string">':shared'</span>)
        compile project(path: <span class="hl-string">':api'</span>, configuration: <span class="hl-string">'spi'</span>)
        testCompile <span class="hl-string">"junit:junit:4.12"</span>, project(<span class="hl-string">':api'</span>)
    }
}
</pre></div></div><br class="example-break"><p>The Java plugin adds per default a jar to your project libraries which contains all the classes. In this example we create an <span class="emphasis"><em>additional</em></span> library containing only the interfaces of the &ldquo;<code class="literal">api</code>&rdquo; project. We assign this library to a new <span class="emphasis"><em>dependency configuration</em></span>. For the person service we declare that the project should be compiled only against the &ldquo;<code class="literal">api</code>&rdquo; interfaces but tested with all classes from &ldquo;<code class="literal">api</code>&rdquo;.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="disable_dependency_projects" class="section-anchor" href="#disable_dependency_projects"></a>Disabling the build of dependency projects</h3></div></div></div><p>Sometimes you don&rsquo;t want depended on projects to be built when doing a partial build. To disable the build of the depended on projects you can run Gradle with the <code class="literal">-a</code> option.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:parallel_execution" class="section-anchor" href="#sec:parallel_execution"></a>Parallel project execution</h2></div></div></div><p>With more and more CPU cores available on developer desktops and CI servers, it is important that Gradle is able to fully utilise these processing resources. More specifically, parallel execution attempts to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Reduce total build time for a multi-project build where execution is IO bound or otherwise does not consume all available CPU resources.</p></li><li class="listitem"><p>Provide faster feedback for execution of small projects without awaiting completion of other projects.</p></li></ul></div><p>Although Gradle already offers parallel test execution via <a class="ulink" href="../javadoc/org/gradle/api/tasks/testing/Test.html#setMaxParallelForks-int-" target="_top"><code class="classname">Test.setMaxParallelForks(int)</code></a> the feature described in this section is parallel execution at a project level. Parallel execution is an incubating feature. Please use it and let us know how it works for you.</p><p>Parallel project execution allows the separate projects in a decoupled multi-project build to be executed in parallel (see also: <a class="xref" href="#sec:decoupled_projects">the section called &ldquo;Decoupled Projects&rdquo;</a>). While parallel execution does not strictly require decoupling at configuration time, the long-term goal is to provide a powerful set of features that will be available for fully decoupled projects. Such features include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="#sec:configuration_on_demand">the section called &ldquo;Configuration on demand&rdquo;</a>.</p></li><li class="listitem"><p>Configuration of projects in parallel.</p></li><li class="listitem"><p>Re-use of configuration for unchanged projects.</p></li><li class="listitem"><p>Project-level up-to-date checks.</p></li><li class="listitem"><p>Using pre-built artifacts in the place of building dependent projects.</p></li></ul></div><p>How does parallel execution work? First, you need to tell Gradle to use parallel mode. You can use the <a class="link" href="#sec:command_line_performance"><code class="literal">--parallel</code> command line argument</a> or configure your build environment (<a class="xref" href="#sec:gradle_configuration_properties">the section called &ldquo;Gradle properties&rdquo;</a>). Unless you provide a specific number of parallel threads, Gradle attempts to choose the right number based on available CPU cores. Every parallel worker exclusively owns a given project while executing a task. Task dependencies are fully supported and parallel workers will start executing upstream tasks first. Bear in mind that the alphabetical ordering of decoupled tasks, as can be seen during sequential execution, is not guaranteed in parallel mode. In other words, in parallel mode tasks will run as soon as their dependencies complete <span class="emphasis"><em>and a task worker is available to run them</em></span>, which may be earlier than they would start during a sequential build. You should make sure that task dependencies and task inputs/outputs are declared correctly to avoid ordering issues.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:decoupled_projects" class="section-anchor" href="#sec:decoupled_projects"></a>Decoupled Projects</h2></div></div></div><p>Gradle allows any project to access any other project during both the configuration and execution phases. While this provides a great deal of power and flexibility to the build author, it also limits the flexibility that Gradle has when building those projects. For instance, this effectively prevents Gradle from correctly building multiple projects in parallel, configuring only a subset of projects, or from substituting a pre-built artifact in place of a project dependency.</p><p>Two projects are said to be <span class="emphasis"><em>decoupled</em></span> if they do not directly access each other&rsquo;s project model. Decoupled projects may only interact in terms of declared dependencies: project dependencies (<a class="xref" href="#sub:project_dependencies">the section called &ldquo;Project dependencies&rdquo;</a>) and/or task dependencies (<a class="xref" href="#sec:task_dependencies">the section called &ldquo;Task dependencies&rdquo;</a>). Any other form of project interaction (i.e. by modifying another project object or by reading a value from another project object) causes the projects to be coupled. The consequence of coupling during the configuration phase is that if gradle is invoked with the 'configuration on demand' option, the result of the build can be flawed in several ways. The consequence of coupling during execution phase is that if gradle is invoked with the parallel option, one project task runs too late to influence a task of a project building in parallel. Gradle does not attempt to detect coupling and warn the user, as there are too many possibilities to introduce coupling.</p><p>A very common way for projects to be coupled is by using configuration injection (<a class="xref" href="#sec:cross_project_configuration">the section called &ldquo;Cross project configuration&rdquo;</a>). It may not be immediately apparent, but using key Gradle features like the <code class="literal">allprojects</code> and <code class="literal">subprojects</code> keywords automatically cause your projects to be coupled. This is because these keywords are used in a <code class="literal">build.gradle</code> file, which defines a project. Often this is a &ldquo;root project&rdquo; that does nothing more than define common configuration, but as far as Gradle is concerned this root project is still a fully-fledged project, and by using <code class="literal">allprojects</code> that project is effectively coupled to all other projects. Coupling of the root project to subprojects does not impact 'configuration on demand', but using the <code class="literal">allprojects</code> and <code class="literal">subprojects</code> in any subproject&rsquo;s <code class="literal">build.gradle</code> file will have an impact.</p><p>This means that using any form of shared build script logic or configuration injection (<code class="literal">allprojects</code>, <code class="literal">subprojects</code>, etc.) will cause your projects to be coupled. As we extend the concept of project decoupling and provide features that take advantage of decoupled projects, we will also introduce new features to help you to solve common use cases (like configuration injection) without causing your projects to be coupled.</p><p>In order to make good use of cross project configuration without running into issues for parallel and 'configuration on demand' options, follow these recommendations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid a subproject&rsquo;s <code class="literal">build.gradle</code> referencing other subprojects; preferring cross configuration from the root project.</p></li><li class="listitem"><p>Avoid changing the configuration of other projects at execution time.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:multiproject_build_and_test" class="section-anchor" href="#sec:multiproject_build_and_test"></a>Multi-Project Building and Testing</h2></div></div></div><p>The <code class="literal">build</code> task of the Java plugin is typically used to compile, test, and perform code style checks (if the CodeQuality plugin is used) of a single project. In multi-project builds you may often want to do all of these tasks across a range of projects. The <code class="literal">buildNeeded</code> and <code class="literal">buildDependents</code> tasks can help with this.</p><p>Look at <a class="xref" href="#javadependencies_2" title="Example&nbsp;202.&nbsp;Project lib dependencies">Example&nbsp;202</a>. In this example, the &ldquo;<code class="literal">:services:personservice</code>&rdquo; project depends on both the &ldquo;<code class="literal">:api</code>&rdquo; and &ldquo;<code class="literal">:shared</code>&rdquo; projects. The &ldquo;<code class="literal">:api</code>&rdquo; project also depends on the &ldquo;<code class="literal">:shared</code>&rdquo; project.</p><p>Assume you are working on a single project, the &ldquo;<code class="literal">:api</code>&rdquo; project. You have been making changes, but have not built the entire project since performing a clean. You want to build any necessary supporting jars, but only perform code quality and unit tests on the project you have changed. The <code class="literal">build</code> task does this.</p><div class="example"><a name="multitestingBuild"></a><p class="title"><b>Example&nbsp;204.&nbsp;Build and Test Single Project</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle :api:build</code></strong></p><pre class="screen">&gt; gradle :api:build
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed
</pre></div></div><br class="example-break"><p>While you are working in a typical development cycle repeatedly building and testing changes to the &ldquo;<code class="literal">:api</code>&rdquo; project (knowing that you are only changing files in this one project), you may not want to even suffer the expense of building &ldquo;<code class="literal">:shared:compile</code>&rdquo; to see what has changed in the &ldquo;<code class="literal">:shared</code>&rdquo; project. Adding the &ldquo;<code class="literal">-a</code>&rdquo; option will cause Gradle to use cached jars to resolve any project lib dependencies and not try to re-build the depended on projects.</p><div class="example"><a name="multitestingBuildDashA"></a><p class="title"><b>Example&nbsp;205.&nbsp;Partial Build and Test Single Project</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -a :api:build</code></strong></p><pre class="screen">&gt; gradle -a :api:build
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build

BUILD SUCCESSFUL in 0s
6 actionable tasks: 6 executed
</pre></div></div><br class="example-break"><p>If you have just gotten the latest version of source from your version control system which included changes in other projects that &ldquo;<code class="literal">:api</code>&rdquo; depends on, you might want to not only build all the projects you depend on, but test them as well. The <code class="literal">buildNeeded</code> task also tests all the projects from the project lib dependencies of the testRuntime configuration.</p><div class="example"><a name="multitestingBuildNeeded"></a><p class="title"><b>Example&nbsp;206.&nbsp;Build and Test Depended On Projects</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle :api:buildNeeded</code></strong></p><pre class="screen">&gt; gradle :api:buildNeeded
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build
:shared:assemble
:shared:compileTestJava
:shared:processTestResources
:shared:testClasses
:shared:test
:shared:check
:shared:build
:shared:buildNeeded
:api:buildNeeded

BUILD SUCCESSFUL in 0s
12 actionable tasks: 12 executed
</pre></div></div><br class="example-break"><p>You also might want to refactor some part of the &ldquo;<code class="literal">:api</code>&rdquo; project that is used in other projects. If you make these types of changes, it is not sufficient to test just the &ldquo;<code class="literal">:api</code>&rdquo; project, you also need to test all projects that depend on the &ldquo;<code class="literal">:api</code>&rdquo; project. The <code class="literal">buildDependents</code> task also tests all the projects that have a project lib dependency (in the testRuntime configuration) on the specified project.</p><div class="example"><a name="multitestingBuildDependents"></a><p class="title"><b>Example&nbsp;207.&nbsp;Build and Test Dependent Projects</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle :api:buildDependents</code></strong></p><pre class="screen">&gt; gradle :api:buildDependents
:shared:compileJava
:shared:processResources
:shared:classes
:shared:jar
:api:compileJava
:api:processResources
:api:classes
:api:jar
:api:assemble
:api:compileTestJava
:api:processTestResources
:api:testClasses
:api:test
:api:check
:api:build
:services:personService:compileJava
:services:personService:processResources
:services:personService:classes
:services:personService:jar
:services:personService:assemble
:services:personService:compileTestJava
:services:personService:processTestResources
:services:personService:testClasses
:services:personService:test
:services:personService:check
:services:personService:build
:services:personService:buildDependents
:api:buildDependents

BUILD SUCCESSFUL in 0s
17 actionable tasks: 17 executed
</pre></div></div><br class="example-break"><p>Finally, you may want to build and test everything in all projects. Any task you run in the root project folder will cause that same named task to be run on all the children. So you can just run &ldquo;<code class="literal">gradle build</code>&rdquo; to build and test all projects.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:multi_project_and_buildsrc" class="section-anchor" href="#sec:multi_project_and_buildsrc"></a>Multi Project and buildSrc</h2></div></div></div><p><a class="xref" href="#sec:build_sources">the section called &ldquo;Build sources in the <code class="literal">buildSrc</code> project&rdquo;</a> tells us that we can place build logic to be compiled and tested in the special <code class="literal">buildSrc</code> directory. In a multi project build, there can only be one <code class="literal">buildSrc</code> directory which must be located in the root directory.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:property_and_method_inheritance" class="section-anchor" href="#sec:property_and_method_inheritance"></a>Property and method inheritance</h2></div></div></div><p>Properties and methods declared in a project are inherited to all its subprojects. This is an alternative to configuration injection. But we think that the model of inheritance does not reflect the problem space of multi-project builds very well. In a future edition of this user guide we might write more about this.</p><p>Method inheritance might be interesting to use as Gradle&rsquo;s <span class="emphasis"><em>Configuration Injection</em></span> does not support methods yet (but will in a future release).</p><p>You might be wondering why we have implemented a feature we obviously don&rsquo;t like that much. One reason is that it is offered by other tools and we want to have the check mark in a feature comparison :). And we like to offer our users a choice.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:multiproject_summary" class="section-anchor" href="#sec:multiproject_summary"></a>Summary</h2></div></div></div><p>Writing this chapter was pretty exhausting and reading it might have a similar effect. Our final message for this chapter is that multi-project builds with Gradle are usually <span class="emphasis"><em>not</em></span> difficult. There are five elements you need to remember: <code class="literal">allprojects</code>, <code class="literal">subprojects</code>, <code class="literal">evaluationDependsOn</code>, <code class="literal">evaluationDependsOnChildren</code> and project lib dependencies.<sup>[<a href="#ftn.N136E9" name="N136E9" class="footnote">11</a>]</sup> With those elements, and keeping in mind that Gradle has a distinct configuration and execution phase, you already have a lot of flexibility. But when you enter steep territory Gradle does not become an obstacle and usually accompanies and carries you to the top of the mountain.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N134E5" name="ftn.N134E5" class="para">9</a>] </sup>The real use case we had, was using <a class="ulink" href="http://lucene.apache.org/solr" target="_top">http://lucene.apache.org/solr</a>, where you need a separate war for each index you are accessing. That was one reason why we have created a distribution of webapps. The Resin servlet container allows us, to let such a distribution point to a base installation of the servlet container.</p></div><div class="footnote"><p><sup>[<a href="#N1358C" name="ftn.N1358C" class="para">10</a>] </sup>We do this here, as it makes the layout a bit easier. We usually put the project specific stuff into the build script of the respective projects.</p></div><div class="footnote"><p><sup>[<a href="#N136E9" name="ftn.N136E9" class="para">11</a>] </sup>So we are well in the range of the <a class="ulink" href="http://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two" target="_top">7 plus 2 Rule</a> :)</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="plugins"></a>Using Gradle Plugins</h1></div></div></div><p>Gradle at its core intentionally provides very little for real world automation. All of the useful features, like the ability to compile Java code, are added by <span class="emphasis"><em>plugins</em></span>. Plugins add new tasks (e.g. <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>), domain objects (e.g. <a class="ulink" href="../dsl/org.gradle.api.tasks.SourceSet.html" target="_top"><code class="classname">SourceSet</code></a>), conventions (e.g. Java source is located at <code class="literal">src/main/java</code>) as well as extending core objects and objects from other plugins.</p><p>In this chapter we discuss how to use plugins and the terminology and concepts surrounding plugins.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:what_plugins_do" class="section-anchor" href="#sec:what_plugins_do"></a>What plugins do</h2></div></div></div><p>Applying a plugin to a project allows the plugin to extend the project&rsquo;s capabilities. It can do things such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Extend the Gradle model (e.g. add new DSL elements that can be configured)</p></li><li class="listitem"><p>Configure the project according to conventions (e.g. add new tasks or configure sensible defaults)</p></li><li class="listitem"><p>Apply specific configuration (e.g. add organizational repositories or enforce standards)</p></li></ul></div><p>By applying plugins, rather than adding logic to the project build script, we can reap a number of benefits. Applying plugins:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Promotes reuse and reduces the overhead of maintaining similar logic across multiple projects</p></li><li class="listitem"><p>Allows a higher degree of modularization, enhancing comprehensibility and organization</p></li><li class="listitem"><p>Encapsulates imperative logic and allows build scripts to be as declarative as possible</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:types_of_plugins" class="section-anchor" href="#sec:types_of_plugins"></a>Types of plugins</h2></div></div></div><p>There are two general types of plugins in Gradle, <span class="emphasis"><em>script</em></span> plugins and <span class="emphasis"><em>binary</em></span> plugins. Script plugins are additional build scripts that further configure the build and usually implement a declarative approach to manipulating the build. They are typically used within a build although they can be externalized and accessed from a remote location. Binary plugins are classes that implement the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> interface and adopt a programmatic approach to manipulating the build. Binary plugins can reside within a build script, within the project hierarchy or externally in a plugin jar.</p><p>A plugin often starts out as a script plugin (because they are easy to write) and then, as the code becomes more valuable, it&rsquo;s migrated to a binary plugin that can be easily tested and shared between multiple projects or organizations.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_plugins" class="section-anchor" href="#sec:using_plugins"></a>Using plugins</h2></div></div></div><p>To use the build logic encapsulated in a plugin, Gradle needs to perform two steps. First, it needs to <span class="emphasis"><em>resolve</em></span> the plugin, and then it needs to <span class="emphasis"><em>apply</em></span> the plugin to the target, usually a <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a>.</p><p><span class="emphasis"><em>Resolving</em></span> a plugin means finding the correct version of the jar which contains a given plugin and adding it the script classpath. Once a plugin is resolved, its API can be used in a build script. Script plugins are self-resolving in that they are resolved from the specific file path or URL provided when applying them. Core binary plugins provided as part of the Gradle distribution are automatically resolved.</p><p><span class="emphasis"><em>Applying</em></span> a plugin means actually executing the plugin&rsquo;s <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html#apply-T-" target="_top"><code class="classname">Plugin.apply(T)</code></a> on the Project you want to enhance with the plugin. Applying plugins is <span class="emphasis"><em>idempotent</em></span>. That is, you can safely apply any plugin multiple times without side effects.</p><p>The most common use case for using a plugin is to both resolve the plugin and apply it to the current project. Since this is such a common use case, it&rsquo;s recommended that build authors use the <a class="link" href="#sec:plugins_block">plugins DSL</a> to both resolve and apply plugins in one step. The feature is technically still incubating, but it works well, and should be used by most users.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:script_plugins" class="section-anchor" href="#sec:script_plugins"></a>Script plugins</h2></div></div></div><div class="example"><a name="configureProjectUsingScript"></a><p class="title"><b>Example&nbsp;208.&nbsp;Applying a script plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply from: <span class="hl-string">'other.gradle'</span>
</pre></div></div><br class="example-break"><p>Script plugins are automatically resolved and can be applied from a script on the local filesystem or at a remote location. Filesystem locations are relative to the project directory, while remote script locations are specified with an HTTP URL. Multiple script plugins (of either form) can be applied to a given target.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:binary_plugins" class="section-anchor" href="#sec:binary_plugins"></a>Binary plugins</h2></div></div></div><p>You apply plugins by their <span class="emphasis"><em>plugin id</em></span>, which is a globally unique identifier, or name, for plugins. Core Gradle plugins are special in that they provide short names, such as <code class="literal">'java'</code> for the core <a class="ulink" href="../javadoc/org/gradle/api/plugins/JavaPlugin.html" target="_top"><code class="classname">JavaPlugin</code></a>. All other binary plugins must use the fully qualified form of the plugin id (e.g. <code class="literal">com.github.foo.bar</code>), although some legacy plugins may still utilize a short, unqualified form. Where you put the plugin id depends on whether you are using the <a class="link" href="#sec:plugins_block">plugins DSL</a> or the <a class="link" href="#sec:old_plugin_application">buildscript block.</a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:binary_plugin_locations" class="section-anchor" href="#sec:binary_plugin_locations"></a>Locations of binary plugins</h3></div></div></div><p>A plugin is simply any class that implements the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> interface. Gradle provides the core plugins (e.g. <code class="literal">JavaPlugin</code>) as part of its distribution which means they are automatically resolved. However, non-core binary plugins need to be resolved before they can be applied. This can be achieved in a number of ways:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Including the plugin from the plugin portal or a <a class="link" href="#sec:custom_plugin_repositories">custom repository</a> using the plugins DSL (see <a class="xref" href="#sec:plugins_block">the section called &ldquo;Applying plugins with the plugins DSL&rdquo;</a>).</p></li><li class="listitem"><p>Including the plugin from an external jar defined as a buildscript dependency (see <a class="xref" href="#sec:applying_plugins_buildscript">the section called &ldquo;Applying plugins with the buildscript block&rdquo;</a>).</p></li><li class="listitem"><p>Defining the plugin as a source file under the buildSrc directory in the project (see <a class="xref" href="#sec:build_sources">the section called &ldquo;Build sources in the <code class="literal">buildSrc</code> project&rdquo;</a>).</p></li><li class="listitem"><p>Defining the plugin as an inline class declaration inside a build script.</p></li></ul></div><p>For more on defining your own plugins, see <a class="xref" href="#custom_plugins"><i>Writing Custom Plugins</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:plugins_block" class="section-anchor" href="#sec:plugins_block"></a>Applying plugins with the plugins DSL</h3></div></div></div><div class="note"><p>The plugins DSL is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The new plugins DSL provides a succinct and convenient way to declare plugin dependencies. It works with the <a class="ulink" href="http://plugins.gradle.org" target="_top">Gradle plugin portal</a> to provide easy access to both core and community plugins. The plugins DSL block configures an instance of <a class="ulink" href="../dsl/org.gradle.plugin.use.PluginDependenciesSpec.html" target="_top"><code class="classname">PluginDependenciesSpec</code></a>.</p><p>To apply a core plugin, the short name can be used:</p><div class="example"><a name="useJavaPluginDSL"></a><p class="title"><b>Example&nbsp;209.&nbsp;Applying a core plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'java'</span>
}
</pre></div></div><br class="example-break"><p>To apply a community plugin from the portal, the fully qualified plugin id must be used:</p><div class="example"><a name="useCommunityPluginDSL"></a><p class="title"><b>Example&nbsp;210.&nbsp;Applying a community plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'com.jfrog.bintray'</span> version <span class="hl-string">'0.4.1'</span>
}
</pre></div></div><br class="example-break"><p>See <a class="ulink" href="../dsl/org.gradle.plugin.use.PluginDependenciesSpec.html" target="_top"><code class="classname">PluginDependenciesSpec</code></a> for more information on using the Plugin DSL.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="plugins_dsl_limitations" class="section-anchor" href="#plugins_dsl_limitations"></a>Limitations of the plugins DSL</h4></div></div></div><p>This way of adding plugins to a project is much more than a more convenient syntax. The plugins DSL is processed in a way which allows Gradle to determine the plugins in use very early and very quickly. This allows Gradle to do smart things such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Optimize the loading and reuse of plugin classes.</p></li><li class="listitem"><p>Allow different plugins to use different versions of dependencies.</p></li><li class="listitem"><p>Provide editors detailed information about the potential properties and values in the buildscript for editing assistance.</p></li></ul></div><p>This requires that plugins be specified in a way that Gradle can easily and quickly extract, before executing the rest of the build script. It also requires that the definition of plugins to use be somewhat static.</p><p>There are some key differences between the new plugin mechanism and the &ldquo;traditional&rdquo; <code class="literal">apply()</code> method mechanism. There are also some constraints, some of which are temporary limitations while the mechanism is still being developed and some are inherent to the new approach.</p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:constrained_syntax" class="section-anchor" href="#sec:constrained_syntax"></a>Constrained Syntax</h5></div></div></div><p>The new <code class="literal">plugins {}</code> block does not support arbitrary Groovy code. It is constrained, in order to be idempotent (produce the same result every time) and side effect free (safe for Gradle to execute at any time).</p><p>The form is:</p><pre class="programlisting">plugins {
    id &laquo;plugin id&raquo; version &laquo;plugin version&raquo; [apply &laquo;false&raquo;]
}</pre><p>Where <code class="literal">&laquo;plugin version&raquo;</code> and <code class="literal">&laquo;plugin id&raquo;</code> must be constant, literal, strings and the <code class="literal">apply</code> statement with a <code class="literal">boolean</code> can be used to disable the default behavior of applying the plugin immediately (e.g. you want to apply it only in <code class="literal">subprojects</code>). No other statements are allowed; their presence will cause a compilation error.</p><p>The <code class="literal">plugins {}</code> block must also be a top level statement in the buildscript. It cannot be nested inside another construct (e.g. an if-statement or for-loop).</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:build_scripts_only" class="section-anchor" href="#sec:build_scripts_only"></a>Can only be used in build scripts</h5></div></div></div><p>The <code class="literal">plugins {}</code> block can currently only be used in a project&rsquo;s build script. It cannot be used in script plugins, the settings.gradle file or init scripts.</p><p><span class="emphasis"><em>Future versions of Gradle will remove this restriction.</em></span></p><p>If the restrictions of the new syntax are prohibitive, the recommended approach is to apply plugins using the <a class="link" href="#sec:applying_plugins_buildscript">buildscript {} block</a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:subprojects_plugins_dsl" class="section-anchor" href="#sec:subprojects_plugins_dsl"></a>Applying plugins to subprojects</h4></div></div></div><p>If you have a <a class="link" href="#multi_project_builds">multi-project build</a>, you probably want to apply plugins to some or all of the subprojects in your build, but not to the <code class="literal">root</code> or <code class="literal">master</code> project. The default behavior of the <code class="literal">plugins {}</code> block is to immediately <code class="literal">resolve</code> <span class="emphasis"><em>and</em></span>  <code class="literal">apply</code> the plugins. But, you can use the <code class="literal">apply false</code> syntax to tell Gradle not to apply the plugin to the current project and then use <code class="literal">apply plugin: &laquo;plugin id&raquo;</code> in the <code class="literal">subprojects</code> block:</p><div class="example"><a name="pluginsOnSubprojects"></a><p class="title"><b>Example&nbsp;211.&nbsp;Applying plugins only on certain subprojects.</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">'helloA'</span>
include <span class="hl-string">'helloB'</span>
include <span class="hl-string">'goodbyeC'</span>
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
  id <span class="hl-string">"org.gradle.sample.hello"</span> version <span class="hl-string">"1.0.0"</span> apply false
  id <span class="hl-string">"org.gradle.sample.goodbye"</span> version <span class="hl-string">"1.0.0"</span> apply false
}

subprojects { subproject -&gt;
    <span class="hl-keyword">if</span> (subproject.name.startsWith(<span class="hl-string">"hello"</span>)) {
        apply plugin: <span class="hl-string">'org.gradle.sample.hello'</span>
    }
    <span class="hl-keyword">if</span> (subproject.name.startsWith(<span class="hl-string">"goodbye"</span>)) {
        apply plugin: <span class="hl-string">'org.gradle.sample.goodbye'</span>
    }
}
</pre></div></div><br class="example-break"><p>If you then run <code class="literal">gradle hello</code> you&rsquo;ll see that only the helloA and helloB subprojects had the hello plugin applied.</p><pre class="screen">gradle/subprojects/docs/src/samples/plugins/multiproject $&gt; gradle hello
Parallel execution is an incubating feature.
:helloA:hello
:helloB:hello
Hello!
Hello!

BUILD SUCCEEDED</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:plugin_management" class="section-anchor" href="#sec:plugin_management"></a>Plugin Management</h4></div></div></div><div class="note"><p>The <code class="literal">pluginManagement {}</code> DSL is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:custom_plugin_repositories" class="section-anchor" href="#sec:custom_plugin_repositories"></a>Custom Plugin Repositories</h5></div></div></div><p>By default, the <code class="literal">plugins {}</code> DSL resolves plugins from the public <a class="ulink" href="https://plugins.gradle.org" target="_top">Gradle Plugin Portal.</a> Many build authors would also like to resolve plugins from private Maven or Ivy repositories because the plugins contain proprietary implementation details, or just to have more control over what plugins are available to their builds.</p><p>To specify custom plugin repositories, use the <code class="literal">repositories {}</code> block inside <code class="literal">pluginManagement {}</code> in the <code class="literal">settings.gradle</code> file:</p><div class="example"><a name="customPluginRepositories"></a><p class="title"><b>Example&nbsp;212.&nbsp;Using plugins from custom plugin repositories.</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">pluginManagement {
  repositories {
      maven {
        url <span class="hl-string">'maven-repo'</span>
      }
      gradlePluginPortal()
      ivy {
        url <span class="hl-string">'ivy-repo'</span>
      }
  }
}
</pre></div></div><br class="example-break"><p>This tells Gradle to first look in the Maven repository at <code class="literal">maven-repo</code> when resolving plugins and then to check the Gradle Plugin Portal if the plugins are not found in the Maven repository. If you don&rsquo;t want the Gradle Plugin Portal to be searched, omit the <code class="literal">gradlePluginPortal()</code> line. Finally, the Ivy repository at <code class="literal">ivy-repo</code> will be checked.</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="sec:plugin_resolution_rules" class="section-anchor" href="#sec:plugin_resolution_rules"></a>Plugin Resolution Rules</h5></div></div></div><p>Plugin resolution rules allow you to modify plugin requests made in <code class="literal">plugins {}</code> blocks, e.g. changing the requested version or explicitly specifying the implementation artifact coordinates.</p><p>To add resolution rules, use the <code class="literal">resolutionStrategy {}</code> inside the <code class="literal">pluginManagement {}</code> block:</p><div class="example"><a name="pluginResolutionStrategy"></a><p class="title"><b>Example&nbsp;213.&nbsp;Plugin resolution strategy.</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">pluginManagement {
  resolutionStrategy {
      eachPlugin {
          <span class="hl-keyword">if</span> (requested.id.namespace == <span class="hl-string">'org.gradle.sample'</span>) {
              useModule(<span class="hl-string">'org.gradle.sample:sample-plugins:1.0.0'</span>)
          }
      }
  }
  repositories {
      maven {
        url <span class="hl-string">'maven-repo'</span>
      }
      gradlePluginPortal()
      ivy {
        url <span class="hl-string">'ivy-repo'</span>
      }
  }
}
</pre></div></div><br class="example-break"><p>This tells Gradle to use the specified plugin implementation artifact instead of using its built-in default mapping from plugin ID to Maven/Ivy coordinates.</p><p>The <code class="literal">pluginManagement {}</code> block may only appear in the <code class="literal">settings.gradle</code> file, and must be the first block in the file. Custom Maven and Ivy plugin repositories must contain <a class="link" href="#sec:plugin_markers">plugin marker artifacts</a> in addition to the artifacts which actually implement the plugin. For more information on publishing plugins to custom repositories read <a class="xref" href="#java_gradle_plugin"><i>Gradle Plugin Development Plugin</i></a>.</p><p>See <a class="ulink" href="../dsl/org.gradle.plugin.management.PluginManagementSpec.html" target="_top"><code class="classname">PluginManagementSpec</code></a> for complete documentation for using the <code class="literal">pluginManagement {}</code> block.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:plugin_markers" class="section-anchor" href="#sec:plugin_markers"></a>Plugin Marker Artifacts</h4></div></div></div><p>Since the <code class="literal">plugins {}</code> DSL block only allows for declaring plugins by their globally unique plugin <code class="literal">id</code> and <code class="literal">version</code> properties, Gradle needs a way to look up the coordinates of the plugin implementation artifact. To do so, Gradle will look for a Plugin Marker Artifact with the coordinates <code class="literal">plugin.id:plugin.id.gradle.plugin:plugin.version</code>. This marker needs to have a dependency on the actual plugin implementation. Publishing these markers is automated by the <a class="link" href="#">java-gradle-plugin</a>.</p><p>For example, the following complete sample from the <code class="literal">sample-plugins</code> project shows how to publish a <code class="literal">org.gradle.sample.hello</code> plugin and a <code class="literal">org.gradle.sample.goodbye</code> plugin to both an Ivy and Maven repository using the combination of the <a class="link" href="#">java-gradle-plugin</a>, the <a class="link" href="#publishing_maven">maven-publish</a> plugin, and the <a class="link" href="#publishing_ivy">ivy-publish</a> plugin.</p><div class="example"><a name="completePluginPublishing"></a><p class="title"><b>Example&nbsp;214.&nbsp;Complete Plugin Publishing Sample</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
  id <span class="hl-string">'java-gradle-plugin'</span>
  id <span class="hl-string">'maven-publish'</span>
  id <span class="hl-string">'ivy-publish'</span>
}

group <span class="hl-string">'org.gradle.sample'</span>
version <span class="hl-string">'1.0.0'</span>

gradlePlugin {
  plugins {
    hello {
      id = <span class="hl-string">"org.gradle.sample.hello"</span>
      implementationClass = <span class="hl-string">"org.gradle.sample.hello.HelloPlugin"</span>
    }
    goodbye {
      id = <span class="hl-string">"org.gradle.sample.goodbye"</span>
      implementationClass = <span class="hl-string">"org.gradle.sample.goodbye.GoodbyePlugin"</span>
    }
  }
}

publishing {
  repositories {
    maven {
      url <span class="hl-string">"../consuming/maven-repo"</span>
    }
    ivy {
      url <span class="hl-string">"../consuming/ivy-repo"</span>
    }
  }
}
</pre></div></div><br class="example-break"><p>Running <code class="literal">gradle publish</code> in the sample directory causes the following repo layouts to exist:</p><div class="informalfigure"><div class="mediaobject"><img src="img/pluginMarkers.png" alt="pluginMarkers"></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:old_plugin_application" class="section-anchor" href="#sec:old_plugin_application"></a>Legacy Plugin Application</h3></div></div></div><p>With the introduction of the <a class="link" href="#sec:plugins_block">plugins DSL</a>, users should have little reason to use the legacy method of applying plugins. It is documented here in case a build author cannot use the plugins DSL due to restrictions in how it currently works.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:applying_binary_plugins" class="section-anchor" href="#sec:applying_binary_plugins"></a>Applying Binary Plugins</h4></div></div></div><div class="example"><a name="useJavaPlugin"></a><p class="title"><b>Example&nbsp;215.&nbsp;Applying a binary plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
</pre></div></div><br class="example-break"><p>Plugins can be applied using a <span class="emphasis"><em>plugin id</em></span>. In the above case, we are using the short name &lsquo;<code class="literal">java</code>&rsquo; to apply the <a class="ulink" href="../javadoc/org/gradle/api/plugins/JavaPlugin.html" target="_top"><code class="classname">JavaPlugin</code></a>.</p><p>Rather than using a plugin id, plugins can also be applied by simply specifying the class of the plugin:</p><div class="example"><a name="pluginIntro"></a><p class="title"><b>Example&nbsp;216.&nbsp;Applying a binary plugin by type</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: JavaPlugin
</pre></div></div><br class="example-break"><p>The <code class="literal">JavaPlugin</code> symbol in the above sample refers to the <a class="ulink" href="../javadoc/org/gradle/api/plugins/JavaPlugin.html" target="_top"><code class="classname">JavaPlugin</code></a>. This class does not strictly need to be imported as the <code class="literal">org.gradle.api.plugins</code> package is automatically imported in all build scripts (see <a class="xref" href="#script-default-imports">the section called &ldquo;Default imports&rdquo;</a>). Furthermore, it is not necessary to append <code class="literal">.class</code> to identify a class literal in Groovy as it is in Java.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:applying_plugins_buildscript" class="section-anchor" href="#sec:applying_plugins_buildscript"></a>Applying plugins with the buildscript block</h4></div></div></div><p>Binary plugins that have been published as external jar files can be added to a project by adding the plugin to the build script classpath and then applying the plugin. External jars can be added to the build script classpath using the <code class="literal">buildscript {}</code> block as described in <a class="xref" href="#sec:build_script_external_dependencies">the section called &ldquo;External dependencies for the build script&rdquo;</a>.</p><div class="example"><a name="applyPluginBuildscript"></a><p class="title"><b>Example&nbsp;217.&nbsp;Applying a plugin with the buildscript block</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath <span class="hl-string">"com.jfrog.bintray.gradle:gradle-bintray-plugin:0.4.1"</span>
    }
}

apply plugin: <span class="hl-string">"com.jfrog.bintray"</span>
</pre></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:finding_community_plugins" class="section-anchor" href="#sec:finding_community_plugins"></a>Finding community plugins</h2></div></div></div><p>Gradle has a vibrant community of plugin developers who contribute plugins for a wide variety of capabilities. The Gradle <a class="ulink" href="http://plugins.gradle.org" target="_top">plugin portal</a> provides an interface for searching and exploring community plugins.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:more_on_plugins" class="section-anchor" href="#sec:more_on_plugins"></a>More on plugins</h2></div></div></div><p>This chapter aims to serve as an introduction to plugins and Gradle and the role they play. For more information on the inner workings of plugins, see <a class="xref" href="#custom_plugins"><i>Writing Custom Plugins</i></a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="standard_plugins"></a>Standard Gradle plugins</h1></div></div></div><p>There are a number of plugins included in the Gradle distribution. These are listed below.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:language_plugins" class="section-anchor" href="#sec:language_plugins"></a>Language plugins</h2></div></div></div><p>These plugins add support for various languages which can be compiled for and executed in the JVM.</p><div class="table"><p class="title"><b>Table&nbsp;13.&nbsp;Language plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N139A6"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#java_plugin"><code class="literal">java</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p>-</p></td>
<td><p>Adds Java compilation, testing and bundling capabilities to a project. It serves as the basis for many of the other Gradle plugins. See also <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#groovy_plugin"><code class="literal">groovy</code> </a></p></td>
<td><p><code class="literal">java</code>, <code class="literal">groovy-base</code></p></td>
<td><p>-</p></td>
<td><p>Adds support for building Groovy projects. See also <a class="xref" href="#tutorial_groovy_projects"><i>Groovy Quickstart</i></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#scala_plugin"><code class="literal">scala</code> </a></p></td>
<td><p><code class="literal">java</code>, <code class="literal">scala-base</code></p></td>
<td><p>-</p></td>
<td><p>Adds support for building Scala projects.</p></td>
</tr><tr>
<td><p><a class="link" href="#antlr_plugin"><code class="literal">antlr</code> </a></p></td>
<td><p><code class="literal">java</code></p></td>
<td><p>-</p></td>
<td><p>Adds support for generating parsers using <a class="ulink" href="http://www.antlr.org/" target="_top">Antlr</a>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:incubating_language_plugins" class="section-anchor" href="#sec:incubating_language_plugins"></a>Incubating language plugins</h2></div></div></div><p>These plugins add support for various languages:</p><div class="table"><p class="title"><b>Table&nbsp;14.&nbsp;Language plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13A2E"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#native_software"><code class="literal">assembler</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds native assembly language capabilities to a project.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">c</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds C source compilation capabilities to a project.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">cpp</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds C++ source compilation capabilities to a project.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">objective-c</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds Objective-C source compilation capabilities to a project.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">objective-cpp</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds Objective-C++ source compilation capabilities to a project.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">windows-resources</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds support for including Windows resources in native binaries.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:integration_plugins" class="section-anchor" href="#sec:integration_plugins"></a>Integration plugins</h2></div></div></div><p>These plugins provide some integration with various runtime technologies.</p><div class="table"><p class="title"><b>Table&nbsp;15.&nbsp;Integration plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13ACE"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#application_plugin"><code class="literal">application</code> </a></p></td>
<td><p><code class="literal">java</code>, <code class="literal">distribution</code></p></td>
<td><p>-</p></td>
<td><p>Adds tasks for running and bundling a Java project as a command-line application.</p></td>
</tr><tr>
<td><p><a class="link" href="#ear_plugin"><code class="literal">ear</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code></p></td>
<td><p>Adds support for building J2EE applications.</p></td>
</tr><tr>
<td><p><a class="link" href="#maven_plugin"><code class="literal">maven</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code>, <code class="literal">war</code></p></td>
<td><p>Adds support for publishing artifacts to Maven repositories.</p></td>
</tr><tr>
<td><p><a class="link" href="#osgi_plugin"><code class="literal">osgi</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p><code class="literal">java</code></p></td>
<td><p>Adds support for building OSGi bundles.</p></td>
</tr><tr>
<td><p><a class="link" href="#war_plugin"><code class="literal">war</code> </a></p></td>
<td><p><code class="literal">java</code></p></td>
<td><p>-</p></td>
<td><p>Adds support for assembling web application WAR files. See also <a class="xref" href="#web_project_tutorial"><i>Web Application Quickstart</i></a>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:incubating_integration_plugins" class="section-anchor" href="#sec:incubating_integration_plugins"></a>Incubating integration plugins</h2></div></div></div><p>These plugins provide some integration with various runtime technologies.</p><div class="table"><p class="title"><b>Table&nbsp;16.&nbsp;Incubating integration plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13B67"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#distribution_plugin"><code class="literal">distribution</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds support for building ZIP and TAR distributions.</p></td>
</tr><tr>
<td><p><a class="link" href="#java_library_distribution_plugin"><code class="literal">java-library-distribution</code> </a></p></td>
<td><p><code class="literal">java</code>, <code class="literal">distribution</code></p></td>
<td><p>-</p></td>
<td><p>Adds support for building ZIP and TAR distributions for a Java library.</p></td>
</tr><tr>
<td><p><a class="link" href="#publishing_ivy"><code class="literal">ivy-publish</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code>, <code class="literal">war</code></p></td>
<td><p>This plugin provides a new DSL to support publishing artifacts to Ivy repositories, which improves on the existing DSL.</p></td>
</tr><tr>
<td><p><a class="link" href="#publishing_maven"><code class="literal">maven-publish</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code>, <code class="literal">war</code></p></td>
<td><p>This plugin provides a new DSL to support publishing artifacts to Maven repositories, which improves on the existing DSL.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:software_development_plugins" class="section-anchor" href="#sec:software_development_plugins"></a>Software development plugins</h2></div></div></div><p>These plugins provide help with your software development process.</p><div class="table"><p class="title"><b>Table&nbsp;17.&nbsp;Software development plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13BE7"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#announce_plugin"><code class="literal">announce</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Publish messages to your favourite platforms, such as Twitter or Growl.</p></td>
</tr><tr>
<td><p><a class="link" href="#build_announcements_plugin"><code class="literal">build-announcements</code> </a></p></td>
<td><p>announce</p></td>
<td><p>-</p></td>
<td><p>Sends local announcements to your desktop about interesting events in the build lifecycle.</p></td>
</tr><tr>
<td><p><a class="link" href="#checkstyle_plugin"><code class="literal">checkstyle</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p>-</p></td>
<td><p>Performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://checkstyle.sourceforge.net/index.html" target="_top">Checkstyle</a> and generates reports from these checks.</p></td>
</tr><tr>
<td><p><a class="link" href="#codenarc_plugin"><code class="literal">codenarc</code> </a></p></td>
<td><p><code class="literal">groovy-base</code></p></td>
<td><p>-</p></td>
<td><p>Performs quality checks on your project&rsquo;s Groovy source files using <a class="ulink" href="http://codenarc.sourceforge.net/index.html" target="_top">CodeNarc</a> and generates reports from these checks.</p></td>
</tr><tr>
<td><p><a class="link" href="#eclipse_plugin"><code class="literal">eclipse</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code>,<code class="literal">groovy</code>, <code class="literal">scala</code></p></td>
<td><p>Generates files that are used by <a class="ulink" href="http://eclipse.org" target="_top">Eclipse IDE</a>, thus making it possible to import the project into Eclipse. See also <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#eclipse_plugin"><code class="literal">eclipse-wtp</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">ear</code>, <code class="literal">war</code></p></td>
<td><p>Does the same as the eclipse plugin plus generates eclipse WTP (Web Tools Platform) configuration files. After importing to eclipse your war/ear projects should be configured to work with WTP. See also <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#findbugs_plugin"><code class="literal">findbugs</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p>-</p></td>
<td><p>Performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://findbugs.sourceforge.net" target="_top">FindBugs</a> and generates reports from these checks.</p></td>
</tr><tr>
<td><p><a class="link" href="#idea_plugin"><code class="literal">idea</code> </a></p></td>
<td><p>-</p></td>
<td><p><code class="literal">java</code></p></td>
<td><p>Generates files that are used by <a class="ulink" href="http://www.jetbrains.com/idea/index.html" target="_top">Intellij IDEA IDE</a>, thus making it possible to import the project into IDEA.</p></td>
</tr><tr>
<td><p><a class="link" href="#jdepend_plugin"><code class="literal">jdepend</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p>-</p></td>
<td><p>Performs quality checks on your project&rsquo;s source files using <a class="ulink" href="http://clarkware.com/software/JDepend.html" target="_top">JDepend</a> and generates reports from these checks.</p></td>
</tr><tr>
<td><p><a class="link" href="#pmd_plugin"><code class="literal">pmd</code> </a></p></td>
<td><p><code class="literal">java-base</code></p></td>
<td><p>-</p></td>
<td><p>Performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://pmd.sourceforge.net" target="_top">PMD</a> and generates reports from these checks.</p></td>
</tr><tr>
<td><p><a class="link" href="#"><code class="literal">project-report</code> </a></p></td>
<td><p><code class="literal">reporting-base</code></p></td>
<td><p>-</p></td>
<td><p>Generates reports containing useful information about your Gradle build.</p></td>
</tr><tr>
<td><p><a class="link" href="#signing_plugin"><code class="literal">signing</code> </a></p></td>
<td><p>base</p></td>
<td><p>-</p></td>
<td><p>Adds the ability to digitally sign built files and artifacts.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:incubating_software_development_plugins" class="section-anchor" href="#sec:incubating_software_development_plugins"></a>Incubating software development plugins</h2></div></div></div><p>These plugins provide help with your software development process.</p><div class="table"><p class="title"><b>Table&nbsp;18.&nbsp;Software development plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13D3F"><thead><tr>
<td>Plugin Id</td>
<td>Automatically applies</td>
<td>Works with</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="link" href="#build_dashboard_plugin"><code class="literal">build-dashboard</code> </a></p></td>
<td><p>reporting-base</p></td>
<td><p>-</p></td>
<td><p>Generates build dashboard report.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">cunit</code> </a></p></td>
<td><p>-</p></td>
<td><p>-</p></td>
<td><p>Adds support for running <a class="ulink" href="http://cunit.sourceforge.net" target="_top">CUnit</a> tests.</p></td>
</tr><tr>
<td><p><a class="link" href="#jacoco_plugin"><code class="literal">jacoco</code> </a></p></td>
<td><p>reporting-base</p></td>
<td><p>java</p></td>
<td><p>Provides integration with the <a class="ulink" href="http://www.eclemma.org/jacoco/" target="_top">JaCoCo</a> code coverage library for Java.</p></td>
</tr><tr>
<td><p><a class="link" href="#native_software"><code class="literal">visual-studio</code> </a></p></td>
<td><p>-</p></td>
<td><p>native language plugins</p></td>
<td><p>Adds integration with Visual Studio.</p></td>
</tr><tr>
<td><p><a class="link" href="#java_gradle_plugin"><code class="literal">java-gradle-plugin</code> </a></p></td>
<td><p>java</p></td>
<td></td>
<td><p>Assists with development of Gradle plugins by providing standard plugin build configuration and validation.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:base_plugins" class="section-anchor" href="#sec:base_plugins"></a>Base plugins</h2></div></div></div><p>These plugins form the basic building blocks which the other plugins are assembled from. They are available for you to use in your build files, and are listed here for completeness. However, be aware that they are not yet considered part of Gradle&rsquo;s public API. As such, these plugins are not documented in the user guide. You might refer to their API documentation to learn more about them.</p><div class="table"><p class="title"><b>Table&nbsp;19.&nbsp;Base plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13DCF"><thead><tr>
<td>Plugin Id</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>base</p></td>
<td><p>Adds the standard lifecycle tasks and configures reasonable defaults for the archive tasks:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>adds build <span class="emphasis"><em>ConfigurationName</em></span> tasks. Those tasks assemble the artifacts belonging to the specified configuration.</p></li><li class="listitem"><p>adds upload <span class="emphasis"><em>ConfigurationName</em></span> tasks. Those tasks assemble and upload the artifacts belonging to the specified configuration.</p></li><li class="listitem"><p>configures reasonable default values for all archive tasks (e.g. tasks that inherit from <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html" target="_top"><code class="classname">AbstractArchiveTask</code></a>). For example, the archive tasks are tasks of types: <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a>. Specifically, <code class="literal">destinationDir</code>, <code class="literal">baseName</code> and <code class="literal">version</code> properties of the archive tasks are preconfigured with defaults. This is extremely useful because it drives consistency across projects; the consistency regarding naming conventions of archives and their location after the build completed.</p></li></ul></div></td>
</tr><tr>
<td><p>java-base</p></td>
<td><p>Adds the source sets concept to the project. Does not add any particular source sets.</p></td>
</tr><tr>
<td><p>groovy-base</p></td>
<td><p>Adds the Groovy source sets concept to the project.</p></td>
</tr><tr>
<td><p>scala-base</p></td>
<td><p>Adds the Scala source sets concept to the project.</p></td>
</tr><tr>
<td><p>reporting-base</p></td>
<td><p>Adds some shared convention properties to the project, relating to report generation.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:third_party_plugins" class="section-anchor" href="#sec:third_party_plugins"></a>Third party plugins</h2></div></div></div><p>You can find a list of external plugins at the <a class="ulink" href="http://plugins.gradle.org/" target="_top">Gradle Plugins site</a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="project_report_plugin"></a>The Project Report Plugin</h1></div></div></div><p>The Project report plugin adds some tasks to your project which generate reports containing useful information about your build. These tasks generate the same content that you get by executing the <code class="literal">tasks</code>, <code class="literal">dependencies</code>, and <code class="literal">properties</code> tasks from the command line (see <a class="xref" href="#sec:command_line_project_reporting">the section called &ldquo;Project reporting&rdquo;</a>). In contrast to the command line reports, the report plugin generates the reports into a file. There is also an aggregating task that depends on all report tasks added by the plugin.</p><p>We plan to add much more to the existing reports and create additional ones in future releases of Gradle.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_reports_usage" class="section-anchor" href="#sec:project_reports_usage"></a>Usage</h2></div></div></div><p>To use the Project report plugin, include the following in your build script:</p><pre class="programlisting">apply plugin: <span class="hl-string">'project-report'</span></pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_reports_tasks" class="section-anchor" href="#sec:project_reports_tasks"></a>Tasks</h2></div></div></div><p>The project report plugin defines the following tasks:</p><div class="table"><p class="title"><b>Table&nbsp;20.&nbsp;Project report plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13E6E"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">dependencyReport</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.diagnostics.DependencyReportTask.html" target="_top"><code class="classname">DependencyReportTask</code></a></p></td>
<td><p>Generates the project dependency report.</p></td>
</tr><tr>
<td><p><code class="literal">htmlDependencyReport</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.reporting.dependencies.HtmlDependencyReportTask.html" target="_top"><code class="classname">HtmlDependencyReportTask</code></a></p></td>
<td><p>Generates an HTML dependency and dependency insight report for the project or a set of projects.</p></td>
</tr><tr>
<td><p><code class="literal">propertyReport</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.diagnostics.PropertyReportTask.html" target="_top"><code class="classname">PropertyReportTask</code></a></p></td>
<td><p>Generates the project property report.</p></td>
</tr><tr>
<td><p><code class="literal">taskReport</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.diagnostics.TaskReportTask.html" target="_top"><code class="classname">TaskReportTask</code></a></p></td>
<td><p>Generates the project task report.</p></td>
</tr><tr>
<td><p><code class="literal">projectReport</code></p></td>
<td><p><code class="literal">dependencyReport</code>, <code class="literal">propertyReport</code>, <code class="literal">taskReport</code>, <code class="literal">htmlDependencyReport</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Generates all project reports.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_reports_project_layout" class="section-anchor" href="#sec:project_reports_project_layout"></a>Project layout</h2></div></div></div><p>The project report plugin does not require any particular project layout.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_reports_dependency_management" class="section-anchor" href="#sec:project_reports_dependency_management"></a>Dependency management</h2></div></div></div><p>The project report plugin does not define any dependency configurations.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:project_reports_convention_properties" class="section-anchor" href="#sec:project_reports_convention_properties"></a>Convention properties</h2></div></div></div><p>The project report defines the following convention properties:</p><div class="table"><p class="title"><b>Table&nbsp;21.&nbsp;Project report plugin - convention properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13F0E"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">reportsDirName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">reports</code></p></td>
<td><p>The name of the directory to generate reports into, relative to the build directory.</p></td>
</tr><tr>
<td><p><code class="literal">reportsDir</code></p></td>
<td><p><code class="literal">File</code> (read-only)</p></td>
<td><p><code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>reportsDirName</em></span></code></p></td>
<td><p>The directory to generate reports into.</p></td>
</tr><tr>
<td><p><code class="literal">projects</code></p></td>
<td><p><code class="literal">Set&lt;Project&gt;</code></p></td>
<td><p>A one element set with the project the plugin was applied to.</p></td>
<td><p>The projects to generate the reports for.</p></td>
</tr><tr>
<td><p><code class="literal">projectReportDirName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">project</code></p></td>
<td><p>The name of the directory to generate the project report into, relative to the reports directory.</p></td>
</tr><tr>
<td><p><code class="literal">projectReportDir</code></p></td>
<td><p><code class="literal">File</code> (read-only)</p></td>
<td><p><code class="literal"><span class="emphasis"><em>reportsDir</em></span>/<span class="emphasis"><em>projectReportDirName</em></span></code></p></td>
<td><p>The directory to generate the project report into.</p></td>
</tr></tbody></table></div></div><p>These convention properties are provided by a convention object of type <a class="ulink" href="../dsl/org.gradle.api.plugins.ProjectReportsPluginConvention.html" target="_top"><code class="classname">ProjectReportsPluginConvention</code></a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_dashboard_plugin"></a>The Build Dashboard Plugin</h1></div></div></div><div class="note"><p>The build dashboard plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The Build Dashboard plugin can be used to generate a single HTML dashboard that provides a single point of access to all of the reports generated by a build.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_dashboard_usage" class="section-anchor" href="#sec:build_dashboard_usage"></a>Usage</h2></div></div></div><p>To use the Build Dashboard plugin, include the following in your build script:</p><div class="example"><a name="useBuildDashboardPlugin"></a><p class="title"><b>Example&nbsp;218.&nbsp;Using the Build Dashboard plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'build-dashboard'</span>
</pre></div></div><br class="example-break"><p>Applying the plugin adds the <code class="literal">buildDashboard</code> task to your project. The task aggregates the reports for all tasks that implement the <a class="ulink" href="../dsl/org.gradle.api.reporting.Reporting.html" target="_top"><code class="classname">Reporting</code></a> interface from <span class="emphasis"><em>all projects</em></span> in the build. It is typically only applied to the root project.</p><p>The <code class="literal">buildDashboard</code> task does not depend on any other tasks. It will only aggregate the reporting tasks that are independently being executed as part of the build run. To generate the build dashboard, simply include this task in the list of tasks to execute. For example, &ldquo;<code class="literal">gradle buildDashboard build</code>&rdquo; will generate a dashboard for all of the reporting tasks that are dependents of the <code class="literal">build</code> task.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_dashboard_tasks" class="section-anchor" href="#sec:build_dashboard_tasks"></a>Tasks</h2></div></div></div><p>The Build Dashboard plugin adds the following task to the project:</p><div class="table"><p class="title"><b>Table&nbsp;22.&nbsp;Build Dashboard plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N13FD9"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">buildDashboard</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.reporting.GenerateBuildDashboard.html" target="_top"><code class="classname">GenerateBuildDashboard</code></a></p></td>
<td><p>Generates build dashboard report.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_dashboard_project_layout" class="section-anchor" href="#sec:build_dashboard_project_layout"></a>Project layout</h2></div></div></div><p>The Build Dashboard plugin does not require any particular project layout.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_dashboard_dependency_management" class="section-anchor" href="#sec:build_dashboard_dependency_management"></a>Dependency management</h2></div></div></div><p>The Build Dashboard plugin does not define any dependency configurations.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_dashboard_configuration" class="section-anchor" href="#sec:build_dashboard_configuration"></a>Configuration</h2></div></div></div><p>You can influence the location of build dashboard plugin generation via <a class="ulink" href="../dsl/org.gradle.api.reporting.ReportingExtension.html" target="_top"><code class="classname">ReportingExtension</code></a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="comparing_builds"></a>Comparing Builds</h1></div></div></div><div class="note"><p>Build comparison support is an <a class="link" href="#feature_lifecycle">incubating</a> feature. This means that it is incomplete and not yet at regular Gradle production quality. This also means that this Gradle User Guide chapter is a work in progress.</p></div><p>Gradle provides support for comparing the <span class="emphasis"><em>outcomes</em></span> (e.g. the produced binary archives) of two builds. There are several reasons why you may want to compare the outcomes of two builds. You may want to compare:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A build with a newer version of Gradle than it&rsquo;s currently using (i.e. upgrading the Gradle version).</p></li><li class="listitem"><p>A Gradle build with a build executed by another tool such as Apache Ant, Apache Maven or something else (i.e. migrating to Gradle).</p></li><li class="listitem"><p>The same Gradle build, with the same version, before and after a change to the build (i.e. testing build changes).</p></li></ul></div><p>By comparing builds in these scenarios you can make an informed decision about the Gradle upgrade, migration to Gradle or build change by understanding the differences in the outcomes. The comparison process produces a HTML report outlining which outcomes were found to be identical and identifying the differences between non-identical outcomes.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:definition_of_terms" class="section-anchor" href="#sec:definition_of_terms"></a>Definition of terms</h2></div></div></div><p>The following are the terms used for build comparison and their definitions.</p><div class="variablelist"><dl><dt><span class="term">&ldquo;Build&rdquo;</span></dt><dd><p>In the context of build comparison, a build is not necessarily a Gradle build. It can be any invokable &ldquo;process&rdquo; that produces observable &ldquo;outcomes&rdquo;. At least one of the builds in a comparison will be a Gradle build.</p></dd><dt><span class="term">&ldquo;Build Outcome&rdquo;</span></dt><dd><p>Something that happens in an observable manner during a build, such as the creation of a zip file or test execution. These are the things that are compared.</p></dd><dt><span class="term">&ldquo;Source Build&rdquo;</span></dt><dd><p>The build that comparisons are being made against, typically the build in its &ldquo;current&rdquo; state. In other words, the left hand side of the comparison.</p></dd><dt><span class="term">&ldquo;Target Build&rdquo;</span></dt><dd><p>The build that is being compared to the source build, typically the &ldquo;proposed&rdquo; build. In other words, the right hand side of the comparison.</p></dd><dt><span class="term">&ldquo;Host Build&rdquo;</span></dt><dd><p>The Gradle build that executes the comparison process. It may be the same project as either the &ldquo;target&rdquo; or &ldquo;source&rdquo; build or may be a completely separate project. It does not need to be the same Gradle version as the &ldquo;source&rdquo; or &ldquo;target&rdquo; builds. The host build must be run with Gradle 1.2 or newer.</p></dd><dt><span class="term">&ldquo;Compared Build Outcome&rdquo;</span></dt><dd><p>Build outcomes that are intended to be logically equivalent in the &ldquo;source&rdquo; and &ldquo;target&rdquo; builds, and are therefore meaningfully comparable.</p></dd><dt><span class="term">&ldquo;Uncompared Build Outcome&rdquo;</span></dt><dd><p>A build outcome is uncompared if a logical equivalent from the other build cannot be found (e.g. a build produces a zip file that the other build does not).</p></dd><dt><span class="term">&ldquo;Unknown Build Outcome&rdquo;</span></dt><dd><p>A build outcome that cannot be understood by the host build. This can occur when the source or target build is a newer Gradle version than the host build and that Gradle version exposes new outcome types. Unknown build outcomes can be compared in so far as they can be identified to be logically equivalent to an unknown build outcome in the other build, but no meaningful comparison of what the build outcome actually is can be performed. Using the latest Gradle version for the host build will avoid encountering unknown build outcomes.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:current_capabilities" class="section-anchor" href="#sec:current_capabilities"></a>Current Capabilities</h2></div></div></div><p>As this is an <a class="link" href="#feature_lifecycle">incubating</a> feature, a limited set of the eventual functionality has been implemented at this time.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:supported_builds" class="section-anchor" href="#sec:supported_builds"></a>Supported builds</h3></div></div></div><p>Only support for comparing Gradle builds is available at this time. Both the source and target build must execute with Gradle newer or equal to version <code class="literal">1.0</code>. The host build must be at least version <code class="literal">1.2</code>. If the host build is run with version <code class="literal">3.0</code> or newer, source and target builds must be at least version <code class="literal">1.2</code>. If the host build is run with a version older than <code class="literal">2.0</code>, source and target builds must be older than version <code class="literal">3.0</code>. So if you for example want to compare a build under version <code class="literal">1.1</code> with a build under version <code class="literal">3.0</code>, you have to execute the host build with a <code class="literal">2.x</code> version.</p><p>Future versions will provide support for executing builds from other build systems such as Apache Ant or Apache Maven, as well as support for executing arbitrary processes (e.g. shell script based builds)</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:supported_build_outcomes" class="section-anchor" href="#sec:supported_build_outcomes"></a>Supported build outcomes</h3></div></div></div><p>Only support for comparing build outcomes that are <code class="literal">zip</code> archives is supported at this time. This includes <code class="literal">jar</code>, <code class="literal">war</code> and <code class="literal">ear</code> archives.</p><p>Future versions will provide support for comparing outcomes such as test execution (i.e. which tests were executed, which tests failed, etc.)</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:comparing_gradle_builds" class="section-anchor" href="#sec:comparing_gradle_builds"></a>Comparing Gradle Builds</h2></div></div></div><p>The <code class="literal">compare-gradle-builds</code> plugin can be used to facilitate a comparison between two Gradle builds. The plugin adds a <a class="ulink" href="../dsl/org.gradle.api.plugins.buildcomparison.gradle.CompareGradleBuilds.html" target="_top"><code class="classname">CompareGradleBuilds</code></a> task named &ldquo;<code class="literal">compareGradleBuilds</code>&rdquo; to the project. The configuration of this task specifies what is to be compared. By default, it is configured to compare the current build with itself using the current Gradle version by executing the tasks: &ldquo;<code class="literal">clean assemble</code>&rdquo;.</p><pre class="programlisting">apply plugin: 'compare-gradle-builds'</pre><p>This task can be configured to change what is compared.</p><pre class="programlisting">compareGradleBuilds {
    sourceBuild {
        projectDir "/projects/project-a"
        gradleVersion "1.1"
    }
    targetBuild {
        projectDir "/projects/project-b"
        gradleVersion "1.2"
    }
}</pre><p>The example above specifies a comparison between two different projects using two different Gradle versions.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:trying_gradle_upgrades" class="section-anchor" href="#sec:trying_gradle_upgrades"></a>Trying Gradle upgrades</h3></div></div></div><p>You can use the build comparison functionality to very quickly try a new Gradle version with your build.</p><p>To try your current build with a different Gradle version, simply add the following to the <code class="literal">build.gradle</code> of the <span class="emphasis"><em>root project</em></span>.</p><pre class="programlisting">apply plugin: 'compare-gradle-builds'

compareGradleBuilds {
    targetBuild.gradleVersion = "&laquo;gradle version&raquo;"
}</pre><p>Then simply execute the <code class="literal">compareGradleBuilds</code> task. You will see the console output of the &ldquo;source&rdquo; and &ldquo;target&rdquo; builds as they are executing.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_comparison_result" class="section-anchor" href="#sec:the_comparison_result"></a>The comparison &ldquo;result&rdquo;</h3></div></div></div><p>If there are any differences between the <span class="emphasis"><em>compared outcomes</em></span>, the task will fail. The location of the HTML report providing insight into the comparison will be given. If all compared outcomes are found to be identical, and there are no uncompared outcomes, and there are no unknown build outcomes, the task will succeed.</p><p>You can configure the task to not fail on compared outcome differences by setting the <code class="literal">ignoreFailures</code> property to true.</p><pre class="programlisting">compareGradleBuilds {
    ignoreFailures = true
}</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:which_archives_are_compared" class="section-anchor" href="#sec:which_archives_are_compared"></a>Which archives are compared?</h3></div></div></div><p>For an archive to be a candidate for comparison, it must be added as an artifact of the archives configuration. Take a look at <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a> for more information on how to configure and add artifacts.</p><p>The archive must also have been produced by a <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.War.html" target="_top"><code class="classname">War</code></a>, <a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a> task. Future versions of Gradle will support increased flexibility in this area.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="artifact_management"></a>Publishing artifacts</h1></div></div></div><div class="note"><p>This chapter describes the <span class="emphasis"><em>original</em></span> publishing mechanism available in Gradle 1.0: in Gradle 1.3 a new mechanism for publishing was introduced. While this new mechanism is <a class="link" href="#feature_lifecycle">incubating</a> and not yet complete, it introduces some new concepts and features that do (and will) make Gradle publishing even more powerful.</p><p>You can read about the new publishing plugins in <a class="xref" href="#publishing_ivy"><i>Ivy Publishing (new)</i></a> and <a class="xref" href="#publishing_maven"><i>Maven Publishing (new)</i></a>. Please try them out and give us feedback.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:introduction" class="section-anchor" href="#sec:introduction"></a>Introduction</h2></div></div></div><p>This chapter is about how you declare the outgoing artifacts of your project, and how to work with them (e.g. upload them). We define the artifacts of the projects as the files the project provides to the outside world. This might be a library or a ZIP distribution or any other file. A project can publish as many artifacts as it wants.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:artifacts_and_configurations" class="section-anchor" href="#sec:artifacts_and_configurations"></a>Artifacts and configurations</h2></div></div></div><p>Like dependencies, artifacts are grouped by configurations. In fact, a configuration can contain both artifacts and dependencies at the same time.</p><p>For each configuration in your project, Gradle provides the tasks <code class="literal">upload<span class="emphasis"><em>ConfigurationName</em></span></code> and <code class="literal">build<span class="emphasis"><em>ConfigurationName</em></span></code>.<sup>[<a href="#ftn.N14148" name="N14148" class="footnote">12</a>]</sup> Execution of these tasks will build or upload the artifacts belonging to the respective configuration.</p><p><a class="xref" href="#tab:configurations">the section called &ldquo;Dependency configurations&rdquo;</a> shows the configurations added by the Java plugin. Two of the configurations are relevant for the usage with artifacts. The <code class="literal">archives</code> configuration is the standard configuration to assign your artifacts to. The Java plugin automatically assigns the default jar to this configuration. We will talk more about the <code class="literal">runtime</code> configuration in <a class="xref" href="#project_libraries">the section called &ldquo;More about project libraries&rdquo;</a>. As with dependencies, you can declare as many custom configurations as you like and assign artifacts to them.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_artifacts" class="section-anchor" href="#sec:declaring_artifacts"></a>Declaring artifacts</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:archive_task_artifacts" class="section-anchor" href="#sec:archive_task_artifacts"></a>Archive task artifacts</h3></div></div></div><p>You can use an archive task to define an artifact:</p><div class="example"><a name="archiveTaskArtifact"></a><p class="title"><b>Example&nbsp;219.&nbsp;Defining an artifact using an archive task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myJar(type: Jar)

artifacts {
    archives myJar
}
</pre></div></div><br class="example-break"><p>It is important to note that the custom archives you are creating as part of your build are not automatically assigned to any configuration. You have to explicitly do this assignment.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:file_artifacts" class="section-anchor" href="#sec:file_artifacts"></a>File artifacts</h3></div></div></div><p>You can also use a file to define an artifact:</p><div class="example"><a name="fileArtifact"></a><p class="title"><b>Example&nbsp;220.&nbsp;Defining an artifact using a file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">def someFile = file(<span class="hl-string">'build/somefile.txt'</span>)

artifacts {
    archives someFile
}
</pre></div></div><br class="example-break"><p>Gradle will figure out the properties of the artifact based on the name of the file. You can customize these properties:</p><div class="example"><a name="fileArtifact"></a><p class="title"><b>Example&nbsp;221.&nbsp;Customizing an artifact</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task myTask(type:  MyTaskType) {
    destFile = file(<span class="hl-string">'build/somefile.txt'</span>)
}

artifacts {
    archives(myTask.destFile) {
        name <span class="hl-string">'my-artifact'</span>
        type <span class="hl-string">'text'</span>
        builtBy myTask
    }
}
</pre></div></div><br class="example-break"><p>There is a map-based syntax for defining an artifact using a file. The map must include a <code class="literal">file</code> entry that defines the file. The map may include other artifact properties:</p><div class="example"><a name="fileArtifact"></a><p class="title"><b>Example&nbsp;222.&nbsp;Map syntax for defining an artifact using a file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task generate(type:  MyTaskType) {
    destFile = file(<span class="hl-string">'build/somefile.txt'</span>)
}

artifacts {
    archives file: generate.destFile, name: <span class="hl-string">'my-artifact'</span>, type: <span class="hl-string">'text'</span>, builtBy: generate
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:publishing_artifacts" class="section-anchor" href="#sec:publishing_artifacts"></a>Publishing artifacts</h2></div></div></div><p>We have said that there is a specific upload task for each configuration. Before you can do an upload, you have to configure the upload task and define where to publish the artifacts to. The repositories you have defined (as described in <a class="xref" href="#declaring_repositories"><i>Declaring Repositories</i></a>) are not automatically used for uploading. In fact, some of those repositories only allow downloading artifacts, not uploading. Here is an example of how you can configure the upload task of a configuration:</p><div class="example"><a name="uploading"></a><p class="title"><b>Example&nbsp;223.&nbsp;Configuration of the upload task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    flatDir {
        name <span class="hl-string">"fileRepo"</span>
        dirs <span class="hl-string">"repo"</span>
    }
}

uploadArchives {
    repositories {
        add project.repositories.fileRepo
        ivy {
            credentials {
                username <span class="hl-string">"username"</span>
                password <span class="hl-string">"pw"</span>
            }
            url <span class="hl-string">"http://repo.mycompany.com"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>As you can see, you can either use a reference to an existing repository or create a new repository.</p><p>If an upload repository is defined with multiple patterns, Gradle must choose a pattern to use for uploading each file. By default, Gradle will upload to the pattern defined by the <code class="literal">url</code> parameter, combined with the optional <code class="literal">layout</code> parameter. If no <code class="literal">url</code> parameter is supplied, then Gradle will use the first defined <code class="literal">artifactPattern</code> for uploading, or the first defined <code class="literal">ivyPattern</code> for uploading Ivy files, if this is set.</p><p>Uploading to a Maven repository is described in <a class="xref" href="#uploading_to_maven_repositories">the section called &ldquo;Interacting with Maven repositories&rdquo;</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="project_libraries" class="section-anchor" href="#project_libraries"></a>More about project libraries</h2></div></div></div><p>If your project is supposed to be used as a library, you need to define what are the artifacts of this library and what are the dependencies of these artifacts. The Java plugin adds a <code class="literal">runtime</code> configuration for this purpose, with the implicit assumption that the <code class="literal">runtime</code> dependencies are the dependencies of the artifact you want to publish. Of course this is fully customizable. You can add your own custom configuration or let the existing configurations extend from other configurations. You might have a different group of artifacts which have a different set of dependencies. This mechanism is very powerful and flexible.</p><p>If someone wants to use your project as a library, she simply needs to declare which configuration of the dependency to depend on. A Gradle dependency offers the <code class="literal">configuration</code> property to declare this. If this is not specified, the <code class="literal">default</code> configuration is used (see <a class="xref" href="#sub:scope_of_dependency_configurations">the section called &ldquo;Defining the scope of a dependency with configurations&rdquo;</a>). Using your project as a library can either happen from within a multi-project build or by retrieving your project from a repository. In the latter case, an <code class="literal">ivy.xml</code> descriptor in the repository is supposed to contain all the necessary information. If you work with Maven repositories you don&rsquo;t have the flexibility as described above. For how to publish to a Maven repository, see the section <a class="xref" href="#uploading_to_maven_repositories">the section called &ldquo;Interacting with Maven repositories&rdquo;</a>.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N14148" name="ftn.N14148" class="para">12</a>] </sup>To be exact, the Base plugin provides those tasks. This plugin is automatically applied if you use the Java plugin.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="maven_plugin"></a>The Maven Plugin</h1></div></div></div><div class="note"><p>This chapter is a work in progress</p></div><p>The Maven plugin adds support for deploying artifacts to Maven repositories.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:maven_usage" class="section-anchor" href="#sec:maven_usage"></a>Usage</h2></div></div></div><p>To use the Maven plugin, include the following in your build script:</p><div class="example"><a name="useMavenPlugin"></a><p class="title"><b>Example&nbsp;224.&nbsp;Using the Maven plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'maven'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:maven_tasks" class="section-anchor" href="#sec:maven_tasks"></a>Tasks</h2></div></div></div><p>The Maven plugin defines the following tasks:</p><div class="table"><p class="title"><b>Table&nbsp;23.&nbsp;Maven plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14202"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">install</code></p></td>
<td><p>All tasks that build the associated archives.</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Upload.html" target="_top"><code class="classname">Upload</code></a></p></td>
<td><p>Installs the associated artifacts to the local Maven cache, including Maven metadata generation. By default the install task is associated with the <code class="literal">archives</code> configuration. This configuration has by default only the default jar as an element. To learn more about installing to the local repository, see: <a class="xref" href="#sub:installing_to_the_local_repository">the section called &ldquo;Installing to the local repository&rdquo;</a></p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:maven_dependency_management" class="section-anchor" href="#sec:maven_dependency_management"></a>Dependency management</h2></div></div></div><p>The Maven plugin does not define any dependency configurations.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:maven_convention_properties" class="section-anchor" href="#sec:maven_convention_properties"></a>Convention properties</h2></div></div></div><p>The Maven plugin defines the following convention properties:</p><div class="table"><p class="title"><b>Table&nbsp;24.&nbsp;Maven plugin - properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1423F"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">mavenPomDir</code></p></td>
<td><p><code class="literal">File</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>${project.buildDir}</em></span>/poms</code></p></td>
<td><p>The directory where the generated POMs are written to.</p></td>
</tr><tr>
<td><p><code class="literal">conf2ScopeMappings</code></p></td>
<td><p><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/Conf2ScopeMappingContainer.html" target="_top"><code class="classname">Conf2ScopeMappingContainer</code></a></code></p></td>
<td><p><code class="literal">n/a</code></p></td>
<td><p>Instructions for mapping Gradle configurations to Maven scopes. See <a class="xref" href="#sub:dependency_mapping">the section called &ldquo;Dependency mapping&rdquo;</a>.</p></td>
</tr></tbody></table></div></div><p>These properties are provided by a <a class="ulink" href="../dsl/org.gradle.api.plugins.MavenPluginConvention.html" target="_top"><code class="classname">MavenPluginConvention</code></a> convention object.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:maven_convention_methods" class="section-anchor" href="#sec:maven_convention_methods"></a>Convention methods</h2></div></div></div><p>The maven plugin provides a factory method for creating a POM. This is useful if you need a POM without the context of uploading to a Maven repo.</p><div class="example"><a name="newPom"></a><p class="title"><b>Example&nbsp;225.&nbsp;Creating a standalone pom.</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task writeNewPom {
    doLast {
        pom {
            project {
                inceptionYear <span class="hl-string">'2008'</span>
                licenses {
                    license {
                        name <span class="hl-string">'The Apache Software License, Version 2.0'</span>
                        url <span class="hl-string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                        distribution <span class="hl-string">'repo'</span>
                    }
                }
            }
        }.writeTo(<span class="hl-string">"$buildDir/newpom.xml"</span>)
    }
}
</pre></div></div><br class="example-break"><p>Amongst other things, Gradle supports the same builder syntax as polyglot Maven. To learn more about the Gradle Maven POM object, see <a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/MavenPom.html" target="_top"><code class="classname">MavenPom</code></a>. See also: <a class="ulink" href="../dsl/org.gradle.api.plugins.MavenPluginConvention.html" target="_top"><code class="classname">MavenPluginConvention</code></a></p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="uploading_to_maven_repositories" class="section-anchor" href="#uploading_to_maven_repositories"></a>Interacting with Maven repositories</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:maven_upload_intro" class="section-anchor" href="#sec:maven_upload_intro"></a>Introduction</h3></div></div></div><p>With Gradle you can deploy to remote Maven repositories or install to your local Maven repository. This includes all Maven metadata manipulation and works also for Maven snapshots. In fact, Gradle&rsquo;s deployment is 100 percent Maven compatible as we use the native Maven Ant tasks under the hood.</p><p>Deploying to a Maven repository is only half the fun if you don&rsquo;t have a POM. Fortunately Gradle can generate this POM for you using the dependency information it has.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:deploying_to_a_maven_repository" class="section-anchor" href="#sec:deploying_to_a_maven_repository"></a>Deploying to a Maven repository</h3></div></div></div><p>Let&rsquo;s assume your project produces just the default jar file. Now you want to deploy this jar file to a remote Maven repository.</p><div class="example"><a name="uploadFile"></a><p class="title"><b>Example&nbsp;226.&nbsp;Upload of file to remote Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'maven'</span>

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://localhost/tmp/myRepo/"</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>That is all. Calling the <code class="literal">uploadArchives</code> task will generate the POM and deploys the artifact and the POM to the specified repository.</p><p>There is more work to do if you need support for protocols other than <code class="literal">file</code>. In this case the native Maven code we delegate to needs additional libraries. Which libraries are needed depends on what protocol you plan to use. The available protocols and the corresponding libraries are listed in <a class="xref" href="#wagonLibs" title="Table&nbsp;25.&nbsp;Protocol jars for Maven deployment">Table&nbsp;25</a> (those libraries have transitive dependencies which have transitive dependencies).<sup>[<a href="#ftn.N142D2" name="N142D2" class="footnote">13</a>]</sup> For example, to use the ssh protocol you can do:</p><div class="example"><a name="uploadWithSsh"></a><p class="title"><b>Example&nbsp;227.&nbsp;Upload of file via SSH</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    deployerJars
}

repositories {
    mavenCentral()
}

dependencies {
    deployerJars <span class="hl-string">"org.apache.maven.wagon:wagon-ssh:2.2"</span>
}

uploadArchives {
    repositories.mavenDeployer {
        configuration = configurations.deployerJars
        repository(url: <span class="hl-string">"scp://repos.mycompany.com/releases"</span>) {
            authentication(userName: <span class="hl-string">"me"</span>, password: <span class="hl-string">"myPassword"</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>There are many configuration options for the Maven deployer. The configuration is done via a Groovy builder. All the elements of this tree are Java beans. To configure the simple attributes you pass a map to the bean elements. To add bean elements to its parent, you use a closure. In the example above <span class="emphasis"><em>repository</em></span> and <span class="emphasis"><em>authentication</em></span> are such bean elements. <a class="xref" href="#deployerConfig" title="Table&nbsp;26.&nbsp;Configuration elements of the MavenDeployer">Table&nbsp;26</a> lists the available bean elements and a link to the Javadoc of the corresponding class. In the Javadoc you can see the possible attributes you can set for a particular element.</p><p>In Maven you can define repositories and optionally snapshot repositories. If no snapshot repository is defined, releases and snapshots are both deployed to the <code class="literal">repository</code> element. Otherwise snapshots are deployed to the <code class="literal">snapshotRepository</code> element.</p><div class="table"><p class="title"><b>Table&nbsp;25.&nbsp;Protocol jars for Maven deployment</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="wagonLibs"><thead><tr>
<td>Protocol</td>
<td>Library</td>
</tr></thead><tbody><tr>
<td><p>http</p></td>
<td><p>org.apache.maven.wagon:wagon-http:2.2</p></td>
</tr><tr>
<td><p>ssh</p></td>
<td><p>org.apache.maven.wagon:wagon-ssh:2.2</p></td>
</tr><tr>
<td><p>ssh-external</p></td>
<td><p>org.apache.maven.wagon:wagon-ssh-external:2.2</p></td>
</tr><tr>
<td><p>ftp</p></td>
<td><p>org.apache.maven.wagon:wagon-ftp:2.2</p></td>
</tr><tr>
<td><p>webdav</p></td>
<td><p>org.apache.maven.wagon:wagon-webdav:1.0-beta-2</p></td>
</tr><tr>
<td><p>file</p></td>
<td><p>-</p></td>
</tr></tbody></table></div></div><div class="table"><p class="title"><b>Table&nbsp;26.&nbsp;Configuration elements of the MavenDeployer</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="deployerConfig"><thead><tr>
<td>Element</td>
<td>Javadoc</td>
</tr></thead><tbody><tr>
<td><p>root</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html" target="_top"><code class="classname">MavenDeployer</code></a></p></td>
</tr><tr>
<td><p>repository</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RemoteRepository.html" target="_top">org.apache.maven.artifact.ant.RemoteRepository</a></p></td>
</tr><tr>
<td><p>authentication</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/Authentication.html" target="_top">org.apache.maven.artifact.ant.Authentication</a></p></td>
</tr><tr>
<td><p>releases</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RepositoryPolicy.html" target="_top">org.apache.maven.artifact.ant.RepositoryPolicy</a></p></td>
</tr><tr>
<td><p>snapshots</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RepositoryPolicy.html" target="_top">org.apache.maven.artifact.ant.RepositoryPolicy</a></p></td>
</tr><tr>
<td><p>proxy</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/Proxy.html" target="_top">org.apache.maven.artifact.ant.Proxy</a></p></td>
</tr><tr>
<td><p>snapshotRepository</p></td>
<td><p><a class="ulink" href="http://www.docjar.com/docs/api/org/apache/maven/artifact/ant/RemoteRepository.html" target="_top">org.apache.maven.artifact.ant.RemoteRepository</a></p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:installing_to_the_local_repository" class="section-anchor" href="#sub:installing_to_the_local_repository"></a>Installing to the local repository</h3></div></div></div><p>The Maven plugin adds an <code class="literal">install</code> task to your project. This task depends on all the archives task of the <code class="literal">archives</code> configuration. It installs those archives to your local Maven repository. If the default location for the local repository is redefined in a Maven <code class="literal">settings.xml</code>, this is considered by this task.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:maven_pom_generation" class="section-anchor" href="#sec:maven_pom_generation"></a>Maven POM generation</h3></div></div></div><p>When deploying an artifact to a Maven repository, Gradle automatically generates a POM for it. The <code class="literal">groupId</code>, <code class="literal">artifactId</code>, <code class="literal">version</code> and <code class="literal">packaging</code> elements used for the POM default to the values shown in the table below. The <code class="literal">dependency</code> elements are created from the project&rsquo;s dependency declarations.</p><div class="table"><p class="title"><b>Table&nbsp;27.&nbsp;Default Values for Maven POM generation</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N143CA"><thead><tr>
<td>Maven Element</td>
<td>Default Value</td>
</tr></thead><tbody><tr>
<td><p>groupId</p></td>
<td><p>project.group</p></td>
</tr><tr>
<td><p>artifactId</p></td>
<td><p>uploadTask.repositories.mavenDeployer.pom.artifactId (if set) or archiveTask.baseName.</p></td>
</tr><tr>
<td><p>version</p></td>
<td><p>project.version</p></td>
</tr><tr>
<td><p>packaging</p></td>
<td><p>archiveTask.extension</p></td>
</tr></tbody></table></div></div><p>Here, <code class="literal">uploadTask</code> and <code class="literal">archiveTask</code> refer to the tasks used for uploading and generating the archive, respectively (for example <code class="literal">uploadArchives</code> and <code class="literal">jar</code>). <code class="literal">archiveTask.baseName</code> defaults to <code class="literal">project.archivesBaseName</code> which in turn defaults to <code class="literal">project.name</code>.</p><div class="note"><p>When you set the &ldquo;<code class="literal">archiveTask.baseName</code>&rdquo; property to a value other than the default, you&rsquo;ll also have to set <code class="literal">uploadTask.repositories.mavenDeployer.pom.artifactId</code> to the same value. Otherwise, the project at hand may be referenced with the wrong artifact ID from generated POMs for other projects in the same build.</p></div><p>Generated POMs can be found in <code class="literal">&lt;buildDir&gt;/poms</code>. They can be further customized via the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/MavenPom.html" target="_top"><code class="classname">MavenPom</code></a> API. For example, you might want the artifact deployed to the Maven repository to have a different version or name than the artifact generated by Gradle. To customize these you can do:</p><div class="example"><a name="customizePom"></a><p class="title"><b>Example&nbsp;228.&nbsp;Customization of pom</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://localhost/tmp/myRepo/"</span>)
            pom.version = <span class="hl-string">'1.0Maven'</span>
            pom.artifactId = <span class="hl-string">'myMavenName'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>To add additional content to the POM, the <code class="literal">pom.project</code> builder can be used. With this builder, any element listed in the <a class="ulink" href="http://maven.apache.org/pom.html" target="_top">Maven POM reference</a> can be added.</p><div class="example"><a name="pomBuilder"></a><p class="title"><b>Example&nbsp;229.&nbsp;Builder style customization of pom</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://localhost/tmp/myRepo/"</span>)
            pom.project {
                licenses {
                    license {
                        name <span class="hl-string">'The Apache Software License, Version 2.0'</span>
                        url <span class="hl-string">'http://www.apache.org/licenses/LICENSE-2.0.txt'</span>
                        distribution <span class="hl-string">'repo'</span>
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note: <code class="literal">groupId</code>, <code class="literal">artifactId</code>, <code class="literal">version</code>, and <code class="literal">packaging</code> should always be set directly on the <code class="literal">pom</code> object.</p><div class="example"><a name="pomBuilder"></a><p class="title"><b>Example&nbsp;230.&nbsp;Modifying auto-generated content</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">def installer = install.repositories.mavenInstaller
def deployer = uploadArchives.repositories.mavenDeployer

[installer, deployer]*.pom*.whenConfigured {pom -&gt;
    pom.dependencies.find {dep -&gt; dep.groupId == <span class="hl-string">'group3'</span> &amp;&amp; dep.artifactId == <span class="hl-string">'runtime'</span> }.optional = true
}
</pre></div></div><br class="example-break"><p>If you have more than one artifact to publish, things work a little bit differently. See <a class="xref" href="#sub:multiple_artifacts_per_project">the section called &ldquo;Multiple artifacts per project&rdquo;</a>.</p><p>To customize the settings for the Maven installer (see <a class="xref" href="#sub:installing_to_the_local_repository">the section called &ldquo;Installing to the local repository&rdquo;</a>), you can do:</p><div class="example"><a name="customizeInstaller"></a><p class="title"><b>Example&nbsp;231.&nbsp;Customization of Maven installer</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">install {
    repositories.mavenInstaller {
        pom.version = <span class="hl-string">'1.0Maven'</span>
        pom.artifactId = <span class="hl-string">'myName'</span>
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sub:multiple_artifacts_per_project" class="section-anchor" href="#sub:multiple_artifacts_per_project"></a>Multiple artifacts per project</h4></div></div></div><p>Maven can only deal with one artifact per project. This is reflected in the structure of the Maven POM. We think there are many situations where it makes sense to have more than one artifact per project. In such a case you need to generate multiple POMs. In such a case you have to explicitly declare each artifact you want to publish to a Maven repository. The <a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/MavenDeployer.html" target="_top"><code class="classname">MavenDeployer</code></a> and the MavenInstaller both provide an API for this:</p><div class="example"><a name="multiplePoms"></a><p class="title"><b>Example&nbsp;232.&nbsp;Generation of multiple poms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://localhost/tmp/myRepo/"</span>)
            addFilter(<span class="hl-string">'api'</span>) {artifact, file -&gt;
                artifact.name == <span class="hl-string">'api'</span>
            }
            addFilter(<span class="hl-string">'service'</span>) {artifact, file -&gt;
                artifact.name == <span class="hl-string">'service'</span>
            }
            pom(<span class="hl-string">'api'</span>).version = <span class="hl-string">'mySpecialMavenVersion'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>You need to declare a filter for each artifact you want to publish. This filter defines a boolean expression for which Gradle artifact it accepts. Each filter has a POM associated with it which you can configure. To learn more about this have a look at <a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/PomFilterContainer.html" target="_top"><code class="classname">PomFilterContainer</code></a> and its associated classes.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sub:dependency_mapping" class="section-anchor" href="#sub:dependency_mapping"></a>Dependency mapping</h4></div></div></div><p>The Maven plugin configures the default mapping between the Gradle configurations added by the Java and War plugin and the Maven scopes. Most of the time you don&rsquo;t need to touch this and you can safely skip this section. The mapping works like the following. You can map a configuration to one and only one scope. Different configurations can be mapped to one or different scopes. You can also assign a priority to a particular configuration-to-scope mapping. Have a look at <a class="ulink" href="../javadoc/org/gradle/api/artifacts/maven/Conf2ScopeMappingContainer.html" target="_top"><code class="classname">Conf2ScopeMappingContainer</code></a> to learn more. To access the mapping configuration you can say:</p><div class="example"><a name="mappings"></a><p class="title"><b>Example&nbsp;233.&nbsp;Accessing a mapping configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task mappings {
    doLast {
        println conf2ScopeMappings.mappings
    }
}
</pre></div></div><br class="example-break"><p>Gradle exclude rules are converted to Maven excludes if possible. Such a conversion is possible if in the Gradle exclude rule the group as well as the module name is specified (as Maven needs both in contrast to Ivy). Per-configuration excludes are also included in the Maven POM, if they are convertible.</p></div></div></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N142D2" name="ftn.N142D2" class="para">13</a>] </sup>It is planned for a future release to provide out-of-the-box support for this</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="signing_plugin"></a>The Signing Plugin</h1></div></div></div><p>The signing plugin adds the ability to digitally sign built files and artifacts. These digital signatures can then be used to prove who built the artifact the signature is attached to as well as other information such as when the signature was generated.</p><p>The signing plugin currently only provides support for generating <a class="ulink" href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy#OpenPGP" target="_top">OpenPGP signatures</a> (which is the signature format <a class="ulink" href="http://central.sonatype.org/pages/requirements.html#sign-files-with-gpgpgp" target="_top">required for publication to the Maven Central Repository</a>).</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:signing_usage" class="section-anchor" href="#sec:signing_usage"></a>Usage</h2></div></div></div><p>To use the Signing plugin, include the following in your build script:</p><div class="example"><a name="useSigningPlugin"></a><p class="title"><b>Example&nbsp;234.&nbsp;Using the Signing plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'signing'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:signatory_credentials" class="section-anchor" href="#sec:signatory_credentials"></a>Signatory credentials</h2></div></div></div><p>In order to create OpenPGP signatures, you will need a key pair (instructions on creating a key pair using the <a class="ulink" href="https://www.gnupg.org/" target="_top">GnuPG tools</a> can be found in the <a class="ulink" href="https://www.gnupg.org/documentation/howtos.html" target="_top">GnuPG HOWTOs</a>). You need to provide the signing plugin with your key information, which means three things:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The public key ID (an 8 character hexadecimal string).</p></li><li class="listitem"><p>The absolute path to the secret key ring file containing your private key.</p></li><li class="listitem"><p>The passphrase used to protect your private key.</p></li></ul></div><p>These items must be supplied as the values of properties <code class="literal">signing.keyId</code>, <code class="literal">signing.secretKeyRingFile</code>, and <code class="literal">signing.password</code> respectively. Given the personal and private nature of these values, a good practice is to store them in the user <code class="literal">gradle.properties</code> file (described in <a class="xref" href="#sec:gradle_system_properties">the section called &ldquo;System properties&rdquo;</a>).</p><pre class="programlisting">signing.keyId=24875D73
signing.password=secret
signing.secretKeyRingFile=/Users/me/.gnupg/secring.gpg</pre><p>If specifying this information (especially <code class="literal">signing.password</code>) in the user <code class="literal">gradle.properties</code> file is not feasible for your environment, you can source the information however you need to and set the project properties manually.</p><pre class="programlisting">import org.gradle.plugins.signing.Sign

gradle.taskGraph.whenReady { taskGraph -&gt;
    if (taskGraph.allTasks.any { it instanceof Sign }) {
        // Use Java 6's console to read from the console (no good for
        // a CI environment)
        Console console = System.console()
        console.printf "\n\nWe have to sign some things in this build." +
                       "\n\nPlease enter your signing details.\n\n"

        def id = console.readLine("PGP Key Id: ")
        def file = console.readLine("PGP Secret Key Ring File (absolute path): ")
        def password = console.readPassword("PGP Private Key Password: ")

        allprojects { ext."signing.keyId" = id }
        allprojects { ext."signing.secretKeyRingFile" = file }
        allprojects { ext."signing.password" = password }

        console.printf "\nThanks.\n\n"
    }
}</pre><p>Note that the presence of a null value for any these three properties will cause an exception.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:subkeys" class="section-anchor" href="#sec:subkeys"></a>Using OpenPGP subkeys</h3></div></div></div><p>OpenPGP supports subkeys, which are like the normal keys, except they&rsquo;re bound to a master key pair. One feature of OpenPGP subkeys is that they can be revoked independently of the master keys which makes key management easier. A practical case study of how subkeys can be leveraged in software development can be read on the <a class="ulink" href="https://wiki.debian.org/Subkeys" target="_top">Debian wiki</a>.</p><p>The signing plugin supports OpenPGP subkeys out of the box. Just specify a subkey ID as the value in the <code class="literal">signing.keyId</code> property.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_gpg_agent" class="section-anchor" href="#sec:using_gpg_agent"></a>Using gpg-agent</h2></div></div></div><p>By default the signing plugin uses a Java-based implementation of PGP for signing. This implementation cannot use the gpg-agent program for managing private keys, though. If you want to use the gpg-agent, you can change the signatory implementation used by the signing plugin:</p><div class="example"><a name="useGnupg"></a><p class="title"><b>Example&nbsp;235.&nbsp;Sign with GnuPG</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">signing {
    useGpgCmd()
    sign configurations.archives
}
</pre></div></div><br class="example-break"><p>This tells the signing plugin to use the <code class="literal">GnupgSignatory</code> instead of the default <a class="ulink" href="../javadoc/org/gradle/plugins/signing/signatory/pgp/PgpSignatory.html" target="_top"><code class="classname">PgpSignatory</code></a>. The <code class="literal">GnupgSignatory</code> relies on the gpg2 program to sign the artifacts. Of course, this requires that GnuPG is installed.</p><p>Without any further configuration the <code class="literal">gpg2</code> (on Windows: <code class="literal">gpg2.exe</code>) executable found on the <code class="literal">PATH</code> will be used. The password is supplied by the <code class="literal">gpg-agent</code> and the default key is used for signing.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:sec:gnupg_signatory_configuration" class="section-anchor" href="#sec:sec:gnupg_signatory_configuration"></a>Gnupg signatory configuration</h3></div></div></div><p>The <code class="literal">GnupgSignatory</code> supports a number of configuration options for controlling how gpg is invoked. These are typically set in gradle.properties:</p><div class="example"><a name="configureGnupg"></a><p class="title"><b>Example&nbsp;236.&nbsp;Configure the GnupgSignatory</b></p><div class="example-contents"><p><code class="filename">gradle.properties</code></p><pre class="programlisting">signing.gnupg.executable=gpg
signing.gnupg.useLegacyGpg=true
signing.gnupg.homeDir=gnupg-home
signing.gnupg.optionsFile=gnupg-home/gpg.conf
signing.gnupg.keyName=24875D73
signing.gnupg.passphrase=gradle
</pre></div></div><br class="example-break"><div class="variablelist"><dl><dt><span class="term"><code class="literal">signing.gnupg.executable</code></span></dt><dd><p>The gpg executable that is invoked for signing. The default value of this property depends on <code class="literal">useLegacyGpg</code>. If that is <code class="literal">true</code> then the default value of executable is "gpg" otherwise it is "gpg2".</p></dd><dt><span class="term"><code class="literal">signing.gnupg.useLegacyGpg</code></span></dt><dd><p>Must be <code class="literal">true</code> if GnuPG version 1 is used and <code class="literal">false</code> otherwise. The default value of the property is <code class="literal">false</code>.</p></dd><dt><span class="term"><code class="literal">signing.gnupg.homeDir</code></span></dt><dd><p>Sets the home directory for GnuPG. If not given the default home directory of GnuPG is used.</p></dd><dt><span class="term"><code class="literal">signing.gnupg.optionsFile</code></span></dt><dd><p>Sets a custom options file for GnuPG. If not given GnuPG&rsquo;s default configuration file is used.</p></dd><dt><span class="term"><code class="literal">signing.gnupg.keyName</code></span></dt><dd><p>The id of the key that should be used for signing. If not given then the default key configured in GnuPG will be used.</p></dd><dt><span class="term"><code class="literal">signing.gnupg.passphrase</code></span></dt><dd><p>The passphrase for unlocking the secret key. If not given then the gpg-agent program is used for getting the passphrase.</p></dd></dl></div><p>All configuration properties are optional.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:specifying_what_to_sign" class="section-anchor" href="#sec:specifying_what_to_sign"></a>Specifying what to sign</h2></div></div></div><p>As well as configuring how things are to be signed (i.e. the signatory configuration), you must also specify what is to be signed. The Signing plugin provides a DSL that allows you to specify the tasks and/or configurations that should be signed.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:signing_configurations" class="section-anchor" href="#sec:signing_configurations"></a>Signing Configurations</h3></div></div></div><p>It is common to want to sign the artifacts of a configuration. For example, the <a class="link" href="#java_plugin">Java plugin</a> configures a jar to build and this jar artifact is added to the <code class="literal">archives</code> configuration. Using the Signing DSL, you can specify that all of the artifacts of this configuration should be signed.</p><div class="example"><a name="signingArchives"></a><p class="title"><b>Example&nbsp;237.&nbsp;Signing a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">signing {
    sign configurations.archives
}
</pre></div></div><br class="example-break"><p>This will create a task (of type <a class="ulink" href="../dsl/org.gradle.plugins.signing.Sign.html" target="_top"><code class="classname">Sign</code></a>) in your project named &ldquo;<code class="literal">signArchives</code>&rdquo;, that will build any <code class="literal">archives</code> artifacts (if needed) and then generate signatures for them. The signature files will be placed alongside the artifacts being signed.</p><div class="example"><a name="signingArchivesOutput"></a><p class="title"><b>Example&nbsp;238.&nbsp;Signing a configuration output</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle signArchives</code></strong></p><pre class="screen">&gt; gradle signArchives
:compileJava
:processResources
:classes
:jar
:signArchives

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:signing_tasks" class="section-anchor" href="#sec:signing_tasks"></a>Signing Tasks</h3></div></div></div><p>In some cases the artifact that you need to sign may not be part of a configuration. In this case you can directly sign the task that produces the artifact to sign.</p><div class="example"><a name="signingTasks"></a><p class="title"><b>Example&nbsp;239.&nbsp;Signing a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task stuffZip (type: Zip) {
    baseName = <span class="hl-string">"stuff"</span>
    from <span class="hl-string">"src/stuff"</span>
}

signing {
    sign stuffZip
}
</pre></div></div><br class="example-break"><p>This will create a task (of type <a class="ulink" href="../dsl/org.gradle.plugins.signing.Sign.html" target="_top"><code class="classname">Sign</code></a>) in your project named &ldquo;<code class="literal">signStuffZip</code>&rdquo;, that will build the input task&rsquo;s archive (if needed) and then sign it. The signature file will be placed alongside the artifact being signed.</p><div class="example"><a name="signingTaskOutput"></a><p class="title"><b>Example&nbsp;240.&nbsp;Signing a task output</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle signStuffZip</code></strong></p><pre class="screen">&gt; gradle signStuffZip
:stuffZip
:signStuffZip

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"><p>For a task to be &ldquo;signable&rdquo;, it must produce an archive of some type. Tasks that do this are the <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>, <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.War.html" target="_top"><code class="classname">War</code></a> and <a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a> tasks.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:conditional_signing" class="section-anchor" href="#sec:conditional_signing"></a>Conditional Signing</h3></div></div></div><p>A common usage pattern is to only sign build artifacts under certain conditions. For example, you may not wish to sign artifacts for non-release versions. To achieve this, you can specify that signing is only required under certain conditions.</p><div class="example"><a name="conditionalSigning"></a><p class="title"><b>Example&nbsp;241.&nbsp;Conditional signing</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">version = <span class="hl-string">'1.0-SNAPSHOT'</span>
ext.isReleaseVersion = !version.endsWith(<span class="hl-string">"SNAPSHOT"</span>)

signing {
    required { isReleaseVersion &amp;&amp; gradle.taskGraph.hasTask(<span class="hl-string">"uploadArchives"</span>) }
    sign configurations.archives
}
</pre></div></div><br class="example-break"><p>In this example, we only want to require signing if we are building a release version and we are going to publish it. Because we are inspecting the task graph to determine if we are going to be publishing, we must set the <code class="literal">signing.required</code> property to a closure to defer the evaluation. See <a class="ulink" href="../javadoc/org/gradle/plugins/signing/SigningExtension.html#setRequired-java.lang.Object-" target="_top"><code class="classname">SigningExtension.setRequired(java.lang.Object)</code></a> for more information.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:publishing_the_signatures" class="section-anchor" href="#sec:publishing_the_signatures"></a>Publishing the signatures</h2></div></div></div><p>When specifying what is to be signed via the Signing DSL, the resultant signature artifacts are automatically added to the <code class="literal">signatures</code> and <code class="literal">archives</code> dependency configurations. This means that if you want to upload your signatures to your distribution repository along with the artifacts you simply execute the <code class="literal">uploadArchives</code> task as normal.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:signing_pom_files" class="section-anchor" href="#sec:signing_pom_files"></a>Signing POM files</h2></div></div></div><div class="note"><p>Signing the generated POM file generated by the <a class="link" href="#publishing_maven">Maven Publishing plugin</a> is currently not supported. Future versions of Gradle might add this functionality.</p></div><p>When deploying signatures for your artifacts to a Maven repository, you will also want to sign the published POM file. The signing plugin adds a <code class="literal">signing.signPom()</code> (see: <a class="ulink" href="../dsl/org.gradle.plugins.signing.SigningExtension.html#org.gradle.plugins.signing.SigningExtension:signPom(org.gradle.api.artifacts.maven.MavenDeployment, groovy.lang.Closure)" target="_top"><code class="classname">SigningExtension.signPom(org.gradle.api.artifacts.maven.MavenDeployment, groovy.lang.Closure)</code></a>) method that can be used in the <code class="literal">beforeDeployment()</code> block in your upload task configuration.</p><div class="example"><a name="signingMavenPom"></a><p class="title"><b>Example&nbsp;242.&nbsp;Signing a POM for deployment</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
        mavenDeployer {
            beforeDeployment { MavenDeployment deployment -&gt; signing.signPom(deployment) }
        }
    }
}
</pre></div></div><br class="example-break"><p>When signing is not required and the POM cannot be signed due to insufficient configuration (i.e. no credentials for signing) then the <code class="literal">signPom()</code> method will silently do nothing.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="publishing_ivy"></a>Ivy Publishing (new)</h1></div></div></div><div class="note"><p>This chapter describes the new <a class="link" href="#feature_lifecycle">incubating</a> Ivy publishing support provided by the &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin. Eventually this new publishing support will replace publishing via the <code class="literal">Upload</code> task.</p><p>If you are looking for documentation on the original Ivy publishing support using the <code class="literal">Upload</code> task please see <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p></div><p>This chapter describes how to publish build artifacts in the <a class="ulink" href="http://ant.apache.org/ivy/" target="_top">Apache Ivy</a> format, usually to a repository for consumption by other builds or projects. What is published is one or more artifacts created by the build, and an Ivy <span class="emphasis"><em>module descriptor</em></span> (normally <code class="literal">ivy.xml</code>) that describes the artifacts and the dependencies of the artifacts, if any.</p><p>A published Ivy module can be consumed by Gradle (see <a class="xref" href="#declaring_dependencies"><i>Declaring Dependencies</i></a>) and other tools that understand the Ivy format.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:plugin" class="section-anchor" href="#publishing_ivy:plugin"></a>The &ldquo;<code class="literal">ivy-publish</code>&rdquo; Plugin</h2></div></div></div><p>The ability to publish in the Ivy format is provided by the &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin.</p><p>The &ldquo;<code class="literal">publishing</code>&rdquo; plugin creates an extension on the project named &ldquo;<code class="literal">publishing</code>&rdquo; of type <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html" target="_top"><code class="classname">PublishingExtension</code></a>. This extension provides a container of named publications and a container of named repositories. The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin works with <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> publications and <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html" target="_top"><code class="classname">IvyArtifactRepository</code></a> repositories.</p><div class="example"><a name="publishing_ivy:apply-plugin-snippet"></a><p class="title"><b>Example&nbsp;243.&nbsp;Applying the &ldquo;ivy-publish&rdquo; plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'ivy-publish'</span>
</pre></div></div><br class="example-break"><p>Applying the &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Applies the &ldquo;<code class="literal">publishing</code>&rdquo; plugin</p></li><li class="listitem"><p>Establishes a rule to automatically create a <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.GenerateIvyDescriptor.html" target="_top"><code class="classname">GenerateIvyDescriptor</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> added (see <a class="xref" href="#publishing_ivy:publications">the section called &ldquo;Publications&rdquo;</a>).</p></li><li class="listitem"><p>Establishes a rule to automatically create a <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html" target="_top"><code class="classname">PublishToIvyRepository</code></a> task for the combination of each <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> added (see <a class="xref" href="#publishing_ivy:publications">the section called &ldquo;Publications&rdquo;</a>), with each <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html" target="_top"><code class="classname">IvyArtifactRepository</code></a> added (see <a class="xref" href="#publishing_ivy:repositories">the section called &ldquo;Repositories&rdquo;</a>).</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:publications" class="section-anchor" href="#publishing_ivy:publications"></a>Publications</h2></div></div></div><div class="note"><p>If you are not familiar with project artifacts and configurations, you should read <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>, which introduces these concepts. This chapter also describes &ldquo;publishing artifacts&rdquo; using a different mechanism than what is described in this chapter. The publishing functionality described here will eventually supersede that functionality.</p></div><p>Publication objects describe the structure/configuration of a publication to be created. Publications are published to repositories via tasks, and the configuration of the publication object determines exactly what is published. All of the publications of a project are defined in the <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html#org.gradle.api.publish.PublishingExtension:publications" target="_top"><code class="classname">PublishingExtension.getPublications()</code></a> container. Each publication has a unique name within the project.</p><p>For the &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin to have any effect, an <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> must be added to the set of publications. This publication determines which artifacts are actually published as well as the details included in the associated Ivy module descriptor file. A publication can be configured by adding components, customizing artifacts, and by modifying the generated module descriptor file directly.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_component_to_ivy" class="section-anchor" href="#sec:publishing_component_to_ivy"></a>Publishing a Software Component</h3></div></div></div><p>The simplest way to publish a Gradle project to an Ivy repository is to specify a <a class="ulink" href="../javadoc/org/gradle/api/component/SoftwareComponent.html" target="_top"><code class="classname">SoftwareComponent</code></a> to publish. The components presently available for publication are:</p><div class="table"><p class="title"><b>Table&nbsp;28.&nbsp;Software Components</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14707"><thead><tr>
<td>Name</td>
<td>Provided By</td>
<td>Artifacts</td>
<td>Dependencies</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">java</code></p></td>
<td><p><a class="link" href="#java_plugin">Java Plugin</a></p></td>
<td><p>Generated jar file</p></td>
<td><p>Dependencies from 'runtime' configuration</p></td>
</tr><tr>
<td><p><code class="literal">web</code></p></td>
<td><p><a class="link" href="#war_plugin">War Plugin</a></p></td>
<td><p>Generated war file</p></td>
<td><p>No dependencies</p></td>
</tr></tbody></table></div></div><p>In the following example, artifacts and runtime dependencies are taken from the <code class="literal">java</code> component, which is added by the <code class="literal">Java Plugin</code>.</p><div class="example"><a name="publishing_ivy:publish-component-snippet"></a><p class="title"><b>Example&nbsp;244.&nbsp;Publishing a Java module to Ivy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publications {
    ivyJava(IvyPublication) {
        from components.java
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_custom_artifacts_to_ivy" class="section-anchor" href="#sec:publishing_custom_artifacts_to_ivy"></a>Publishing custom artifacts</h3></div></div></div><p>It is also possible to explicitly configure artifacts to be included in the publication. Artifacts are commonly supplied as raw files, or as instances of <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html" target="_top"><code class="classname">AbstractArchiveTask</code></a> (e.g. Jar, Zip).</p><p>For each custom artifact, it is possible to specify the <code class="literal">name</code>, <code class="literal">extension</code>, <code class="literal">type</code>, <code class="literal">classifier</code> and <code class="literal">conf</code> values to use for publication. Note that each artifacts must have a unique name/classifier/extension combination.</p><p>Configure custom artifacts as follows:</p><div class="example"><a name="publishing_ivy:publish-custom-artifact-snippet"></a><p class="title"><b>Example&nbsp;245.&nbsp;Publishing additional artifact to Ivy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task sourceJar(type: Jar) {
    from sourceSets.main.java
    classifier <span class="hl-string">"source"</span>
}
publishing {
    publications {
        ivy(IvyPublication) {
            from components.java
            artifact(sourceJar) {
                type <span class="hl-string">"source"</span>
                conf <span class="hl-string">"compile"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>See the <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> class in the API documentation for more detailed information on how artifacts can be customized.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:identity_values_for_the_published_project" class="section-anchor" href="#sec:identity_values_for_the_published_project"></a>Identity values for the published project</h3></div></div></div><p>The generated Ivy module descriptor file contains an <code class="literal">&lt;info&gt;</code> element that identifies the module. The default identity values are derived from the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">organisation</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:group" target="_top"><code class="classname">Project.getGroup()</code></a></p></li><li class="listitem"><p><code class="literal">module</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:name" target="_top"><code class="classname">Project.getName()</code></a></p></li><li class="listitem"><p><code class="literal">revision</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:version" target="_top"><code class="classname">Project.getVersion()</code></a></p></li><li class="listitem"><p><code class="literal">status</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:status" target="_top"><code class="classname">Project.getStatus()</code></a></p></li><li class="listitem"><p><code class="literal">branch</code> - (not set)</p></li></ul></div><p>Overriding the default identity values is easy: simply specify the <code class="literal">organisation</code>, <code class="literal">module</code> or <code class="literal">revision</code> attributes when configuring the <code class="literal">IvyPublication</code>. The <code class="literal">status</code> and <code class="literal">branch</code> attributes can be set via the <code class="literal">descriptor</code> property (see <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html" target="_top"><code class="classname">IvyModuleDescriptorSpec</code></a>). The <code class="literal">descriptor</code> property can also be used to add additional custom elements as children of the <code class="literal">&lt;info&gt;</code> element.</p><div class="example"><a name="publishing_ivy:publish-customize-identity"></a><p class="title"><b>Example&nbsp;246.&nbsp;customizing the publication identity</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publishing {
    publications {
        ivy(IvyPublication) {
            organisation <span class="hl-string">'org.gradle.sample'</span>
            module <span class="hl-string">'project1-sample'</span>
            revision <span class="hl-string">'1.1'</span>
            descriptor.status = <span class="hl-string">'milestone'</span>
            descriptor.branch = <span class="hl-string">'testing'</span>
            descriptor.extraInfo <span class="hl-string">'http://my.namespace'</span>, <span class="hl-string">'myElement'</span>, <span class="hl-string">'Some value'</span>

            from components.java
        }
    }
}
</pre></div></div><br class="example-break"><div class="tip"><p>Certain repositories are not able to handle all supported characters. For example, the ':' character cannot be used as an identifier when publishing to a filesystem-backed repository on Windows.</p></div><p>Gradle will handle any valid Unicode character for organisation, module and revision (as well as artifact name, extension and classifier). The only values that are explicitly prohibited are &lsquo;<code class="literal">\</code>&rsquo;, &lsquo;<code class="literal">/</code>&rsquo; and any ISO control character. The supplied values are validated early during publication.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:modifying_the_generated_module_descriptor" class="section-anchor" href="#sec:modifying_the_generated_module_descriptor"></a>Modifying the generated module descriptor</h3></div></div></div><p>At times, the module descriptor file generated from the project information will need to be tweaked before publishing. The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin provides a hook to allow such modification.</p><div class="example"><a name="publishing_ivy:descriptor-customization-snippet"></a><p class="title"><b>Example&nbsp;247.&nbsp;Customizing the module descriptor file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publications {
    ivyCustom(IvyPublication) {
        descriptor.withXml {
            asNode().info[<span class="hl-number">0</span>].appendNode(<span class="hl-string">'description'</span>,
                                        <span class="hl-string">'A demonstration of ivy descriptor customization'</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>In this example we are simply adding a 'description' element to the generated Ivy dependency descriptor, but this hook allows you to modify any aspect of the generated descriptor. For example, you could replace the version range for a dependency with the actual version used to produce the build.</p><p>See <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyModuleDescriptorSpec.html#org.gradle.api.publish.ivy.IvyModuleDescriptorSpec:withXml(org.gradle.api.Action)" target="_top"><code class="classname">IvyModuleDescriptorSpec.withXml(org.gradle.api.Action)</code></a> in the API documentation for more information.</p><p>It is possible to modify virtually any aspect of the created descriptor should you need to. This means that it is also possible to modify the descriptor in such a way that it is no longer a valid Ivy module descriptor, so care must be taken when using this feature.</p><p>The identifier (organisation, module, revision) of the published module is an exception; these values cannot be modified in the descriptor using the <code class="literal">withXML</code> hook.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_multiple_modules_to_ivy" class="section-anchor" href="#sec:publishing_multiple_modules_to_ivy"></a>Publishing multiple modules</h3></div></div></div><p>Sometimes it&rsquo;s useful to publish multiple modules from your Gradle build, without creating a separate Gradle subproject. An example is publishing a separate API and implementation jar for your library. With Gradle this is simple:</p><div class="example"><a name="publishing_ivy:publish-multiple-publications"></a><p class="title"><b>Example&nbsp;248.&nbsp;Publishing multiple modules from a single project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task apiJar(type: Jar) {
    baseName <span class="hl-string">"publishing-api"</span>
    from sourceSets.main.output
    exclude <span class="hl-string">'**/impl/**'</span>
}
publishing {
    publications {
        impl(IvyPublication) {
            organisation <span class="hl-string">'org.gradle.sample.impl'</span>
            module <span class="hl-string">'project2-impl'</span>
            revision <span class="hl-string">'2.3'</span>

            from components.java
        }
        api(IvyPublication) {
            organisation <span class="hl-string">'org.gradle.sample'</span>
            module <span class="hl-string">'project2-api'</span>
            revision <span class="hl-string">'2'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>If a project defines multiple publications then Gradle will publish each of these to the defined repositories. Each publication must be given a unique identity as described above.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:repositories" class="section-anchor" href="#publishing_ivy:repositories"></a>Repositories</h2></div></div></div><p>Publications are published to repositories. The repositories to publish to are defined by the <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html#org.gradle.api.publish.PublishingExtension:repositories" target="_top"><code class="classname">PublishingExtension.getRepositories()</code></a> container.</p><div class="example"><a name="publishing_ivy:sample_repositories"></a><p class="title"><b>Example&nbsp;249.&nbsp;Declaring repositories to publish to</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        <span class="hl-comment">// change to point to your repo, e.g. http://my.org/repo</span>
        url <span class="hl-string">"$buildDir/repo"</span>
    }
}
</pre></div></div><br class="example-break"><p>The DSL used to declare repositories for publishing is the same DSL that is used to declare repositories for dependencies (<a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html" target="_top"><code class="classname">RepositoryHandler</code></a>). However, in the context of Ivy publication only the repositories created by the <code class="literal">ivy()</code> methods can be used as publication destinations. You cannot publish an <code class="literal">IvyPublication</code> to a Maven repository for example.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:publishing" class="section-anchor" href="#publishing_ivy:publishing"></a>Performing a publish</h2></div></div></div><p>The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin automatically creates a <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html" target="_top"><code class="classname">PublishToIvyRepository</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a> and <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html" target="_top"><code class="classname">IvyArtifactRepository</code></a> combination in the <code class="literal">publishing.publications</code> and <code class="literal">publishing.repositories</code> containers respectively.</p><p>The created task is named &ldquo;<code class="literal">publish&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;PublicationTo&laquo;<span class="emphasis"><em>REPONAME</em></span>&raquo;Repository</code>&rdquo;, which is &ldquo;<code class="literal">publishIvyJavaPublicationToIvyRepository</code>&rdquo; for this example. This task is of type <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html" target="_top"><code class="classname">PublishToIvyRepository</code></a>.</p><div class="example"><a name="publishingIvyPublishSingle"></a><p class="title"><b>Example&nbsp;250.&nbsp;Choosing a particular publication to publish</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
apply plugin: <span class="hl-string">'ivy-publish'</span>

group = <span class="hl-string">'org.gradle.sample'</span>
version = <span class="hl-string">'1.0'</span>

publishing {
    publications {
        ivyJava(IvyPublication) {
            from components.java
        }
    }
    repositories {
        ivy {
            <span class="hl-comment">// change to point to your repo, e.g. http://my.org/repo</span>
            url <span class="hl-string">"$buildDir/repo"</span>
        }
    }
}

</pre><p>Output of <strong class="userinput"><code>gradle publishIvyJavaPublicationToIvyRepository</code></strong></p><pre class="screen">&gt; gradle publishIvyJavaPublicationToIvyRepository
:generateDescriptorFileForIvyJavaPublication
:compileJava NO-SOURCE
:processResources NO-SOURCE
:classes UP-TO-DATE
:jar
:publishIvyJavaPublicationToIvyRepository

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_publish_lifecycle_task" class="section-anchor" href="#sec:the_publish_lifecycle_task"></a>The &ldquo;<code class="literal">publish</code>&rdquo; lifecycle task</h3></div></div></div><p>The &ldquo;<code class="literal">publish</code>&rdquo; plugin (that the &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin implicitly applies) adds a lifecycle task that can be used to publish all publications to all applicable repositories named &ldquo;<code class="literal">publish</code>&rdquo;.</p><p>In more concrete terms, executing this task will execute all <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html" target="_top"><code class="classname">PublishToIvyRepository</code></a> tasks in the project. This is usually the most convenient way to perform a publish.</p><div class="example"><a name="publishingIvyPublishLifecycle"></a><p class="title"><b>Example&nbsp;251.&nbsp;Publishing all publications via the &ldquo;publish&rdquo; lifecycle task</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle publish</code></strong></p><pre class="screen">&gt; gradle publish
:generateDescriptorFileForIvyJavaPublication
:compileJava NO-SOURCE
:processResources NO-SOURCE
:classes UP-TO-DATE
:jar
:publishIvyJavaPublicationToIvyRepository
:publish

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:descriptor" class="section-anchor" href="#publishing_ivy:descriptor"></a>Generating the Ivy module descriptor file without publishing</h2></div></div></div><p>At times it is useful to generate the Ivy module descriptor file (normally <code class="literal">ivy.xml</code>) without publishing your module to an Ivy repository. Since descriptor file generation is performed by a separate task, this is very easy to do.</p><p>The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin creates one <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.GenerateIvyDescriptor.html" target="_top"><code class="classname">GenerateIvyDescriptor</code></a> task for each registered <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.IvyPublication.html" target="_top"><code class="classname">IvyPublication</code></a>, named &ldquo;<code class="literal">generateDescriptorFileFor&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;Publication</code>&rdquo;, which will be &ldquo;<code class="literal">generateDescriptorFileForIvyJavaPublication</code>&rdquo; for the previous example of the &ldquo;<code class="literal">ivyJava</code>&rdquo; publication.</p><p>You can specify where the generated Ivy file will be located by setting the <code class="literal">destination</code> property on the generated task. By default this file is written to &ldquo;<code class="literal">build/publications/&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;/ivy.xml</code>&rdquo;.</p><div class="example"><a name="publishingIvyGenerateDescriptor"></a><p class="title"><b>Example&nbsp;252.&nbsp;Generating the Ivy module descriptor file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    tasks.generateDescriptorFileForIvyCustomPublication {
        destination = file(<span class="hl-string">"$buildDir/generated-ivy.xml"</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle generateDescriptorFileForIvyCustomPublication</code></strong></p><pre class="screen">&gt; gradle generateDescriptorFileForIvyCustomPublication
:generateDescriptorFileForIvyCustomPublication

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><div class="note"><p>The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin leverages some experimental support for late plugin configuration, and the <code class="literal">GenerateIvyDescriptor</code> task will not be constructed until the publishing extension is configured. The simplest way to ensure that the publishing plugin is configured when you attempt to access the <code class="literal">GenerateIvyDescriptor</code> task is to place the access inside a <code class="literal">model</code> block, as the example above demonstrates.</p><p>The same applies to any attempt to access publication-specific tasks like <a class="ulink" href="../dsl/org.gradle.api.publish.ivy.tasks.PublishToIvyRepository.html" target="_top"><code class="classname">PublishToIvyRepository</code></a>. These tasks should be referenced from within a <code class="literal">model</code> block.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:example" class="section-anchor" href="#publishing_ivy:example"></a>Complete example</h2></div></div></div><p>The following example demonstrates publishing with a multi-project build. Each project publishes a Java component and a configured additional source artifact. The descriptor file is customized to include the project description for each project.</p><div class="example"><a name="publishing_ivy:complete_example"></a><p class="title"><b>Example&nbsp;253.&nbsp;Publishing a Java module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    apply plugin: <span class="hl-string">'java'</span>
    apply plugin: <span class="hl-string">'ivy-publish'</span>

    version = <span class="hl-string">'1.0'</span>
    group = <span class="hl-string">'org.gradle.sample'</span>

    repositories {
        mavenCentral()
    }
    task sourceJar(type: Jar) {
        from sourceSets.main.java
        classifier <span class="hl-string">"source"</span>
    }
}

project(<span class="hl-string">":project1"</span>) {
    description = <span class="hl-string">"The first project"</span>

    dependencies {
       compile <span class="hl-string">'junit:junit:4.12'</span>, project(<span class="hl-string">':project2'</span>)
    }
}

project(<span class="hl-string">":project2"</span>) {
    description = <span class="hl-string">"The second project"</span>

    dependencies {
       compile <span class="hl-string">'commons-collections:commons-collections:3.2.2'</span>
    }
}

subprojects {
    publishing {
        repositories {
            ivy {
                <span class="hl-comment">// change to point to your repo, e.g. http://my.org/repo</span>
                url <span class="hl-string">"${rootProject.buildDir}/repo"</span>
            }
        }
        publications {
            ivy(IvyPublication) {
                from components.java
                artifact(sourceJar) {
                    type <span class="hl-string">"source"</span>
                    conf <span class="hl-string">"compile"</span>
                }
                descriptor.withXml {
                    asNode().info[<span class="hl-number">0</span>].appendNode(<span class="hl-string">'description'</span>, description)
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>The result is that the following artifacts will be published for each project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The Ivy module descriptor file: &ldquo;<code class="literal">ivy-1.0.xml</code>&rdquo;.</p></li><li class="listitem"><p>The primary &ldquo;jar&rdquo; artifact for the Java component: &ldquo;<code class="literal">project1-1.0.jar</code>&rdquo;.</p></li><li class="listitem"><p>The source &ldquo;jar&rdquo; artifact that has been explicitly configured: &ldquo;<code class="literal">project1-1.0-source.jar</code>&rdquo;.</p></li></ul></div><p>When <code class="literal">project1</code> is published, the module descriptor (i.e. the <code class="literal">ivy.xml</code> file) that is produced will look like:</p><div class="tip"><p>Note that <code class="literal">&laquo;PUBLICATION-TIME-STAMP&raquo;</code> in this example Ivy module descriptor will be the timestamp of when the descriptor was generated.</p></div><div class="example"><a name="publishing_ivy:output_ivy.xml"></a><p class="title"><b>Example&nbsp;254.&nbsp;Example generated ivy.xml</b></p><div class="example-contents"><p><code class="filename">output-ivy.xml</code></p><pre class="programlisting"><span style="color: maroon" class="hl-directive">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hl-tag">&lt;ivy-module</span> <span class="hl-attribute">version</span>=<span class="hl-value">"2.0"</span><span class="hl-tag">&gt;</span>
  <span class="hl-tag">&lt;info</span> <span class="hl-attribute">organisation</span>=<span class="hl-value">"org.gradle.sample"</span> <span class="hl-attribute">module</span>=<span class="hl-value">"project1"</span> <span class="hl-attribute">revision</span>=<span class="hl-value">"1.0"</span> <span class="hl-attribute">status</span>=<span class="hl-value">"integration"</span> <span class="hl-attribute">publication</span>=<span class="hl-value">"&laquo;PUBLICATION-TIME-STAMP&raquo;"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;description&gt;</span>The first project<span class="hl-tag">&lt;/description&gt;</span>
  <span class="hl-tag">&lt;/info&gt;</span>
  <span class="hl-tag">&lt;configurations&gt;</span>
    <span class="hl-tag">&lt;conf</span> <span class="hl-attribute">name</span>=<span class="hl-value">"compile"</span> <span class="hl-attribute">visibility</span>=<span class="hl-value">"public"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;conf</span> <span class="hl-attribute">name</span>=<span class="hl-value">"default"</span> <span class="hl-attribute">visibility</span>=<span class="hl-value">"public"</span> <span class="hl-attribute">extends</span>=<span class="hl-value">"compile,runtime"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;conf</span> <span class="hl-attribute">name</span>=<span class="hl-value">"runtime"</span> <span class="hl-attribute">visibility</span>=<span class="hl-value">"public"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/configurations&gt;</span>
  <span class="hl-tag">&lt;publications&gt;</span>
    <span class="hl-tag">&lt;artifact</span> <span class="hl-attribute">name</span>=<span class="hl-value">"project1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"jar"</span> <span class="hl-attribute">ext</span>=<span class="hl-value">"jar"</span> <span class="hl-attribute">conf</span>=<span class="hl-value">"compile"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;artifact</span> <span class="hl-attribute">name</span>=<span class="hl-value">"project1"</span> <span class="hl-attribute">type</span>=<span class="hl-value">"source"</span> <span class="hl-attribute">ext</span>=<span class="hl-value">"jar"</span> <span class="hl-attribute">conf</span>=<span class="hl-value">"compile"</span> <span class="hl-attribute">m:classifier</span>=<span class="hl-value">"source"</span> <span class="hl-attribute">xmlns:m</span>=<span class="hl-value">"http://ant.apache.org/ivy/maven"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/publications&gt;</span>
  <span class="hl-tag">&lt;dependencies&gt;</span>
    <span class="hl-tag">&lt;dependency</span> <span class="hl-attribute">org</span>=<span class="hl-value">"junit"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"junit"</span> <span class="hl-attribute">rev</span>=<span class="hl-value">"4.12"</span> <span class="hl-attribute">conf</span>=<span class="hl-value">"compile-&amp;gt;default"</span><span class="hl-tag">/&gt;</span>
    <span class="hl-tag">&lt;dependency</span> <span class="hl-attribute">org</span>=<span class="hl-value">"org.gradle.sample"</span> <span class="hl-attribute">name</span>=<span class="hl-value">"project2"</span> <span class="hl-attribute">rev</span>=<span class="hl-value">"1.0"</span> <span class="hl-attribute">conf</span>=<span class="hl-value">"compile-&amp;gt;default"</span><span class="hl-tag">/&gt;</span>
  <span class="hl-tag">&lt;/dependencies&gt;</span>
<span class="hl-tag">&lt;/ivy-module&gt;</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_ivy:future" class="section-anchor" href="#publishing_ivy:future"></a>Future features</h2></div></div></div><p>The &ldquo;<code class="literal">ivy-publish</code>&rdquo; plugin functionality as described above is incomplete, as the feature is still <a class="link" href="#feature_lifecycle">incubating</a>. In upcoming Gradle releases, the functionality will be expanded to include (but not limited to):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Convenient customization of module attributes (<code class="literal">module</code>, <code class="literal">organisation</code> etc.)</p></li><li class="listitem"><p>Convenient customization of dependencies reported in <code class="literal">module descriptor</code>.</p></li><li class="listitem"><p>Multiple discrete publications per project</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="publishing_maven"></a>Maven Publishing (new)</h1></div></div></div><div class="note"><p>This chapter describes the new <a class="link" href="#feature_lifecycle">incubating</a> Maven publishing support provided by the &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin. Eventually this new publishing support will replace publishing via the <code class="literal">Upload</code> task.</p><p><span class="emphasis"><em>Note:</em></span> Signing the generated POM file generated by this plugin is currently not supported. Future versions of Gradle might add this functionality. Please use the <a class="link" href="#maven_plugin">Maven plugin</a> for the purpose of publishing your artifacts to Maven Central.</p><p>If you are looking for documentation on the original Maven publishing support using the <code class="literal">Upload</code> task please see <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p></div><p>This chapter describes how to publish build artifacts to an <a class="ulink" href="http://maven.apache.org/" target="_top">Apache Maven</a> Repository. A module published to a Maven repository can be consumed by Maven, Gradle (see <a class="xref" href="#declaring_dependencies"><i>Declaring Dependencies</i></a>) and other tools that understand the Maven repository format.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:the_mavenpublish_plugin" class="section-anchor" href="#sec:the_mavenpublish_plugin"></a>The &ldquo;<code class="literal">maven-publish</code>&rdquo; Plugin</h2></div></div></div><p>The ability to publish in the Maven format is provided by the &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin.</p><p>The &ldquo;<code class="literal">publishing</code>&rdquo; plugin creates an extension on the project named &ldquo;<code class="literal">publishing</code>&rdquo; of type <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html" target="_top"><code class="classname">PublishingExtension</code></a>. This extension provides a container of named publications and a container of named repositories. The &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin works with <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> publications and <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html" target="_top"><code class="classname">MavenArtifactRepository</code></a> repositories.</p><div class="example"><a name="publishing_maven:apply_plugin"></a><p class="title"><b>Example&nbsp;255.&nbsp;Applying the 'maven-publish' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'maven-publish'</span>
</pre></div></div><br class="example-break"><p>Applying the &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin does the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Applies the &ldquo;<code class="literal">publishing</code>&rdquo; plugin</p></li><li class="listitem"><p>Establishes a rule to automatically create a <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html" target="_top"><code class="classname">GenerateMavenPom</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> added (see <a class="xref" href="#publishing_maven:publications">the section called &ldquo;Publications&rdquo;</a>).</p></li><li class="listitem"><p>Establishes a rule to automatically create a <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html" target="_top"><code class="classname">PublishToMavenRepository</code></a> task for the combination of each <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> added (see <a class="xref" href="#publishing_maven:publications">the section called &ldquo;Publications&rdquo;</a>), with each <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html" target="_top"><code class="classname">MavenArtifactRepository</code></a> added (see <a class="xref" href="#publishing_maven:repositories">the section called &ldquo;Repositories&rdquo;</a>).</p></li><li class="listitem"><p>Establishes a rule to automatically create a <a class="ulink" href="../javadoc/org/gradle/api/publish/maven/tasks/PublishToMavenLocal.html" target="_top"><code class="classname">PublishToMavenLocal</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> added (see<a class="xref" href="#publishing_maven:publications">the section called &ldquo;Publications&rdquo;</a>).</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_maven:publications" class="section-anchor" href="#publishing_maven:publications"></a>Publications</h2></div></div></div><div class="note"><p>If you are not familiar with project artifacts and configurations, you should read the <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a> that introduces these concepts. This chapter also describes &ldquo;publishing artifacts&rdquo; using a different mechanism than what is described in this chapter. The publishing functionality described here will eventually supersede that functionality.</p></div><p>Publication objects describe the structure/configuration of a publication to be created. Publications are published to repositories via tasks, and the configuration of the publication object determines exactly what is published. All of the publications of a project are defined in the <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html#org.gradle.api.publish.PublishingExtension:publications" target="_top"><code class="classname">PublishingExtension.getPublications()</code></a> container. Each publication has a unique name within the project.</p><p>For the &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin to have any effect, a <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> must be added to the set of publications. This publication determines which artifacts are actually published as well as the details included in the associated POM file. A publication can be configured by adding components, customizing artifacts, and by modifying the generated POM file directly.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_component_to_maven" class="section-anchor" href="#sec:publishing_component_to_maven"></a>Publishing a Software Component</h3></div></div></div><p>The simplest way to publish a Gradle project to a Maven repository is to specify a <a class="ulink" href="../javadoc/org/gradle/api/component/SoftwareComponent.html" target="_top"><code class="classname">SoftwareComponent</code></a> to publish. The components presently available for publication are:</p><div class="table"><p class="title"><b>Table&nbsp;29.&nbsp;Software Components</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14A27"><thead><tr>
<td>Name</td>
<td>Provided By</td>
<td>Artifacts</td>
<td>Dependencies</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">java</code></p></td>
<td><p><a class="xref" href="#java_plugin"><i>The Java Plugin</i></a></p></td>
<td><p>Generated jar file</p></td>
<td><p>Dependencies from 'runtime' configuration</p></td>
</tr><tr>
<td><p><code class="literal">web</code></p></td>
<td><p><a class="xref" href="#war_plugin"><i>The War Plugin</i></a></p></td>
<td><p>Generated war file</p></td>
<td><p>No dependencies</p></td>
</tr></tbody></table></div></div><p>In the following example, artifacts and runtime dependencies are taken from the <code class="literal">java</code> component, which is added by the <code class="literal">Java Plugin</code>.</p><div class="example"><a name="publishing_maven:publish-component"></a><p class="title"><b>Example&nbsp;256.&nbsp;Adding a MavenPublication for a Java component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_custom_artifacts_to_maven" class="section-anchor" href="#sec:publishing_custom_artifacts_to_maven"></a>Publishing custom artifacts</h3></div></div></div><p>It is also possible to explicitly configure artifacts to be included in the publication. Artifacts are commonly supplied as raw files, or as instances of <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.AbstractArchiveTask.html" target="_top"><code class="classname">AbstractArchiveTask</code></a> (e.g. Jar, Zip).</p><p>For each custom artifact, it is possible to specify the <code class="literal">extension</code> and <code class="literal">classifier</code> values to use for publication. Note that only one of the published artifacts can have an empty classifier, and all other artifacts must have a unique classifier/extension combination.</p><p>Configure custom artifacts as follows:</p><div class="example"><a name="publishing_maven:publish-custom-artifact"></a><p class="title"><b>Example&nbsp;257.&nbsp;Adding additional artifact to a MavenPublication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task sourceJar(type: Jar) {
    from sourceSets.main.allJava
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java

            artifact sourceJar {
                classifier <span class="hl-string">"sources"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>See the <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> class in the API documentation for more information about how artifacts can be customized.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:identity_values_in_the_generated_pom" class="section-anchor" href="#sec:identity_values_in_the_generated_pom"></a>Identity values in the generated POM</h3></div></div></div><p>The attributes of the generated <code class="literal">POM</code> file will contain identity values derived from the following project properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">groupId</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:group" target="_top"><code class="classname">Project.getGroup()</code></a></p></li><li class="listitem"><p><code class="literal">artifactId</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:name" target="_top"><code class="classname">Project.getName()</code></a></p></li><li class="listitem"><p><code class="literal">version</code> - <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:version" target="_top"><code class="classname">Project.getVersion()</code></a></p></li></ul></div><p>Overriding the default identity values is easy: simply specify the <code class="literal">groupId</code>, <code class="literal">artifactId</code> or <code class="literal">version</code> attributes when configuring the <code class="literal">MavenPublication</code>.</p><div class="example"><a name="publishing_maven:publish-customize-identity"></a><p class="title"><b>Example&nbsp;258.&nbsp;customizing the publication identity</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publishing {
    publications {
        maven(MavenPublication) {
            groupId <span class="hl-string">'org.gradle.sample'</span>
            artifactId <span class="hl-string">'project1-sample'</span>
            version <span class="hl-string">'1.1'</span>

            from components.java
        }
    }
}
</pre></div></div><br class="example-break"><div class="tip"><p>Certain repositories will not be able to handle all supported characters. For example, the ':' character cannot be used as an identifier when publishing to a filesystem-backed repository on Windows.</p></div><p>Maven restricts 'groupId' and 'artifactId' to a limited character set (<code class="literal">[A-Za-z0-9_\\-.]+</code>) and Gradle enforces this restriction. For 'version' (as well as artifact 'extension' and 'classifier'), Gradle will handle any valid Unicode character.</p><p>The only Unicode values that are explicitly prohibited are &lsquo;<code class="literal">\</code>&rsquo;, &lsquo;<code class="literal">/</code>&rsquo; and any ISO control character. Supplied values are validated early in publication.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:modifying_the_generated_pom" class="section-anchor" href="#sec:modifying_the_generated_pom"></a>Modifying the generated POM</h3></div></div></div><p>The generated POM file may need to be tweaked before publishing. The &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin provides a hook to allow such modification.</p><div class="example"><a name="publishing_maven:pom_modification"></a><p class="title"><b>Example&nbsp;259.&nbsp;Modifying the POM file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publications {
    mavenCustom(MavenPublication) {
        pom.withXml {
            asNode().appendNode(<span class="hl-string">'description'</span>,
                                <span class="hl-string">'A demonstration of maven POM customization'</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>In this example we are adding a 'description' element for the generated POM. With this hook, you can modify any aspect of the POM. For example, you could replace the version range for a dependency with the actual version used to produce the build.</p><p>See <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPom.html#org.gradle.api.publish.maven.MavenPom:withXml(org.gradle.api.Action)" target="_top"><code class="classname">MavenPom.withXml(org.gradle.api.Action)</code></a> in the API documentation for more information.</p><p>It is possible to modify virtually any aspect of the created POM. This means that it is also possible to modify the POM in such a way that it is no longer a valid Maven POM, so care must be taken when using this feature.</p><p>The identifier (groupId, artifactId, version) of the published module is an exception; these values cannot be modified in the POM using the <code class="literal">withXML</code> hook.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_multiple_modules_to_maven" class="section-anchor" href="#sec:publishing_multiple_modules_to_maven"></a>Publishing multiple modules</h3></div></div></div><p>Sometimes it&rsquo;s useful to publish multiple modules from your Gradle build, without creating a separate Gradle subproject. An example is publishing a separate API and implementation jar for your library. With Gradle this is simple:</p><div class="example"><a name="publishing_maven:publish-multiple-publications"></a><p class="title"><b>Example&nbsp;260.&nbsp;Publishing multiple modules from a single project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task apiJar(type: Jar) {
    baseName <span class="hl-string">"publishing-api"</span>
    from sourceSets.main.output
    exclude <span class="hl-string">'**/impl/**'</span>
}

publishing {
    publications {
        impl(MavenPublication) {
            groupId <span class="hl-string">'org.gradle.sample.impl'</span>
            artifactId <span class="hl-string">'project2-impl'</span>
            version <span class="hl-string">'2.3'</span>

            from components.java
        }
        api(MavenPublication) {
            groupId <span class="hl-string">'org.gradle.sample'</span>
            artifactId <span class="hl-string">'project2-api'</span>
            version <span class="hl-string">'2'</span>

            artifact apiJar
        }
    }
}
</pre></div></div><br class="example-break"><p>If a project defines multiple publications then Gradle will publish each of these to the defined repositories. Each publication must be given a unique identity as described above.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_maven:repositories" class="section-anchor" href="#publishing_maven:repositories"></a>Repositories</h2></div></div></div><p>Publications are published to repositories. The repositories to publish to are defined by the <a class="ulink" href="../dsl/org.gradle.api.publish.PublishingExtension.html#org.gradle.api.publish.PublishingExtension:repositories" target="_top"><code class="classname">PublishingExtension.getRepositories()</code></a> container.</p><div class="example"><a name="publishing_maven:repositories"></a><p class="title"><b>Example&nbsp;261.&nbsp;Declaring repositories to publish to</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">publishing {
    repositories {
        maven {
            <span class="hl-comment">// change to point to your repo, e.g. http://my.org/repo</span>
            url <span class="hl-string">"$buildDir/repo"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>The DSL used to declare repositories for publication is the same DSL that is used to declare repositories to consume dependencies from, <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html" target="_top"><code class="classname">RepositoryHandler</code></a>. However, in the context of Maven publication only <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html" target="_top"><code class="classname">MavenArtifactRepository</code></a> repositories can be used for publication.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_maven:publishing" class="section-anchor" href="#publishing_maven:publishing"></a>Performing a publish</h2></div></div></div><p>The &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin automatically creates a <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html" target="_top"><code class="classname">PublishToMavenRepository</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> and <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.MavenArtifactRepository.html" target="_top"><code class="classname">MavenArtifactRepository</code></a> combination in the <code class="literal">publishing.publications</code> and <code class="literal">publishing.repositories</code> containers respectively.</p><p>The created task is named &ldquo;<code class="literal">publish&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;PublicationTo&laquo;<span class="emphasis"><em>REPONAME</em></span>&raquo;Repository</code>&rdquo;.</p><div class="example"><a name="publishingMavenPublishMinimal"></a><p class="title"><b>Example&nbsp;262.&nbsp;Publishing a project to a Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
apply plugin: <span class="hl-string">'maven-publish'</span>

group = <span class="hl-string">'org.gradle.sample'</span>
version = <span class="hl-string">'1.0'</span>

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
        }
    }
}
publishing {
    repositories {
        maven {
            <span class="hl-comment">// change to point to your repo, e.g. http://my.org/repo</span>
            url <span class="hl-string">"$buildDir/repo"</span>
        }
    }
}

</pre><p>Output of <strong class="userinput"><code>gradle publish</code></strong></p><pre class="screen">&gt; gradle publish
:generatePomFileForMavenJavaPublication
:compileJava
:processResources NO-SOURCE
:classes
:jar
:publishMavenJavaPublicationToMavenRepository
:publish

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"><p>In this example, a task named &ldquo;<code class="literal">publishMavenJavaPublicationToMavenRepository</code>&rdquo; is created, which is of type <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html" target="_top"><code class="classname">PublishToMavenRepository</code></a>. This task is wired into the <code class="literal">publish</code> lifecycle task. Executing &ldquo;<code class="literal">gradle publish</code>&rdquo; builds the POM file and all of the artifacts to be published, and transfers them to the repository.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_maven:install" class="section-anchor" href="#publishing_maven:install"></a>Publishing to Maven Local</h2></div></div></div><p>For integration with a local Maven installation, it is sometimes useful to publish the module into the local .m2 repository. In Maven parlance, this is referred to as 'installing' the module. The &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin makes this easy to do by automatically creating a <a class="ulink" href="../javadoc/org/gradle/api/publish/maven/tasks/PublishToMavenLocal.html" target="_top"><code class="classname">PublishToMavenLocal</code></a> task for each <a class="ulink" href="../dsl/org.gradle.api.publish.maven.MavenPublication.html" target="_top"><code class="classname">MavenPublication</code></a> in the <code class="literal">publishing.publications</code> container. Each of these tasks is wired into the <code class="literal">publishToMavenLocal</code> lifecycle task. You do not need to have <code class="literal">mavenLocal</code> in your <code class="literal">publishing.repositories</code> section.</p><p>The created task is named &ldquo;<code class="literal">publish&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;PublicationToMavenLocal</code>&rdquo;.</p><div class="example"><a name="publishingMavenPublishLocal"></a><p class="title"><b>Example&nbsp;263.&nbsp;Publish a project to the Maven local repository</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle publishToMavenLocal</code></strong></p><pre class="screen">&gt; gradle publishToMavenLocal
:generatePomFileForMavenJavaPublication
:compileJava
:processResources NO-SOURCE
:classes
:jar
:publishMavenJavaPublicationToMavenLocal
:publishToMavenLocal

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"><p>The resulting task in this example is named &ldquo;<code class="literal">publishMavenJavaPublicationToMavenLocal</code>&rdquo;. This task is wired into the <code class="literal">publishToMavenLocal</code> lifecycle task. Executing &ldquo;<code class="literal">gradle publishToMavenLocal</code>&rdquo; builds the POM file and all of the artifacts to be published, and &ldquo;installs&rdquo; them into the local Maven repository.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="publishing_maven:generate-pom" class="section-anchor" href="#publishing_maven:generate-pom"></a>Generating the POM file without publishing</h2></div></div></div><p>At times it is useful to generate a Maven POM file for a module without actually publishing. Since POM generation is performed by a separate task, it is very easy to do so.</p><p>The task for generating the POM file is of type <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.GenerateMavenPom.html" target="_top"><code class="classname">GenerateMavenPom</code></a>, and it is given a name based on the name of the publication: &ldquo;<code class="literal">generatePomFileFor&laquo;<span class="emphasis"><em>PUBNAME</em></span>&raquo;Publication</code>&rdquo;. So in the example below, where the publication is named &ldquo;<code class="literal">mavenCustom</code>&rdquo;, the task will be named &ldquo;<code class="literal">generatePomFileForMavenCustomPublication</code>&rdquo;.</p><div class="example"><a name="publishingMavenGeneratePom"></a><p class="title"><b>Example&nbsp;264.&nbsp;Generate a POM file without publishing</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    tasks.generatePomFileForMavenCustomPublication {
        destination = file(<span class="hl-string">"$buildDir/generated-pom.xml"</span>)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle generatePomFileForMavenCustomPublication</code></strong></p><pre class="screen">&gt; gradle generatePomFileForMavenCustomPublication
:generatePomFileForMavenCustomPublication

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>All details of the publishing model are still considered in POM generation, including <code class="literal">components</code>, custom <code class="literal">artifacts</code>, and any modifications made via <code class="literal">pom.withXml</code>.</p><div class="note"><p>The &ldquo;<code class="literal">maven-publish</code>&rdquo; plugin leverages some experimental support for late plugin configuration, and any <code class="literal">GenerateMavenPom</code> tasks will not be constructed until the publishing extension is configured. The simplest way to ensure that the publishing plugin is configured when you attempt to access the <code class="literal">GenerateMavenPom</code> task is to place the access inside a <code class="literal">model</code> block, as the example above demonstrates.</p><p>The same applies to any attempt to access publication-specific tasks like <a class="ulink" href="../dsl/org.gradle.api.publish.maven.tasks.PublishToMavenRepository.html" target="_top"><code class="classname">PublishToMavenRepository</code></a>. These tasks should be referenced from within a <code class="literal">model</code> block.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="distribution_plugin"></a>The Distribution Plugin</h1></div></div></div><div class="note"><p>The distribution plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The distribution plugin facilitates building archives that serve as distributions of the project. Distribution archives typically contain the executable application and other supporting files, such as documentation.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:distribution_usage" class="section-anchor" href="#sec:distribution_usage"></a>Usage</h2></div></div></div><p>To use the distribution plugin, include the following in your build script:</p><div class="example"><a name="useDistributionPlugin"></a><p class="title"><b>Example&nbsp;265.&nbsp;Using the distribution plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'distribution'</span>
</pre></div></div><br class="example-break"><p>The plugin adds an extension named &ldquo;<code class="literal">distributions</code>&rdquo; of type <a class="ulink" href="../dsl/org.gradle.api.distribution.DistributionContainer.html" target="_top"><code class="classname">DistributionContainer</code></a> to the project. It also creates a single distribution in the distributions container extension named &ldquo;<code class="literal">main</code>&rdquo;. If your build only produces one distribution you only need to configure this distribution (or use the defaults).</p><p>You can run &ldquo;<code class="literal">gradle distZip</code>&rdquo; to package the main distribution as a ZIP, or &ldquo;<code class="literal">gradle distTar</code>&rdquo; to create a TAR file. To build both types of archives just run <code class="literal">gradle assembleDist</code>. The files will be created at &ldquo;<code class="literal"><span class="emphasis"><em>$buildDir</em></span>/distributions/<span class="emphasis"><em>$project.name</em></span>-<span class="emphasis"><em>$project.version</em></span>.<span class="emphasis"><em>&laquo;ext&raquo;</em></span></code>&rdquo;.</p><p>You can run &ldquo;<code class="literal">gradle installDist</code>&rdquo; to assemble the uncompressed distribution into &ldquo;<code class="literal"><span class="emphasis"><em>$buildDir</em></span>/install/<span class="emphasis"><em>main</em></span></code>&rdquo;.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:distribution_tasks" class="section-anchor" href="#sec:distribution_tasks"></a>Tasks</h2></div></div></div><p>The Distribution plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;30.&nbsp;Distribution plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14C67"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">distZip</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a></p></td>
<td><p>Creates a ZIP archive of the distribution contents</p></td>
</tr><tr>
<td><p><code class="literal">distTar</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a></p></td>
<td><p>Creates a TAR archive of the distribution contents</p></td>
</tr><tr>
<td><p><code class="literal">assembleDist</code></p></td>
<td><p><code class="literal">distTar</code>, <code class="literal">distZip</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Creates ZIP and TAR archives with the distribution contents</p></td>
</tr><tr>
<td><p><code class="literal">installDist</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Sync.html" target="_top"><code class="classname">Sync</code></a></p></td>
<td><p>Assembles the distribution content and installs it on the current machine</p></td>
</tr></tbody></table></div></div><p>For each extra distribution set you add to the project, the distribution plugin adds the following tasks:</p><div class="table"><p class="title"><b>Table&nbsp;31.&nbsp;Multiple distributions - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14CDE"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal"><span class="emphasis"><em>${distribution.name}</em></span>DistZip</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a></p></td>
<td><p>Creates a ZIP archive of the distribution contents</p></td>
</tr><tr>
<td><p><code class="literal"><span class="emphasis"><em>${distribution.name}</em></span>DistTar</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a></p></td>
<td><p>Creates a TAR archive of the distribution contents</p></td>
</tr><tr>
<td><p><code class="literal">assemble<span class="emphasis"><em>${distribution.name.capitalize()}</em></span>Dist</code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>${distribution.name}</em></span>DistTar</code>, <code class="literal"><span class="emphasis"><em>${distribution.name}</em></span>DistZip</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Assembles all distribution archives</p></td>
</tr><tr>
<td><p><code class="literal">install<span class="emphasis"><em>${distribution.name.capitalize()}</em></span>Dist</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Sync.html" target="_top"><code class="classname">Sync</code></a></p></td>
<td><p>Assembles the distribution content and installs it on the current machine</p></td>
</tr></tbody></table></div></div><div class="example"><a name="multipleDistribution"></a><p class="title"><b>Example&nbsp;266.&nbsp;Adding extra distributions</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'distribution'</span>

version = <span class="hl-string">'1.2'</span>
distributions {
    custom {}
}
</pre></div></div><br class="example-break"><p>This will add following tasks to the project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>customDistZip</p></li><li class="listitem"><p>customDistTar</p></li><li class="listitem"><p>assembleCustomDist</p></li><li class="listitem"><p>installCustomDist</p></li></ul></div><p>Given that the project name is &ldquo;<code class="literal">myproject</code>&rdquo; and version &ldquo;<code class="literal">1.2</code>&rdquo;, running &ldquo;<code class="literal">gradle customDistZip</code>&rdquo; will produce a ZIP file named &ldquo;<code class="literal">myproject-custom-1.2.zip</code>&rdquo;.</p><p>Running &ldquo;<code class="literal">gradle installCustomDist</code>&rdquo; will install the distribution contents into &ldquo;<code class="literal"><span class="emphasis"><em>$buildDir</em></span>/install/custom</code>&rdquo;.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:distribution_contents" class="section-anchor" href="#sec:distribution_contents"></a>Distribution contents</h2></div></div></div><p>All of the files in the &ldquo;<code class="literal">src/<span class="emphasis"><em>$distribution.name</em></span>/dist</code>&rdquo; directory will automatically be included in the distribution. You can add additional files by configuring the <a class="ulink" href="../javadoc/org/gradle/api/distribution/Distribution.html" target="_top"><code class="classname">Distribution</code></a> object that is part of the container.</p><div class="example"><a name="configureDistribution"></a><p class="title"><b>Example&nbsp;267.&nbsp;Configuring the main distribution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'distribution'</span>

distributions {
    main {
        baseName = <span class="hl-string">'someName'</span>
        contents {
            from { <span class="hl-string">'src/readme'</span> }
        }
    }
}

apply plugin:<span class="hl-string">'maven'</span>

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://some/repo"</span>)
        }
    }
}

</pre></div></div><br class="example-break"><p>In the example above, the content of the &ldquo;<code class="literal">src/readme</code>&rdquo; directory will be included in the distribution (along with the files in the &ldquo;<code class="literal">src/main/dist</code>&rdquo; directory which are added by default).</p><p>The &ldquo;<code class="literal">baseName</code>&rdquo; property has also been changed. This will cause the distribution archives to be created with a different name.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:publishing_distributions" class="section-anchor" href="#sec:publishing_distributions"></a>Publishing distributions</h2></div></div></div><p>The distribution plugin adds the distribution archives as candidate for default publishing artifacts. With the <code class="literal">maven</code> plugin applied the distribution zip file will be published when running uploadArchives if no other default artifact is configured</p><div class="example"><a name="publishDistribution"></a><p class="title"><b>Example&nbsp;268.&nbsp;publish main distribution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin:<span class="hl-string">'maven'</span>

uploadArchives {
    repositories {
        mavenDeployer {
            repository(url: <span class="hl-string">"file://some/repo"</span>)
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="announce_plugin"></a>The Announce Plugin</h1></div></div></div><p>The Gradle announce plugin allows you to send custom announcements during a build. The following notification systems are supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="http://twitter.com" target="_top">Twitter</a></p></li><li class="listitem"><p><a class="ulink" href="http://manpages.ubuntu.com/manpages/zesty/en/man1/notify-send.1.html" target="_top">notify-send</a> (Ubuntu)</p></li><li class="listitem"><p><a class="ulink" href="https://sites.google.com/site/snarlapp/home" target="_top">Snarl</a> (Windows)</p></li><li class="listitem"><p><a class="ulink" href="http://growl.info/" target="_top">Growl</a> (macOS)</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:announce_usage" class="section-anchor" href="#sec:announce_usage"></a>Usage</h2></div></div></div><p>To use the announce plugin, apply it to your build script:</p><div class="example"><a name="useAnnouncePlugin"></a><p class="title"><b>Example&nbsp;269.&nbsp;Applying the announce plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'announce'</span>
</pre></div></div><br class="example-break"><p>Next, configure your notification service(s) of choice (see table below for which configuration properties are available):</p><div class="example"><a name="useAnnouncePlugin"></a><p class="title"><b>Example&nbsp;270.&nbsp;Configure the announce plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">announce {  
  username = <span class="hl-string">'myId'</span>
  password = <span class="hl-string">'myPassword'</span>
}
</pre></div></div><br class="example-break"><p>Finally, send announcements with the <code class="literal">announce</code> method:</p><div class="example"><a name="useAnnouncePlugin"></a><p class="title"><b>Example&nbsp;271.&nbsp;Using the announce plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task helloWorld {
    doLast {
        println <span class="hl-string">"Hello, world!"</span>
    }
}  

helloWorld.doLast {  
    announce.announce(<span class="hl-string">"helloWorld completed!"</span>, <span class="hl-string">"twitter"</span>)
    announce.announce(<span class="hl-string">"helloWorld completed!"</span>, <span class="hl-string">"local"</span>)
}
</pre></div></div><br class="example-break"><p>The <code class="literal">announce</code> method takes two String arguments: The message to be sent, and the notification service to be used. The following table lists supported notification services and their configuration properties.</p><div class="table"><p class="title"><b>Table&nbsp;32.&nbsp;Announce Plugin Notification Services</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N14E1C"><thead><tr>
<td>Notification Service</td>
<td>Operating System</td>
<td>Configuration Properties</td>
<td>Further Information</td>
</tr></thead><tbody><tr>
<td><p>twitter</p></td>
<td><p>Any</p></td>
<td><p>username, password</p></td>
<td></td>
</tr><tr>
<td><p>snarl</p></td>
<td><p>Windows</p></td>
<td></td>
<td></td>
</tr><tr>
<td><p>growl</p></td>
<td><p>macOS</p></td>
<td></td>
<td></td>
</tr><tr>
<td><p>notify-send</p></td>
<td><p>Ubuntu</p></td>
<td></td>
<td><p>Requires the notify-send package to be installed. Use <code class="literal">sudo apt-get install libnotify-bin</code> to install it.</p></td>
</tr><tr>
<td><p>local</p></td>
<td><p>Windows, macOS, Ubuntu</p></td>
<td></td>
<td><p>Automatically chooses between snarl, growl, and notify-send depending on the current operating system.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:announce_configuration" class="section-anchor" href="#sec:announce_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.announce.AnnouncePluginExtension.html" target="_top"><code class="classname">AnnouncePluginExtension</code></a> class in the API documentation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="build_announcements_plugin"></a>The Build Announcements Plugin</h1></div></div></div><div class="note"><p>The build announcements plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The build announcements plugin uses the <a class="link" href="#announce_plugin">announce</a> plugin to send local announcements on important events in the build.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_announcements_usage" class="section-anchor" href="#sec:build_announcements_usage"></a>Usage</h2></div></div></div><p>To use the build announcements plugin, include the following in your build script:</p><div class="example"><a name="useBuildAnnouncementsPlugin"></a><p class="title"><b>Example&nbsp;272.&nbsp;Using the build announcements plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'build-announcements'</span>
</pre></div></div><br class="example-break"><p>That&rsquo;s it. If you want to tweak where the announcements go, you can configure the <a class="link" href="#announce_plugin">announce</a> plugin to change the local announcer.</p><p>You can also apply the plugin from an init script:</p><div class="example"><a name="useBuildAnnouncementsPlugin"></a><p class="title"><b>Example&nbsp;273.&nbsp;Using the build announcements plugin from an init script</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting">rootProject {
    apply plugin: <span class="hl-string">'build-announcements'</span>
}
</pre></div></div><br class="example-break"></div></div></div><div class="part" title="Dependency management"><div class="titlepage"><div><div><h1 class="title"><a name="N14EC0"></a>Dependency management</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="introduction_dependency_management"></a>Introduction to Dependency Management</h1></div></div></div><p>Dependency management is a critical feature of every build, and Gradle has placed an emphasis on offering first-class dependency management that is both easy to understand and compatible with a wide variety of approaches. If you are familiar with the approach used by either Maven or Ivy you will be delighted to learn that Gradle is fully compatible with both approaches in addition to being flexible enough to support fully-customized approaches.</p><p>Here are the major highlights of Gradle&rsquo;s support for dependency management:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Transitive dependency management</em></span>: Gradle gives you full control of your project&rsquo;s dependency tree.</p></li><li class="listitem"><p><span class="emphasis"><em>Support for non-managed dependencies</em></span>: If your dependencies are simply files in version control or a shared drive, Gradle provides powerful functionality to support this.</p></li><li class="listitem"><p><span class="emphasis"><em>Support for custom dependency definitions.</em></span>: Gradle&rsquo;s Module Dependencies give you the ability to describe the dependency hierarchy in the build script.</p></li><li class="listitem"><p><span class="emphasis"><em>A fully customizable approach to Dependency Resolution</em></span>: Gradle provides you with the ability to customize resolution rules making dependency substitution easy.</p></li><li class="listitem"><p><span class="emphasis"><em>Full Compatibility with Maven and Ivy</em></span>: If you have defined dependencies in a Maven POM or an Ivy file, Gradle provides seamless integration with a range of popular build tools.</p></li><li class="listitem"><p><span class="emphasis"><em>Integration with existing dependency management infrastructure</em></span>: Gradle is compatible with both Maven and Ivy repositories. If you use Archiva, Nexus, or Artifactory, Gradle is 100% compatible with all repository formats.</p></li></ul></div><p>With hundreds of thousands of interdependent open source components each with a range of versions and incompatibilities, dependency management has a habit of causing problems as builds grow in complexity. When a build&rsquo;s dependency tree becomes unwieldy, your build tool shouldn&rsquo;t force you to adopt a single, inflexible approach to dependency management. A proper build system has to be designed to be flexible, and Gradle can handle any situation.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:dependency_management_and_migrations" class="section-anchor" href="#sub:dependency_management_and_migrations"></a>Flexible dependency management for migrations</h2></div></div></div><p>Dependency management can be particularly challenging during a migration from one build system to another. If you are migrating from a tool like Ant or Maven to Gradle, you may be faced with some difficult situations. For example, one common pattern is an Ant project with version-less jar files stored in the filesystem. Other build systems require a wholesale replacement of this approach before migrating. With Gradle, you can adapt your new build to any existing source of dependencies or dependency metadata. This makes incremental migration to Gradle much easier than the alternative. On most large projects, build migrations and any change to development process is incremental because most organizations can&rsquo;t afford to stop everything and migrate to a build tool&rsquo;s idea of dependency management.</p><p>Even if your project is using a custom dependency management system or something like an Eclipse .classpath file as master data for dependency management, it is very easy to write a Gradle plugin to use this data in Gradle. For migration purposes this is a common technique with Gradle. (But, once you&rsquo;ve migrated, it might be a good idea to move away from a .classpath file and use Gradle&rsquo;s dependency management features directly.)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:dependency_management_and_java" class="section-anchor" href="#sub:dependency_management_and_java"></a>Dependency management and Java</h2></div></div></div><p>It is ironic that in a language known for its rich library of open source components that Java has no concept of libraries or versions. In Java, there is no standard way to tell the JVM that you are using version 3.0.5 of Hibernate, and there is no standard way to say that <code class="literal">foo-1.0.jar</code> depends on <code class="literal">bar-2.0.jar</code>. This has led to external solutions often based on build tools. The most popular ones at the moment are Maven and Ivy. While Maven provides a complete build system, Ivy focuses solely on dependency management.</p><p>Both tools rely on descriptor XML files, which contain information about the dependencies of a particular jar. Both also use repositories where the actual jars are placed together with their descriptor files, and both offer resolution for conflicting jar versions in one form or the other. Both have emerged as standards for solving dependency conflicts, and while Gradle originally used Ivy under the hood for its dependency management. Gradle has replaced this direct dependency on Ivy with a native Gradle dependency resolution engine which supports a range of approaches to dependency resolution including both POM and Ivy descriptor files.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dependency_resolution" class="section-anchor" href="#sec:dependency_resolution"></a>How dependency resolution works</h2></div></div></div><p>Gradle takes your dependency declarations and repository definitions and attempts to download all of your dependencies by a process called <span class="emphasis"><em>dependency resolution</em></span>. Below is a brief outline of how this process works.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Given a required dependency, Gradle first attempts to resolve the <span class="emphasis"><em>module</em></span> for that dependency. Each repository is inspected in order, searching first for a <span class="emphasis"><em>module descriptor</em></span> file (POM or Ivy file) that indicates the presence of that module. If no module descriptor is found, Gradle will search for the presence of the primary <span class="emphasis"><em>module artifact</em></span> file indicating that the module exists in the repository.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the dependency is declared as a dynamic version (like <code class="literal">1.+</code>), Gradle will resolve this to the newest available static version (like <code class="literal">1.2</code>) in the repository. For Maven repositories, this is done using the <code class="literal">maven-metadata.xml</code> file, while for Ivy repositories this is done by directory listing.</p></li><li class="listitem"><p>If the module descriptor is a POM file that has a parent POM declared, Gradle will recursively attempt to resolve each of the parent modules for the POM.</p></li></ul></div></li><li class="listitem"><p>Once each repository has been inspected for the module, Gradle will choose the 'best' one to use. This is done using the following criteria:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For a dynamic version, a 'higher' static version is preferred over a 'lower' version.</p></li><li class="listitem"><p>Modules declared by a module descriptor file (Ivy or POM file) are preferred over modules that have an artifact file only.</p></li><li class="listitem"><p>Modules from earlier repositories are preferred over modules in later repositories.</p></li><li class="listitem"><p>When the dependency is declared by a static version and a module descriptor file is found in a repository, there is no need to continue searching later repositories and the remainder of the process is short-circuited.</p></li></ul></div></li><li class="listitem"><p>All of the artifacts for the module are then requested from the <span class="emphasis"><em>same repository</em></span> that was chosen in the process above.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dependency_cache" class="section-anchor" href="#sec:dependency_cache"></a>The dependency cache</h2></div></div></div><p>Gradle contains a highly sophisticated dependency caching mechanism, which seeks to minimise the number of remote requests made in dependency resolution, while striving to guarantee that the results of dependency resolution are correct and reproducible.</p><p>The Gradle dependency cache consists of 2 key types of storage:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A file-based store of downloaded artifacts, including binaries like jars as well as raw downloaded meta-data like POM files and Ivy files. The storage path for a downloaded artifact includes the SHA1 checksum, meaning that 2 artifacts with the same name but different content can easily be cached.</p></li><li class="listitem"><p>A binary store of resolved module meta-data, including the results of resolving dynamic versions, module descriptors, and artifacts.</p></li></ul></div><p>Separating the storage of downloaded artifacts from the cache metadata permits us to do some very powerful things with our cache that would be difficult with a transparent, file-only cache layout.</p><p>The Gradle cache does not allow the local cache to hide problems and create other mysterious and difficult to debug behavior that has been a challenge with many build tools. This new behavior is implemented in a bandwidth and storage efficient way. In doing so, Gradle enables reliable and reproducible enterprise builds.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:cache_metadata" class="section-anchor" href="#sub:cache_metadata"></a>Separate metadata cache</h3></div></div></div><p>Gradle keeps a record of various aspects of dependency resolution in binary format in the metadata cache. The information stored in the metadata cache includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The result of resolving a dynamic version (e.g. <code class="literal">1.+</code>) to a concrete version (e.g. <code class="literal">1.2</code>).</p></li><li class="listitem"><p>The resolved module metadata for a particular module, including module artifacts and module dependencies.</p></li><li class="listitem"><p>The resolved artifact metadata for a particular artifact, including a pointer to the downloaded artifact file.</p></li><li class="listitem"><p>The <span class="emphasis"><em>absence</em></span> of a particular module or artifact in a particular repository, eliminating repeated attempts to access a resource that does not exist.</p></li></ul></div><p>Every entry in the metadata cache includes a record of the repository that provided the information as well as a timestamp that can be used for cache expiry.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:cache_repository_independence" class="section-anchor" href="#sub:cache_repository_independence"></a>Repository caches are independent</h3></div></div></div><p>As described above, for each repository there is a separate metadata cache. A repository is identified by its URL, type and layout. If a module or artifact has not been previously resolved from <span class="emphasis"><em>this repository</em></span>, Gradle will attempt to resolve the module against the repository. This will always involve a remote lookup on the repository, however in many cases no download will be required (see <a class="xref" href="#sub:cache_artifact_reuse">the section called &ldquo;Artifact reuse&rdquo;</a>, below).</p><p>Dependency resolution will fail if the required artifacts are not available in any repository specified by the build, even if the local cache has a copy of this artifact which was retrieved from a different repository. Repository independence allows builds to be isolated from each other in an advanced way that no build tool has done before. This is a key feature to create builds that are reliable and reproducible in any environment.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:cache_artifact_reuse" class="section-anchor" href="#sub:cache_artifact_reuse"></a>Artifact reuse</h3></div></div></div><p>Before downloading an artifact, Gradle tries to determine the checksum of the required artifact by downloading the sha file associated with that artifact. If the checksum can be retrieved, an artifact is not downloaded if an artifact already exists with the same id and checksum. If the checksum cannot be retrieved from the remote server, the artifact will be downloaded (and ignored if it matches an existing artifact).</p><p>As well as considering artifacts downloaded from a different repository, Gradle will also attempt to reuse artifacts found in the local Maven Repository. If a candidate artifact has been downloaded by Maven, Gradle will use this artifact if it can be verified to match the checksum declared by the remote server.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:cache_checksum_storage" class="section-anchor" href="#sub:cache_checksum_storage"></a>Checksum based storage</h3></div></div></div><p>It is possible for different repositories to provide a different binary artifact in response to the same artifact identifier. This is often the case with Maven SNAPSHOT artifacts, but can also be true for any artifact which is republished without changing its identifier. By caching artifacts based on their SHA1 checksum, Gradle is able to maintain multiple versions of the same artifact. This means that when resolving against one repository Gradle will never overwrite the cached artifact file from a different repository. This is done without requiring a separate artifact file store per repository.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:cache_locking" class="section-anchor" href="#sub:cache_locking"></a>Cache Locking</h3></div></div></div><p>The Gradle dependency cache uses file-based locking to ensure that it can safely be used by multiple Gradle processes concurrently. The lock is held whenever the binary meta-data store is being read or written, but is released for slow operations such as downloading remote artifacts.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="declaring_dependencies"></a>Declaring Dependencies</h1></div></div></div><p>Gradle builds can declare dependencies on external binaries, raw files and other Gradle projects. You can find examples for common scenarios in this section. For more information, see the <a class="link" href="#dependency_types">full reference on all types of dependencies</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_binary_dependency" class="section-anchor" href="#sec:declaring_binary_dependency"></a>Declaring a binary dependency</h2></div></div></div><p>Modern software projects rarely build code in isolation. Projects reference external libraries for the purpose of reusing existing and proven functionality, so-called <span class="emphasis"><em>binary dependencies</em></span>. Upon resolution binary dependencies are downloaded from dedicated repositories and stored in a cache to avoid unnecessary network traffic.</p><div class="figure"><a name="N14FA6"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Resolving binary dependencies from remote repositories</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="531"><tr><td><img src="img/dependency-management-binary-dependencies.png" width="531" alt="Resolving binary dependencies from remote repositories"></td></tr></table></div></div><br class="figure-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_declaring_a_concrete_version_of_a_binary_dependency" class="section-anchor" href="#_declaring_a_concrete_version_of_a_binary_dependency"></a>Declaring a concrete version of a binary dependency</h3></div></div></div><p>A typical example for such a library in a Java project is the <a class="ulink" href="https://projects.spring.io/spring-framework/" target="_top">Spring framework</a>. The following code snippet declares a compile-time dependency on the Spring web module by its coordinates: <code class="literal">org.springframework:spring-web:5.0.2.RELEASE</code>. Gradle resolves the dependency including its transitive dependencies from the <a class="ulink" href="https://search.maven.org/" target="_top">Maven Central repository</a> and uses it to compile Java source code. The version attribute of the dependency coordinates points to a <span class="emphasis"><em>concrete version</em></span> indicating that the underlying artifacts don&rsquo;t change over time. The use of concrete versions ensures reproducibility for the aspect of dependency resolution.</p><div class="example"><a name="binary-dependencies-concrete-version"></a><p class="title"><b>Example&nbsp;274.&nbsp;Declaring a binary dependencies with a concrete version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-library'</span>

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="hl-string">'org.springframework:spring-web:5.0.2.RELEASE'</span>
}
</pre></div></div><br class="example-break"><p>A Gradle project can define other types of repositories hosting binary dependencies. You can learn more about the syntax and API in the section on <a class="link" href="#">declaring repositories</a>. Refer to <a class="xref" href="#java_plugin"><i>The Java Plugin</i></a> for a deep dive on declaring dependencies for a Java project. The resolution behavior for binary dependencies declarations is <a class="link" href="#">highly customizable</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_declaring_a_dynamic_version_of_a_binary_dependency" class="section-anchor" href="#_declaring_a_dynamic_version_of_a_binary_dependency"></a>Declaring a dynamic version of a binary dependency</h3></div></div></div><p>Projects might adopt a more aggressive approach for consuming binary dependencies. For example you might want to always integrate the latest version of a dependency to consume cutting edge features at any given time. A <span class="emphasis"><em>dynamic version</em></span> allows for resolving the latest version or the latest version of a version range for a given dependency.</p><div class="note"><p>Using dynamic versions in a build bears the risk of potentially breaking it. As soon as a new version of the dependency is released that contains an incompatible API change your source code might stop compiling.</p></div><div class="example"><a name="binary-dependencies-dynamic-version"></a><p class="title"><b>Example&nbsp;275.&nbsp;Declaring a binary dependencies with a dynamic version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-library'</span>

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="hl-string">'org.springframework:spring-web:5.+'</span>
}
</pre></div></div><br class="example-break"><p>A <a class="ulink" href="https://scans.gradle.com/" target="_top">build scan</a> can effectively visualize dynamic dependency versions and their respective, selected versions.</p><div class="figure"><a name="N14FF4"></a><p class="title"><b>Figure&nbsp;7.&nbsp;Dynamic dependencies in build scan</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="478"><tr><td><img src="img/dependency-management-dynamic-dependency-build-scan.png" width="478" alt="Dynamic dependencies in build scan"></td></tr></table></div></div><br class="figure-break"><p>By default, Gradle caches dynamic versions of dependencies for 24 hours. The <a class="link" href="#">threshold can be configured</a> as needed for example if you want to resolve new versions earlier.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_declaring_a_changing_version_of_a_binary_dependency" class="section-anchor" href="#_declaring_a_changing_version_of_a_binary_dependency"></a>Declaring a changing version of a binary dependency</h3></div></div></div><p>A team might decide to implement a series of features before releasing a new version of the application or library. A common strategy to allow consumers to integrate an unfinished version of their artifacts early and often is to release a so-called <span class="emphasis"><em>changing version</em></span>. A changing version indicates that the feature set is still under active development and hasn&rsquo;t released a stable version for general availability yet.</p><p>In Maven repositories, changing versions are commonly referred to as <a class="ulink" href="https://maven.apache.org/guides/getting-started/index.html#What_is_a_SNAPSHOT_version" target="_top">snapshot versions</a>. Snapshot versions contain the suffix <code class="literal">-SNAPSHOT</code>. The following example demonstrates how to declare a snapshot version on the Spring dependency.</p><div class="example"><a name="binary-dependencies-changing-version"></a><p class="title"><b>Example&nbsp;276.&nbsp;Declaring a binary dependencies with a changing version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-library'</span>

repositories {
    mavenCentral()
    maven {
        url <span class="hl-string">'https://repo.spring.io/snapshot/'</span>
    }
}

dependencies {
    implementation <span class="hl-string">'org.springframework:spring-web:5.0.3.BUILD-SNAPSHOT'</span>
}
</pre></div></div><br class="example-break"><p>By default, Gradle caches changing versions of dependencies for 24 hours. The <a class="link" href="#">threshold can be configured</a> as needed for example if you want to resolve new snapshot versions earlier.</p><p>Gradle is flexible enough to treat any version as changing version. All you need to do is to set the property <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html#setChanging-boolean-" target="_top"><code class="classname">ExternalModuleDependency.setChanging(boolean)</code></a> to <code class="literal">true</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_file_dependency" class="section-anchor" href="#sec:declaring_file_dependency"></a>Declaring a file dependency</h2></div></div></div><p>Projects sometimes do not rely on a binary repository product e.g. JFrog Artifactory or Sonatype Nexus for hosting and resolving external dependencies. It&rsquo;s common practice to host those dependencies on a shared drive or check them into version control alongside the project source code. Those dependencies are referred to as <span class="emphasis"><em>file dependencies</em></span>, the reason being that they represent a files without any metadata (like information about transitive dependencies, the origin or its author) attached to them.</p><div class="figure"><a name="N15036"></a><p class="title"><b>Figure&nbsp;8.&nbsp;Resolving file dependencies from the local file system and a shared drive</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="496"><tr><td><img src="img/dependency-management-file-dependencies.png" width="496" alt="Resolving file dependencies from the local file system and a shared drive"></td></tr></table></div></div><br class="figure-break"><p>The following example resolves file dependencies from the directories <code class="literal">ant</code>, <code class="literal">libs</code> and <code class="literal">tools</code>.</p><div class="example"><a name="file-dependencies"></a><p class="title"><b>Example&nbsp;277.&nbsp;Declaring multiple file dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    antContrib
    externalLibs
    deploymentTools
}

dependencies {
    antContrib files(<span class="hl-string">'ant/antcontrib.jar'</span>)
    externalLibs files(<span class="hl-string">'libs/commons-lang.jar'</span>, <span class="hl-string">'libs/log4j.jar'</span>)
    deploymentTools fileTree(dir: <span class="hl-string">'tools'</span>, include: <span class="hl-string">'*.exe'</span>)
}
</pre></div></div><br class="example-break"><p>As you can see in the code example, every dependency has to define its exact location in the file system. The most prominent methods for creating a file reference are <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])" target="_top"><code class="classname">Project.files(java.lang.Object[])</code></a> and <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)" target="_top"><code class="classname">Project.fileTree(java.lang.Object)</code></a>. Alternatively, you can also define the source directory of one or many file dependencies in the form of a <a class="link" href="#sec:flat_dir_resolver">flat directory repository</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_project_dependency" class="section-anchor" href="#sec:declaring_project_dependency"></a>Declaring a project dependency</h2></div></div></div><p>Software projects often break up software components into modules to improve maintainability and prevent strong coupling. Modules can define dependencies between each other to reuse code within the same project.</p><p>Gradle can model dependencies between modules. Those dependencies are called <span class="emphasis"><em>project dependencies</em></span> because each module is represented by a Gradle project. At runtime, the build automatically ensures that project dependencies are built in the correct order and added to the classpath for compilation. The chapter <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a> discusses how to set up and configure multi-project builds in more detail.</p><div class="figure"><a name="N15070"></a><p class="title"><b>Figure&nbsp;9.&nbsp;Dependencies between projects</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="354"><tr><td><img src="img/dependency-management-project-dependencies.png" width="354" alt="Dependencies between projects"></td></tr></table></div></div><br class="figure-break"><p>The following example declares the dependencies on the <code class="literal">utils</code> and <code class="literal">api</code> project from the <code class="literal">web-service</code> project. The method <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:project(java.lang.String)" target="_top"><code class="classname">Project.project(java.lang.String)</code></a> creates a reference to a specific subproject by path.</p><div class="example"><a name="project-dependencies"></a><p class="title"><b>Example&nbsp;278.&nbsp;Declaring project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span class="hl-string">':web-service'</span>) {
    dependencies {
        implementation project(<span class="hl-string">':utils'</span>)
        implementation project(<span class="hl-string">':api'</span>)
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:scope_of_dependency_configurations" class="section-anchor" href="#sub:scope_of_dependency_configurations"></a>Defining the scope of a dependency with configurations</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_what_is_a_configuration" class="section-anchor" href="#_what_is_a_configuration"></a>What is a configuration?</h3></div></div></div><p>Every dependency declared for a Gradle project applies to a specific scope. For example some dependencies should be used for compiling source code whereas others only need to be available at runtime. Gradle represents the scope of a dependency with the help of a <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p><p>Many Gradle plugins add pre-defined configurations to your project. The Java plugin, for example, adds configurations to represent the various classpaths it needs for source code compilation, executing tests and the like. See <a class="link" href="#sec:java_plugin_and_dependency_management">the Java plugin chapter</a> for an example. The sections above demonstrate how to <a class="link" href="#declaring_dependencies">declare dependencies</a> for different use cases.</p><div class="figure"><a name="N150AA"></a><p class="title"><b>Figure&nbsp;10.&nbsp;Configurations use declared dependencies for specific purposes</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="709"><tr><td><img src="img/dependency-management-configurations.png" width="709" alt="Configurations use declared dependencies for specific purposes"></td></tr></table></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_defining_custom_configurations" class="section-anchor" href="#_defining_custom_configurations"></a>Defining custom configurations</h3></div></div></div><p>You can also define configurations yourself, so-called <span class="emphasis"><em>custom configurations</em></span>. A custom configuration is useful for separating the scope of dependencies needed for a dedicated purpose.</p><p>Let&rsquo;s say you wanted to declare a dependency on the <a class="ulink" href="https://tomcat.apache.org/tomcat-9.0-doc/jasper-howto.html" target="_top">Jasper Ant task</a> for the purpose of pre-compiling JSP files that should <span class="emphasis"><em>not</em></span> end up in the classpath for compiling your source code. It&rsquo;s fairly simply to achieve that goal by introducing a custom configuration and using it in a task.</p><div class="example"><a name="custom-configuration"></a><p class="title"><b>Example&nbsp;279.&nbsp;Declaring and using a custom configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    jasper
}

repositories {
    mavenCentral()
}

dependencies {
    jasper <span class="hl-string">'org.apache.tomcat.embed:tomcat-embed-jasper:9.0.2'</span>
}

task preCompileJsps {
    doLast {
        ant.taskdef(classname: <span class="hl-string">'org.apache.jasper.JspC'</span>,
                    name: <span class="hl-string">'jasper'</span>,
                    classpath: configurations.jasper.asPath)
        ant.jasper(validateXml: false,
                   uriroot: file(<span class="hl-string">'src/main/webapp'</span>),
                   outputDir: file(<span class="hl-string">"$buildDir/compiled-jsps"</span>))
    }
}
</pre></div></div><br class="example-break"><p>A project&rsquo;s configurations are managed by a <code class="literal">configurations</code> object. Configurations have a name and can extend each other. To learn more about this API have a look at <a class="ulink" href="../dsl/org.gradle.api.artifacts.ConfigurationContainer.html" target="_top"><code class="classname">ConfigurationContainer</code></a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:resolve_specific_artifacts_from_dependency" class="section-anchor" href="#sub:resolve_specific_artifacts_from_dependency"></a>Resolving specific artifacts from a module dependency</h2></div></div></div><p>Whenever Gradle tries to resolve a dependency from a Maven or Ivy repository, it looks for a metadata file and the default artifact file, a JAR. The build fails if none of these artifact files can be resolved. Under certain conditions, you might want to tweak the way Gradle resolves artifacts for a dependency.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The dependency only provides a non-standard artifact without any metadata e.g. a ZIP file.</p></li><li class="listitem"><p>The dependency metadata declares more than one artifact e.g. as part of an Ivy dependency descriptor.</p></li><li class="listitem"><p>You only want to download a specific artifact without any of the transitive dependencies declared in the metadata.</p></li></ul></div><p>Gradle is a polyglot build tool and not limited to just resolving Java libraries. Let&rsquo;s assume you wanted to build a web application using JavaScript as the client technology. Most projects check in external JavaScript libraries into version control. An external JavaScript library is no different than a reusable Java library so why not download it from a repository instead?</p><p><a class="ulink" href="https://developers.google.com/speed/libraries/" target="_top">Google Hosted Libraries</a> is a distribution platform for popular, open-source JavaScript libraries. With the help of the artifact-only notation you can download a JavaScript library file e.g. JQuery. The <code class="literal">@</code> character separates the dependency&rsquo;s coordinates from the artifact&rsquo;s file extension.</p><div class="example"><a name="artifact-only-dependency-declaration"></a><p class="title"><b>Example&nbsp;280.&nbsp;Resolving a JavaScript artifact for a declared dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">'https://ajax.googleapis.com/ajax/libs'</span>
        layout <span class="hl-string">'pattern'</span>, {
            artifact <span class="hl-string">'[organization]/[revision]/[module].[ext]'</span>
        }
    }
}

configurations {
    js
}

dependencies {
    js <span class="hl-string">'jquery:jquery:3.2.1@js'</span>
}
</pre></div></div><br class="example-break"><p>Some dependencies ship different "flavors" of the same artifact or they publish multiple artifacts that belong to a specific version of the dependency but have a different purpose. It&rsquo;s common for a Java library to publish the artifact with the compiled class files, another one with just the source code in it and a third one containing the Javadocs.</p><p>In JavaScript, a library may exist as uncompressed or minified artifact. In Gradle, a specific artifact identifier is called <span class="emphasis"><em>classifier</em></span>, a term generally used in Maven and Ivy dependency management.</p><p>Let&rsquo;s say we wanted to download the minified artifact of the JQuery library instead of the uncompressed file. You can provide the classifier <code class="literal">min</code> as part of the dependency declaration.</p><div class="example"><a name="artifact-only-dependency-declaration-with-classifier"></a><p class="title"><b>Example&nbsp;281.&nbsp;Resolving a JavaScript artifact with classifier for a declared dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">'https://ajax.googleapis.com/ajax/libs'</span>
        layout <span class="hl-string">'pattern'</span>, {
            artifact <span class="hl-string">'[organization]/[revision]/[module](.[classifier]).[ext]'</span>
        }
    }
}

configurations {
    js
}

dependencies {
    js <span class="hl-string">'jquery:jquery:3.2.1:min@js'</span>
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="declaring_repositories"></a>Declaring Repositories</h1></div></div></div><p>Gradle can resolve external dependencies from one or many repositories based on Maven, Ivy or flat directory directory formats. Check out the <a class="link" href="#repository_types">full reference on all types of repositories</a> for more information.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_public_repository" class="section-anchor" href="#sec:declaring_public_repository"></a>Declaring a publicly-available repository</h2></div></div></div><p>Organizations building software may want to leverage public binary repositories to download and consume open source dependencies. Popular public repositories include Maven Central, Bintray JCenter and the Google Android repository. Gradle provides built-in shortcut methods for the most widely-used repositories.</p><div class="figure"><a name="N15122"></a><p class="title"><b>Figure&nbsp;11.&nbsp;Declaring a repository with the help of shortcut methods</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="425"><tr><td><img src="img/dependency-management-shortcut-repositories.png" width="425" alt="Declaring a repository with the help of shortcut methods"></td></tr></table></div></div><br class="figure-break"><p>To declare JCenter as repository, add this code to your build script:</p><div class="example"><a name="public-repository"></a><p class="title"><b>Example&nbsp;282.&nbsp;Declaring JCenter repository as source for resolving dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}
</pre></div></div><br class="example-break"><p>Under the covers Gradle resolves dependencies from the respective URL of the public repository defined by the shortcut method. All shortcut methods are available via the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html" target="_top"><code class="classname">RepositoryHandler</code></a> API. Alternatively, you can <a class="link" href="#sec:declaring_custom_repository">spell out the URL of the repository</a> for more fine-grained control.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_custom_repository" class="section-anchor" href="#sec:declaring_custom_repository"></a>Declaring a custom repository by URL</h2></div></div></div><p>Most enterprise projects set up a binary repository available only within an intranet. In-house repositories enable teams to publish internal binaries, setup user management and security measure and ensure uptime and availability. Specifying a custom URL is also helpful if you want to declare a less popular, but publicly-available repository.</p><p>Add the following code to declare an in-house repository for your build reachable through a custom URL.</p><div class="example"><a name="custom-repository"></a><p class="title"><b>Example&nbsp;283.&nbsp;Declaring a custom repository by URL</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Repositories with custom URLs can be specified as Maven or Ivy repositories by calling the corresponding methods available on the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.RepositoryHandler.html" target="_top"><code class="classname">RepositoryHandler</code></a> API. Gradle supports other protocols than <code class="literal">http</code> or <code class="literal">https</code> as part of the custom URL e.g. <code class="literal">file</code>, <code class="literal">sftp</code> or <code class="literal">s3</code>. For a full coverage see the <a class="link" href="#sub:supported_transport_protocols">reference manual on supported transport protocols</a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:declaring_multiple_repositories" class="section-anchor" href="#sec:declaring_multiple_repositories"></a>Declaring multiple repositories</h2></div></div></div><p>You can define more than one repository for resolving dependencies. Declaring multiple repositories is helpful if some dependencies are only available in one repository but not the other. You can mix any type of repository described in the <a class="link" href="#repository_types">reference section</a>.</p><p>This example demonstrates how to declare various shortcut and custom URL repositories for a project:</p><div class="example"><a name="multiple-repositories"></a><p class="title"><b>Example&nbsp;284.&nbsp;Declaring multiple repositories</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
    maven {
        url <span class="hl-string">"https://maven.springframework.org/release"</span>
    }
    maven {
        url <span class="hl-string">"https://maven.restlet.org"</span>
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>The order of declaration determines how Gradle will check for dependencies at runtime. If Gradle finds a module descriptor in a particular repository, it will attempt to download all of the artifacts for that module from <span class="emphasis"><em>the same repository</em></span>. You can learn more about <a class="link" href="#sec:dependency_resolution">Gradle&rsquo;s resolution mechanism</a> in the dedicated section.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="inspecting_dependencies"></a>Inspecting Dependencies</h1></div></div></div><p>Gradle provides sufficient tooling to navigate large dependency graphs and mitigate situations that can lead to <a class="ulink" href="https://en.wikipedia.org/wiki/Dependency_hell" target="_top">dependency hell</a>. Users can chose to render the full graph of dependencies as well as identify the selection reason and origin for a dependency. The origin of a dependency can be a declared dependency in the build script or a transitive dependency in graph plus their corresponding configuration. Gradle offers both capabilities through visual representation via build scans and as command line tooling.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:listing_dependencies" class="section-anchor" href="#sec:listing_dependencies"></a>Listing dependencies in a project</h2></div></div></div><p>A project can declare one or more dependencies. Gradle can visualize the whole dependency tree for every configuration available in the project.</p><p>Rendering the dependency tree is particularly useful if you&rsquo;d like to identify which dependencies have been resolved at runtime. It also provides you with information about any dependency conflict resolution that occurred in the process and clearly indicates the selected version. The dependency report always contains declared and transitive dependencies.</p><p>Let&rsquo;s say you&rsquo;d want to create tasks for your project that use the <a class="ulink" href="https://www.eclipse.org/jgit/" target="_top">JGit library</a> to execute SCM operations e.g. to model a release process. You can declare dependencies for any external tooling with the help of a <a class="link" href="#sub:scope_of_dependency_configurations">custom configuration</a> so that it doesn&rsquo;t doesn&rsquo;t pollute other contexts like the compilation classpath for your production source code.</p><div class="example"><a name="jgit-dependency"></a><p class="title"><b>Example&nbsp;285.&nbsp;Declaring the JGit dependency with a custom configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm <span class="hl-string">'org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r'</span>
}
</pre></div></div><br class="example-break"><p>A <a class="ulink" href="https://scans.gradle.com/" target="_top">build scan</a> can visualize dependencies as a navigable, searchable tree. Additional context information can be rendered by clicking on a specific dependency in the graph.</p><div class="figure"><a name="N151B9"></a><p class="title"><b>Figure&nbsp;12.&nbsp;Dependency tree in a build scan</b></p><div class="figure-contents"><table cellpadding="0" cellspacing="0" summary="manufactured viewport for HTML img" border="0" width="638"><tr><td><img src="img/dependency-management-dependencies-report-build-scan.png" width="638" alt="Dependency tree in a build scan"></td></tr></table></div></div><br class="figure-break"><p>Every Gradle project provides the task <code class="literal">dependencies</code> to render the so-called <span class="emphasis"><em>dependency report</em></span> from the command line. By default the dependency report renders dependencies for all configurations. To pair down on the information provide the optional parameter <code class="literal">--configuration</code>.</p><div class="example"><a name="dependencyReport"></a><p class="title"><b>Example&nbsp;286.&nbsp;Rendering the dependency report for a custom configuration</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q dependencies --configuration scm</code></strong></p><pre class="screen">&gt; gradle -q dependencies --configuration scm

------------------------------------------------------------
Root project
------------------------------------------------------------

scm
\--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
     +--- com.jcraft:jsch:0.1.54
     +--- com.googlecode.javaewah:JavaEWAH:1.1.6
     +--- org.apache.httpcomponents:httpclient:4.3.6
     |    +--- org.apache.httpcomponents:httpcore:4.3.3
     |    +--- commons-logging:commons-logging:1.1.3
     |    \--- commons-codec:commons-codec:1.6
     \--- org.slf4j:slf4j-api:1.7.2
</pre></div></div><br class="example-break"><p>The dependencies report provides detailed information about the dependencies available in the graph. Any dependency that could not be resolved is marked with <code class="literal">FAILED</code> in red color. Dependencies with the same coordinates that can occur multiple times in the graph are omitted and indicated by an asterisk. Dependencies that had to undergo conflict resolution render the requested and selected version separated by a right arrow character.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="_identifying_which_dependency_version_was_selected_and_why" class="section-anchor" href="#_identifying_which_dependency_version_was_selected_and_why"></a>Identifying which dependency version was selected and why</h2></div></div></div><p>Large software projects inevitably deal with an increased number of dependencies either through direct or transitive dependencies. The <a class="link" href="#sec:listing_dependencies">dependencies report</a> provides you with the raw list of dependencies but does not explain <span class="emphasis"><em>why</em></span> they have been selected or <span class="emphasis"><em>which</em></span> dependency is responsible for pulling them into the graph.</p><p>Let&rsquo;s have a look at a concrete example. A project may request two different versions of the same dependency either as direct or transitive dependency. Gradle applies version conflict resolution to ensure that only one version of the dependency exists in the dependency graph. In this example the conflicting dependency is represented by <code class="literal">commons-codec:commons-codec</code>.</p><div class="example"><a name="jgit-dependency-with-conflict"></a><p class="title"><b>Example&nbsp;287.&nbsp;Declaring the JGit dependency and a conflicting dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}

configurations {
    scm
}

dependencies {
    scm <span class="hl-string">'org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r'</span>
    scm <span class="hl-string">'commons-codec:commons-codec:1.7'</span>
}
</pre></div></div><br class="example-break"><p>The dependency tree in a <a class="ulink" href="https://scans.gradle.com/" target="_top">build scan</a> renders the selection reason (conflict resolution) as well as the origin of a dependency if you click on a dependency and select the "Required By" tab.</p><div class="figure"><a name="N151FF"></a><p class="title"><b>Figure&nbsp;13.&nbsp;Dependency insight capabilities in a build scan</b></p><div class="figure-contents"><img src="img/dependency-management-dependency-insight-report-build-scan.png" alt="Dependency insight capabilities in a build scan"></div></div><br class="figure-break"><p>Every Gradle project provides the task <code class="literal">dependencyInsight</code> to render the so-called  <span class="emphasis"><em>dependency insight report</em></span> from the command line. Given a dependency in the dependency graph you can identify the selection reason and track down the origin of the dependency selection. You can think of the dependency insight report as the inverse representation of the dependency report for a given dependency. When executing the task you have to provide the mandatory parameter <code class="literal">--dependency</code> to specify the coordinates of the dependency under inspection. The parameter <code class="literal">--configuration</code> is optional but helps with filtering the output.</p><div class="example"><a name="dependencyInsightReport"></a><p class="title"><b>Example&nbsp;288.&nbsp;Using the dependency insight report for a given dependency</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q dependencyInsight --dependency commons-codec --configuration scm</code></strong></p><pre class="screen">&gt; gradle -q dependencyInsight --dependency commons-codec --configuration scm
commons-codec:commons-codec:1.7 (conflict resolution)
\--- scm

commons-codec:commons-codec:1.6 -&gt; 1.7
\--- org.apache.httpcomponents:httpclient:4.3.6
     \--- org.eclipse.jgit:org.eclipse.jgit:4.9.2.201712150930-r
          \--- scm
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="managing_transitive_dependencies"></a>Managing Transitive Dependencies</h1></div></div></div><p>Resolution behavior for transitive dependencies can be customized to a high degree to meet enterprise requirements.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:excluding_transitive_module_dependencies" class="section-anchor" href="#sec:excluding_transitive_module_dependencies"></a>Excluding transitive module dependencies</h2></div></div></div><p>Declared dependencies in a build script can pull in a lot of transitive dependencies. You might decide that you do not want a particular transitive dependency as part of the dependency graph for a good reason.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The dependency is undesired due to licensing constraints.</p></li><li class="listitem"><p>The dependency is not available in any of the declared repositories.</p></li><li class="listitem"><p>The metadata for the dependency exists but the artifact does not.</p></li><li class="listitem"><p>The metadata provides incorrect coordinates for a transitive dependency.</p></li></ul></div><p>Transitive dependencies can be excluded on the level of a declared dependency or a configuration. Let&rsquo;s demonstrate both use cases. In the following two examples the build script declares a dependency on Log4J, a popular logging framework in the Java world. The metadata of the particular version of Log4J also defines transitive dependencies.</p><div class="example"><a name="unresolvedTransitiveDependencies"></a><p class="title"><b>Example&nbsp;289.&nbsp;Unresolved artifacts for transitive dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>

repositories {
    mavenCentral()
}

dependencies {
    implementation <span class="hl-string">'log4j:log4j:1.2.15'</span>
}
</pre></div></div><br class="example-break"><p>If resolved from Maven Central some of the transitive dependencies provide metadata but not the corresponding binary artifact. As a result any task requiring the binary files will fail e.g. a compilation task.</p><pre class="screen">&gt; gradle -q compileJava

* What went wrong:
Could not resolve all files for configuration ':compileClasspath'.
&gt; Could not find jms.jar (javax.jms:jms:1.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/javax/jms/jms/1.1/jms-1.1.jar
&gt; Could not find jmxtools.jar (com.sun.jdmk:jmxtools:1.2.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/com/sun/jdmk/jmxtools/1.2.1/jmxtools-1.2.1.jar
&gt; Could not find jmxri.jar (com.sun.jmx:jmxri:1.2.1).
  Searched in the following locations:
      https://repo.maven.apache.org/maven2/com/sun/jmx/jmxri/1.2.1/jmxri-1.2.1.jar</pre><p>The situation can be fixed by adding a repository containing those dependencies. In the given example project, the source code does not actually use any of Log4J&rsquo;s functionality that require the JMS (e.g. <a class="ulink" href="https://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/net/JMSAppender.html" target="_top"><code class="literal">JMSAppender</code></a>) or JMX libraries. It&rsquo;s safe to exclude them from the dependency declaration.</p><p>Exclusions need to spelled out as a key/value pair via the attributes <code class="literal">group</code> and/or <code class="literal">module</code>. For more information, refer to <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html#exclude-java.util.Map-" target="_top"><code class="classname">ModuleDependency.exclude(java.util.Map)</code></a>.</p><div class="example"><a name="exclude-transitive-for-dependency"></a><p class="title"><b>Example&nbsp;290.&nbsp;Excluding transitive dependency for a particular dependency declaration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    implementation(<span class="hl-string">'log4j:log4j:1.2.15'</span>) {
        exclude group: <span class="hl-string">'javax.jms'</span>, module: <span class="hl-string">'jms'</span>
        exclude group: <span class="hl-string">'com.sun.jdmk'</span>, module: <span class="hl-string">'jmxtools'</span>
        exclude group: <span class="hl-string">'com.sun.jmx'</span>, module: <span class="hl-string">'jmxri'</span>
    }
}
</pre></div></div><br class="example-break"><p>You may find that other dependencies will want to pull in the same transitive dependency that misses the artifacts. Alternatively, you can exclude the transitive dependencies for a particular configuration by calling the method <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html#org.gradle.api.artifacts.Configuration:exclude(java.util.Map)" target="_top"><code class="classname">Configuration.exclude(java.util.Map)</code></a>.</p><div class="example"><a name="exclude-transitive-for-configuration"></a><p class="title"><b>Example&nbsp;291.&nbsp;Excluding transitive dependency for a particular configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    implementation {
        exclude group: <span class="hl-string">'javax.jms'</span>, module: <span class="hl-string">'jms'</span>
        exclude group: <span class="hl-string">'com.sun.jdmk'</span>, module: <span class="hl-string">'jmxtools'</span>
        exclude group: <span class="hl-string">'com.sun.jmx'</span>, module: <span class="hl-string">'jmxri'</span>
    }
}

dependencies {
    implementation <span class="hl-string">'log4j:log4j:1.2.15'</span>
}
</pre></div></div><br class="example-break"><div class="note"><p>As a build script author you often times know that you want to exclude a dependency for all configurations available in the project. You can use the method <a class="ulink" href="../javadoc/org/gradle/api/DomainObjectCollection.html#all-org.gradle.api.Action-" target="_top"><code class="classname">DomainObjectCollection.all(org.gradle.api.Action)</code></a> to define a global rule.</p></div><p>You might encounter other use cases that don&rsquo;t quite fit the bill of an exclude rule. For example you want to automatically select a version for a dependency with a specific requested version or you want to select a different group for a requested dependency to react to a relocation. Those use cases are better solved by the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> API. Some of these use cases are covered in <a class="xref" href="#customizing_dependency_resolution_behavior"><i>Customizing Dependency Resolution Behavior</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:enforcing_dependency_version" class="section-anchor" href="#sec:enforcing_dependency_version"></a>Enforcing a particular dependency version</h2></div></div></div><p>Gradle resolves any dependency version conflicts by selecting the latest version found in the dependency graph. Some projects might need to divert from the default behavior and enforce an earlier version of a dependency e.g. if the source code of the project depends on an older API of a dependency than some of the external libraries.</p><div class="note"><p>Enforcing a version of a dependency requires a conscious decision. Changing the version of a transitive dependency might lead to runtime errors if external libraries do not properly function without them. Consider upgrading your source code to use a newer version of the library as an alternative approach.</p></div><p>Let&rsquo;s say a project uses the <a class="ulink" href="https://hc.apache.org/httpcomponents-client-ga/" target="_top">HttpClient library</a> for performing HTTP calls. HttpClient pulls in <a class="ulink" href="https://commons.apache.org/proper/commons-codec/" target="_top">Commons Codec</a> as transitive dependency with version 1.10. However, the production source code of the project requires an API from Commons Codec 1.9 which is not available in 1.10 anymore. A dependency version can be enforced by declaring it in the build script and setting <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalDependency.html#setForce-boolean-" target="_top"><code class="classname">ExternalDependency.setForce(boolean)</code></a> to <code class="literal">true</code>.</p><div class="example"><a name="force-per-dependency"></a><p class="title"><b>Example&nbsp;292.&nbsp;Enforcing a dependency version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    implementation <span class="hl-string">'org.apache.httpcomponents:httpclient:4.5.4'</span>
    implementation(<span class="hl-string">'commons-codec:commons-codec:1.9'</span>) {
        force = true
    }
}
</pre></div></div><br class="example-break"><p>If the project requires a specific version of a dependency on a configuration-level then it can be achieved by calling the method <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html#org.gradle.api.artifacts.ResolutionStrategy:force(java.lang.Object[])" target="_top"><code class="classname">ResolutionStrategy.force(java.lang.Object[])</code></a>.</p><div class="example"><a name="force-per-configuration"></a><p class="title"><b>Example&nbsp;293.&nbsp;Enforcing a dependency version on the configuration-level</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    compileClasspath {
        resolutionStrategy.force <span class="hl-string">'commons-codec:commons-codec:1.9'</span>
    }
}

dependencies {
    implementation <span class="hl-string">'org.apache.httpcomponents:httpclient:4.5.4'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:disabling_resolution_transitive_dependencies" class="section-anchor" href="#sub:disabling_resolution_transitive_dependencies"></a>Disabling resolution of transitive dependencies</h2></div></div></div><p>By default Gradle resolves all transitive dependencies specified by the dependency metadata. Sometimes this behavior may not be desirable e.g. if the metadata is incorrect or defines a large graph of transitive dependencies. You can tell Gradle to disable transitive dependency management for a dependency by setting <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ModuleDependency.html#setTransitive-boolean-" target="_top"><code class="classname">ModuleDependency.setTransitive(boolean)</code></a> to <code class="literal">true</code>. As a result only the main artifact will be resolved for the declared dependency.</p><div class="example"><a name="disabling-transitive-dependency-resolution"></a><p class="title"><b>Example&nbsp;294.&nbsp;Disabling transitive dependency resolution for a declared dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    implementation(<span class="hl-string">'com.google.guava:guava:23.0'</span>) {
        transitive = false
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>Disabling transitive dependency resolution will likely require you to declare the necessary runtime dependencies in your build script which otherwise would have been resolved automatically. Not doing so might lead to runtime classpath issues.</p></div><p>A project can decide to disable transitive dependency resolution completely. You either don&rsquo;t want to rely on the metadata published to the consumed repositories or you want to gain full control over the dependencies in your graph. For more information, see <a class="ulink" href="../javadoc/org/gradle/api/artifacts/Configuration.html#setTransitive-boolean-" target="_top"><code class="classname">Configuration.setTransitive(boolean)</code></a>.</p><div class="example"><a name="disabling-transitive-dependency-resolution-for-configuration"></a><p class="title"><b>Example&nbsp;295.&nbsp;Disabling transitive dependency resolution on the configuration-level</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    transitive = false
}

dependencies {
    implementation <span class="hl-string">'com.google.guava:guava:23.0'</span>
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="working_with_dependencies"></a>Working with Dependencies</h1></div></div></div><p>For the examples below we have the following dependencies setup:</p><div class="example"><a name="configurationHandlingSetup"></a><p class="title"><b>Example&nbsp;296.&nbsp;Configuration.copy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    sealife
    alllife
}

dependencies {
    sealife <span class="hl-string">"sea.mammals:orca:1.0"</span>, <span class="hl-string">"sea.fish:shark:1.0"</span>, <span class="hl-string">"sea.fish:tuna:1.0"</span>
    alllife configurations.sealife
    alllife <span class="hl-string">"air.birds:albatross:1.0"</span>
}
</pre></div></div><br class="example-break"><p>The dependencies have the following transitive dependencies:</p><p>shark-1.0 -&gt; seal-2.0, tuna-1.0</p><p>orca-1.0 -&gt; seal-1.0</p><p>tuna-1.0 -&gt; herring-1.0</p><p>You can use the configuration to access the declared dependencies or a subset of those:</p><div class="example"><a name="configurationHandlingDependencies"></a><p class="title"><b>Example&nbsp;297.&nbsp;Accessing declared dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task dependencies {
    doLast {
        configurations.alllife.dependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.allDependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.allDependencies.findAll { dep -&gt; dep.name != <span class="hl-string">'orca'</span> }
            .each { dep -&gt; println dep.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q dependencies</code></strong></p><pre class="screen">&gt; gradle -q dependencies
albatross

albatross
orca
shark
tuna

albatross
shark
tuna
</pre></div></div><br class="example-break"><p>The <code class="literal">dependencies</code> task returns only the dependencies belonging explicitly to the configuration. The <code class="literal">allDependencies</code> task includes the dependencies from extended configurations.</p><p>To get the library files of the configuration dependencies you can do:</p><div class="example"><a name="configurationHandlingAllFiles"></a><p class="title"><b>Example&nbsp;298.&nbsp;Configuration.files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task allFiles {
    doLast {
        configurations.sealife.files.each { file -&gt;
            println file.name
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q allFiles</code></strong></p><pre class="screen">&gt; gradle -q allFiles
orca-1.0.jar
shark-1.0.jar
tuna-1.0.jar
seal-2.0.jar
herring-1.0.jar
</pre></div></div><br class="example-break"><p>Sometimes you want the library files of a subset of the configuration dependencies (e.g. of a single dependency).</p><div class="example"><a name="configurationHandlingFiles"></a><p class="title"><b>Example&nbsp;299.&nbsp;Configuration.files with spec</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task files {
    doLast {
        configurations.sealife.files { dep -&gt; dep.name == <span class="hl-string">'orca'</span> }.each { file -&gt;
            println file.name
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q files</code></strong></p><pre class="screen">&gt; gradle -q files
orca-1.0.jar
seal-2.0.jar</pre></div></div><br class="example-break"><p>The <code class="literal">Configuration.files</code> method always retrieves all artifacts of the <span class="emphasis"><em>whole</em></span> configuration. It then filters the retrieved files by specified dependencies. As you can see in the example, transitive dependencies are included.</p><p>You can also copy a configuration. You can optionally specify that only a subset of dependencies from the original configuration should be copied. The copying methods come in two flavors. The <code class="literal">copy</code> method copies only the dependencies belonging explicitly to the configuration. The <code class="literal">copyRecursive</code> method copies all the dependencies, including the dependencies from extended configurations.</p><div class="example"><a name="configurationHandlingCopy"></a><p class="title"><b>Example&nbsp;300.&nbsp;Configuration.copy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copy {
    doLast {
        configurations.alllife.copyRecursive { dep -&gt; dep.name != <span class="hl-string">'orca'</span> }
            .allDependencies.each { dep -&gt; println dep.name }
        println()
        configurations.alllife.copy().allDependencies
            .each { dep -&gt; println dep.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copy</code></strong></p><pre class="screen">&gt; gradle -q copy
albatross
shark
tuna

albatross
</pre></div></div><br class="example-break"><p>It is important to note that the returned files of the copied configuration are often but not always the same than the returned files of the dependency subset of the original configuration. In case of version conflicts between dependencies of the subset and dependencies not belonging to the subset the resolve result might be different.</p><div class="example"><a name="configurationHandlingCopyVsFiles"></a><p class="title"><b>Example&nbsp;301.&nbsp;Configuration.copy vs. Configuration.files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task copyVsFiles {
    doLast {
        configurations.sealife.copyRecursive { dep -&gt; dep.name == <span class="hl-string">'orca'</span> }
            .each { file -&gt; println file.name }
        println()
        configurations.sealife.files { dep -&gt; dep.name == <span class="hl-string">'orca'</span> }
            .each { file -&gt; println file.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q copyVsFiles</code></strong></p><pre class="screen">&gt; gradle -q copyVsFiles
orca-1.0.jar
seal-1.0.jar

orca-1.0.jar
seal-2.0.jar</pre></div></div><br class="example-break"><p>In the example above, <code class="literal">orca</code> has a dependency on <code class="literal">seal-1.0</code> whereas <code class="literal">shark</code> has a dependency on <code class="literal">seal-2.0</code>. The original configuration has therefore a version conflict which is resolved to the newer <code class="literal">seal-2.0</code> version. The <code class="literal">files</code> method therefore returns <code class="literal">seal-2.0</code> as a transitive dependency of <code class="literal">orca</code>. The copied configuration only has <code class="literal">orca</code> as a dependency and therefore there is no version conflict and <code class="literal">seal-1.0</code> is returned as a transitive dependency.</p><p>Once a configuration is resolved it is immutable. Changing its state or the state of one of its dependencies will cause an exception. You can always copy a resolved configuration. The copied configuration is in the unresolved state and can be freshly resolved.</p><p>To learn more about the API of the configuration class see the API documentation: <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a>.</p></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="customizing_dependency_resolution_behavior"></a>Customizing Dependency Resolution Behavior</h1></div></div></div><p>In most cases, Gradle&rsquo;s default dependency management will resolve the dependencies that you want in your build. In some cases, however, it can be necessary to tweak dependency resolution to ensure that your build receives exactly the right dependencies.</p><p>There are a number of ways that you can influence how Gradle resolves dependencies.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dependency_resolve_rules" class="section-anchor" href="#sec:dependency_resolve_rules"></a>Using dependency resolve rules</h2></div></div></div><p>A dependency resolve rule is executed for each resolved dependency, and offers a powerful api for manipulating a requested dependency prior to that dependency being resolved. This feature is <a class="link" href="#feature_lifecycle">incubating</a>, but currently offers the ability to change the group, name and/or version of a requested dependency, allowing a dependency to be substituted with a completely different module during resolution.</p><p>Dependency resolve rules provide a very powerful way to control the dependency resolution process, and can be used to implement all sorts of advanced patterns in dependency management. Some of these patterns are outlined below. For more information and code samples see the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> class in the API documentation.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:releasable_unit" class="section-anchor" href="#sec:releasable_unit"></a>Modelling releasable units</h3></div></div></div><p>Often an organisation publishes a set of libraries with a single version; where the libraries are built, tested and published together. These libraries form a 'releasable unit', designed and intended to be used as a whole. It does not make sense to use libraries from different releasable units together.</p><p>But it is easy for transitive dependency resolution to violate this contract. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">module-a</code> depends on <code class="literal">releasable-unit:part-one:1.0</code></p></li><li class="listitem"><p><code class="literal">module-b</code> depends on <code class="literal">releasable-unit:part-two:1.1</code></p></li></ul></div><p>A build depending on both <code class="literal">module-a</code> and <code class="literal">module-b</code> will obtain different versions of libraries within the releasable unit.</p><p>Dependency resolve rules give you the power to enforce releasable units in your build. Imagine a releasable unit defined by all libraries that have 'org.gradle' group. We can force all of these libraries to use a consistent version:</p><div class="example"><a name="releasable-unit"></a><p class="title"><b>Example&nbsp;302.&nbsp;Forcing consistent version for a group of libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="hl-keyword">if</span> (details.requested.group == <span class="hl-string">'org.gradle'</span>) {
            details.useVersion <span class="hl-string">'1.4'</span>
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:custom_versioning_scheme" class="section-anchor" href="#sec:custom_versioning_scheme"></a>Implementing a custom versioning scheme</h3></div></div></div><p>In some corporate environments, the list of module versions that can be declared in Gradle builds is maintained and audited externally. Dependency resolve rules provide a neat implementation of this pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In the build script, the developer declares dependencies with the module group and name, but uses a placeholder version, for example: <code class="literal">'default'</code>.</p></li><li class="listitem"><p>The 'default' version is resolved to a specific version via a dependency resolve rule, which looks up the version in a corporate catalog of approved modules.</p></li></ul></div><p>This rule implementation can be neatly encapsulated in a corporate plugin, and shared across all builds within the organisation.</p><div class="example"><a name="custom-versioning-scheme"></a><p class="title"><b>Example&nbsp;303.&nbsp;Using a custom versioning scheme</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="hl-keyword">if</span> (details.requested.version == <span class="hl-string">'default'</span>) {
            def version = findDefaultVersionInCatalog(details.requested.group, details.requested.name)
            details.useVersion version
        }
    }
}

def findDefaultVersionInCatalog(String group, String name) {
    <span class="hl-comment">//some custom logic that resolves the default version into a specific version</span>
    <span class="hl-string">"1.0"</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:blacklisting_version" class="section-anchor" href="#sec:blacklisting_version"></a>Blacklisting a particular version with a replacement</h3></div></div></div><p>Dependency resolve rules provide a mechanism for blacklisting a particular version of a dependency and providing a replacement version. This can be useful if a certain dependency version is broken and should not be used, where a dependency resolve rule causes this version to be replaced with a known good version. One example of a broken module is one that declares a dependency on a library that cannot be found in any of the public repositories, but there are many other reasons why a particular module version is unwanted and a different version is preferred.</p><p>In example below, imagine that version <code class="literal">1.2.1</code> contains important fixes and should always be used in preference to <code class="literal">1.2</code>. The rule provided will enforce just this: any time version <code class="literal">1.2</code> is encountered it will be replaced with <code class="literal">1.2.1</code>. Note that this is different from a forced version as described above, in that any other versions of this module would not be affected. This means that the 'newest' conflict resolution strategy would still select version <code class="literal">1.3</code> if this version was also pulled transitively.</p><div class="example"><a name="blacklisting_version"></a><p class="title"><b>Example&nbsp;304.&nbsp;Blacklisting a version with a replacement</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="hl-keyword">if</span> (details.requested.group == <span class="hl-string">'org.software'</span> &amp;&amp; details.requested.name == <span class="hl-string">'some-library'</span> &amp;&amp; details.requested.version == <span class="hl-string">'1.2'</span>) {
            <span class="hl-comment">//prefer different version which contains some necessary fixes</span>
            details.useVersion <span class="hl-string">'1.2.1'</span>
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:module_substitution" class="section-anchor" href="#sec:module_substitution"></a>Substituting a dependency module with a compatible replacement</h3></div></div></div><p>At times a completely different module can serve as a replacement for a requested module dependency. Examples include using <code class="literal">'groovy'</code> in place of <code class="literal">'groovy-all'</code>, or using <code class="literal">'log4j-over-slf4j'</code> instead of <code class="literal">'log4j'</code>. Starting with Gradle 1.5 you can make these substitutions using dependency resolve rules:</p><div class="example"><a name="module_substitution"></a><p class="title"><b>Example&nbsp;305.&nbsp;Changing dependency group and/or name at the resolution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        <span class="hl-keyword">if</span> (details.requested.name == <span class="hl-string">'groovy-all'</span>) {
            <span class="hl-comment">//prefer 'groovy' over 'groovy-all':</span>
            details.useTarget group: details.requested.group, name: <span class="hl-string">'groovy'</span>, version: details.requested.version
        }
        <span class="hl-keyword">if</span> (details.requested.name == <span class="hl-string">'log4j'</span>) {
            <span class="hl-comment">//prefer 'log4j-over-slf4j' over 'log4j', with fixed version:</span>
            details.useTarget <span class="hl-string">"org.slf4j:log4j-over-slf4j:1.7.10"</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="dependency_substitution_rules" class="section-anchor" href="#dependency_substitution_rules"></a>Dependency Substitution Rules</h2></div></div></div><p>Dependency substitution rules work similarly to dependency resolve rules. In fact, many capabilities of dependency resolve rules can be implemented with dependency substitution rules. They allow project and module dependencies to be transparently substituted with specified replacements. Unlike dependency resolve rules, dependency substitution rules allow project and module dependencies to be substituted interchangeably.</p><p><span class="emphasis"><em>Adding a dependency substitution rule to a configuration changes the timing of when that configuration is resolved.</em></span> Instead of being resolved on first use, the configuration is instead resolved when the task graph is being constructed. This can have unexpected consequences if the configuration is being further modified during task execution, or if the configuration relies on modules that are published during execution of another task.</p><p>To explain:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <code class="literal">Configuration</code> can be declared as an input to any Task, and that configuration can include project dependencies when it is resolved.</p></li><li class="listitem"><p>If a project dependency is an input to a Task (via a configuration), then tasks to build the project artifacts must be added to the task dependencies.</p></li><li class="listitem"><p>In order to determine the project dependencies that are inputs to a task, Gradle needs to resolve the <code class="literal">Configuration</code> inputs.</p></li><li class="listitem"><p>Because the Gradle task graph is fixed once task execution has commenced, Gradle needs to perform this resolution prior to executing any tasks.</p></li></ul></div><p>In the absence of dependency substitution rules, Gradle knows that an external module dependency will never transitively reference a project dependency. This makes it easy to determine the full set of project dependencies for a configuration through simple graph traversal. With this functionality, Gradle can no longer make this assumption, and must perform a full resolve in order to determine the project dependencies.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:module_to_project_substitution" class="section-anchor" href="#sec:module_to_project_substitution"></a>Substituting an external module dependency with a project dependency</h3></div></div></div><p>One use case for dependency substitution is to use a locally developed version of a module in place of one that is downloaded from an external repository. This could be useful for testing a local, patched version of a dependency.</p><p>The module to be replaced can be declared with or without a version specified.</p><div class="example"><a name="module_to_project_substitution"></a><p class="title"><b>Example&nbsp;306.&nbsp;Substituting a module with a project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute module(<span class="hl-string">"org.utils:api"</span>) with project(<span class="hl-string">":api"</span>)
        substitute module(<span class="hl-string">"org.utils:util:2.5"</span>) with project(<span class="hl-string">":util"</span>)
    }
}
</pre></div></div><br class="example-break"><p>Note that a project that is substituted must be included in the multi-project build (via settings.gradle). Dependency substitution rules take care of replacing the module dependency with the project dependency and wiring up any task dependencies, but do not implicitly include the project in the build.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:project_to_module_substitution" class="section-anchor" href="#sec:project_to_module_substitution"></a>Substituting a project dependency with a module replacement</h3></div></div></div><p>Another way to use substitution rules is to replace a project dependency with a module in a multi-project build. This can be useful to speed up development with a large multi-project build, by allowing a subset of the project dependencies to be downloaded from a repository rather than being built.</p><p>The module to be used as a replacement must be declared with a version specified.</p><div class="example"><a name="project_to_module_substitution"></a><p class="title"><b>Example&nbsp;307.&nbsp;Substituting a project with a module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution {
        substitute project(<span class="hl-string">":api"</span>) with module(<span class="hl-string">"org.utils:api:1.3"</span>)
    }
}
</pre></div></div><br class="example-break"><p>When a project dependency has been replaced with a module dependency, that project is still included in the overall multi-project build. However, tasks to build the replaced dependency will not be executed in order to build the resolve the depending <code class="literal">Configuration</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:conditional_dependency_substitution" class="section-anchor" href="#sec:conditional_dependency_substitution"></a>Conditionally substituting a dependency</h3></div></div></div><p>A common use case for dependency substitution is to allow more flexible assembly of sub-projects within a multi-project build. This can be useful for developing a local, patched version of an external dependency or for building a subset of the modules within a large multi-project build.</p><p>The following example uses a dependency substitution rule to replace any module dependency with the group "org.example", but only if a local project matching the dependency name can be located.</p><div class="example"><a name="project_substitution"></a><p class="title"><b>Example&nbsp;308.&nbsp;Conditionally substituting a dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.dependencySubstitution.all { DependencySubstitution dependency -&gt;
        <span class="hl-keyword">if</span> (dependency.requested <span class="hl-keyword">instanceof</span> ModuleComponentSelector &amp;&amp; dependency.requested.group == <span class="hl-string">"org.example"</span>) {
            def targetProject = findProject(<span class="hl-string">":${dependency.requested.module}"</span>)
            <span class="hl-keyword">if</span> (targetProject != null) {
                dependency.useTarget targetProject
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note that a project that is substituted must be included in the multi-project build (via settings.gradle). Dependency substitution rules take care of replacing the module dependency with the project dependency, but do not implicitly include the project in the build.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuration_defaults" class="section-anchor" href="#sec:configuration_defaults"></a>Specifying default dependencies for a configuration</h2></div></div></div><p>A configuration can be configured with default dependencies to be used if no dependencies are explicitly set for the configuration. A primary use case of this functionality is for developing plugins that make use of versioned tools that the user might override. By specifying default dependencies, the plugin can use a default version of the tool only if the user has not specified a particular version to use.</p><div class="example"><a name="configuration_default_dependencies"></a><p class="title"><b>Example&nbsp;309.&nbsp;Specifying default dependencies on a configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    pluginTool {
        defaultDependencies { dependencies -&gt;
            dependencies.add(<span class="hl-keyword">this</span>.project.dependencies.create(<span class="hl-string">"org.gradle:my-util:1.0"</span>))
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="ivy_dynamic_resolve_mode" class="section-anchor" href="#ivy_dynamic_resolve_mode"></a>Enabling Ivy dynamic resolve mode</h2></div></div></div><p>Gradle&rsquo;s Ivy repository implementations support the equivalent to Ivy&rsquo;s dynamic resolve mode. Normally, Gradle will use the <code class="literal">rev</code> attribute for each dependency definition included in an <code class="literal">ivy.xml</code> file. In dynamic resolve mode, Gradle will instead prefer the <code class="literal">revConstraint</code> attribute over the <code class="literal">rev</code> attribute for a given dependency definition. If the <code class="literal">revConstraint</code> attribute is not present, the <code class="literal">rev</code> attribute is used instead.</p><p>To enable dynamic resolve mode, you need to set the appropriate option on the repository definition. A couple of examples are shown below. Note that dynamic resolve mode is only available for Gradle&rsquo;s Ivy repositories. It is not available for Maven repositories, or custom Ivy <code class="literal">DependencyResolver</code> implementations.</p><div class="example"><a name="dynamicResolveMode"></a><p class="title"><b>Example&nbsp;310.&nbsp;Enabling dynamic resolve mode</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Can enable dynamic resolve mode when you define the repository</span>
repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
        resolve.dynamicMode = true
    }
}

<span class="hl-comment">// Can use a rule instead to enable (or disable) dynamic resolve mode for all repositories</span>
repositories.withType(IvyArtifactRepository) {
    resolve.dynamicMode = true
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="component_metadata_rules" class="section-anchor" href="#component_metadata_rules"></a>Component metadata rules</h2></div></div></div><p>Each module (also called <span class="emphasis"><em>component</em></span>) has metadata associated with it, such as its group, name, version, dependencies, and so on. This metadata typically originates in the module&rsquo;s descriptor. Metadata rules allow certain parts of a module&rsquo;s metadata to be manipulated from within the build script. They take effect after a module&rsquo;s descriptor has been downloaded, but before it has been selected among all candidate versions. This makes metadata rules another instrument for customizing dependency resolution.</p><p>One piece of module metadata that Gradle understands is a module&rsquo;s <span class="emphasis"><em>status scheme</em></span>. This concept, also known from Ivy, models the different levels of maturity that a module transitions through over time. The default status scheme, ordered from least to most mature status, is <code class="literal">integration</code>, <code class="literal">milestone</code>, <code class="literal">release</code>. Apart from a status scheme, a module also has a (current) <span class="emphasis"><em>status</em></span>, which must be one of the values in its status scheme. If not specified in the (Ivy) descriptor, the status defaults to <code class="literal">integration</code> for Ivy modules and Maven snapshot modules, and <code class="literal">release</code> for Maven modules that aren&rsquo;t snapshots.</p><p>A module&rsquo;s status and status scheme are taken into consideration when a <code class="literal">latest</code> version selector is resolved. Specifically, <code class="literal">latest.someStatus</code> will resolve to the highest module version that has status <code class="literal">someStatus</code> or a more mature status. For example, with the default status scheme in place, <code class="literal">latest.integration</code> will select the highest module version regardless of its status (because <code class="literal">integration</code> is the least mature status), whereas <code class="literal">latest.release</code> will select the highest module version with status <code class="literal">release</code>. Here is what this looks like in code:</p><div class="example"><a name="latestSelector"></a><p class="title"><b>Example&nbsp;311.&nbsp;'Latest' version selector</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config1 <span class="hl-string">"org.sample:client:latest.integration"</span>
    config2 <span class="hl-string">"org.sample:client:latest.release"</span>
}

task listConfigs {
    doLast {
        configurations.config1.each { println it.name }
        println()
        configurations.config2.each { println it.name }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q listConfigs</code></strong></p><pre class="screen">&gt; gradle -q listConfigs
client-1.5.jar

client-1.4.jar</pre></div></div><br class="example-break"><p>The next example demonstrates <code class="literal">latest</code> selectors based on a custom status scheme declared in a component metadata rule that applies to all modules:</p><div class="example"><a name="customStatusScheme"></a><p class="title"><b>Example&nbsp;312.&nbsp;Custom status scheme</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config3 <span class="hl-string">"org.sample:api:latest.silver"</span>
    components {
        all { ComponentMetadataDetails details -&gt;
            <span class="hl-keyword">if</span> (details.id.group == <span class="hl-string">"org.sample"</span> &amp;&amp; details.id.name == <span class="hl-string">"api"</span>) {
                details.statusScheme = [<span class="hl-string">"bronze"</span>, <span class="hl-string">"silver"</span>, <span class="hl-string">"gold"</span>, <span class="hl-string">"platinum"</span>]
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Component metadata rules can be applied to a specified module. Modules must be specified in the form of "group:module".</p><div class="example"><a name="customStatusSchemeModule"></a><p class="title"><b>Example&nbsp;313.&nbsp;Custom status scheme by module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config4 <span class="hl-string">"org.sample:lib:latest.prod"</span>
    components {
        withModule(<span class="hl-string">'org.sample:lib'</span>) { ComponentMetadataDetails details -&gt;
            details.statusScheme = [<span class="hl-string">"int"</span>, <span class="hl-string">"rc"</span>, <span class="hl-string">"prod"</span>]
        }
    }
}
</pre></div></div><br class="example-break"><p>Gradle can also create component metadata rules utilizing Ivy-specific metadata for modules resolved from an Ivy repository. Values from the Ivy descriptor are made available via the <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a> interface.</p><div class="example"><a name="ivyComponentMetadataRule"></a><p class="title"><b>Example&nbsp;314.&nbsp;Ivy component metadata rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config6 <span class="hl-string">"org.sample:lib:latest.rc"</span>
    components {
        withModule(<span class="hl-string">"org.sample:lib"</span>) { ComponentMetadataDetails details, IvyModuleDescriptor ivyModule -&gt;
            <span class="hl-keyword">if</span> (ivyModule.branch == <span class="hl-string">'testing'</span>) {
                details.status = <span class="hl-string">"rc"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note that any rule that declares specific arguments must <span class="emphasis"><em>always</em></span> include a <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadataDetails.html" target="_top"><code class="classname">ComponentMetadataDetails</code></a> argument as the first argument. The second Ivy metadata argument is optional.</p><p>Component metadata rules can also be defined using a <span class="emphasis"><em>rule source</em></span> object. A rule source object is any object that contains exactly one method that defines the rule action and is annotated with <code class="literal">@Mutate</code>.</p><p>This method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>must return void.</p></li><li class="listitem"><p>must have <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadataDetails.html" target="_top"><code class="classname">ComponentMetadataDetails</code></a> as the first argument.</p></li><li class="listitem"><p>may have an additional parameter of type <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.</p></li></ul></div><div class="example"><a name="ruleSourceComponentMetadataRule"></a><p class="title"><b>Example&nbsp;315.&nbsp;Rule source component metadata rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    config5 <span class="hl-string">"org.sample:api:latest.gold"</span>
    components {
        withModule(<span class="hl-string">'org.sample:api'</span>, <span class="hl-keyword">new</span> CustomStatusRule())
    }
}

<span class="hl-keyword">class</span> CustomStatusRule {
    <span class="hl-annotation">@Mutate</span>
    <span class="hl-keyword">void</span> setStatusScheme(ComponentMetadataDetails details) {
        details.statusScheme = [<span class="hl-string">"bronze"</span>, <span class="hl-string">"silver"</span>, <span class="hl-string">"gold"</span>, <span class="hl-string">"platinum"</span>]
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="component_selection_rules" class="section-anchor" href="#component_selection_rules"></a>Component Selection Rules</h2></div></div></div><p>Component selection rules may influence which component instance should be selected when multiple versions are available that match a version selector. Rules are applied against every available version and allow the version to be explicitly rejected by rule. This allows Gradle to ignore any component instance that does not satisfy conditions set by the rule. Examples include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For a dynamic version like '1.+' certain versions may be explicitly rejected from selection</p></li><li class="listitem"><p>For a static version like '1.4' an instance may be rejected based on extra component metadata such as the Ivy branch attribute, allowing an instance from a subsequent repository to be used.</p></li></ul></div><p>Rules are configured via the <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelectionRules.html" target="_top"><code class="classname">ComponentSelectionRules</code></a> object. Each rule configured will be called with a <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> object as an argument which contains information about the candidate version being considered. Calling <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html#org.gradle.api.artifacts.ComponentSelection:reject(java.lang.String)" target="_top"><code class="classname">ComponentSelection.reject(java.lang.String)</code></a> causes the given candidate version to be explicitly rejected, in which case the candidate will not be considered for the selector.</p><p>The following example shows a rule that disallows a particular version of a module but allows the dynamic version to choose the next best candidate.</p><div class="example"><a name="componentSelectionRulesReject"></a><p class="title"><b>Example&nbsp;316.&nbsp;Component selection rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    rejectConfig {
        resolutionStrategy {
            componentSelection {
                <span class="hl-comment">// Accept the highest version matching the requested version that isn't '1.5'</span>
                all { ComponentSelection selection -&gt;
                    <span class="hl-keyword">if</span> (selection.candidate.group == <span class="hl-string">'org.sample'</span> &amp;&amp; selection.candidate.module == <span class="hl-string">'api'</span> &amp;&amp; selection.candidate.version == <span class="hl-string">'1.5'</span>) {
                        selection.reject(<span class="hl-string">"version 1.5 is broken for 'org.sample:api'"</span>)
                    }
                }
            }
        }
    }
}

dependencies {
    rejectConfig <span class="hl-string">"org.sample:api:1.+"</span>
}
</pre></div></div><br class="example-break"><p>Note that version selection is applied starting with the highest version first. The version selected will be the first version found that all component selection rules accept. A version is considered accepted no rule explicitly rejects it.</p><p>Similarly, rules can be targeted at specific modules. Modules must be specified in the form of "group:module".</p><div class="example"><a name="componentSelectionRulesTarget"></a><p class="title"><b>Example&nbsp;317.&nbsp;Component selection rule with module target</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    targetConfig {
        resolutionStrategy {
            componentSelection {
                withModule(<span class="hl-string">"org.sample:api"</span>) { ComponentSelection selection -&gt;
                    <span class="hl-keyword">if</span> (selection.candidate.version == <span class="hl-string">"1.5"</span>) {
                        selection.reject(<span class="hl-string">"version 1.5 is broken for 'org.sample:api'"</span>)
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Component selection rules can also consider component metadata when selecting a version. Possible metadata arguments that can be considered are <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html" target="_top"><code class="classname">ComponentMetadata</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.</p><div class="example"><a name="componentSelectionRulesMetadata"></a><p class="title"><b>Example&nbsp;318.&nbsp;Component selection rule with metadata</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    metadataRulesConfig {
        resolutionStrategy {
            componentSelection {
                <span class="hl-comment">// Reject any versions with a status of 'experimental'</span>
                all { ComponentSelection selection, ComponentMetadata metadata -&gt;
                    <span class="hl-keyword">if</span> (selection.candidate.group == <span class="hl-string">'org.sample'</span> &amp;&amp; metadata.status == <span class="hl-string">'experimental'</span>) {
                        selection.reject(<span class="hl-string">"don't use experimental candidates from 'org.sample'"</span>)
                    }
                }
                <span class="hl-comment">// Accept the highest version with either a "release" branch or a status of 'milestone'</span>
                withModule(<span class="hl-string">'org.sample:api'</span>) { ComponentSelection selection, IvyModuleDescriptor descriptor, ComponentMetadata metadata -&gt;
                    <span class="hl-keyword">if</span> (descriptor.branch != <span class="hl-string">"release"</span> &amp;&amp; metadata.status != <span class="hl-string">'milestone'</span>) {
                        selection.reject(<span class="hl-string">"'org.sample:api' must have testing branch or milestone status"</span>)
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note that a <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> argument is <span class="emphasis"><em>always</em></span> required as the first parameter when declaring a component selection rule with additional Ivy metadata parameters, but the metadata parameters can be declared in any order.</p><p>Lastly, component selection rules can also be defined using a <span class="emphasis"><em>rule source</em></span> object. A rule source object is any object that contains exactly one method that defines the rule action and is annotated with <code class="literal">@Mutate</code>.</p><p>This method:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>must return void.</p></li><li class="listitem"><p>must have <a class="ulink" href="../dsl/org.gradle.api.artifacts.ComponentSelection.html" target="_top"><code class="classname">ComponentSelection</code></a> as the first argument.</p></li><li class="listitem"><p>may have additional parameters of type <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ComponentMetadata.html" target="_top"><code class="classname">ComponentMetadata</code></a> and/or <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ivy/IvyModuleDescriptor.html" target="_top"><code class="classname">IvyModuleDescriptor</code></a>.</p></li></ul></div><div class="example"><a name="componentSelectionRulesRuleSource"></a><p class="title"><b>Example&nbsp;319.&nbsp;Component selection rule using a rule source object</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> RejectTestBranch {
    <span class="hl-annotation">@Mutate</span>
    <span class="hl-keyword">void</span> evaluateRule(ComponentSelection selection, IvyModuleDescriptor ivy) {
        <span class="hl-keyword">if</span> (ivy.branch == <span class="hl-string">"test"</span>) {
            selection.reject(<span class="hl-string">"reject test branch"</span>)
        }
    }
}

configurations {
    ruleSourceConfig {
        resolutionStrategy {
            componentSelection {
                all <span class="hl-keyword">new</span> RejectTestBranch()
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:module_replacement" class="section-anchor" href="#sec:module_replacement"></a>Module replacement rules</h2></div></div></div><p>Module replacement rules allow a build to declare that a legacy library has been replaced by a new one. A good example when a new library replaced a legacy one is the "google-collections" -&gt; "guava" migration. The team that created google-collections decided to change the module name from "com.google.collections:google-collections" into "com.google.guava:guava". This is a legal scenario in the industry: teams need to be able to change the names of products they maintain, including the module coordinates. Renaming of the module coordinates has impact on conflict resolution.</p><p>To explain the impact on conflict resolution, let&rsquo;s consider the "google-collections" -&gt; "guava" scenario. It may happen that both libraries are pulled into the same dependency graph. For example, "our" project depends on guava but some of our dependencies pull in a legacy version of google-collections. This can cause runtime errors, for example during test or application execution. Gradle does not automatically resolve the google-collections VS guava conflict because it is not considered as a "version conflict". It&rsquo;s because the module coordinates for both libraries are completely different and conflict resolution is activated when "group" and "name" coordinates are the same but there are different versions available in the dependency graph (for more info, refer to the section on conflict resolution). Traditional remedies to this problem are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Declare exclusion rule to avoid pulling in "google-collections" to graph. It is probably the most popular approach.</p></li><li class="listitem"><p>Avoid dependencies that pull in legacy libraries.</p></li><li class="listitem"><p>Upgrade the dependency version if the new version no longer pulls in a legacy library.</p></li><li class="listitem"><p>Downgrade to "google-collections". It&rsquo;s not recommended, just mentioned for completeness.</p></li></ul></div><p>Traditional approaches work but they are not general enough. For example, an organisation wants to resolve the google-collections VS guava conflict resolution problem in all projects. Starting from Gradle 2.2 it is possible to declare that certain module was replaced by other. This enables organisations to include the information about module replacement in the corporate plugin suite and resolve the problem holistically for all Gradle-powered projects in the enterprise.</p><div class="example"><a name="module_replacement_declaration"></a><p class="title"><b>Example&nbsp;320.&nbsp;Declaring module replacement</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    modules {
        module(<span class="hl-string">"com.google.collections:google-collections"</span>) {
            replacedBy(<span class="hl-string">"com.google.guava:guava"</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>For more examples and detailed API, refer to the DSL reference for <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.ComponentMetadataHandler.html" target="_top"><code class="classname">ComponentMetadataHandler</code></a>.</p><p>What happens when we declare that "google-collections" are replaced by "guava"? Gradle can use this information for conflict resolution. Gradle will consider every version of "guava" newer/better than any version of "google-collections". Also, Gradle will ensure that only guava jar is present in the classpath / resolved file list. Note that if only "google-collections" appears in the dependency graph (e.g. no "guava") Gradle will not eagerly replace it with "guava". Module replacement is an information that Gradle uses for resolving conflicts. If there is no conflict (e.g. only "google-collections" or only "guava" in the graph) the replacement information is not used.</p><p>Currently it is not possible to declare that certain modules is replaced by a set of modules. However, it is possible to declare that multiple modules are replaced by a single module.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="troubleshooting_dependency_resolution"></a>Troubleshooting Dependency Resolution</h1></div></div></div><p>Managing large dependency graphs can be challenging. This section describes techniques for troubleshooting issues you might encounter in your project.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:versioning_the_jar_name" class="section-anchor" href="#sub:versioning_the_jar_name"></a>Putting the version in the filename (version the jar)</h2></div></div></div><p>The version of a library must be part of the filename. While the version of a jar is usually in the Manifest file, it isn&rsquo;t readily apparent when you are inspecting a project. If someone asks you to look at a collection of 20 jar files, which would you prefer? A collection of files with names like <code class="literal">commons-beanutils-1.3.jar</code> or a collection of files with names like <code class="literal">spring.jar</code>? If dependencies have file names with version numbers you can quickly identify the versions of your dependencies.</p><p>If versions are unclear you can introduce subtle bugs which are very hard to find. For example there might be a project which uses Hibernate 2.5. Think about a developer who decides to install version 3.0.5 of Hibernate on her machine to fix a critical security bug but forgets to notify others in the team of this change. She may address the security bug successfully, but she also may have introduced subtle bugs into a codebase that was using a now-deprecated feature from Hibernate. Weeks later there is an exception on the integration machine which can&rsquo;t be reproduced on anyone&rsquo;s machine. Multiple developers then spend days on this issue only finally realising that the error would have been easy to uncover if they knew that Hibernate had been upgraded from 2.5 to 3.0.5.</p><p>Versions in jar names increase the expressiveness of your project and make them easier to maintain. This practice also reduces the potential for error.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:version_conflicts" class="section-anchor" href="#sub:version_conflicts"></a>Resolving version conflicts</h2></div></div></div><p>Conflicting versions of the same jar should be detected and either resolved or cause an exception. If you don&rsquo;t use transitive dependency management, version conflicts are undetected and the often accidental order of the classpath will determine what version of a dependency will win. On a large project with many developers changing dependencies, successful builds will be few and far between as the order of dependencies may directly affect whether a build succeeds or fails (or whether a bug appears or disappears in production).</p><p>If you haven&rsquo;t had to deal with the curse of conflicting versions of jars on a classpath, here is a small anecdote of the fun that awaits you. In a large project with 30 submodules, adding a dependency to a subproject changed the order of a classpath, swapping Spring 2.5 for an older 2.4 version. While the build continued to work, developers were starting to notice all sorts of surprising (and surprisingly awful) bugs in production. Worse yet, this unintentional downgrade of Spring introduced several security vulnerabilities into the system, which now required a full security audit throughout the organization.</p><p>In short, version conflicts are bad, and you should manage your transitive dependencies to avoid them. You might also want to learn where conflicting versions are used and consolidate on a particular version of a dependency across your organization. With a good conflict reporting tool like Gradle, that information can be used to communicate with the entire organization and standardize on a single version. <span class="emphasis"><em>If you think version conflicts don&rsquo;t happen to you, think again.</em></span> It is very common for different first-level dependencies to rely on a range of different overlapping versions for other dependencies, and the JVM doesn&rsquo;t yet offer an easy way to have different versions of the same jar in the classpath (see <a class="xref" href="#sub:dependency_management_and_java">the section called &ldquo;Dependency management and Java&rdquo;</a>).</p><p>Gradle offers the following conflict resolution strategies:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Newest</em></span>: The newest version of the dependency is used. This is Gradle&rsquo;s default strategy, and is often an appropriate choice as long as versions are backwards-compatible.</p></li><li class="listitem"><p><span class="emphasis"><em>Fail</em></span>: A version conflict results in a build failure. This strategy requires all version conflicts to be resolved explicitly in the build script. See <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a> for details on how to explicitly choose a particular version.</p></li></ul></div><p>While the strategies introduced above are usually enough to solve most conflicts, Gradle provides more fine-grained mechanisms to resolve version conflicts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Configuring a first level dependency as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is already a first level dependency. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a>.</p></li><li class="listitem"><p>Configuring any dependency (transitive or not) as <span class="emphasis"><em>forced</em></span>. This approach is useful if the dependency in conflict is a transitive dependency. It also can be used to force versions of first level dependencies. See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p></li><li class="listitem"><p>Configuring dependency resolution to <span class="emphasis"><em>prefer modules that are part of your build</em></span> (transitive or not). This approach is useful if your build contains custom forks of modules (as part of <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a> or as include in <a class="xref" href="#composite_builds"><i>Composite builds</i></a>). See examples in <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p></li><li class="listitem"><p>Dependency resolve rules are an <a class="link" href="#feature_lifecycle">incubating</a> feature give you fine-grained control over the version selected for a particular dependency.</p></li></ul></div><p>To deal with problems due to version conflicts, reports with dependency graphs are also very helpful. Such reports are another feature of dependency management.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:dynamic_versions_and_changing_modules" class="section-anchor" href="#sub:dynamic_versions_and_changing_modules"></a>Using dynamic versions and changing modules</h2></div></div></div><p>There are many situations when you want to use the latest version of a particular dependency, or the latest in a range of versions. This can be a requirement during development, or you may be developing a library that is designed to work with a range of dependency versions. You can easily depend on these constantly changing dependencies by using a <span class="emphasis"><em>dynamic version</em></span>. A dynamic version can be either a version range (e.g. <code class="literal">2.+</code>) or it can be a placeholder for the latest version available (e.g. <code class="literal">latest.integration</code>).</p><p>Alternatively, sometimes the module you request can change over time, even for the same version. An example of this type of <span class="emphasis"><em>changing module</em></span> is a Maven <code class="literal">SNAPSHOT</code> module, which always points at the latest artifact published. In other words, a standard Maven snapshot is a module that never stands still so to speak, it is a &ldquo;changing module&rdquo;.</p><p>The main difference between a <span class="emphasis"><em>dynamic version</em></span> and a <span class="emphasis"><em>changing module</em></span> is that when you resolve a <span class="emphasis"><em>dynamic version</em></span>, you&rsquo;ll get the real, static version as the module name. When you resolve a <span class="emphasis"><em>changing module</em></span>, the artifacts are named using the version you requested, but the underlying artifacts may change over time.</p><p>By default, Gradle caches dynamic versions and changing modules for 24 hours. You can override the default cache modes using <a class="link" href="#sec:controlling_dependency_caching_command_line">command line options</a>. You can also <a class="link" href="#sec:controlling_dependency_caching_programmatically">change the cache expiry times in your build programmatically</a> using the resolution strategy.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:controlling_dependency_caching_programmatically" class="section-anchor" href="#sec:controlling_dependency_caching_programmatically"></a>Controlling dependency caching programmatically</h2></div></div></div><p>You can fine-tune certain aspects of caching using the <code class="literal">ResolutionStrategy</code> for a configuration.</p><p>By default, Gradle caches dynamic versions for 24 hours. To change how long Gradle will cache the resolved version for a dynamic version, use:</p><div class="example"><a name="dynamic-version-cache-control"></a><p class="title"><b>Example&nbsp;321.&nbsp;Dynamic version cache control</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.cacheDynamicVersionsFor <span class="hl-number">10</span>, <span class="hl-string">'minutes'</span>
}
</pre></div></div><br class="example-break"><p>By default, Gradle caches changing modules for 24 hours. To change how long Gradle will cache the meta-data and artifacts for a changing module, use:</p><div class="example"><a name="changing-module-cache-control"></a><p class="title"><b>Example&nbsp;322.&nbsp;Changing module cache control</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.cacheChangingModulesFor <span class="hl-number">4</span>, <span class="hl-string">'hours'</span>
}
</pre></div></div><br class="example-break"><p>For more details, take a look at the API documentation for <a class="ulink" href="../dsl/org.gradle.api.artifacts.ResolutionStrategy.html" target="_top"><code class="classname">ResolutionStrategy</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:controlling_dependency_caching_command_line" class="section-anchor" href="#sec:controlling_dependency_caching_command_line"></a>Controlling dependency caching from the command line</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_avoiding_network_access_with_offline_mode" class="section-anchor" href="#_avoiding_network_access_with_offline_mode"></a>Avoiding network access with offline mode</h3></div></div></div><p>The <code class="literal">--offline</code> command line switch tells Gradle to always use dependency modules from the cache, regardless if they are due to be checked again. When running with offline, Gradle will never attempt to access the network to perform dependency resolution. If required modules are not present in the dependency cache, build execution will fail.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_forcing_all_dependencies_to_be_re_resolved" class="section-anchor" href="#_forcing_all_dependencies_to_be_re_resolved"></a>Forcing all dependencies to be re-resolved</h3></div></div></div><p>At times, the Gradle Dependency Cache can be out of sync with the actual state of the configured repositories. Perhaps a repository was initially misconfigured, or perhaps a &ldquo;non-changing&rdquo; module was published incorrectly. To refresh all dependencies in the dependency cache, use the <code class="literal">--refresh-dependencies</code> option on the command line.</p><p>The <code class="literal">--refresh-dependencies</code> option tells Gradle to ignore all cached entries for resolved modules and artifacts. A fresh resolve will be performed against all configured repositories, with dynamic versions recalculated, modules refreshed, and artifacts downloaded. However, where possible Gradle will check if the previously downloaded artifacts are valid before downloading again. This is done by comparing published SHA1 values in the repository with the SHA1 values for existing downloaded artifacts.</p></div></div></div></div><div class="part" title="Extending the build"><div class="titlepage"><div><div><h1 class="title"><a name="N15705"></a>Extending the build</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="custom_tasks"></a>Writing Custom Task Classes</h1></div></div></div><p>Gradle supports two types of task. One such type is the simple task, where you define the task with an action closure. We have seen these in <a class="xref" href="#tutorial_using_tasks"><i>Build Script Basics</i></a>. For this type of task, the action closure determines the behaviour of the task. This type of task is good for implementing one-off tasks in your build script.</p><p>The other type of task is the enhanced task, where the behaviour is built into the task, and the task provides some properties which you can use to configure the behaviour. We have seen these in <a class="xref" href="#more_about_tasks"><i>Authoring Tasks</i></a>. Most Gradle plugins use enhanced tasks. With enhanced tasks, you don&rsquo;t need to implement the task behaviour as you do with simple tasks. You simply declare the task and configure the task using its properties. In this way, enhanced tasks let you reuse a piece of behaviour in many different places, possibly across different builds.</p><p>The behaviour and properties of an enhanced task is defined by the task&rsquo;s class. When you declare an enhanced task, you specify the type, or class of the task.</p><p>Implementing your own custom task class in Gradle is easy. You can implement a custom task class in pretty much any language you like, provided it ends up compiled to bytecode. In our examples, we are going to use Groovy as the implementation language. Groovy, Java or Kotlin are all good choices as the language to use to implement a task class, as the Gradle API has been designed to work well with these languages. In general, a task implemented using Java or Kotlin, which are statically typed, will perform better than the same task implemented using Groovy.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:packaging_a_task_class" class="section-anchor" href="#sec:packaging_a_task_class"></a>Packaging a task class</h2></div></div></div><p>There are several places where you can put the source for the task class.</p><div class="variablelist"><dl><dt><span class="term">Build script</span></dt><dd><p>You can include the task class directly in the build script. This has the benefit that the task class is automatically compiled and included in the classpath of the build script without you having to do anything. However, the task class is not visible outside the build script, and so you cannot reuse the task class outside the build script it is defined in.</p></dd><dt><span class="term"><code class="literal">buildSrc</code> project</span></dt><dd><p>You can put the source for the task class in the <code class="literal"><span class="emphasis"><em>rootProjectDir</em></span>/buildSrc/src/main/groovy</code> directory. Gradle will take care of compiling and testing the task class and making it available on the classpath of the build script. The task class is visible to every build script used by the build. However, it is not visible outside the build, and so you cannot reuse the task class outside the build it is defined in. Using the <code class="literal">buildSrc</code> project approach separates the task declaration - that is, what the task should do - from the task implementation - that is, how the task does it.</p><p>See <a class="xref" href="#organizing_build_logic"><i>Organizing Build Logic</i></a> for more details about the <code class="literal">buildSrc</code> project.</p></dd><dt><span class="term">Standalone project</span></dt><dd><p>You can create a separate project for your task class. This project produces and publishes a JAR which you can then use in multiple builds and share with others. Generally, this JAR might include some custom plugins, or bundle several related task classes into a single library. Or some combination of the two.</p></dd></dl></div><p>In our examples, we will start with the task class in the build script, to keep things simple. Then we will look at creating a standalone project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:writing_a_simple_task_class" class="section-anchor" href="#sec:writing_a_simple_task_class"></a>Writing a simple task class</h2></div></div></div><p>To implement a custom task class, you extend <a class="ulink" href="../dsl/org.gradle.api.DefaultTask.html" target="_top"><code class="classname">DefaultTask</code></a>.</p><div class="example"><a name="customTask"></a><p class="title"><b>Example&nbsp;323.&nbsp;Defining a custom task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingTask <span class="hl-keyword">extends</span> DefaultTask {
}
</pre></div></div><br class="example-break"><p>This task doesn&rsquo;t do anything useful, so let&rsquo;s add some behaviour. To do so, we add a method to the task and mark it with the <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskAction.html" target="_top"><code class="classname">TaskAction</code></a> annotation. Gradle will call the method when the task executes. You don&rsquo;t have to use a method to define the behaviour for the task. You could, for instance, call <code class="literal">doFirst()</code> or <code class="literal">doLast()</code> with a closure in the task constructor to add behaviour.</p><div class="example"><a name="customTaskWithAction"></a><p class="title"><b>Example&nbsp;324.&nbsp;A hello world task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingTask <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-annotation">@TaskAction</span>
    def greet() {
        println <span class="hl-string">'hello from GreetingTask'</span>
    }
}

<span class="hl-comment">// Create a task using the task type</span>
task hello(type: GreetingTask)
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
hello from GreetingTask</pre></div></div><br class="example-break"><p>Let&rsquo;s add a property to the task, so we can customize it. Tasks are simply POGOs, and when you declare a task, you can set the properties or call methods on the task object. Here we add a <code class="literal">greeting</code> property, and set the value when we declare the <code class="literal">greeting</code> task.</p><div class="example"><a name="customTaskWithProperty"></a><p class="title"><b>Example&nbsp;325.&nbsp;A customizable hello world task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingTask <span class="hl-keyword">extends</span> DefaultTask {
    String greeting = <span class="hl-string">'hello from GreetingTask'</span>

    <span class="hl-annotation">@TaskAction</span>
    def greet() {
        println greeting
    }
}

<span class="hl-comment">// Use the default greeting</span>
task hello(type: GreetingTask)

<span class="hl-comment">// Customize the greeting</span>
task greeting(type: GreetingTask) {
    greeting = <span class="hl-string">'greetings from GreetingTask'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello greeting</code></strong></p><pre class="screen">&gt; gradle -q hello greeting
hello from GreetingTask
greetings from GreetingTask</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:custom_tasks_standalone_project" class="section-anchor" href="#sec:custom_tasks_standalone_project"></a>A standalone project</h2></div></div></div><p>Now we will move our task to a standalone project, so we can publish it and share it with others. This project is simply a Groovy project that produces a JAR containing the task class. Here is a simple build script for the project. It applies the Groovy plugin, and adds the Gradle API as a compile-time dependency.</p><div class="example"><a name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;326.&nbsp;A build for a custom task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>

dependencies {
    compile gradleApi()
    compile localGroovy()
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/customPlugin/plugin</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>We just follow the convention for where the source for the task class should go.</p><div class="example"><a name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;327.&nbsp;A custom task</b></p><div class="example-contents"><p><code class="filename">src/main/groovy/org/gradle/GreetingTask.groovy</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle

<span class="hl-keyword">import</span> org.gradle.api.DefaultTask
<span class="hl-keyword">import</span> org.gradle.api.tasks.TaskAction

<span class="hl-keyword">class</span> GreetingTask <span class="hl-keyword">extends</span> DefaultTask {
    String greeting = <span class="hl-string">'hello from GreetingTask'</span>

    <span class="hl-annotation">@TaskAction</span>
    def greet() {
        println greeting
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_your_task_class_in_another_project" class="section-anchor" href="#sec:using_your_task_class_in_another_project"></a>Using your task class in another project</h3></div></div></div><p>To use a task class in a build script, you need to add the class to the build script&rsquo;s classpath. To do this, you use a <code class="literal">buildscript { }</code> block, as described in <a class="xref" href="#sec:build_script_external_dependencies">the section called &ldquo;External dependencies for the build script&rdquo;</a>. The following example shows how you might do this when the JAR containing the task class has been published to a local repository:</p><div class="example"><a name="usingCustomTask"></a><p class="title"><b>Example&nbsp;328.&nbsp;Using a custom task in another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        maven {
            url uri(<span class="hl-string">'../repo'</span>)
        }
    }
    dependencies {
        classpath group: <span class="hl-string">'org.gradle'</span>, name: <span class="hl-string">'customPlugin'</span>,
                  version: <span class="hl-string">'1.0-SNAPSHOT'</span>
    }
}

task greeting(type: org.gradle.GreetingTask) {
    greeting = <span class="hl-string">'howdy!'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:writing_tests_for_your_task_class" class="section-anchor" href="#sec:writing_tests_for_your_task_class"></a>Writing tests for your task class</h3></div></div></div><p>You can use the <a class="ulink" href="../javadoc/org/gradle/testfixtures/ProjectBuilder.html" target="_top"><code class="classname">ProjectBuilder</code></a> class to create <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> instances to use when you test your task class.</p><div class="example"><a name="customTaskStandalone"></a><p class="title"><b>Example&nbsp;329.&nbsp;Testing a custom task</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/GreetingTaskTest.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingTaskTest {
    <span class="hl-annotation">@Test</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> canAddTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        def task = project.task(<span class="hl-string">'greeting'</span>, type: GreetingTask)
        assertTrue(task <span class="hl-keyword">instanceof</span> GreetingTask)
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="incremental_tasks" class="section-anchor" href="#incremental_tasks"></a>Incremental tasks</h2></div></div></div><div class="note"><p>Incremental tasks are an <a class="link" href="#feature_lifecycle">incubating</a> feature.</p><p>Since the introduction of the implementation described above (early in the Gradle 1.6 release cycle), discussions within the Gradle community have produced superior ideas for exposing the information about changes to task implementors to what is described below. As such, the API for this feature will almost certainly change in upcoming releases. However, please do experiment with the current implementation and share your experiences with the Gradle community.</p><p>The feature incubation process, which is part of the Gradle feature lifecycle (see <a class="xref" href="#feature_lifecycle">Appendix&nbsp;C</a>), exists for this purpose of ensuring high quality final implementations through incorporation of early user feedback.</p></div><p>With Gradle, it&rsquo;s very simple to implement a task that is skipped when all of its inputs and outputs are up to date (see <a class="xref" href="#sec:up_to_date_checks">the section called &ldquo;Up-to-date checks (AKA Incremental Build)&rdquo;</a>). However, there are times when only a few input files have changed since the last execution, and you&rsquo;d like to avoid reprocessing all of the unchanged inputs. This can be particularly useful for a transformer task, that converts input files to output files on a 1:1 basis.</p><p>If you&rsquo;d like to optimise your build so that only out-of-date inputs are processed, you can do so with an <span class="emphasis"><em>incremental task</em></span>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:implementing_an_incremental_task" class="section-anchor" href="#sec:implementing_an_incremental_task"></a>Implementing an incremental task</h3></div></div></div><p>For a task to process inputs incrementally, that task must contain an <span class="emphasis"><em>incremental task action</em></span>. This is a task action method that contains a single <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html" target="_top"><code class="classname">IncrementalTaskInputs</code></a> parameter, which indicates to Gradle that the action will process the changed inputs only.</p><p>The incremental task action may supply an <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action for processing any input file that is out-of-date, and a <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action that executes for any input file that has been removed since the previous execution.</p><div class="example"><a name="taskDefinition"></a><p class="title"><b>Example&nbsp;330.&nbsp;Defining an incremental task action</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> IncrementalReverseTask <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-annotation">@InputDirectory</span>
    def File inputDir

    <span class="hl-annotation">@OutputDirectory</span>
    def File outputDir

    <span class="hl-annotation">@Input</span>
    def inputProperty

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> execute(IncrementalTaskInputs inputs) {
        println inputs.incremental ? <span class="hl-string">'CHANGED inputs considered out of date'</span>
                                   : <span class="hl-string">'ALL inputs considered out of date'</span>
        <span class="hl-keyword">if</span> (!inputs.incremental)
            project.delete(outputDir.listFiles())

        inputs.outOfDate { change -&gt;
            println <span class="hl-string">"out of date: ${change.file.name}"</span>
            def targetFile = <span class="hl-keyword">new</span> File(outputDir, change.file.name)
            targetFile.text = change.file.text.reverse()
        }

        inputs.removed { change -&gt;
            println <span class="hl-string">"removed: ${change.file.name}"</span>
            def targetFile = <span class="hl-keyword">new</span> File(outputDir, change.file.name)
            targetFile.delete()
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/tasks/incrementalTask</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>If for some reason the task is not run incremental, e.g. by running with <code class="literal">--rerun-tasks</code>, only the outOfDate action is executed, even if there were deleted input files. You should consider handling this case at the beginning, as is done in the example above.</p><p>For a simple transformer task like this, the task action simply needs to generate output files for any out-of-date inputs, and delete output files for any removed inputs.</p><p>A task may only contain a single incremental task action.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:which_inputs_are_considered_out_of_date" class="section-anchor" href="#sec:which_inputs_are_considered_out_of_date"></a>Which inputs are considered out of date?</h3></div></div></div><p>When Gradle has history of a previous task execution, and the only changes to the task execution context since that execution are to input files, then Gradle is able to determine which input files need to be reprocessed by the task. In this case, the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action will be executed for any input file that was <span class="emphasis"><em>added</em></span> or <span class="emphasis"><em>modified</em></span>, and the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action will be executed for any <span class="emphasis"><em>removed</em></span> input file.</p><p>However, there are many cases where Gradle is unable to determine which input files need to be reprocessed. Examples include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is no history available from a previous execution.</p></li><li class="listitem"><p>You are building with a different version of Gradle. Currently, Gradle does not use task history from a different version.</p></li><li class="listitem"><p>An <code class="literal">upToDateWhen</code> criteria added to the task returns <code class="literal">false</code>.</p></li><li class="listitem"><p>An input property has changed since the previous execution.</p></li><li class="listitem"><p>One or more output files have changed since the previous execution.</p></li></ul></div><p>In any of these cases, Gradle will consider all of the input files to be <code class="literal">outOfDate</code>. The <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action will be executed for every input file, and the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action will not be executed at all.</p><p>You can check if Gradle was able to determine the incremental changes to input files with <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:incremental" target="_top"><code class="classname">IncrementalTaskInputs.isIncremental()</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:an_incremental_task_in_action" class="section-anchor" href="#sec:an_incremental_task_in_action"></a>An incremental task in action</h3></div></div></div><p>Given the incremental task implementation <a class="link" href="#taskDefinition" title="Example&nbsp;330.&nbsp;Defining an incremental task action">above</a>, we can explore the various change scenarios by example. Note that the various mutation tasks ('updateInputs', 'removeInput', etc) are only present for demonstration purposes: these would not normally be part of your build script.</p><p>First, consider the <code class="literal">IncrementalReverseTask</code> executed against a set of inputs for the first time. In this case, all inputs will be considered &ldquo;out of date&rdquo;:</p><div class="example"><a name="incrementalTaskFirstRun"></a><p class="title"><b>Example&nbsp;331.&nbsp;Running the incremental task for the first time</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task incrementalReverse(type: IncrementalReverseTask) {
    inputDir = file(<span class="hl-string">'inputs'</span>)
    outputDir = file(<span class="hl-string">"$buildDir/outputs"</span>)
    inputProperty = project.properties[<span class="hl-string">'taskInputProperty'</span>] ?: <span class="hl-string">'original'</span>
}
</pre><p>Build layout</p><pre class="programlisting">incrementalTask/
  build.gradle
  inputs/
    1.txt
    2.txt
    3.txt
</pre><p>Output of <strong class="userinput"><code>gradle -q incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"><p>Naturally when the task is executed again with no changes, then the entire task is up to date and no files are reported to the task action:</p><div class="example"><a name="incrementalTaskNoChange"></a><p class="title"><b>Example&nbsp;332.&nbsp;Running the incremental task with unchanged inputs</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q incrementalReverse
</pre></div></div><br class="example-break"><p>When an input file is modified in some way or a new input file is added, then re-executing the task results in those files being reported to <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a>:</p><div class="example"><a name="incrementalTaskUpdatedInputs"></a><p class="title"><b>Example&nbsp;333.&nbsp;Running the incremental task with updated input files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task updateInputs() {
    doLast {
        file(<span class="hl-string">'inputs/1.txt'</span>).text = <span class="hl-string">'Changed content for existing file 1.'</span>
        file(<span class="hl-string">'inputs/4.txt'</span>).text = <span class="hl-string">'Content for new file 4.'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q updateInputs incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q updateInputs incrementalReverse
CHANGED inputs considered out of date
out of date: 1.txt
out of date: 4.txt</pre></div></div><br class="example-break"><p>When an existing input file is removed, then re-executing the task results in that file being reported to <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a>:</p><div class="example"><a name="incrementalTaskRemovedInput"></a><p class="title"><b>Example&nbsp;334.&nbsp;Running the incremental task with an input file removed</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task removeInput() {
    doLast {
        file(<span class="hl-string">'inputs/3.txt'</span>).delete()
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q removeInput incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q removeInput incrementalReverse
CHANGED inputs considered out of date
removed: 3.txt</pre></div></div><br class="example-break"><p>When an output file is deleted (or modified), then Gradle is unable to determine which input files are out of date. In this case, <span class="emphasis"><em>all</em></span> input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action, and no input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action:</p><div class="example"><a name="incrementalTaskRemovedOutput"></a><p class="title"><b>Example&nbsp;335.&nbsp;Running the incremental task with an output file removed</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task removeOutput() {
    doLast {
        file(<span class="hl-string">"$buildDir/outputs/1.txt"</span>).delete()
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q removeOutput incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q removeOutput incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"><p>When a task input property is modified, Gradle is unable to determine how this property impacted the task outputs, so all input files are assumed to be out of date. So similar to the changed output file example, <span class="emphasis"><em>all</em></span> input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:outOfDate(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.outOfDate(org.gradle.api.Action)</code></a> action, and no input files are reported to the <a class="ulink" href="../dsl/org.gradle.api.tasks.incremental.IncrementalTaskInputs.html#org.gradle.api.tasks.incremental.IncrementalTaskInputs:removed(org.gradle.api.Action)" target="_top"><code class="classname">IncrementalTaskInputs.removed(org.gradle.api.Action)</code></a> action:</p><div class="example"><a name="incrementalTaskChangedProperty"></a><p class="title"><b>Example&nbsp;336.&nbsp;Running the incremental task with an input property changed</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q -PtaskInputProperty=changed incrementalReverse</code></strong></p><pre class="screen">&gt; gradle -q -PtaskInputProperty=changed incrementalReverse
ALL inputs considered out of date
out of date: 1.txt
out of date: 2.txt
out of date: 3.txt</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:storing_incremental_task_state" class="section-anchor" href="#sec:storing_incremental_task_state"></a>Storing incremental state for cached tasks</h3></div></div></div><p>Using Gradle&rsquo;s <code class="literal">IncrementalTaskInputs</code> is not the only way to create tasks that only works on changes since the last execution. Tools like the Kotlin compiler provide incrementality as a built-in feature. The way this is typically implemented is that the tool stores some analysis data about the state of the previous execution in some file. If such state files are <a class="link" href="#sec:task_output_caching_inputs">relocatable</a>, then they can be declared as outputs of the task. This way when the task&rsquo;s results are loaded from cache, the next execution can already use the analysis data loaded from cache, too.</p><p>However, if the state files are non-relocatable, then they can&rsquo;t be shared via the build cache. Indeed, when the task is loaded from cache, any such state files must be cleaned up to prevent stale state to confuse the tool during the next execution. Gradle can ensure such stale files are removed if they are declared via <code class="literal">task.localState.register()</code> or a property is marked with the <code class="literal">@LocalState</code> annotation.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="worker_api" class="section-anchor" href="#worker_api"></a>The Worker API</h2></div></div></div><div class="note"><p>The Worker API is an <a class="link" href="#feature_lifecycle">incubating</a> feature.</p></div><p>As can be seen from the discussion of <a class="link" href="#incremental_tasks">incremental tasks</a>, the work that a task performs can be viewed as discrete units (i.e. a subset of inputs that are transformed to a certain subset of outputs). Many times, these units of work are highly independent of each other, meaning they can be performed in any order and simply aggregated together to form the overall action of the task. In a single threaded execution, these units of work would execute in sequence, however if we have multiple processors, it would be desirable to perform independent units of work concurrently. By doing so, we can fully utilize the available resources at build time and complete the activity of the task faster.</p><p>The Worker API provides a mechanism for doing exactly this. It allows for safe, concurrent execution of multiple items of work during a task action. But the benefits of the Worker API are not confined to parallelizing the work of a task. You can also configure a desired level of isolation such that work can be executed in an isolated classloader or even in an isolated process. Furthermore, the benefits extend beyond even the execution of a single task. Using the Worker API, Gradle can begin to execute tasks in parallel by default. In other words, once a task has submitted its work to be executed asynchronously, and has exited the task action, Gradle can then begin the execution of other independent tasks in parallel, even if those tasks are in the same project.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="using-the-worker-api" class="section-anchor" href="#using-the-worker-api"></a>Using the Worker API</h3></div></div></div><p>In order to submit work to the Worker API, two things must be provided: an implementation of the unit of work, and a configuration for the unit of work. The implementation is simply a class that extends <code class="literal">java.lang.Runnable</code>. This class should have a constructor that is annotated with <code class="literal">javax.inject.Inject</code> and accepts parameters that configure the class for a single unit of work. When a unit of work is submitted to the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a>, an instance of this class will be created and the parameters configured for the unit of work will be passed to the constructor.</p><div class="example"><a name="unitOfWork"></a><p class="title"><b>Example&nbsp;337.&nbsp;Creating a unit of work implementation</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">
<span class="hl-keyword">import</span> org.gradle.workers.WorkerExecutor

<span class="hl-keyword">import</span> javax.inject.Inject

<span class="hl-comment">// The implementation of a single unit of work</span>
<span class="hl-keyword">class</span> ReverseFile <span class="hl-keyword">implements</span> Runnable {
    File fileToReverse
    File destinationFile

    <span class="hl-annotation">@Inject</span>
    <span class="hl-keyword">public</span> ReverseFile(File fileToReverse, File destinationFile) {
        <span class="hl-keyword">this</span>.fileToReverse = fileToReverse
        <span class="hl-keyword">this</span>.destinationFile = destinationFile
    }

    <span class="hl-annotation">@Override</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> run() {
        destinationFile.text = fileToReverse.text.reverse()
    }
}
</pre></div></div><br class="example-break"><p>The configuration of the worker is represented by a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html" target="_top"><code class="classname">WorkerConfiguration</code></a> and is set by configuring an instance of this object at the time of submission. However, in order to submit the unit of work, it is necessary to first acquire the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a>. To do this, a constructor should be provided that is annotated with <code class="literal">javax.inject.Inject</code> and accepts a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a> parameter. Gradle will inject the instance of <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html" target="_top"><code class="classname">WorkerExecutor</code></a> at runtime when the task is created.</p><div class="example"><a name="workSubmission"></a><p class="title"><b>Example&nbsp;338.&nbsp;Submitting a unit of work for execution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> ReverseFiles <span class="hl-keyword">extends</span> SourceTask {
    <span class="hl-keyword">final</span> WorkerExecutor workerExecutor

    <span class="hl-annotation">@OutputDirectory</span>
    File outputDir

    <span class="hl-comment">// The WorkerExecutor will be injected by Gradle at runtime</span>
    <span class="hl-annotation">@Inject</span>
    <span class="hl-keyword">public</span> ReverseFiles(WorkerExecutor workerExecutor) {
        <span class="hl-keyword">this</span>.workerExecutor = workerExecutor
    }

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> reverseFiles() {
        <span class="hl-comment">// Create and submit a unit of work for each file</span>
        source.files.each { file -&gt;
            workerExecutor.submit(ReverseFile.<span class="hl-keyword">class</span>) { WorkerConfiguration config -&gt;
                <span class="hl-comment">// Use the minimum level of isolation</span>
                config.isolationMode = IsolationMode.NONE

                <span class="hl-comment">// Constructor parameters for the unit of work implementation</span>
                config.params file, project.file(<span class="hl-string">"${outputDir}/${file.name}"</span>)
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Note that one element of the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html" target="_top"><code class="classname">WorkerConfiguration</code></a> is the <code class="literal">params</code> property. These are the parameters passed to the constructor of the unit of work implementation for each item of work submitted. Any parameters provided to the unit of work <span class="emphasis"><em>must</em></span> be <code class="literal">java.io.Serializable</code>.</p><p>Once all of the work for a task action has been submitted, it is safe to exit the task action. The work will be executed asynchronously and in parallel (up to the setting of <code class="literal">max-workers</code>). Of course, any tasks that are dependent on this task (and any subsequent task actions of this task) will not begin executing until all of the asynchronous work completes. However, other independent tasks that have no relationship to this task can begin executing immediately.</p><p>If any failures occur while executing the asynchronous work, the task will fail and a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutionException.html" target="_top"><code class="classname">WorkerExecutionException</code></a> will be thrown detailing the failure for each failed work item. This will be treated like any failure during task execution and will prevent any dependent tasks from executing.</p><p>In some cases, however, it might be desirable to wait for work to complete before exiting the task action. This is possible using the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await--" target="_top"><code class="classname">WorkerExecutor.await()</code></a> method. As in the case of allowing the work to complete asynchronously, any failures that occur while executing an item of work will be surfaced as a <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutionException.html" target="_top"><code class="classname">WorkerExecutionException</code></a> thrown from the <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await--" target="_top"><code class="classname">WorkerExecutor.await()</code></a> method.</p><div class="note"><p>Note that Gradle will only begin running other independent tasks in parallel when a task has exited a task action and returned control of execution to Gradle. When <a class="ulink" href="../javadoc/org/gradle/workers/WorkerExecutor.html#await--" target="_top"><code class="classname">WorkerExecutor.await()</code></a> is used, execution does not leave the task action. This means that Gradle will not allow other tasks to begin executing and will wait for the task action to complete before doing so.</p></div><div class="example"><a name="waitForCompletion"></a><p class="title"><b>Example&nbsp;339.&nbsp;Waiting for asynchronous work to complete</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Create and submit a unit of work for each file</span>
source.files.each { file -&gt;
    workerExecutor.submit(ReverseFile.<span class="hl-keyword">class</span>) { config -&gt;
        config.isolationMode = IsolationMode.NONE
        <span class="hl-comment">// Constructor parameters for the unit of work implementation</span>
        config.params file, project.file(<span class="hl-string">"${outputDir}/${file.name}"</span>)
    }
}

<span class="hl-comment">// Wait for all asynchronous work to complete before continuing</span>
workerExecutor.await()
logger.lifecycle(<span class="hl-string">"Created ${outputDir.listFiles().size()} reversed files in ${project.relativePath(outputDir)}"</span>)
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="isolation-modes" class="section-anchor" href="#isolation-modes"></a>Isolation Modes</h3></div></div></div><p>Gradle provides three isolation modes that can be configured on a unit of work and are specified using the <a class="ulink" href="../javadoc/org/gradle/workers/IsolationMode.html" target="_top"><code class="classname">IsolationMode</code></a> enum:</p><div class="variablelist"><dl><dt><span class="term">IsolationMode.NONE</span></dt><dd><p>This states that the work should be run in a thread with a minimum of isolation. For instance, it will share the same classloader that the task is loaded from. This is the fastest level of isolation.</p></dd><dt><span class="term">IsolationMode.CLASSLOADER</span></dt><dd><p>This states that the work should be run in a thread with an isolated classloader. The classloader will have the classpath from the classloader that the unit of work implementation class was loaded from as well as any additional classpath entries added through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#classpath-java.lang.Iterable-" target="_top"><code class="classname">WorkerConfiguration.classpath(java.lang.Iterable)</code></a>.</p></dd><dt><span class="term">IsolationMode.PROCESS</span></dt><dd><p>This states that the work should be run with a maximum level of isolation by executing the work in a separate process. The classloader of the process will use the classpath from the classloader that the unit of work was loaded from as well as any additional classpath entries added through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#classpath-java.lang.Iterable-" target="_top"><code class="classname">WorkerConfiguration.classpath(java.lang.Iterable)</code></a>. Furthermore, the process will be a <span class="emphasis"><em>Worker Daemon</em></span> which will stay alive and can be reused for future work items that may have the same requirements. This process can be configured with different settings than the Gradle JVM using <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#forkOptions-org.gradle.api.Action-" target="_top"><code class="classname">WorkerConfiguration.forkOptions(org.gradle.api.Action)</code></a>.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="worker-daemons" class="section-anchor" href="#worker-daemons"></a>Worker Daemons</h3></div></div></div><p>When using <code class="literal">IsolationMode.PROCESS</code>, gradle will start a long-lived <span class="emphasis"><em>Worker Daemon</em></span> process that can be reused for future work items.</p><div class="example"><a name="workerDaemon"></a><p class="title"><b>Example&nbsp;340.&nbsp;Submitting an item of work to run in a worker daemon</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">workerExecutor.submit(ReverseFile.<span class="hl-keyword">class</span>) { WorkerConfiguration config -&gt;
    <span class="hl-comment">// Run this work in an isolated process</span>
    config.isolationMode = IsolationMode.PROCESS

    <span class="hl-comment">// Configure the options for the forked process</span>
    config.forkOptions { JavaForkOptions options -&gt;
        options.maxHeapSize = <span class="hl-string">"512m"</span>
        options.systemProperty <span class="hl-string">"org.gradle.sample.showFileSize"</span>, <span class="hl-string">"true"</span>
    }

    <span class="hl-comment">// Constructor parameters for the unit of work implementation</span>
    config.params file, project.file(<span class="hl-string">"${outputDir}/${file.name}"</span>)
}
</pre></div></div><br class="example-break"><p>When a unit of work for a Worker Daemon is submitted, Gradle will first look to see if a compatible, idle daemon already exists. If so, it will send the unit of work to the idle daemon, marking it as busy. If not, it will start a new daemon. When evaluating compatibility, Gradle looks at a number of criteria, all of which can be controlled through <a class="ulink" href="../javadoc/org/gradle/workers/WorkerConfiguration.html#forkOptions-org.gradle.api.Action-" target="_top"><code class="classname">WorkerConfiguration.forkOptions(org.gradle.api.Action)</code></a>.</p><div class="variablelist"><dl><dt><span class="term">executable</span></dt><dd><p>A daemon is considered compatible only if it uses the same java executable.</p></dd><dt><span class="term">classpath</span></dt><dd><p>A daemon is considered compatible if its classpath contains all of the classpath entries requested. Note that a daemon is considered compatible if it has more classpath entries in addition to those requested.</p></dd><dt><span class="term">heap settings</span></dt><dd><p>A daemon is considered compatible if it has at least the same heap size settings as requested. In other words, a daemon that has higher heap settings than requested would be considered compatible.</p></dd><dt><span class="term">jvm arguments</span></dt><dd><p>A daemon is considered compatible if it has set all of the jvm arguments requested. Note that a daemon is considered compatible if it has additional jvm arguments beyond those requested (except for arguments treated specially such as heap settings, assertions, debug, etc).</p></dd><dt><span class="term">system properties</span></dt><dd><p>A daemon is considered compatible if it has set all of the system properties requested with the same values. Note that a daemon is considered compatible if it has additional system properties beyond those requested.</p></dd><dt><span class="term">environment variables</span></dt><dd><p>A daemon is considered compatible if it has set all of the environment variables requested with the same values. Note that a daemon is considered compatible if it has more environment variables in addition to those requested.</p></dd><dt><span class="term">bootstrap classpath</span></dt><dd><p>A daemon is considered compatible if it contains all of the bootstrap classpath entries requested. Note that a daemon is considered compatible if it has more bootstrap classpath entries in addition to those requested.</p></dd><dt><span class="term">debug</span></dt><dd><p>A daemon is considered compatible only if debug is set to the same value as requested (true or false).</p></dd><dt><span class="term">enable assertions</span></dt><dd><p>A daemon is considered compatible only if enable assertions is set to the same value as requested (true or false).</p></dd><dt><span class="term">default character encoding</span></dt><dd><p>A daemon is considered compatible only if the default character encoding is set to the same value as requested.</p></dd></dl></div><p>Worker daemons will remain running until either the build daemon that started them is stopped, or system memory becomes scarce. When available system memory is low, Gradle will begin stopping worker daemons in an attempt to minimize memory consumption.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:reusing_task_logic" class="section-anchor" href="#sec:reusing_task_logic"></a>Re-using logic between task classes</h2></div></div></div><p>There are different ways to re-use logic between task classes.
The easiest case is when you can extract the logic you want to share in a separate method or class and then use the extracted piece of code in your tasks.
For example, the <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a> task re-uses the logic of the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:copy(org.gradle.api.Action)" target="_top"><code class="classname">Project.copy(org.gradle.api.Action)</code></a> method.
Another option is to add a task dependency on the task which outputs you want to re-use.
Other options include using <a class="link" href="#sec:task_rules">task rules</a> or the <a class="link" href="#worker_api">worker API</a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="custom_plugins"></a>Writing Custom Plugins</h1></div></div></div><p>A Gradle plugin packages up reusable pieces of build logic, which can be used across many different projects and builds. Gradle allows you to implement your own plugins, so you can reuse your build logic, and share it with others.</p><p>You can implement a Gradle plugin in any language you like, provided the implementation ends up compiled as bytecode. In our examples, we are going to use Groovy as the implementation language. Groovy, Java or Kotlin are all good choices as the language to use to implement a plugin, as the Gradle API has been designed to work well with these languages. In general, a plugin implemented using Java or Kotlin, which are statically typed, will perform better than the same plugin implemented using Groovy.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:packaging_a_plugin" class="section-anchor" href="#sec:packaging_a_plugin"></a>Packaging a plugin</h2></div></div></div><p>There are several places where you can put the source for the plugin.</p><div class="variablelist"><dl><dt><span class="term">Build script</span></dt><dd><p>You can include the source for the plugin directly in the build script. This has the benefit that the plugin is automatically compiled and included in the classpath of the build script without you having to do anything. However, the plugin is not visible outside the build script, and so you cannot reuse the plugin outside the build script it is defined in.</p></dd><dt><span class="term"><code class="literal">buildSrc</code> project</span></dt><dd><p>You can put the source for the plugin in the <code class="literal"><span class="emphasis"><em>rootProjectDir</em></span>/buildSrc/src/main/groovy</code> directory. Gradle will take care of compiling and testing the plugin and making it available on the classpath of the build script. The plugin is visible to every build script used by the build. However, it is not visible outside the build, and so you cannot reuse the plugin outside the build it is defined in.</p><p>See <a class="xref" href="#organizing_build_logic"><i>Organizing Build Logic</i></a> for more details about the <code class="literal">buildSrc</code> project.</p></dd><dt><span class="term">Standalone project</span></dt><dd><p>You can create a separate project for your plugin. This project produces and publishes a JAR which you can then use in multiple builds and share with others. Generally, this JAR might include some plugins, or bundle several related task classes into a single library. Or some combination of the two.</p></dd></dl></div><p>In our examples, we will start with the plugin in the build script, to keep things simple. Then we will look at creating a standalone project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:writing_a_simple_plugin" class="section-anchor" href="#sec:writing_a_simple_plugin"></a>Writing a simple plugin</h2></div></div></div><p>To create a Gradle plugin, you need to write a class that implements the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> interface. When the plugin is applied to a project, Gradle creates an instance of the plugin class and calls the instance&rsquo;s <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html#apply-T-" target="_top"><code class="classname">Plugin.apply(T)</code></a> method. The project object is passed as a parameter, which the plugin can use to configure the project however it needs to. The following sample contains a greeting plugin, which adds a <code class="literal">hello</code> task to the project.</p><div class="example"><a name="customPlugin"></a><p class="title"><b>Example&nbsp;341.&nbsp;A custom plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        project.task(<span class="hl-string">'hello'</span>) {
            doLast {
                println <span class="hl-string">'Hello from the GreetingPlugin'</span>
            }
        }
    }
}

<span class="hl-comment">// Apply the plugin</span>
apply plugin: GreetingPlugin
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hello from the GreetingPlugin
</pre></div></div><br class="example-break"><p>One thing to note is that a new instance of a plugin is created for each project it is applied to. Also note that the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> class is a generic type. This example has it receiving the <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> type as a type parameter. A plugin can instead receive a parameter of type <a class="ulink" href="../dsl/org.gradle.api.initialization.Settings.html" target="_top"><code class="classname">Settings</code></a>, in which case the plugin can be applied in a settings script, or a parameter of type <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html" target="_top"><code class="classname">Gradle</code></a>, in which case the plugin can be applied in an initialization script.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:getting_input_from_the_build" class="section-anchor" href="#sec:getting_input_from_the_build"></a>Making the plugin configurable</h2></div></div></div><p>Most plugins need to obtain some configuration from the build script. One method for doing this is to use <span class="emphasis"><em>extension objects</em></span>. The Gradle <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> has an associated <a class="ulink" href="../javadoc/org/gradle/api/plugins/ExtensionContainer.html" target="_top"><code class="classname">ExtensionContainer</code></a> object that contains all the settings and properties for the plugins that have been applied to the project. You can provide configuration for your plugin by adding an extension object to this container. An extension object is simply a Java Bean compliant class. Groovy is a good language choice to implement an extension object because plain old Groovy objects contain all the getter and setter methods that a Java Bean requires. Java and Kotlin are other good choices.</p><p>Let&rsquo;s add a simple extension object to the project. Here we add a <code class="literal">greeting</code> extension object to the project, which allows you to configure the greeting.</p><div class="example"><a name="customPluginWithConvention"></a><p class="title"><b>Example&nbsp;342.&nbsp;A custom plugin extension</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingPluginExtension {
    String message = <span class="hl-string">'Hello from GreetingPlugin'</span>
}

<span class="hl-keyword">class</span> GreetingPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        <span class="hl-comment">// Add the 'greeting' extension object</span>
        def extension = project.extensions.create(<span class="hl-string">'greeting'</span>, GreetingPluginExtension)
        <span class="hl-comment">// Add a task that uses configuration from the extension object</span>
        project.task(<span class="hl-string">'hello'</span>) {
            doLast {
                println extension.message
            }
        }
    }
}

apply plugin: GreetingPlugin

<span class="hl-comment">// Configure the extension</span>
greeting.message = <span class="hl-string">'Hi from Gradle'</span>
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hi from Gradle
</pre></div></div><br class="example-break"><p>In this example, <code class="literal">GreetingPluginExtension</code> is a plain old Groovy object with a property called <code class="literal">message</code>. The extension object is added to the plugin list with the name <code class="literal">greeting</code>. This object then becomes available as a project property with the same name as the extension object.</p><p>Oftentimes, you have several related properties you need to specify on a single plugin. Gradle adds a configuration closure block for each extension object, so you can group settings together. The following example shows you how this works.</p><div class="example"><a name="customPluginWithAdvancedConvention"></a><p class="title"><b>Example&nbsp;343.&nbsp;A custom plugin with configuration closure</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingPluginExtension {
    String message
    String greeter
}

<span class="hl-keyword">class</span> GreetingPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        def extension = project.extensions.create(<span class="hl-string">'greeting'</span>, GreetingPluginExtension)
        project.task(<span class="hl-string">'hello'</span>) {
            doLast {
                println <span class="hl-string">"${extension.message} from ${extension.greeter}"</span>
            }
        }
    }
}

apply plugin: GreetingPlugin

<span class="hl-comment">// Configure the extension using a DSL block</span>
greeting {
    message = <span class="hl-string">'Hi'</span>
    greeter = <span class="hl-string">'Gradle'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hi from Gradle
</pre></div></div><br class="example-break"><p>In this example, several settings can be grouped together within the <code class="literal">greeting</code> closure. The name of the closure block in the build script (<code class="literal">greeting</code>) needs to match the extension object name. Then, when the closure is executed, the fields on the extension object will be mapped to the variables within the closure based on the standard Groovy closure delegate feature.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_with_files_in_custom_tasks_and_plugins" class="section-anchor" href="#sec:working_with_files_in_custom_tasks_and_plugins"></a>Working with files in custom tasks and plugins</h2></div></div></div><p>When developing custom tasks and plugins, it&rsquo;s a good idea to be very flexible when accepting input configuration for file locations. To do this, you can leverage the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a> method to resolve values to files as late as possible.</p><div class="example"><a name="lazyFileProperties"></a><p class="title"><b>Example&nbsp;344.&nbsp;Evaluating file properties lazily</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingToFileTask <span class="hl-keyword">extends</span> DefaultTask {

    def destination

    File getDestination() {
        project.file(destination)
    }

    <span class="hl-annotation">@TaskAction</span>
    def greet() {
        def file = getDestination()
        file.parentFile.mkdirs()
        file.write <span class="hl-string">'Hello!'</span>
    }
}

task greet(type: GreetingToFileTask) {
    destination = { project.greetingFile }
}

task sayGreeting(dependsOn: greet) {
    doLast {
        println file(greetingFile).text
    }
}

ext.greetingFile = <span class="hl-string">"$buildDir/hello.txt"</span>
</pre><p>Output of <strong class="userinput"><code>gradle -q sayGreeting</code></strong></p><pre class="screen">&gt; gradle -q sayGreeting
Hello!
</pre></div></div><br class="example-break"><p>In this example, we configure the <code class="literal">greet</code> task <code class="literal">destination</code> property as a closure, which is evaluated with the <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:file(java.lang.Object)" target="_top"><code class="classname">Project.file(java.lang.Object)</code></a> method to turn the return value of the closure into a <code class="literal">File</code> object at the last minute. You will notice that in the example above we specify the <code class="literal">greetingFile</code> property value after we have configured to use it for the task. This kind of lazy evaluation is a key benefit of accepting any value when setting a file property, then resolving that value when reading the property.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:mapping_extension_properties_to_task_properties" class="section-anchor" href="#sec:mapping_extension_properties_to_task_properties"></a>Mapping extension properties to task properties</h2></div></div></div><p>Capturing user input from the build script through an extension and mapping it to input/output properties of a custom task is considered a best practice. The end user only interacts with the exposed DSL defined by the extension. The imperative logic is hidden in the plugin implementation.</p><p>The extension declaration in the build script as well as the mapping between extension properties and custom task properties occurs during Gradle&rsquo;s configuration phase of the build lifecycle. To avoid evaluation order issues, the actual value of a mapped property has to be resolved during the execution phase. For more information please see <a class="xref" href="#sec:build_phases">the section called &ldquo;Build phases&rdquo;</a>. Gradle&rsquo;s API offers types for representing a property that should be lazily evaluated e.g. during execution time. Refer to <a class="xref" href="#lazy_configuration"><i>Lazy Configuration</i></a> for more information.</p><p>The following demonstrates the usage of the type for mapping an extension property to a task property:</p><div class="example"><a name="mapExtensionPropertiesToTaskProperties"></a><p class="title"><b>Example&nbsp;345.&nbsp;Mapping extension properties to task properties</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        def extension = project.extensions.create(<span class="hl-string">'greeting'</span>, GreetingPluginExtension, project)
        project.tasks.create(<span class="hl-string">'hello'</span>, Greeting) {
            message = extension.message
            outputFiles = extension.outputFiles
        }
    }
}

<span class="hl-keyword">class</span> GreetingPluginExtension {
    <span class="hl-keyword">final</span> Property&lt;String&gt; message
    <span class="hl-keyword">final</span> ConfigurableFileCollection outputFiles

    GreetingPluginExtension(Project project) {
        message = project.objects.property(String)
        message.set(<span class="hl-string">'Hello from GreetingPlugin'</span>)
        outputFiles = project.files()
    }

    <span class="hl-keyword">void</span> setOutputFiles(FileCollection outputFiles) {
        <span class="hl-keyword">this</span>.outputFiles.setFrom(outputFiles)
    }
}

<span class="hl-keyword">class</span> Greeting <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-keyword">final</span> Property&lt;String&gt; message = project.objects.property(String)
    <span class="hl-keyword">final</span> ConfigurableFileCollection outputFiles = project.files()

    <span class="hl-keyword">void</span> setOutputFiles(FileCollection outputFiles) {
        <span class="hl-keyword">this</span>.outputFiles.setFrom(outputFiles)
    }

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> printMessage() {
        outputFiles.each {
            logger.quiet <span class="hl-string">"Writing message 'Hi from Gradle' to file"</span>
            it.text = message.get()
        }
    }
}

apply plugin: GreetingPlugin

greeting {
    message = <span class="hl-string">'Hi from Gradle'</span>
    outputFiles = files(<span class="hl-string">'a.txt'</span>, <span class="hl-string">'b.txt'</span>)
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/userguide/tasks/mapExtensionPropertiesToTaskProperties</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Writing message 'Hi from Gradle' to file
Writing message 'Hi from Gradle' to file
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:custom_plugins_standalone_project" class="section-anchor" href="#sec:custom_plugins_standalone_project"></a>A standalone project</h2></div></div></div><p>Now we will move our plugin to a standalone project, so we can publish it and share it with others. This project is simply a Groovy project that produces a JAR containing the plugin classes. Here is a simple build script for the project. It applies the Groovy plugin, and adds the Gradle API as a compile-time dependency.</p><div class="example"><a name="customPluginStandalone"></a><p class="title"><b>Example&nbsp;346.&nbsp;A build for a custom plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>

dependencies {
    compile gradleApi()
    compile localGroovy()
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/customPlugin/plugin</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>So how does Gradle find the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> implementation? The answer is you need to provide a properties file in the jar&rsquo;s <code class="literal">META-INF/gradle-plugins</code> directory that matches the id of your plugin.</p><div class="example"><a name="customPluginStandalone"></a><p class="title"><b>Example&nbsp;347.&nbsp;Wiring for a custom plugin</b></p><div class="example-contents"><p><code class="filename">src/main/resources/META-INF/gradle-plugins/org.samples.greeting.properties</code></p><pre class="programlisting">implementation-class=org.gradle.GreetingPlugin
</pre></div></div><br class="example-break"><p>Notice that the properties filename matches the plugin id and is placed in the resources folder, and that the <code class="literal">implementation-class</code> property identifies the <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> implementation class.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:creating_a_plugin_id" class="section-anchor" href="#sec:creating_a_plugin_id"></a>Creating a plugin id</h3></div></div></div><p>Plugin ids are fully qualified in a manner similar to Java packages (i.e. a reverse domain name). This helps to avoid collisions and provides a way to group plugins with similar ownership.</p><p>Your plugin id should be a combination of components that reflect namespace (a reasonable pointer to you or your organization) and the name of the plugin it provides. For example if you had a Github account named "foo" and your plugin was named "bar", a suitable plugin id might be <code class="literal">com.github.foo.bar</code>. Similarly, if the plugin was developed at the baz organization, the plugin id might be <code class="literal">org.baz.bar</code>.</p><p>Plugin ids should conform to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>May contain any alphanumeric character, '.', and '-'.</p></li><li class="listitem"><p>Must contain at least one '.' character separating the namespace from the name of the plugin.</p></li><li class="listitem"><p>Conventionally use a lowercase reverse domain name convention for the namespace.</p></li><li class="listitem"><p>Conventionally use only lowercase characters in the name.</p></li><li class="listitem"><p><code class="literal">org.gradle</code> and <code class="literal">com.gradleware</code> namespaces may not be used.</p></li><li class="listitem"><p>Cannot start or end with a '.' character.</p></li><li class="listitem"><p>Cannot contain consecutive '.' characters (i.e. '..').</p></li></ul></div><p>Although there are conventional similarities between plugin ids and package names, package names are generally more detailed than is necessary for a plugin id. For instance, it might seem reasonable to add "gradle" as a component of your plugin id, but since plugin ids are only used for Gradle plugins, this would be superfluous. Generally, a namespace that identifies ownership and a name are all that are needed for a good plugin id.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_your_plugin" class="section-anchor" href="#sec:publishing_your_plugin"></a>Publishing your plugin</h3></div></div></div><p>If you are publishing your plugin internally for use within your organization, you can publish it like any other code artifact. See the <a class="link" href="#publishing_ivy">ivy</a> and <a class="link" href="#publishing_maven">maven</a> chapters on publishing artifacts.</p><p>If you are interested in publishing your plugin to be used by the wider Gradle community, you can publish it to the <a class="ulink" href="http://plugins.gradle.org" target="_top">Gradle plugin portal</a>. This site provides the ability to search for and gather information about plugins contributed by the Gradle community. See the instructions <a class="ulink" href="http://plugins.gradle.org/docs/submit" target="_top">here</a> on how to make your plugin available on this site.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_your_plugin_in_another_project" class="section-anchor" href="#sec:using_your_plugin_in_another_project"></a>Using your plugin in another project</h3></div></div></div><p>To use a plugin in a build script, you need to add the plugin classes to the build script&rsquo;s classpath. To do this, you use a &ldquo;buildscript { }&rdquo; block, as described in <a class="xref" href="#sec:applying_plugins_buildscript">the section called &ldquo;Applying plugins with the buildscript block&rdquo;</a>. The following example shows how you might do this when the JAR containing the plugin has been published to a local repository:</p><div class="example"><a name="customPluginStandalone"></a><p class="title"><b>Example&nbsp;348.&nbsp;Using a custom plugin in another project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        maven {
            url uri(<span class="hl-string">'../repo'</span>)
        }
    }
    dependencies {
        classpath group: <span class="hl-string">'org.gradle'</span>, name: <span class="hl-string">'customPlugin'</span>,
                  version: <span class="hl-string">'1.0-SNAPSHOT'</span>
    }
}
apply plugin: <span class="hl-string">'org.samples.greeting'</span>
</pre></div></div><br class="example-break"><p>Alternatively, if your plugin is published to the plugin portal, you can use the incubating plugins DSL (see <a class="xref" href="#sec:plugins_block">the section called &ldquo;Applying plugins with the plugins DSL&rdquo;</a>) to apply the plugin:</p><div class="example"><a name="useCommunityPluginDSL"></a><p class="title"><b>Example&nbsp;349.&nbsp;Applying a community plugin with the plugins DSL</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'com.jfrog.bintray'</span> version <span class="hl-string">'0.4.1'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:writing_tests_for_your_plugin" class="section-anchor" href="#sec:writing_tests_for_your_plugin"></a>Writing tests for your plugin</h3></div></div></div><p>You can use the <a class="ulink" href="../javadoc/org/gradle/testfixtures/ProjectBuilder.html" target="_top"><code class="classname">ProjectBuilder</code></a> class to create <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> instances to use when you test your plugin implementation.</p><div class="example"><a name="customPluginStandalone"></a><p class="title"><b>Example&nbsp;350.&nbsp;Testing a custom plugin</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/GreetingPluginTest.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> GreetingPluginTest {
    <span class="hl-annotation">@Test</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> greeterPluginAddsGreetingTaskToProject() {
        Project project = ProjectBuilder.builder().build()
        project.pluginManager.apply <span class="hl-string">'org.samples.greeting'</span>

        assertTrue(project.tasks.hello <span class="hl-keyword">instanceof</span> GreetingTask)
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_the_java_gradle_plugin_development_plugin" class="section-anchor" href="#sec:using_the_java_gradle_plugin_development_plugin"></a>Using the Java Gradle Plugin development plugin</h3></div></div></div><p>You can use the incubating <a class="link" href="#">Java Gradle Plugin development plugin</a> to eliminate some of the boilerplate declarations in your build script and provide some basic validations of plugin metadata. This plugin will automatically apply the <a class="link" href="#java_plugin">Java plugin</a>, add the <code class="literal">gradleApi()</code> dependency to the compile configuration, and perform plugin metadata validations as part of the <code class="literal">jar</code> task execution.</p><div class="example"><a name="useJavaGradlePluginPlugin"></a><p class="title"><b>Example&nbsp;351.&nbsp;Using the Java Gradle Plugin Development plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'java-gradle-plugin'</span>
}
</pre></div></div><br class="example-break"><p>When publishing plugins to custom plugin repositories using the <a class="link" href="#publishing_ivy">ivy</a> or <a class="link" href="#publishing_maven">maven</a> publish plugins, the <a class="link" href="#">Java Gradle Plugin development plugin</a> will also generate plugin marker artifacts named based on the plugin id which depend on the plugin&rsquo;s implementation artifact.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:implementing_a_dsl" class="section-anchor" href="#sec:implementing_a_dsl"></a>Providing a configuration DSL for the plugin</h2></div></div></div><p>As we saw above, you can use an extension object to provide configuration for your plugin. Using an extension object also extends the Gradle DSL to add a project property and DSL block for the plugin. An extension object is simply a regular object, and so you can provide DSL elements nested inside this block by adding properties and methods to the extension object.</p><p>Gradle provides several conveniences to help create a well-behaved DSL for your plugin.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:nested_dsl_elements" class="section-anchor" href="#sec:nested_dsl_elements"></a>Nested DSL elements</h3></div></div></div><p>When Gradle creates a task or extension object, Gradle <span class="emphasis"><em>decorates</em></span> the implementation class to mix in DSL support. To create a nested DSL element you can use the <a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html" target="_top"><code class="classname">ObjectFactory</code></a> type to create objects that are similarly decorated. These decorated objects can then be made visible to the DSL through properties and methods of the plugin&rsquo;s extension:</p><div class="example"><a name="nestedDslElement"></a><p class="title"><b>Example&nbsp;352.&nbsp;Nested DSL elements</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> Person {
    String name
}

<span class="hl-keyword">class</span> GreetingPluginExtension {
    String message
    <span class="hl-keyword">final</span> Person greeter

    <span class="hl-annotation">@javax.inject.Inject</span>
    GreetingPluginExtension(ObjectFactory objectFactory) {
        <span class="hl-comment">// Create a Person instance</span>
        greeter = objectFactory.newInstance(Person)
    }

    <span class="hl-keyword">void</span> greeter(Action&lt;? <span class="hl-keyword">super</span> Person&gt; action) {
        action.execute(greeter)
    }
}

<span class="hl-keyword">class</span> GreetingPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        <span class="hl-comment">// Create the extension, passing in an ObjectFactory for it to use</span>
        def extension = project.extensions.create(<span class="hl-string">'greeting'</span>, GreetingPluginExtension, project.objects)
        project.task(<span class="hl-string">'hello'</span>) {
            doLast {
                println <span class="hl-string">"${extension.message} from ${extension.greeter.name}"</span>
            }
        }
    }
}

apply plugin: GreetingPlugin

greeting {
    message = <span class="hl-string">'Hi'</span>
    greeter {
        name = <span class="hl-string">'Gradle'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
Hi from Gradle
</pre></div></div><br class="example-break"><p>In this example, the plugin passes the project&rsquo;s <code class="literal">ObjectFactory</code> to the extension object through its constructor. The constructor uses this to create a nested object and makes this object available to the DSL through the <code class="literal">greeter</code> property.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:maintaining_multiple_domain_objects" class="section-anchor" href="#sec:maintaining_multiple_domain_objects"></a>Configuring a collection of objects</h3></div></div></div><p>Gradle provides some utility classes for maintaining collections of objects, intended to work well with the Gradle DSL.</p><div class="example"><a name="domainObjectContainer"></a><p class="title"><b>Example&nbsp;353.&nbsp;Managing a collection of objects</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> Book {
    <span class="hl-keyword">final</span> String name
    File sourceFile

    Book(String name) {
        <span class="hl-keyword">this</span>.name = name
    }
}

<span class="hl-keyword">class</span> DocumentationPlugin <span class="hl-keyword">implements</span> Plugin&lt;Project&gt; {
    <span class="hl-keyword">void</span> apply(Project project) {
        <span class="hl-comment">// Create a container of Book instances</span>
        def books = project.container(Book)
        books.all {
            sourceFile = project.file(<span class="hl-string">"src/docs/$name"</span>)
        }
        <span class="hl-comment">// Add the container as an extension object</span>
        project.extensions.books = books
    }
}

apply plugin: DocumentationPlugin

<span class="hl-comment">// Configure the container</span>
books {
    quickStart {
        sourceFile = file(<span class="hl-string">'src/docs/quick-start'</span>)
    }
    userGuide {

    }
    developerGuide {

    }
}

task books {
    doLast {
        books.each { book -&gt;
            println <span class="hl-string">"$book.name -&gt; $book.sourceFile"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q books</code></strong></p><pre class="screen">&gt; gradle -q books
developerGuide -&gt; /home/user/gradle/samples/userguide/organizeBuildLogic/customPluginWithDomainObjectContainer/src/docs/developerGuide
quickStart -&gt; /home/user/gradle/samples/userguide/organizeBuildLogic/customPluginWithDomainObjectContainer/src/docs/quick-start
userGuide -&gt; /home/user/gradle/samples/userguide/organizeBuildLogic/customPluginWithDomainObjectContainer/src/docs/userGuide
</pre></div></div><br class="example-break"><p>The <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:container(java.lang.Class)" target="_top"><code class="classname">Project.container(java.lang.Class)</code></a> methods create instances of <a class="ulink" href="../dsl/org.gradle.api.NamedDomainObjectContainer.html" target="_top"><code class="classname">NamedDomainObjectContainer</code></a>, that have many useful methods for managing and configuring the objects. In order to use a type with any of the <code class="literal">project.container</code> methods, it MUST expose a property named &ldquo;name&rdquo; as the unique, and constant, name for the object. The <code class="literal">project.container(Class)</code> variant of the container method creates new instances by attempting to invoke the constructor of the class that takes a single string argument, which is the desired name of the object. See the above link for <code class="literal">project.container</code> method variants that allow custom instantiation strategies.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="java_gradle_plugin"></a>Gradle Plugin Development Plugin</h1></div></div></div><div class="note"><p>The Java Gradle plugin development plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The Java Gradle Plugin development plugin can be used to assist in the development of Gradle plugins. It automatically applies the <a class="link" href="#java_plugin">Java</a> plugin, adds the <code class="literal">gradleApi()</code> dependency to the compile configuration and performs validation of plugin metadata during <code class="literal">jar</code> task execution.</p><p>The plugin also integrates with <a class="link" href="#test_kit">TestKit</a>, a library that aids in writing and executing functional tests for plugin code. It automatically adds the <code class="literal">gradleTestKit()</code> dependency to the test compile configuration and generates a plugin classpath manifest file consumed by a <code class="literal">GradleRunner</code> instance if found. Please refer to <a class="xref" href="#sub:test-kit-automatic-classpath-injection">the section called &ldquo;Automatic injection with the Java Gradle Plugin Development plugin&rdquo;</a> for more on its usage, configuration options and samples.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:gradle_plugin_dev_usage" class="section-anchor" href="#sec:gradle_plugin_dev_usage"></a>Usage</h2></div></div></div><p>To use the Java Gradle Plugin Development plugin, include the following in your build script:</p><div class="example"><a name="useJavaGradlePluginPlugin"></a><p class="title"><b>Example&nbsp;354.&nbsp;Using the Java Gradle Plugin Development plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'java-gradle-plugin'</span>
}
</pre></div></div><br class="example-break"><p>Applying the plugin automatically applies the <a class="link" href="#java_plugin">Java</a> plugin and adds the <code class="literal">gradleApi()</code> dependency to the compile configuration. It also adds some validations to the build.</p><p>The following validations are performed:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There is a plugin descriptor defined for the plugin.</p></li><li class="listitem"><p>The plugin descriptor contains an <code class="literal">implementation-class</code> property.</p></li><li class="listitem"><p>The <code class="literal">implementation-class</code> property references a valid class file in the jar.</p></li><li class="listitem"><p>Each property getter or the corresponding field must be annotated with a property annotation like <code class="literal">@InputFile</code> and <code class="literal">@OutputDirectory</code>. Properties that don&rsquo;t participate in up-to-date checks should be annotated with <code class="literal">@Internal</code>.</p></li></ul></div><p>Any failed validations will result in a warning message.</p><p>For each plugin you are developing, add an entry to the <code class="literal">gradlePlugin {}</code> script block:</p><div class="example"><a name="gradlePluginBlock"></a><p class="title"><b>Example&nbsp;355.&nbsp;Using the gradlePlugin {} block.</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">gradlePlugin {
    plugins {
        simplePlugin {
            id = <span class="hl-string">'org.gradle.sample.simple-plugin'</span>
            implementationClass = <span class="hl-string">'org.gradle.sample.SimplePlugin'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>The <code class="literal">gradlePlugin {}</code> block defines the plugins being built by the project including the <code class="literal">id</code> and <code class="literal">implementationClass</code> of the plugin. From this data about the plugins being developed, Gradle can automatically:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Generate the plugin descriptor in the <code class="literal">jar</code> file&rsquo;s <code class="literal">META-INF</code> directory.</p></li><li class="listitem"><p>Configure the <a class="link" href="#publishing_maven">Maven</a> or <a class="link" href="#publishing_ivy">Ivy</a> publishing plugins to publish a <a class="link" href="#sec:plugin_markers">Plugin Marker Artifact</a> for each plugin.</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="organizing_build_logic"></a>Organizing Build Logic</h1></div></div></div><p>Gradle offers a variety of ways to organize your build logic. First of all you can put your build logic directly in the action closure of a task. If a couple of tasks share the same logic you can extract this logic into a method. If multiple projects of a multi-project build share some logic you can define this method in the parent project. If the build logic gets too complex for being properly modeled by methods then you likely should implement your logic with classes to encapsulate your logic.<sup>[<a href="#ftn.N15D44" name="N15D44" class="footnote">14</a>]</sup> Gradle makes this very easy. Just drop your classes in a certain directory and Gradle automatically compiles them and puts them in the classpath of your build script.</p><p>Here is a summary of the ways you can organise your build logic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>POGOs. You can declare and use plain old Groovy objects (POGOs) directly in your build script. The build script is written in Groovy, after all, and Groovy provides you with lots of excellent ways to organize code.</p></li><li class="listitem"><p><a class="link" href="#sec:inherited_properties_and_methods">Inherited properties and methods</a>. In a multi-project build, sub-projects inherit the properties and methods of their parent project.</p></li><li class="listitem"><p><a class="link" href="#sec:injected_configuration">Configuration injection</a>. In a multi-project build, a project (usually the root project) can inject properties and methods into another project.</p></li><li class="listitem"><p><a class="link" href="#sec:build_sources"><code class="literal">buildSrc</code> project</a>. Drop the source for your build classes into a certain directory and Gradle automatically compiles them and includes them in the classpath of your build script.</p></li><li class="listitem"><p><a class="link" href="#sec:configuring_using_external_script">Shared scripts</a>. Define common configuration in an external build, and apply the script to multiple projects, possibly across different builds.</p></li><li class="listitem"><p><a class="link" href="#custom_tasks">Custom tasks</a>. Put your build logic into a custom task, and reuse that task in multiple places.</p></li><li class="listitem"><p><a class="link" href="#custom_plugins">Custom plugins</a>. Put your build logic into a custom plugin, and apply that plugin to multiple projects. The plugin must be in the classpath of your build script. You can achieve this either by using <a class="link" href="#sec:build_sources"><code class="literal">build sources</code></a> or by adding an <a class="link" href="#">external library</a> that contains the plugin.</p></li><li class="listitem"><p><a class="link" href="#sec:external_build">Execute an external build</a>. Execute another Gradle build from the current build.</p></li><li class="listitem"><p><a class="link" href="#">External libraries</a>. Use external libraries directly in your build file.</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:inherited_properties_and_methods" class="section-anchor" href="#sec:inherited_properties_and_methods"></a>Inherited properties and methods</h2></div></div></div><p>Any method or property defined in a project build script is also visible to all the sub-projects. You can use this to define common configurations, and to extract build logic into methods which can be reused by the sub-projects.</p><div class="example"><a name="inheritedBuildLogic"></a><p class="title"><b>Example&nbsp;356.&nbsp;Using inherited properties and methods</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Define an extra property</span>
ext.srcDirName = <span class="hl-string">'src/java'</span>

<span class="hl-comment">// Define a method</span>
def getSrcDir(project) {
    <span class="hl-keyword">return</span> project.file(srcDirName)
}
</pre><p><code class="filename">child/build.gradle</code></p><pre class="programlisting">task show {
    doLast {
        <span class="hl-comment">// Use inherited property</span>
        println <span class="hl-string">'srcDirName: '</span> + srcDirName

        <span class="hl-comment">// Use inherited method</span>
        File srcDir = getSrcDir(project)
        println <span class="hl-string">'srcDir: '</span> + rootProject.relativePath(srcDir)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q show</code></strong></p><pre class="screen">&gt; gradle -q show
srcDirName: src/java
srcDir: child/src/java
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:injected_configuration" class="section-anchor" href="#sec:injected_configuration"></a>Injected configuration</h2></div></div></div><p>You can use the configuration injection technique discussed in <a class="xref" href="#sec:cross_project_configuration">the section called &ldquo;Cross project configuration&rdquo;</a> and <a class="xref" href="#sec:subproject_configuration">the section called &ldquo;Subproject configuration&rdquo;</a> to inject properties and methods into various projects. This is generally a better option than inheritance, for a number of reasons: The injection is explicit in the build script, You can inject different logic into different projects, And you can inject any kind of configuration such as repositories, plug-ins, tasks, and so on. The following sample shows how this works.</p><div class="example"><a name="injectedBuildLogic"></a><p class="title"><b>Example&nbsp;357.&nbsp;Using injected properties and methods</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    <span class="hl-comment">// Define a new property</span>
    ext.srcDirName = <span class="hl-string">'src/java'</span>

    <span class="hl-comment">// Define a method using a closure as the method body</span>
    ext.srcDir = { file(srcDirName) }

    <span class="hl-comment">// Define a task</span>
    task show {
        doLast {
            println <span class="hl-string">'project: '</span> + project.path
            println <span class="hl-string">'srcDirName: '</span> + srcDirName
            File srcDir = srcDir()
            println <span class="hl-string">'srcDir: '</span> + rootProject.relativePath(srcDir)
        }
    }
}

<span class="hl-comment">// Inject special case configuration into a particular project</span>
project(<span class="hl-string">':child2'</span>) {
    ext.srcDirName = <span class="hl-string">"$srcDirName/legacy"</span>
}
</pre><p><code class="filename">child1/build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Use injected property and method. Here, we override the injected value</span>
srcDirName = <span class="hl-string">'java'</span>
def dir = srcDir()
</pre><p>Output of <strong class="userinput"><code>gradle -q show</code></strong></p><pre class="screen">&gt; gradle -q show
project: :child1
srcDirName: java
srcDir: child1/java
project: :child2
srcDirName: src/java/legacy
srcDir: child2/src/java/legacy</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_using_external_script" class="section-anchor" href="#sec:configuring_using_external_script"></a>Configuring the project using an external build script</h2></div></div></div><p>You can configure the current project using an external build script. All of the Gradle build language is available in the external script. You can even apply other scripts from the external script.</p><p>Build scripts can be local files or remotely accessible files downloaded via a URL.</p><p>Remote files will be cached and made available when Gradle runs offline. On each build, Gradle will check if the remote file has changed and will only download the build script file again if it has changed. URLs that contain query strings will not be cached.</p><div class="example"><a name="configureProjectUsingScript"></a><p class="title"><b>Example&nbsp;358.&nbsp;Configuring the project using an external build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply from: <span class="hl-string">'other.gradle'</span>
</pre><p><code class="filename">other.gradle</code></p><pre class="programlisting">println <span class="hl-string">"configuring $project"</span>
task hello {
    doLast {
        println <span class="hl-string">'hello from other script'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q hello</code></strong></p><pre class="screen">&gt; gradle -q hello
configuring root project 'configureProjectUsingScript'
hello from other script</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_sources" class="section-anchor" href="#sec:build_sources"></a>Build sources in the <code class="literal">buildSrc</code> project</h2></div></div></div><p>When you run Gradle, it checks for the existence of a directory called <code class="literal">buildSrc</code>. Gradle then automatically compiles and tests this code and puts it in the classpath of your build script. You don&rsquo;t need to provide any further instruction. This can be a good place to add your custom tasks and plugins.</p><p>For multi-project builds there can be only one <code class="literal">buildSrc</code> directory, which has to be in the root project directory.</p><p>Listed below is the default build script that Gradle applies to the <code class="literal">buildSrc</code> project:</p><p title="Default buildSrc build script"><b>Default buildSrc build script.&nbsp;</b>
</p><pre class="programlisting">apply plugin: 'groovy'
dependencies {
    compile gradleApi()
    compile localGroovy()
}</pre><p title="Default buildSrc build script">
</p><p>This means that you can just put your build source code in this directory and stick to the layout convention for a Java/Groovy project (see <a class="xref" href="#javalayout" title="Table&nbsp;36.&nbsp;Java plugin - default project layout">Table&nbsp;36</a>).</p><p>If you need more flexibility, you can provide your own <code class="literal">build.gradle</code>. Gradle applies the default build script regardless of whether there is one specified. This means you only need to declare the extra things you need. Below is an example. Notice that this example does not need to declare a dependency on the Gradle API, as this is done by the default build script:</p><div class="example"><a name="customBuildSrcBuild"></a><p class="title"><b>Example&nbsp;359.&nbsp;Custom buildSrc build script</b></p><div class="example-contents"><p><code class="filename">buildSrc/build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

dependencies {
    testCompile <span class="hl-string">'junit:junit:4.12'</span>
}
</pre></div></div><br class="example-break"><p>The <code class="literal">buildSrc</code> project can be a multi-project build, just like any other regular multi-project build. However, all of the projects that should be on the classpath of the actual build must be <code class="literal">runtime</code> dependencies of the root project in <code class="literal">buildSrc</code>. You can do this by adding this to the configuration of each project you wish to export:</p><div class="example"><a name="multiProjectBuildSrc"></a><p class="title"><b>Example&nbsp;360.&nbsp;Adding subprojects to the root buildSrc project</b></p><div class="example-contents"><p><code class="filename">buildSrc/build.gradle</code></p><pre class="programlisting">rootProject.dependencies {
  runtime project(path)
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/multiProjectBuildSrc</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:external_build" class="section-anchor" href="#sec:external_build"></a>Running another Gradle build from a build</h2></div></div></div><p>You can use the <a class="ulink" href="../dsl/org.gradle.api.tasks.GradleBuild.html" target="_top"><code class="classname">GradleBuild</code></a> task. You can use either of the <code class="literal">dir</code> or <code class="literal">buildFile</code> properties to specify which build to execute, and the <code class="literal">tasks</code> property to specify which tasks to execute.</p><div class="example"><a name="nestedBuild"></a><p class="title"><b>Example&nbsp;361.&nbsp;Running another build from a build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task build(type: GradleBuild) {
    buildFile = <span class="hl-string">'other.gradle'</span>
    tasks = [<span class="hl-string">'hello'</span>]
}
</pre><p><code class="filename">other.gradle</code></p><pre class="programlisting">task hello {
    doLast {
        println <span class="hl-string">"hello from the other build."</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q build</code></strong></p><pre class="screen">&gt; gradle -q build
hello from the other build.
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:build_script_external_dependencies" class="section-anchor" href="#sec:build_script_external_dependencies"></a>External dependencies for the build script</h2></div></div></div><p>If your build script needs to use external libraries, you can add them to the script&rsquo;s classpath in the build script itself. You do this using the <code class="literal">buildscript()</code> method, passing in a closure which declares the build script classpath.</p><div class="example"><a name="declareExternalBuildDependency"></a><p class="title"><b>Example&nbsp;362.&nbsp;Declaring external dependencies for the build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: <span class="hl-string">'commons-codec'</span>, name: <span class="hl-string">'commons-codec'</span>, version: <span class="hl-string">'1.2'</span>
    }
}
</pre></div></div><br class="example-break"><p>The closure passed to the <code class="literal">buildscript()</code> method configures a <a class="ulink" href="../javadoc/org/gradle/api/initialization/dsl/ScriptHandler.html" target="_top"><code class="classname">ScriptHandler</code></a> instance. You declare the build script classpath by adding dependencies to the <code class="literal">classpath</code> configuration. This is the same way you declare, for example, the Java compilation classpath. You can use any of the dependency types described in <a class="xref" href="#sec:dependency_types">the section called &ldquo;Dependency types&rdquo;</a>, except project dependencies.</p><p>Having declared the build script classpath, you can use the classes in your build script as you would any other classes on the classpath. The following example adds to the previous example, and uses classes from the build script classpath.</p><div class="example"><a name="externalBuildDependency"></a><p class="title"><b>Example&nbsp;363.&nbsp;A build script with external dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.apache.commons.codec.binary.Base6<span class="hl-number">4</span>

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: <span class="hl-string">'commons-codec'</span>, name: <span class="hl-string">'commons-codec'</span>, version: <span class="hl-string">'1.2'</span>
    }
}

task encode {
    doLast {
        def <span class="hl-keyword">byte</span>[] encodedString = <span class="hl-keyword">new</span> Base6<span class="hl-number">4</span>().encode(<span class="hl-string">'hello world\n'</span>.getBytes())
        println <span class="hl-keyword">new</span> String(encodedString)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q encode</code></strong></p><pre class="screen">&gt; gradle -q encode
aGVsbG8gd29ybGQK
</pre></div></div><br class="example-break"><p>For multi-project builds, the dependencies declared with a project&rsquo;s <code class="literal">buildscript()</code> method are available to the build scripts of all its sub-projects.</p><p>Build script dependencies may be Gradle plugins. Please consult <a class="xref" href="#plugins"><i>Using Gradle Plugins</i></a> for more information on Gradle plugins.</p><p>Every project automatically has a <code class="literal">buildEnvironment</code> task of type <a class="ulink" href="../dsl/org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask.html" target="_top"><code class="classname">BuildEnvironmentReportTask</code></a> that can be invoked to report on the resolution of the build script dependencies.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ant_optional_dependencies" class="section-anchor" href="#sec:ant_optional_dependencies"></a>Ant optional dependencies</h2></div></div></div><p>For reasons we don&rsquo;t fully understand yet, external dependencies are not picked up by Ant&rsquo;s optional tasks. But you can easily do it in another way.<sup>[<a href="#ftn.N15EB2" name="N15EB2" class="footnote">15</a>]</sup></p><div class="example"><a name="buildLogic"></a><p class="title"><b>Example&nbsp;364.&nbsp;Ant optional dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    ftpAntTask
}

dependencies {
    ftpAntTask(<span class="hl-string">"org.apache.ant:ant-commons-net:1.9.9"</span>) {
        module(<span class="hl-string">"commons-net:commons-net:1.4.1"</span>) {
            dependencies <span class="hl-string">"oro:oro:2.0.8:jar"</span>
        }
    }
}

task ftp {
    doLast {
        ant {
            taskdef(name: <span class="hl-string">'ftp'</span>,
                    classname: <span class="hl-string">'org.apache.tools.ant.taskdefs.optional.net.FTP'</span>,
                    classpath: configurations.ftpAntTask.asPath)
            ftp(server: <span class="hl-string">"ftp.apache.org"</span>, userid: <span class="hl-string">"anonymous"</span>, password: <span class="hl-string">"me@myorg.com"</span>) {
                fileset(dir: <span class="hl-string">"htdocs/manual"</span>)
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>This is also a good example for the usage of client modules. The POM file in Maven Central for the ant-commons-net task does not provide the right information for this use case.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:philosophy" class="section-anchor" href="#sec:philosophy"></a>Summary</h2></div></div></div><p>Gradle offers you a variety of ways of organizing your build logic. You can choose what is right for your domain and find the right balance between unnecessary indirections, and avoiding redundancy and a hard to maintain code base. It is our experience that even very complex custom build logic is rarely shared between different builds. Other build tools enforce a separation of this build logic into a separate project. Gradle spares you this unnecessary overhead and indirection.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N15D44" name="ftn.N15D44" class="para">14</a>] </sup>Which might range from a single class to something very complex.</p></div><div class="footnote"><p><sup>[<a href="#N15EB2" name="ftn.N15EB2" class="para">15</a>] </sup>In fact, we think this is a better solution. Only if your buildscript and Ant&rsquo;s optional task need the <span class="emphasis"><em>same</em></span> library would you have to define it twice. In such a case it would be nice if Ant&rsquo;s optional task would automatically pick up the classpath defined in the &ldquo;<code class="literal">gradle.settings</code>&rdquo; file.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="lazy_configuration"></a>Lazy Configuration</h1></div></div></div><p>As a build grows in complexity, knowing when and where a particular value is configured can become difficult to reason about. Gradle provides several ways to manage this complexity using <span class="emphasis"><em>lazy configuration</em></span>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:lazy_properties" class="section-anchor" href="#sec:lazy_properties"></a>Lazy properties</h2></div></div></div><div class="note"><p>The Provider API is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>Gradle provides lazy properties, which delay the calculation of a property&rsquo;s value until it&rsquo;s absolutely required. Lazy types are faster, more understandable and better instrumented than the internal convention mapping mechanisms. This provides two main benefits to build script and plugin authors:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Build authors can wire together Gradle models without worrying when a particular property&rsquo;s value will be known. For example, when you want to map properties in an extension to task properties but the values aren&rsquo;t known until the build script configures them.</p></li><li class="listitem"><p>Build authors can avoid resource intensive work during the configuration phase, which can have a direct impact on maximum build performance. For example, when a property value comes from parsing a file.</p></li></ol></div><p>Gradle represents lazy properties with two interfaces:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> are properties that can only be queried and cannot be changed.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Properties with these types are read-only.</p></li><li class="listitem"><p>The method <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html#get--" target="_top"><code class="classname">Provider.get()</code></a> returns the current value of the property.</p></li><li class="listitem"><p>A <code class="literal">Provider</code> can be created by the factory method <a class="ulink" href="../javadoc/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-" target="_top"><code class="classname">ProviderFactory.provider(java.util.concurrent.Callable)</code></a>.</p></li></ul></div></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> are properties that can be queried and overwritten.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Properties with these types are configurable.</p></li><li class="listitem"><p><code class="literal">Property</code> implements the <code class="literal">Provider</code> interface.</p></li><li class="listitem"><p>The method <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html#set-T-" target="_top"><code class="classname">Property.set(T)</code></a> specifies a value for the property, overwriting whatever value may have been present.</p></li><li class="listitem"><p>The method <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html#set-org.gradle.api.provider.Provider-" target="_top"><code class="classname">Property.set(org.gradle.api.provider.Provider)</code></a> specifies a <code class="literal">Provider</code> for the value for the property, overwriting whatever value may have been present. This allows you to wire together <code class="literal">Provider</code> and <code class="literal">Property</code> instances before the values are configured.</p></li><li class="listitem"><p>A <code class="literal">Property</code> can be created by the factory method <a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.property(java.lang.Class)</code></a>.</p></li></ul></div></li></ul></div><p>Neither of these types nor their subtypes are intended to be implemented by a build script or plugin author.  Gradle provides several factory methods to create instances of these types. See the <a class="link" href="#">Quick Reference</a> for all of the types and factories available.</p><p>Lazy properties are intended to be passed around and only evaluated when required (usually, during the execution phase). For more information about the Gradle build phases, please see <a class="xref" href="#sec:build_phases">the section called &ldquo;Build phases&rdquo;</a>.</p><p>The following demonstrates a task with a read-only property and a configurable property:</p><div class="example"><a name="usePropertyAndProvider"></a><p class="title"><b>Example&nbsp;365.&nbsp;Using a read-only and configurable property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> Greeting <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-comment">// Configurable by the user</span>
    <span class="hl-annotation">@Input</span>
    <span class="hl-keyword">final</span> Property&lt;String&gt; message = project.objects.property(String)

    <span class="hl-comment">// Read-only property calculated from the message</span>
    <span class="hl-annotation">@Internal</span>
    <span class="hl-keyword">final</span> Provider&lt;String&gt; fullMessage = message.map { it + <span class="hl-string">" from Gradle"</span> }

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> printMessage() {
        logger.quiet(fullMessage.get())
    }
}

task greeting(type: Greeting) {
    <span class="hl-comment">// Note that this is effectively calling Property.set()</span>
    message = <span class="hl-string">'Hi'</span>
}
</pre><p>Output of <strong class="userinput"><code>gradle greeting</code></strong></p><pre class="screen">&gt; gradle greeting
:greeting
Hi from Gradle

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed</pre></div></div><br class="example-break"><p>The <code class="literal">Greeting</code> task has a <code class="literal">Property&lt;String&gt;</code> for the mutable part of the message and a <code class="literal">Provider&lt;String&gt;</code> for the calculated, read-only, message.</p><div class="note"><p>Note that Groovy Gradle DSL will generate setter methods for each <code class="literal">Property</code>-typed property in a task implementation. These setter methods allow you to configure the property using the assignment (<code class="literal">=</code>) operator as a convenience.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:creating_property_provider" class="section-anchor" href="#sec:creating_property_provider"></a>Creating a Property or Provider</h2></div></div></div><p>If provider types are not intended to be implemented directly by build script or plugin authors, how do you create a new one? Gradle provides various factory APIs to create new instances of both <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/ProviderFactory.html#provider-java.util.concurrent.Callable-" target="_top"><code class="classname">ProviderFactory.provider(java.util.concurrent.Callable)</code></a> instantiates a new <code class="literal">Provider</code>. An instance of the <a class="ulink" href="../javadoc/org/gradle/api/provider/ProviderFactory.html" target="_top"><code class="classname">ProviderFactory</code></a> can be referenced from <a class="ulink" href="../javadoc/org/gradle/api/Project.html#getProviders--" target="_top"><code class="classname">Project.getProviders()</code></a> or by injecting <code class="literal">ProviderFactory</code> through a constructor or method.</p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.property(java.lang.Class)</code></a> instantiates a new <code class="literal">Property</code>. An instance of the <a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html" target="_top"><code class="classname">ObjectFactory</code></a> can be referenced from <a class="ulink" href="../javadoc/org/gradle/api/Project.html#getObjects--" target="_top"><code class="classname">Project.getObjects()</code></a> or by injecting <code class="literal">ObjectFactory</code> through a constructor or method.</p></li></ul></div><div class="note"><p><a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> does not provide a specific method signature for creating a provider from a <code class="literal">groovy.lang.Closure</code>. When writing a plugin with Groovy, you can use the method signature accepting a <code class="literal">java.util.concurrent.Callable</code> parameter. Groovy&rsquo;s <a class="ulink" href="http://docs.groovy-lang.org/next/html/documentation/core-semantics.html#_assigning_a_closure_to_a_sam_type" target="_top">Closure to type coercion</a> will take care of the rest.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_with_files_in_lazy_properties" class="section-anchor" href="#sec:working_with_files_in_lazy_properties"></a>Working with files and Providers</h2></div></div></div><p>In <a class="xref" href="#working_with_files"><i>Working With Files</i></a>, we introduced four collection types for <code class="literal">File</code>-like objects:</p><div class="table"><p class="title"><b>Table&nbsp;33.&nbsp;Collection of files recap</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N15FD1"><thead><tr>
<td>Read-only Type</td>
<td>Configurable Type</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/ConfigurableFileCollection.html" target="_top"><code class="classname">ConfigurableFileCollection</code></a></p></td>
</tr><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/ConfigurableFileTree.html" target="_top"><code class="classname">ConfigurableFileTree</code></a></p></td>
</tr></tbody></table></div></div><p>All of these types are also considered <code class="literal">Provider</code> types.</p><p>In this section, we are going to introduce more strongly typed models for a <a class="ulink" href="../javadoc/org/gradle/api/file/FileSystemLocation.html" target="_top"><code class="classname">FileSystemLocation</code></a>: <a class="ulink" href="../javadoc/org/gradle/api/file/Directory.html" target="_top"><code class="classname">Directory</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/file/RegularFile.html" target="_top"><code class="classname">RegularFile</code></a>. These types shouldn&rsquo;t be confused with the standard Java <a class="ulink" href="https://docs.oracle.com/javase/7/docs/api/java/io/File.html" target="_top">java.io.File</a> type as they tell Gradle to expect more specific values (a directory or a non-directory, regular file).</p><p>Gradle provides two specialized <code class="literal">Property</code> subtypes for dealing with these types: <a class="ulink" href="../javadoc/org/gradle/api/file/RegularFileProperty.html" target="_top"><code class="classname">RegularFileProperty</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html" target="_top"><code class="classname">DirectoryProperty</code></a>. <a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html" target="_top"><code class="classname">ProjectLayout</code></a> has methods to create these: <a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#fileProperty--" target="_top"><code class="classname">ProjectLayout.fileProperty()</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#directoryProperty--" target="_top"><code class="classname">ProjectLayout.directoryProperty()</code></a>.</p><p>A <code class="literal">DirectoryProperty</code> can also be used to create a lazily evaluated <code class="literal">Provider</code> for a <code class="literal">Directory</code> and <code class="literal">RegularFile</code> via <a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-" target="_top"><code class="classname">DirectoryProperty.dir(java.lang.String)</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-" target="_top"><code class="classname">DirectoryProperty.file(java.lang.String)</code></a> respectively. These methods create paths that are relative to the location set for the original <code class="literal">DirectoryProperty</code>.</p><div class="example"><a name="workingWithFiles"></a><p class="title"><b>Example&nbsp;366.&nbsp;Using file and directory property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> FooExtension {
    <span class="hl-keyword">final</span> DirectoryProperty someDirectory
    <span class="hl-keyword">final</span> RegularFileProperty someFile
    <span class="hl-keyword">final</span> ConfigurableFileCollection someFiles

    FooExtension(Project project) {
        someDirectory = project.layout.directoryProperty()
        someFile = project.layout.fileProperty()
        someFiles = project.files()
    }
}

project.extensions.create(<span class="hl-string">'foo'</span>, FooExtension, project)

foo {
    someDirectory = project.layout.projectDirectory.dir(<span class="hl-string">'some-directory'</span>)
    someFile = project.layout.buildDirectory.file(<span class="hl-string">'some-file'</span>)
    someFiles.from project.files(someDirectory, someFile)
}

task print {
    doLast {
        def someDirectory = project.foo.someDirectory.get().asFile
        logger.quiet(<span class="hl-string">"foo.someDirectory = "</span> + someDirectory)
        logger.quiet(<span class="hl-string">"foo.someFiles contains someDirectory? "</span> + project.foo.someFiles.contains(someDirectory))

        def someFile = project.foo.someFile.get().asFile
        logger.quiet(<span class="hl-string">"foo.someFile = "</span> + someFile)
        logger.quiet(<span class="hl-string">"foo.someFiles contains someFile? "</span> + project.foo.someFiles.contains(someFile))
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle print</code></strong></p><pre class="screen">&gt; gradle print
:print
foo.someDirectory = /home/user/gradle/samples/providers/fileAndDirectoryProperty/some-directory
foo.someFiles contains someDirectory? true
foo.someFile = /home/user/gradle/samples/providers/fileAndDirectoryProperty/build/some-file
foo.someFiles contains someFile? true

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>This example shows how <code class="literal">Provider</code> types can be used inside an extension. Lazy values for <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:buildDir" target="_top"><code class="classname">Project.getBuildDir()</code></a> and <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:projectDir" target="_top"><code class="classname">Project.getProjectDir()</code></a> can be accessed through <a class="ulink" href="../javadoc/org/gradle/api/Project.html#getLayout--" target="_top"><code class="classname">Project.getLayout()</code></a> with <a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#getBuildDirectory--" target="_top"><code class="classname">ProjectLayout.getBuildDirectory()</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#getProjectDirectory--" target="_top"><code class="classname">ProjectLayout.getProjectDirectory()</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_with_task_dependencies_in_lazy_properties" class="section-anchor" href="#sec:working_with_task_dependencies_in_lazy_properties"></a>Working with task dependencies and Providers</h2></div></div></div><p>Many builds have several tasks that depend on each other. This usually means that one task processes the outputs of another task as an input. For these outputs and inputs, we need to know their locations on the file system and appropriately configure each task to know where to look. This can be cumbersome if any of these values are configurable by a user or configured by multiple plugins.</p><p>To make this easier, Gradle offers convenient APIs for defining files or directories as task inputs and outputs in a descriptive way. As an example consider the following plugin with a producer and consumer task, which are wired together via inputs and outputs:</p><div class="example"><a name="implicitTaskDependency"></a><p class="title"><b>Example&nbsp;367.&nbsp;Implicit task dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">
<span class="hl-keyword">class</span> Producer <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-annotation">@OutputFile</span>
    <span class="hl-keyword">final</span> RegularFileProperty outputFile = newOutputFile()

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> produce() {
        String message = <span class="hl-string">'Hello, World!'</span>
        def output = outputFile.get().asFile
        output.text = message
        logger.quiet(<span class="hl-string">"Wrote '${message}' to ${output}"</span>)
    }
}

<span class="hl-keyword">class</span> Consumer <span class="hl-keyword">extends</span> DefaultTask {
    <span class="hl-annotation">@InputFile</span>
    <span class="hl-keyword">final</span> RegularFileProperty inputFile = newInputFile()

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> consume() {
        def input = inputFile.get().asFile
        def message = input.text
        logger.quiet(<span class="hl-string">"Read '${message}' from ${input}"</span>)
    }
}

task producer(type: Producer)
task consumer(type: Consumer)

<span class="hl-comment">// Wire property from producer to consumer task</span>
consumer.inputFile = producer.outputFile

<span class="hl-comment">// Set values for the producer lazily</span>
<span class="hl-comment">// Note that the consumer does not need to be changed again.</span>
producer.outputFile = layout.buildDirectory.file(<span class="hl-string">'file.txt'</span>)

<span class="hl-comment">// Change the base output directory.</span>
<span class="hl-comment">// Note that this automatically changes producer.outputFile and consumer.inputFile</span>
buildDir = <span class="hl-string">'output'</span>
</pre><p>Output of <strong class="userinput"><code>gradle consumer</code></strong></p><pre class="screen">&gt; gradle consumer
:producer
Wrote 'Hello, World!' to /home/user/gradle/samples/providers/implicitTaskDependency/output/file.txt
:consumer
Read 'Hello, World!' from /home/user/gradle/samples/providers/implicitTaskDependency/output/file.txt

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed</pre></div></div><br class="example-break"><p>In the example above, the task outputs and inputs are connected before any location is defined. This is possible because the input and output properties use the <code class="literal">Provider</code> API. The output property is created with <a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newOutputFile--" target="_top"><code class="classname">DefaultTask.newOutputFile()</code></a> and the input property is created with <a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newInputFile--" target="_top"><code class="classname">DefaultTask.newInputFile()</code></a>. Values are only resolved when they are needed during execution. The setters can be called at any time before the task is executed and the change will automatically affect all related input and output properties.</p><p>Another thing to note is the absence of any explicit task dependency. Properties created via <code class="literal">newOutputFile()</code> and <code class="literal">newOutputDirectory()</code> bring knowledge about which task is generating them, so using them as task input will implicitly link tasks together.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_with_collection" class="section-anchor" href="#sec:working_with_collection"></a>Working with collection Providers</h2></div></div></div><p>In this section, we are going to explore lazy collections. They work exactly like any other <code class="literal">Provider</code> and, just like <code class="literal">FileSystemLocation</code> providers, they have additional modeling around them. There are two provider interfaces available, one for <code class="literal">List</code> values and another for <code class="literal">Set</code> values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For <code class="literal">List</code> values the interface is called <a class="ulink" href="../javadoc/org/gradle/api/provider/ListProperty.html" target="_top"><code class="classname">ListProperty</code></a>. You can create a new <code class="literal">ListProperty</code> using <a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.listProperty(java.lang.Class)</code></a> and specifying the element&rsquo;s type.</p></li><li class="listitem"><p>For <code class="literal">Set</code> values the interface is called <a class="ulink" href="../javadoc/org/gradle/api/provider/SetProperty.html" target="_top"><code class="classname">SetProperty</code></a>. You can create a new <code class="literal">SetProperty</code> using <a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.setProperty(java.lang.Class)</code></a> and specifying the element&rsquo;s type.</p></li></ul></div><p>This type of property allows you to overwrite the entire collection value with <a class="ulink" href="../javadoc/org/gradle/api/provider/HasMultipleValues.html#set-java.lang.Iterable-" target="_top"><code class="classname">HasMultipleValues.set(java.lang.Iterable)</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/provider/HasMultipleValues.html#set-org.gradle.api.provider.Provider-" target="_top"><code class="classname">HasMultipleValues.set(org.gradle.api.provider.Provider)</code></a> or add new elements through the various <code class="literal">add</code> methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/HasMultipleValues.html#add-T-" target="_top"><code class="classname">HasMultipleValues.add(T)</code></a>: Add a single concrete element to the collection</p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/HasMultipleValues.html#add-org.gradle.api.provider.Provider-" target="_top"><code class="classname">HasMultipleValues.add(org.gradle.api.provider.Provider)</code></a>: Add a lazily evaluated element to the collection</p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/provider/HasMultipleValues.html#addAll-org.gradle.api.provider.Provider-" target="_top"><code class="classname">HasMultipleValues.addAll(org.gradle.api.provider.Provider)</code></a>: Add a lazily evaluated collection of elements to the list</p></li></ul></div><p>Just like every <code class="literal">Provider</code>, the collection is calculated when <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html#get--" target="_top"><code class="classname">Provider.get()</code></a> is called. The following example show the <a class="ulink" href="../javadoc/org/gradle/api/provider/ListProperty.html" target="_top"><code class="classname">ListProperty</code></a> in action:</p><div class="example"><a name="listProperty"></a><p class="title"><b>Example&nbsp;368.&nbsp;List property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task print {
    doLast {
        ListProperty&lt;String&gt; list = project.objects.listProperty(String)

        <span class="hl-comment">// Resolve the list</span>
        logger.quiet(<span class="hl-string">'The list contains: '</span> + list.get())

        <span class="hl-comment">// Add elements to the empty list</span>
        list.add(project.provider { <span class="hl-string">'element-1'</span> })  <span class="hl-comment">// Add a provider element</span>
        list.add(<span class="hl-string">'element-2'</span>)                       <span class="hl-comment">// Add a concrete element</span>

        <span class="hl-comment">// Resolve the list</span>
        logger.quiet(<span class="hl-string">'The list contains: '</span> + list.get())

        <span class="hl-comment">// Overwrite the entire list with a new list</span>
        list.set([<span class="hl-string">'element-3'</span>, <span class="hl-string">'element-4'</span>])

        <span class="hl-comment">// Resolve the list</span>
        logger.quiet(<span class="hl-string">'The list contains: '</span> + list.get())

        <span class="hl-comment">// Add more elements through a list provider</span>
        list.addAll(project.provider { [<span class="hl-string">'element-5'</span>, <span class="hl-string">'element-6'</span>] })

        <span class="hl-comment">// Resolve the list</span>
        logger.quiet(<span class="hl-string">'The list contains: '</span> + list.get())
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle print</code></strong></p><pre class="screen">&gt; gradle print
:print
The list contains: []
The list contains: [element-1, element-2]
The list contains: [element-3, element-4]
The list contains: [element-3, element-4, element-5, element-6]

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:lazy_configuration_faqs" class="section-anchor" href="#sec:lazy_configuration_faqs"></a>Guidelines</h2></div></div></div><p>This section will introduce guidelines to be successful with the Provider API. To see those guidelines in action, have a look at <a class="ulink" href="https://github.com/gradle-guides/gradle-site-plugin" target="_top">gradle-site-plugin</a>, a Gradle plugin demonstrating established techniques and practices for plugin development.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> and <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> types have all of the overloads you need to query or configure a value. For this reason, you should follow the following guidelines:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>For configurable properties, expose the <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> directly through a single getter.</p></li><li class="listitem"><p>For non-configurable properties, expose an <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> directly through a single getter.</p></li></ul></div></li><li class="listitem"><p>Avoid simplifying calls like <code class="literal">obj.getProperty().get()</code> and <code class="literal">obj.getProperty().set(T)</code> in your code by introducing additional getters and setters.</p></li><li class="listitem"><p>When migrating your plugin to use providers, follow these guidelines:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If it&rsquo;s a new property, expose it as a <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> or <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> using a single getter.</p></li><li class="listitem"><p>If it&rsquo;s incubating, change it to use a <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> or <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> using a single getter.</p></li><li class="listitem"><p>If it&rsquo;s a stable property, add a new <a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a> or <a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a> and deprecate the old one. You should wire the old getter/setters into the new property as appropriate.</p></li></ul></div></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:lazy_configuration_roadmap" class="section-anchor" href="#sec:lazy_configuration_roadmap"></a>Future development</h2></div></div></div><p>Going forward, new properties will use the Provider API. The Groovy Gradle DSL adds convenience methods to make the use of Providers mostly transparent in build scripts. Existing tasks will have their existing "raw" properties replaced by Providers as needed and in a backwards compatible way. New tasks will be designed with the Provider API.</p><p>The Provider API is <a class="link" href="#feature_lifecycle">incubating</a>. Please create new issues at <a class="ulink" href="https://github.com/gradle/gradle/issues/new" target="_top">gradle/gradle</a> to report bugs or to submit use cases for new features.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:lazy_configuration_reference" class="section-anchor" href="#sec:lazy_configuration_reference"></a>Provider API Quick Reference</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;34.&nbsp;Lazy properties summary</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1619F"><thead><tr>
<td>Description</td>
<td>Read-only</td>
<td>Configurable</td>
<td>Factory</td>
</tr></thead><tbody><tr>
<td><p>A file on disk</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;<a class="ulink" href="../javadoc/org/gradle/api/file/RegularFile.html" target="_top"><code class="classname">RegularFile</code></a>&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/RegularFileProperty.html" target="_top"><code class="classname">RegularFileProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#fileProperty--" target="_top"><code class="classname">ProjectLayout.fileProperty()</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/Directory.html#file-java.lang.String-" target="_top"><code class="classname">Directory.file(java.lang.String)</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html#file-java.lang.String-" target="_top"><code class="classname">DirectoryProperty.file(java.lang.String)</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>A file used as a task input/output</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;<a class="ulink" href="../javadoc/org/gradle/api/file/RegularFile.html" target="_top"><code class="classname">RegularFile</code></a>&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/RegularFileProperty.html" target="_top"><code class="classname">RegularFileProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newInputFile--" target="_top"><code class="classname">DefaultTask.newInputFile()</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newOutputFile--" target="_top"><code class="classname">DefaultTask.newOutputFile()</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>A directory on disk</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;<a class="ulink" href="../javadoc/org/gradle/api/file/Directory.html" target="_top"><code class="classname">Directory</code></a>&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html" target="_top"><code class="classname">DirectoryProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/ProjectLayout.html#directoryProperty--" target="_top"><code class="classname">ProjectLayout.directoryProperty()</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/Directory.html#dir-java.lang.String-" target="_top"><code class="classname">Directory.dir(java.lang.String)</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html#dir-java.lang.String-" target="_top"><code class="classname">DirectoryProperty.dir(java.lang.String)</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>A directory used as a task input/output</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;<a class="ulink" href="../javadoc/org/gradle/api/file/Directory.html" target="_top"><code class="classname">Directory</code></a>&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/DirectoryProperty.html" target="_top"><code class="classname">DirectoryProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newInputDirectory--" target="_top"><code class="classname">DefaultTask.newInputDirectory()</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/DefaultTask.html#newOutputDirectory--" target="_top"><code class="classname">DefaultTask.newOutputDirectory()</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>Collection of files</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/ConfigurableFileCollection.html" target="_top"><code class="classname">ConfigurableFileCollection</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:files(java.lang.Object[])" target="_top"><code class="classname">Project.files(java.lang.Object[])</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>Hierarchy of files</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/ConfigurableFileTree.html" target="_top"><code class="classname">ConfigurableFileTree</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:fileTree(java.lang.Object)" target="_top"><code class="classname">Project.fileTree(java.lang.Object)</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>List of any type</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;List&lt;T&gt;&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/ListProperty.html" target="_top"><code class="classname">ListProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#listProperty-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.listProperty(java.lang.Class)</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>Set of any type</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;Set&lt;T&gt;&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/SetProperty.html" target="_top"><code class="classname">SetProperty</code></a></p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#setProperty-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.setProperty(java.lang.Class)</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>Any other type</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Provider.html" target="_top"><code class="classname">Provider</code></a>&lt;T&gt;</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/provider/Property.html" target="_top"><code class="classname">Property</code></a>&lt;T&gt;</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/api/model/ObjectFactory.html#property-java.lang.Class-" target="_top"><code class="classname">ObjectFactory.property(java.lang.Class)</code></a></p></li></ul></div></td>
</tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="init_scripts"></a>Initialization Scripts</h1></div></div></div><p>Gradle provides a powerful mechanism to allow customizing the build based on the current environment. This mechanism also supports tools that wish to integrate with Gradle.</p><p>Note that this is completely different from the &ldquo;<code class="literal">init</code>&rdquo; task provided by the &ldquo;<code class="literal">build-init</code>&rdquo; incubating plugin (see <a class="xref" href="#build_init_plugin"><i>Build Init Plugin</i></a>).</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:basic_usage" class="section-anchor" href="#sec:basic_usage"></a>Basic usage</h2></div></div></div><p>Initialization scripts (a.k.a. <span class="emphasis"><em>init scripts</em></span>) are similar to other scripts in Gradle. These scripts, however, are run before the build starts. Here are several possible uses:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Set up enterprise-wide configuration, such as where to find custom plugins.</p></li><li class="listitem"><p>Set up properties based on the current environment, such as a developer&rsquo;s machine vs. a continuous integration server.</p></li><li class="listitem"><p>Supply personal information about the user that is required by the build, such as repository or database authentication credentials.</p></li><li class="listitem"><p>Define machine specific details, such as where JDKs are installed.</p></li><li class="listitem"><p>Register build listeners. External tools that wish to listen to Gradle events might find this useful.</p></li><li class="listitem"><p>Register build loggers. You might wish to customize how Gradle logs the events that it generates.</p></li></ul></div><p>One main limitation of init scripts is that they cannot access classes in the <code class="literal">buildSrc</code> project (see <a class="xref" href="#sec:build_sources">the section called &ldquo;Build sources in the <code class="literal">buildSrc</code> project&rdquo;</a> for details of this feature).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_an_init_script" class="section-anchor" href="#sec:using_an_init_script"></a>Using an init script</h2></div></div></div><p>There are several ways to use an init script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Specify a file on the command line. The command line option is <code class="literal">-I</code> or <code class="literal">--init-script</code> followed by the path to the script. The command line option can appear more than once, each time adding another init script.</p></li><li class="listitem"><p>Put a file called <code class="literal">init.gradle</code> in the <code class="literal"><span class="emphasis"><em>USER_HOME</em></span>/.gradle/</code> directory.</p></li><li class="listitem"><p>Put a file that ends with <code class="literal">.gradle</code> in the <code class="literal"><span class="emphasis"><em>USER_HOME</em></span>/.gradle/init.d/</code> directory.</p></li><li class="listitem"><p>Put a file that ends with <code class="literal">.gradle</code> in the <code class="literal"><span class="emphasis"><em>GRADLE_HOME</em></span>/init.d/</code> directory, in the Gradle distribution. This allows you to package up a custom Gradle distribution containing some custom build logic and plugins. You can combine this with the <a class="link" href="#gradle_wrapper">Gradle wrapper</a> as a way to make custom logic available to all builds in your enterprise.</p></li></ul></div><p>If more than one init script is found they will all be executed, in the order specified above. Scripts in a given directory are executed in alphabetical order. This allows, for example, a tool to specify an init script on the command line and the user to put one in their home directory for defining the environment and both scripts will run when Gradle is executed.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:writing_an_init_script" class="section-anchor" href="#sec:writing_an_init_script"></a>Writing an init script</h2></div></div></div><p>Similar to a Gradle build script, an init script is a Groovy script. Each init script has a <a class="ulink" href="../dsl/org.gradle.api.invocation.Gradle.html" target="_top"><code class="classname">Gradle</code></a> instance associated with it. Any property reference and method call in the init script will delegate to this <code class="literal">Gradle</code> instance.</p><p>Each init script also implements the <a class="ulink" href="../dsl/org.gradle.api.Script.html" target="_top"><code class="classname">Script</code></a> interface.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuring_projects_from_an_init_script" class="section-anchor" href="#sec:configuring_projects_from_an_init_script"></a>Configuring projects from an init script</h3></div></div></div><p>You can use an init script to configure the projects in the build. This works in a similar way to configuring projects in a multi-project build. The following sample shows how to perform extra configuration from an init script <span class="emphasis"><em>before</em></span> the projects are evaluated. This sample uses this feature to configure an extra repository to be used only for certain environments.</p><div class="example"><a name="initScriptConfiguration"></a><p class="title"><b>Example&nbsp;369.&nbsp;Using init script to perform extra configuration before projects are evaluated</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

task showRepos {
    doLast {
        println <span class="hl-string">"All repos:"</span>
        println repositories.collect { it.name }
    }
}
</pre><p><code class="filename">init.gradle</code></p><pre class="programlisting">allprojects {
    repositories {
        mavenLocal()
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle --init-script init.gradle -q showRepos</code></strong></p><pre class="screen">&gt; gradle --init-script init.gradle -q showRepos
All repos:
[MavenLocal, MavenRepo]</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:custom_classpath" class="section-anchor" href="#sec:custom_classpath"></a>External dependencies for the init script</h2></div></div></div><p>In <a class="xref" href="#sec:build_script_external_dependencies">the section called &ldquo;External dependencies for the build script&rdquo;</a> it was explained how to add external dependencies to a build script. Init scripts can also declare dependencies. You do this with the <code class="literal">initscript()</code> method, passing in a closure which declares the init script classpath.</p><div class="example"><a name="declareExternalInitDependency"></a><p class="title"><b>Example&nbsp;370.&nbsp;Declaring external dependencies for an init script</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting">initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: <span class="hl-string">'org.apache.commons'</span>, name: <span class="hl-string">'commons-math'</span>, version: <span class="hl-string">'2.0'</span>
    }
}
</pre></div></div><br class="example-break"><p>The closure passed to the <code class="literal">initscript()</code> method configures a <a class="ulink" href="../javadoc/org/gradle/api/initialization/dsl/ScriptHandler.html" target="_top"><code class="classname">ScriptHandler</code></a> instance. You declare the init script classpath by adding dependencies to the <code class="literal">classpath</code> configuration. This is the same way you declare, for example, the Java compilation classpath. You can use any of the dependency types described in <a class="xref" href="#sec:declaring_dependencies">the section called &ldquo;Declaring dependencies&rdquo;</a>, except project dependencies.</p><p>Having declared the init script classpath, you can use the classes in your init script as you would any other classes on the classpath. The following example adds to the previous example, and uses classes from the init script classpath.</p><div class="example"><a name="externalInitDependency"></a><p class="title"><b>Example&nbsp;371.&nbsp;An init script with external dependencies</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.apache.commons.math.fraction.Fraction

initscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath group: <span class="hl-string">'org.apache.commons'</span>, name: <span class="hl-string">'commons-math'</span>, version: <span class="hl-string">'2.0'</span>
    }
}

println Fraction.ONE_FIFTH.multiply(<span class="hl-number">2</span>)
</pre><p>Output of <strong class="userinput"><code>gradle --init-script init.gradle -q doNothing</code></strong></p><pre class="screen">&gt; gradle --init-script init.gradle -q doNothing
2 / 5
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:init_script_plugins" class="section-anchor" href="#sec:init_script_plugins"></a>Init script plugins</h2></div></div></div><p>Similar to a Gradle build script or a Gradle settings file, plugins can be applied on init scripts.</p><div class="example"><a name="usePluginsInInitScripts"></a><p class="title"><b>Example&nbsp;372.&nbsp;Using plugins in init scripts</b></p><div class="example-contents"><p><code class="filename">init.gradle</code></p><pre class="programlisting">
apply plugin:EnterpriseRepositoryPlugin

<span class="hl-keyword">class</span> EnterpriseRepositoryPlugin <span class="hl-keyword">implements</span> Plugin&lt;Gradle&gt; {

    <span class="hl-keyword">private</span> <span class="hl-keyword">static</span> String ENTERPRISE_REPOSITORY_URL = <span class="hl-string">"https://repo.gradle.org/gradle/repo"</span>

    <span class="hl-keyword">void</span> apply(Gradle gradle) {
        <span class="hl-comment">// ONLY USE ENTERPRISE REPO FOR DEPENDENCIES</span>
        gradle.allprojects{ project -&gt;
            project.repositories {

                <span class="hl-comment">// Remove all repositories not pointing to the enterprise repository url</span>
                all { ArtifactRepository repo -&gt;
                    <span class="hl-keyword">if</span> (!(repo <span class="hl-keyword">instanceof</span> MavenArtifactRepository) ||
                          repo.url.toString() != ENTERPRISE_REPOSITORY_URL) {
                        project.logger.lifecycle <span class="hl-string">"Repository ${repo.url} removed. Only $ENTERPRISE_REPOSITORY_URL is allowed"</span>
                        remove repo
                    }
                }

                <span class="hl-comment">// add the enterprise repository</span>
                maven {
                    name <span class="hl-string">"STANDARD_ENTERPRISE_REPO"</span>
                    url ENTERPRISE_REPOSITORY_URL
                }
            }
        }
    }
}
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories{
    mavenCentral()
}

 task showRepositories {
     doLast {
         repositories.each {
             println <span class="hl-string">"repository: ${it.name} ('${it.url}')"</span>
         }
     }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q -I init.gradle showRepositories</code></strong></p><pre class="screen">&gt; gradle -q -I init.gradle showRepositories
repository: STANDARD_ENTERPRISE_REPO ('https://repo.gradle.org/gradle/repo')</pre></div></div><br class="example-break"><p>The plugin in the init script ensures that only a specified repository is used when running the build.</p><p>When applying plugins within the init script, Gradle instantiates the plugin and calls the plugin instance&rsquo;s <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html#apply-T-" target="_top"><code class="classname">Plugin.apply(T)</code></a> method. The <code class="literal">gradle</code> object is passed as a parameter, which can be used to configure all aspects of a build. Of course, the applied plugin can be resolved as an external dependency as described in <a class="xref" href="#sec:custom_classpath">the section called &ldquo;External dependencies for the init script&rdquo;</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="test_kit"></a>Testing Build Logic with TestKit</h1></div></div></div><div class="note"><p>The Gradle TestKit is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that its API and other characteristics may change in later Gradle versions.</p></div><p>The Gradle TestKit (a.k.a. just TestKit) is a library that aids in testing Gradle plugins and build logic generally. At this time, it is focused on <span class="emphasis"><em>functional</em></span> testing. That is, testing build logic by exercising it as part of a programmatically executed build. Over time, the TestKit will likely expand to facilitate other kinds of tests.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:testkit_usage" class="section-anchor" href="#sec:testkit_usage"></a>Usage</h2></div></div></div><p>To use the TestKit, include the following in your plugin&rsquo;s build:</p><div class="example"><a name="testKitDependency"></a><p class="title"><b>Example&nbsp;373.&nbsp;Declaring the TestKit dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    testCompile gradleTestKit()
}
</pre></div></div><br class="example-break"><p>The <code class="literal">gradleTestKit()</code> encompasses the classes of the TestKit, as well as the <a class="link" href="#embedding">Gradle Tooling API client</a>. It does not include a version of <a class="ulink" href="http://junit.org" target="_top">JUnit</a>, <a class="ulink" href="http://testng.org" target="_top">TestNG</a>, or any other test execution framework. Such a dependency must be explicitly declared.</p><div class="example"><a name="junitDependency"></a><p class="title"><b>Example&nbsp;374.&nbsp;Declaring the JUnit dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    testCompile <span class="hl-string">'junit:junit:4.12'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:functional_testing_with_the_gradle_runner" class="section-anchor" href="#sec:functional_testing_with_the_gradle_runner"></a>Functional testing with the Gradle runner</h2></div></div></div><p>The <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html" target="_top"><code class="classname">GradleRunner</code></a> facilitates programmatically executing Gradle builds, and inspecting the result.</p><p>A contrived build can be created (e.g. programmatically, or from a template) that exercises the &ldquo;logic under test&rdquo;. The build can then be executed, potentially in a variety of ways (e.g. different combinations of tasks and arguments). The correctness of the logic can then be verified by asserting the following, potentially in combination:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The build&rsquo;s output;</p></li><li class="listitem"><p>The build&rsquo;s logging (i.e. console output);</p></li><li class="listitem"><p>The set of tasks executed by the build and their results (e.g. FAILED, UP-TO-DATE etc.).</p></li></ul></div><p>After creating and configuring a runner instance, the build can be executed via the <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#build--" target="_top"><code class="classname">GradleRunner.build()</code></a> or <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#buildAndFail--" target="_top"><code class="classname">GradleRunner.buildAndFail()</code></a> methods depending on the anticipated outcome.</p><p>The following demonstrates the usage of Gradle runner in a Java JUnit test:</p><div class="example"><a name="testKitFunctionalTestJunit"></a><p class="title"><b>Example&nbsp;375.&nbsp;Using GradleRunner with JUnit</b></p><div class="example-contents"><p><code class="filename">BuildLogicFunctionalTest.java</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.gradle.testkit.runner.BuildResult;
<span class="hl-keyword">import</span> org.gradle.testkit.runner.GradleRunner;
<span class="hl-keyword">import</span> org.junit.Before;
<span class="hl-keyword">import</span> org.junit.Rule;
<span class="hl-keyword">import</span> org.junit.Test;
<span class="hl-keyword">import</span> org.junit.rules.TemporaryFolder;

<span class="hl-keyword">import</span> java.io.BufferedWriter;
<span class="hl-keyword">import</span> java.io.File;
<span class="hl-keyword">import</span> java.io.FileWriter;
<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> java.util.Collections;

<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertEquals;
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.assertTrue;

<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.gradle.testkit.runner.TaskOutcome.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> BuildLogicFunctionalTest {
    <span class="hl-annotation">@Rule</span> <span class="hl-keyword">public</span> <span class="hl-keyword">final</span> TemporaryFolder testProjectDir = <span class="hl-keyword">new</span> TemporaryFolder();
    <span class="hl-keyword">private</span> File buildFile;

    <span class="hl-annotation">@Before</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setup() <span class="hl-keyword">throws</span> IOException {
        buildFile = testProjectDir.newFile(<span class="hl-string">"build.gradle"</span>);
    }

    <span class="hl-annotation">@Test</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> testHelloWorldTask() <span class="hl-keyword">throws</span> IOException {
        String buildFileContent = <span class="hl-string">"task helloWorld {"</span> +
                                  <span class="hl-string">"    doLast {"</span> +
                                  <span class="hl-string">"        println 'Hello world!'"</span> +
                                  <span class="hl-string">"    }"</span> +
                                  <span class="hl-string">"}"</span>;
        writeFile(buildFile, buildFileContent);

        BuildResult result = GradleRunner.create()
            .withProjectDir(testProjectDir.getRoot())
            .withArguments(<span class="hl-string">"helloWorld"</span>)
            .build();

        assertTrue(result.getOutput().contains(<span class="hl-string">"Hello world!"</span>));
        assertEquals(SUCCESS, result.task(<span class="hl-string">":helloWorld"</span>).getOutcome());
    }

    <span class="hl-keyword">private</span> <span class="hl-keyword">void</span> writeFile(File destination, String content) <span class="hl-keyword">throws</span> IOException {
        BufferedWriter output = null;
        <span class="hl-keyword">try</span> {
            output = <span class="hl-keyword">new</span> BufferedWriter(<span class="hl-keyword">new</span> FileWriter(destination));
            output.write(content);
        } <span class="hl-keyword">finally</span> {
            <span class="hl-keyword">if</span> (output != null) {
                output.close();
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Any test execution framework can be used.</p><p>As Gradle build scripts are written in the Groovy programming language, and as many plugins are implemented in Groovy, it is often a productive choice to write Gradle functional tests in Groovy. Furthermore, it is recommended to use the (Groovy based) <a class="ulink" href="https://code.google.com/p/spock/" target="_top">Spock test execution framework</a> as it offers many compelling features over the use of JUnit.</p><p>The following demonstrates the usage of Gradle runner in a Groovy Spock test:</p><div class="example"><a name="testKitFunctionalTestSpock"></a><p class="title"><b>Example&nbsp;376.&nbsp;Using GradleRunner with Spock</b></p><div class="example-contents"><p><code class="filename">BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.gradle.testkit.runner.GradleRunner
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.gradle.testkit.runner.TaskOutcome.*
<span class="hl-keyword">import</span> org.junit.Rule
<span class="hl-keyword">import</span> org.junit.rules.TemporaryFolder
<span class="hl-keyword">import</span> spock.lang.Specification

<span class="hl-keyword">class</span> BuildLogicFunctionalTest <span class="hl-keyword">extends</span> Specification {
    <span class="hl-annotation">@Rule</span> <span class="hl-keyword">final</span> TemporaryFolder testProjectDir = <span class="hl-keyword">new</span> TemporaryFolder()
    File buildFile

    def setup() {
        buildFile = testProjectDir.newFile(<span class="hl-string">'build.gradle'</span>)
    }

    def <span class="hl-string">"hello world task prints hello world"</span>() {
        given:
        buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>            task helloWorld {
                doLast {
                    println <span class="hl-string">'Hello world!'</span>
                }
            }
        <span class="hl-string">""</span><span class="hl-string">"
</span>
        when:
        def result = GradleRunner.create()
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="hl-string">'helloWorld'</span>)
            .build()

        then:
        result.output.contains(<span class="hl-string">'Hello world!'</span>)
        result.task(<span class="hl-string">":helloWorld"</span>).outcome == SUCCESS
    }
}
</pre></div></div><br class="example-break"><p>It is a common practice to implement any custom build logic (like plugins and task types) that is more complex in nature as external classes in a standalone project. The main driver behind this approach is bundle the compiled code into a JAR file, publish it to a binary repository and reuse it across various projects.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:test-kit-classpath-injection" class="section-anchor" href="#sub:test-kit-classpath-injection"></a>Getting the plugin-under-test into the test build</h2></div></div></div><p>The GradleRunner uses the <a class="link" href="#embedding">Tooling API</a> to execute builds. An implication of this is that the builds are executed in a separate process (i.e. not the same process executing the tests). Therefore, the test build does not share the same classpath or classloaders as the test process and the code under test is not implicitly available to the test build.</p><p>Starting with version 2.13, Gradle provides a <a class="link" href="#sub:test-kit-automatic-classpath-injection">conventional mechanism to inject the code under test into the test build</a>.</p><p>For earlier versions of Gradle (before 2.13), it is possible to manually make the code under test available via some extra configuration. The following example demonstrates having the build generate a file containing the implementation classpath of the code under test, and making it available at test runtime.</p><div class="example"><a name="testKitFunctionalTestSpockClassesBuildConfig"></a><p class="title"><b>Example&nbsp;377.&nbsp;Making the code under test classpath available to the tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Write the plugin's classpath to a file to share with the tests</span>
task createClasspathManifest {
    def outputDir = file(<span class="hl-string">"$buildDir/$name"</span>)

    inputs.files sourceSets.main.runtimeClasspath
    outputs.dir outputDir

    doLast {
        outputDir.mkdirs()
        file(<span class="hl-string">"$outputDir/plugin-classpath.txt"</span>).text = sourceSets.main.runtimeClasspath.join(<span class="hl-string">"\n"</span>)
    }
}

<span class="hl-comment">// Add the classpath file to the test runtime classpath</span>
dependencies {
    testRuntime files(createClasspathManifest)
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/manualClasspathInjection</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>The tests can then read this value, and inject the classpath into the test build by using the method<a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-" target="_top"><code class="classname">GradleRunner.withPluginClasspath(java.lang.Iterable)</code></a>. This classpath is then available to use to locate plugins in a test build via the plugins DSL (see<a class="xref" href="#plugins"><i>Using Gradle Plugins</i></a>). Applying plugins with the plugins DSL requires the definition of a plugin identifier. The following is an example (in Groovy) of doing this from within a Spock Framework <code class="literal">setup()</code> method, which is analogous to a JUnit <code class="literal">@Before</code> method.</p><div class="example"><a name="testKitFunctionalTestSpockClassesTestConfig"></a><p class="title"><b>Example&nbsp;378.&nbsp;Injecting the code under test classes into test builds</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting">List&lt;File&gt; pluginClasspath

def setup() {
    buildFile = testProjectDir.newFile(<span class="hl-string">'build.gradle'</span>)

    def pluginClasspathResource = getClass().classLoader.findResource(<span class="hl-string">"plugin-classpath.txt"</span>)
    <span class="hl-keyword">if</span> (pluginClasspathResource == null) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalStateException(<span class="hl-string">"Did not find plugin classpath resource, run `testClasses` build task."</span>)
    }

    pluginClasspath = pluginClasspathResource.readLines().collect { <span class="hl-keyword">new</span> File(it) }
}

def <span class="hl-string">"hello world task prints hello world"</span>() {
    given:
    buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>        plugins {
            id <span class="hl-string">'org.gradle.sample.helloworld'</span>
        }
    <span class="hl-string">""</span><span class="hl-string">"
</span>
    when:
    def result = GradleRunner.create()
        .withProjectDir(testProjectDir.root)
        .withArguments(<span class="hl-string">'helloWorld'</span>)
        .withPluginClasspath(pluginClasspath)
        .build()

    then:
    result.output.contains(<span class="hl-string">'Hello world!'</span>)
    result.task(<span class="hl-string">":helloWorld"</span>).outcome == SUCCESS
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/manualClasspathInjection</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>This approach works well when executing the functional tests as part of the Gradle build. When executing the functional tests from an IDE, there are extra considerations. Namely, the classpath manifest file points to the class files etc. generated by Gradle and not the IDE. This means that after making a change to the source of the code under test, the source must be recompiled by Gradle. Similarly, if the effective classpath of the code under test changes, the manifest must be regenerated. In either case, executing the <code class="literal">testClasses</code> task of the build will ensure that things are up to date.</p><p>Some IDEs provide a convenience option to delegate the "test classpath generation and execution" to the build. In IntelliJ you can find this option under Preferences&hellip; &gt; Build, Execution, Deployment &gt; Build Tools &gt; Gradle &gt; Runner &gt; Delegate IDE build/run actions to gradle. Please consult the documentation of your IDE for more information.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:working_with_gradle_versions_prior_to_28" class="section-anchor" href="#sec:working_with_gradle_versions_prior_to_28"></a>Working with Gradle versions prior to 2.8</h3></div></div></div><p>The <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-" target="_top"><code class="classname">GradleRunner.withPluginClasspath(java.lang.Iterable)</code></a> method will not work when executing the build with a Gradle version earlier than 2.8 (see:<a class="xref" href="#sub:gradle-runner-gradle-version">the section called &ldquo;The Gradle version used to test&rdquo;</a>), as this feature is not supported on such Gradle versions.</p><p>Instead, the code must be injected via the build script itself. The following sample demonstrates how this can be done.</p><div class="example"><a name="testKitFunctionalTestSpockClassesTestConfigGradleVersionPrior2Dot8"></a><p class="title"><b>Example&nbsp;379.&nbsp;Injecting the code under test classes into test builds for Gradle versions prior to 2.8</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting">List&lt;File&gt; pluginClasspath

def setup() {
    buildFile = testProjectDir.newFile(<span class="hl-string">'build.gradle'</span>)

    def pluginClasspathResource = getClass().classLoader.findResource(<span class="hl-string">"plugin-classpath.txt"</span>)
    <span class="hl-keyword">if</span> (pluginClasspathResource == null) {
        <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> IllegalStateException(<span class="hl-string">"Did not find plugin classpath resource, run `testClasses` build task."</span>)
    }

    pluginClasspath = pluginClasspathResource.readLines().collect { <span class="hl-keyword">new</span> File(it) }
}

def <span class="hl-string">"hello world task prints hello world with pre Gradle 2.8"</span>() {
    given:
    def classpathString = pluginClasspath
        .collect { it.absolutePath.replace(<span class="hl-string">'\\'</span>, <span class="hl-string">'\\\\'</span>) } <span class="hl-comment">// escape backslashes in Windows paths</span>
        .collect { <span class="hl-string">"'$it'"</span> }
        .join(<span class="hl-string">", "</span>)

    buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>        buildscript {
            dependencies {
                classpath files($classpathString)
            }
        }
        apply plugin: <span class="hl-string">"org.gradle.sample.helloworld"</span>
    <span class="hl-string">""</span><span class="hl-string">"
</span>
    when:
    def result = GradleRunner.create()
        .withProjectDir(testProjectDir.root)
        .withArguments(<span class="hl-string">'helloWorld'</span>)
        .withGradleVersion(<span class="hl-string">"2.7"</span>)
        .build()

    then:
    result.output.contains(<span class="hl-string">'Hello world!'</span>)
    result.task(<span class="hl-string">":helloWorld"</span>).outcome == SUCCESS
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/manualClasspathInjection</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:test-kit-automatic-classpath-injection" class="section-anchor" href="#sub:test-kit-automatic-classpath-injection"></a>Automatic injection with the Java Gradle Plugin Development plugin</h3></div></div></div><p>The <a class="link" href="#">Java Gradle Plugin development plugin</a> can be used to assist in the development of Gradle plugins. Starting with Gradle version 2.13, the plugin provides a direct integration with TestKit. When applied to a project, the plugin automatically adds the <code class="literal">gradleTestKit()</code> dependency to the test compile configuration. Furthermore, it automatically generates the classpath for the code under test and injects it via <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--" target="_top"><code class="classname">GradleRunner.withPluginClasspath()</code></a> for any <code class="literal">GradleRunner</code> instance created by the user. It&rsquo;s important to note that the mechanism currently <span class="emphasis"><em>only</em></span> works if the plugin under test is applied using the <a class="link" href="#sec:plugins_block">plugins DSL</a>. If the <a class="link" href="#sub:gradle-runner-gradle-version">target Gradle version</a> is prior to 2.8, automatic plugin classpath injection is not performed.</p><p>The plugin uses the following conventions for applying the TestKit dependency and injecting the classpath:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Source set containing code under test: <code class="literal">sourceSets.main</code></p></li><li class="listitem"><p>Source set used for injecting the plugin classpath: <code class="literal">sourceSets.test</code></p></li></ul></div><p>Any of these conventions can be reconfigured with the help of the class<a class="ulink" href="../javadoc/org/gradle/plugin/devel/GradlePluginDevelopmentExtension.html" target="_top"><code class="classname">GradlePluginDevelopmentExtension</code></a>.</p><p>The following Groovy-based sample demonstrates how to automatically inject the plugin classpath by using the standard conventions applied by the Java Gradle Plugin Development plugin.</p><div class="example"><a name="testKitFunctionalTestSpockAutomaticClasspath"></a><p class="title"><b>Example&nbsp;380.&nbsp;Using the Java Gradle Development plugin for generating the plugin metadata</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>
apply plugin: <span class="hl-string">'java-gradle-plugin'</span>

dependencies {
    testCompile(<span class="hl-string">'org.spockframework:spock-core:1.0-groovy-2.4'</span>) {
        exclude module: <span class="hl-string">'groovy-all'</span>
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/automaticClasspathInjectionQuickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="example"><a name="testKitFunctionalTestSpockAutomaticClassesTestConfig"></a><p class="title"><b>Example&nbsp;381.&nbsp;Automatically injecting the code under test classes into test builds</b></p><div class="example-contents"><p><code class="filename">src/test/groovy/org/gradle/sample/BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting">def <span class="hl-string">"hello world task prints hello world"</span>() {
    given:
    buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>        plugins {
            id <span class="hl-string">'org.gradle.sample.helloworld'</span>
        }
    <span class="hl-string">""</span><span class="hl-string">"
</span>
    when:
    def result = GradleRunner.create()
        .withProjectDir(testProjectDir.root)
        .withArguments(<span class="hl-string">'helloWorld'</span>)
        .withPluginClasspath()
        .build()

    then:
    result.output.contains(<span class="hl-string">'Hello world!'</span>)
    result.task(<span class="hl-string">":helloWorld"</span>).outcome == SUCCESS
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/automaticClasspathInjectionQuickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>The following build script demonstrates how to reconfigure the conventions provided by the Java Gradle Plugin Development plugin for a project that uses a custom <code class="literal">Test</code> source set.</p><div class="example"><a name="testKitFunctionalTestSpockAutomaticClasspath"></a><p class="title"><b>Example&nbsp;382.&nbsp;Reconfiguring the classpath generation conventions of the Java Gradle Development plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>
apply plugin: <span class="hl-string">'java-gradle-plugin'</span>

sourceSets {
    functionalTest {
        groovy {
            srcDir file(<span class="hl-string">'src/functionalTest/groovy'</span>)
        }
        resources {
            srcDir file(<span class="hl-string">'src/functionalTest/resources'</span>)
        }
        compileClasspath += sourceSets.main.output + configurations.testRuntime
        runtimeClasspath += output + compileClasspath
    }
}

task functionalTest(type: Test) {
    testClassesDirs = sourceSets.functionalTest.output.classesDirs
    classpath = sourceSets.functionalTest.runtimeClasspath
}

check.dependsOn functionalTest

gradlePlugin {
    testSourceSets sourceSets.functionalTest
}

dependencies {
    functionalTestCompile(<span class="hl-string">'org.spockframework:spock-core:1.0-groovy-2.4'</span>) {
        exclude module: <span class="hl-string">'groovy-all'</span>
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testKit/gradleRunner/automaticClasspathInjectionCustomTestSourceSet</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:controlling_the_build_environment" class="section-anchor" href="#sec:controlling_the_build_environment"></a>Controlling the build environment</h2></div></div></div><p>The runner executes the test builds in an isolated environment by specifying a dedicated "working directory" in a directory inside the JVM&rsquo;s temp directory (i.e. the location specified by the <code class="literal">java.io.tmpdir</code> system property, typically <code class="literal">/tmp</code>). Any configuration in the default Gradle user home directory (e.g. <code class="literal">~/.gradle/gradle.properties</code>) is not used for test execution. The TestKit does not expose a mechanism for fine grained control of environment variables etc. Future versions of the TestKit will provide improved configuration options.</p><p>The TestKit uses dedicated daemon processes that are automatically shut down after test execution.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:gradle-runner-gradle-version" class="section-anchor" href="#sub:gradle-runner-gradle-version"></a>The Gradle version used to test</h2></div></div></div><p>The Gradle runner requires a Gradle distribution in order to execute the build. The TestKit does not depend on all of Gradle&rsquo;s implementation.</p><p>By default, the runner will attempt to find a Gradle distribution based on where the <code class="literal">GradleRunner</code> class was loaded from. That is, it is expected that the class was loaded from a Gradle distribution, as is the case when using the <code class="literal">gradleTestKit()</code> dependency declaration.</p><p>When using the runner as part of tests <span class="emphasis"><em>being executed by Gradle</em></span> (e.g. executing the <code class="literal">test</code> task of a plugin project), the same distribution used to execute the tests will be used by the runner. When using the runner as part of tests <span class="emphasis"><em>being executed by an IDE</em></span>, the same distribution of Gradle that was used when importing the project will be used. This means that the plugin will effectively be tested with the same version of Gradle that it is being built with.</p><p>Alternatively, a different and specific version of Gradle to use can be specified by the any of the following <code class="literal">GradleRunner</code> methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleVersion-java.lang.String-" target="_top"><code class="classname">GradleRunner.withGradleVersion(java.lang.String)</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleInstallation-java.io.File-" target="_top"><code class="classname">GradleRunner.withGradleInstallation(java.io.File)</code></a></p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withGradleDistribution-java.net.URI-" target="_top"><code class="classname">GradleRunner.withGradleDistribution(java.net.URI)</code></a></p></li></ul></div><p>This can potentially be used to test build logic across Gradle versions. The following demonstrates a cross-version compatibility test written as Groovy Spock test:</p><div class="example"><a name="testKitFunctionalTestSpockGradleDistribution"></a><p class="title"><b>Example&nbsp;383.&nbsp;Specifying a Gradle version for test execution</b></p><div class="example-contents"><p><code class="filename">BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting"><span class="hl-keyword">import</span> org.gradle.testkit.runner.GradleRunner
<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.gradle.testkit.runner.TaskOutcome.*
<span class="hl-keyword">import</span> org.junit.Rule
<span class="hl-keyword">import</span> org.junit.rules.TemporaryFolder
<span class="hl-keyword">import</span> spock.lang.Specification
<span class="hl-keyword">import</span> spock.lang.Unroll

<span class="hl-keyword">class</span> BuildLogicFunctionalTest <span class="hl-keyword">extends</span> Specification {
    <span class="hl-annotation">@Rule</span> <span class="hl-keyword">final</span> TemporaryFolder testProjectDir = <span class="hl-keyword">new</span> TemporaryFolder()
    File buildFile

    def setup() {
        buildFile = testProjectDir.newFile(<span class="hl-string">'build.gradle'</span>)
    }

    <span class="hl-annotation">@Unroll</span>
    def <span class="hl-string">"can execute hello world task with Gradle version #gradleVersion"</span>() {
        given:
        buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>            task helloWorld {
                doLast {
                    logger.quiet <span class="hl-string">'Hello world!'</span>
                }
            }
        <span class="hl-string">""</span><span class="hl-string">"
</span>
        when:
        def result = GradleRunner.create()
            .withGradleVersion(gradleVersion)
            .withProjectDir(testProjectDir.root)
            .withArguments(<span class="hl-string">'helloWorld'</span>)
            .build()

        then:
        result.output.contains(<span class="hl-string">'Hello world!'</span>)
        result.task(<span class="hl-string">":helloWorld"</span>).outcome == SUCCESS

        where:
        gradleVersion &lt;&lt; [<span class="hl-string">'2.6'</span>, <span class="hl-string">'2.7'</span>]
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:test-kit-compatibility" class="section-anchor" href="#sub:test-kit-compatibility"></a>Feature support when testing with different Gradle versions</h3></div></div></div><p>It is possible to use the GradleRunner to execute builds with Gradle 1.0 and later. However, some runner features are not supported on earlier versions. In such cases, the runner will throw an exception when attempting to use the feature.</p><p>The following table lists the features that are sensitive to the Gradle version being used.</p><div class="table"><p class="title"><b>Table&nbsp;35.&nbsp;Gradle version compatibility</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N165BA"><thead><tr>
<td>Feature</td>
<td>Minimum Version</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>&lt;link&gt;Inspecting executed tasks&lt;/link&gt;</p></td>
<td><p>2.5</p></td>
<td><p>Inspecting the executed tasks, using <a class="ulink" href="../javadoc/org/gradle/testkit/runner/BuildResult.html#getTasks--" target="_top"><code class="classname">BuildResult.getTasks()</code></a> and similar methods.</p></td>
</tr><tr>
<td><p><a class="link" href="#sub:test-kit-classpath-injection">Plugin classpath injection</a></p></td>
<td><p>2.8</p></td>
<td><p>Injecting the code under test via<a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath-java.lang.Iterable-" target="_top"><code class="classname">GradleRunner.withPluginClasspath(java.lang.Iterable)</code></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#sub:test-kit-debug">Inspecting build output in debug mode</a></p></td>
<td><p>2.9</p></td>
<td><p>Inspecting the build&rsquo;s text output when run in debug mode, using <a class="ulink" href="../javadoc/org/gradle/testkit/runner/BuildResult.html#getOutput--" target="_top"><code class="classname">BuildResult.getOutput()</code></a>.</p></td>
</tr><tr>
<td><p><a class="link" href="#sub:test-kit-automatic-classpath-injection">Automatic plugin classpath injection</a></p></td>
<td><p>2.13</p></td>
<td><p>Injecting the code under test automatically via <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withPluginClasspath--" target="_top"><code class="classname">GradleRunner.withPluginClasspath()</code></a> by applying the Java Gradle Plugin Development plugin.</p></td>
</tr></tbody></table></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:test-kit-debug" class="section-anchor" href="#sub:test-kit-debug"></a>Debugging build logic</h2></div></div></div><p>The runner uses the <a class="link" href="#embedding">Tooling API</a> to execute builds. An implication of this is that the builds are executed in a separate process (i.e. not the same process executing the tests). Therefore, executing your <span class="emphasis"><em>tests</em></span> in debug mode does not allow you to debug your build logic as you may expect. Any breakpoints set in your IDE will be not be tripped by the code being exercised by the test build.</p><p>The TestKit provides two different ways to enable the debug mode:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Setting &ldquo;<code class="literal">org.gradle.testkit.debug</code>&rdquo; system property to <code class="literal">true</code> for the JVM <span class="emphasis"><em>using</em></span> the <code class="literal">GradleRunner</code> (i.e. not the build being executed with the runner);</p></li><li class="listitem"><p>Calling the <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html#withDebug-boolean-" target="_top"><code class="classname">GradleRunner.withDebug(boolean)</code></a> method.</p></li></ul></div><p>The system property approach can be used when it is desirable to enable debugging support without making an adhoc change to the runner configuration. Most IDEs offer the capability to set JVM system properties for test execution, and such a feature can be used to set this system property.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:test-kit-build-cache" class="section-anchor" href="#sub:test-kit-build-cache"></a>Testing with the Build Cache</h2></div></div></div><p>To enable the <a class="link" href="#build_cache">Build Cache</a> in your tests, you can pass the <code class="literal">--build-cache</code> argument to <a class="ulink" href="../javadoc/org/gradle/testkit/runner/GradleRunner.html" target="_top"><code class="classname">GradleRunner</code></a> or use one of the other methods described in <a class="xref" href="#sec:build_cache_enable">the section called &ldquo;Enable the Build Cache&rdquo;</a>. You can then check for the task outcome <a class="ulink" href="../javadoc/org/gradle/testkit/runner/TaskOutcome.html#FROM_CACHE" target="_top"><code class="classname">TaskOutcome.FROM_CACHE</code></a> when your plugin&rsquo;s custom task is cached. This outcome is only valid for Gradle 3.5 and newer.</p><div class="example"><a name="testKitFunctionalTestSpockBuildCache"></a><p class="title"><b>Example&nbsp;384.&nbsp;Testing cacheable tasks</b></p><div class="example-contents"><p><code class="filename">BuildLogicFunctionalTest.groovy</code></p><pre class="programlisting">def <span class="hl-string">"cacheableTask is loaded from cache"</span>() {
    given:
    buildFile &lt;&lt; <span class="hl-string">""</span><span class="hl-string">"
</span>        plugins {
            id <span class="hl-string">'org.gradle.sample.helloworld'</span>
        }
    <span class="hl-string">""</span><span class="hl-string">"
</span>
    when:
    def result = runner()
        .withArguments( <span class="hl-string">'--build-cache'</span>, <span class="hl-string">'cacheableTask'</span>)
        .build()

    then:
    result.task(<span class="hl-string">":cacheableTask"</span>).outcome == SUCCESS

    when:
    <span class="hl-keyword">new</span> File(testProjectDir.root, <span class="hl-string">'build'</span>).deleteDir()
    result = runner()
        .withArguments( <span class="hl-string">'--build-cache'</span>, <span class="hl-string">'cacheableTask'</span>)
        .build()

    then:
    result.task(<span class="hl-string">":cacheableTask"</span>).outcome == FROM_CACHE
}
</pre></div></div><br class="example-break"></div></div></div><div class="part" title="Building JVM projects"><div class="titlepage"><div><div><h1 class="title"><a name="N1666C"></a>Building JVM projects</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="tutorial_java_projects"></a>Java Quickstart</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:the_java_plugin" class="section-anchor" href="#sec:the_java_plugin"></a>The Java plugin</h2></div></div></div><p>As we have seen, Gradle is a general-purpose build tool. It can build pretty much anything you care to implement in your build script. Out-of-the-box, however, it doesn&rsquo;t build anything unless you add code to your build script to do so.</p><p>Most Java projects are pretty similar as far as the basics go: you need to compile your Java source files, run some unit tests, and create a JAR file containing your classes. It would be nice if you didn&rsquo;t have to code all this up for every project. Luckily, you don&rsquo;t have to. Gradle solves this problem through the use of <span class="emphasis"><em>plugins</em></span>. A plugin is an extension to Gradle which configures your project in some way, typically by adding some pre-configured tasks which together do something useful. Gradle ships with a number of plugins, and you can easily write your own and share them with others. One such plugin is the <span class="emphasis"><em>Java plugin</em></span>. This plugin adds some tasks to your project which will compile and unit test your Java source code, and bundle it into a JAR file.</p><p>The Java plugin is convention based. This means that the plugin defines default values for many aspects of the project, such as where the Java source files are located. If you follow the convention in your project, you generally don&rsquo;t need to do much in your build script to get a useful build. Gradle allows you to customize your project if you don&rsquo;t want to or cannot follow the convention in some way. In fact, because support for Java projects is implemented as a plugin, you don&rsquo;t have to use the plugin at all to build a Java project, if you don&rsquo;t want to.</p><p>We have in-depth coverage with many examples about the Java plugin, dependency management and multi-project builds in later chapters. In this chapter we want to give you an initial idea of how to use the Java plugin to build a Java project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:a_basic_java_project" class="section-anchor" href="#sec:a_basic_java_project"></a>A basic Java project</h2></div></div></div><p>Let&rsquo;s look at a simple example. To use the Java plugin, add the following to your build file:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;385.&nbsp;Using the Java plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/java/quickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>This is all you need to define a Java project. This will apply the Java plugin to your project, which adds a number of tasks to your project.</p><div class="tip"><h3 class="title">What tasks are available?</h3><p>You can use <code class="literal">gradle tasks</code> to list the tasks of a project. This will let you see the tasks that the Java plugin has added to your project.</p></div><p>Gradle expects to find your production source code under <code class="literal">src/main/java</code> and your test source code under <code class="literal">src/test/java</code>. In addition, any files under <code class="literal">src/main/resources</code> will be included in the JAR file as resources, and any files under <code class="literal">src/test/resources</code> will be included in the classpath used to run the tests. All output files are created under the <code class="literal">build</code> directory, with the JAR file ending up in the <code class="literal">build/libs</code> directory.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:building_the_project" class="section-anchor" href="#sec:building_the_project"></a>Building the project</h3></div></div></div><p>The Java plugin adds quite a few tasks to your project. However, there are only a handful of tasks that you will need to use to build the project. The most commonly used task is the <code class="literal">build</code> task, which does a full build of the project. When you run <code class="literal">gradle build</code>, Gradle will compile and test your code, and create a JAR file containing your main classes and resources:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;386.&nbsp;Building a Java project</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle build</code></strong></p><pre class="screen">&gt; gradle build
:compileJava
:processResources
:classes
:jar
:assemble
:compileTestJava
:processTestResources
:testClasses
:test
:check
:build

BUILD SUCCESSFUL in 0s
6 actionable tasks: 6 executed
</pre></div></div><br class="example-break"><p>Some other useful tasks are:</p><div class="variablelist"><dl><dt><span class="term">clean</span></dt><dd><p>Deletes the <code class="literal">build</code> directory, removing all built files.</p></dd><dt><span class="term">assemble</span></dt><dd><p>Compiles and jars your code, but does not run the unit tests. Other plugins add more artifacts to this task. For example, if you use the War plugin, this task will also build the WAR file for your project.</p></dd><dt><span class="term">check</span></dt><dd><p>Compiles and tests your code. Other plugins add more checks to this task. For example, if you use the <code class="literal">checkstyle</code> plugin, this task will also run Checkstyle against your source code.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:java_external_dependencies" class="section-anchor" href="#sec:java_external_dependencies"></a>External dependencies</h3></div></div></div><p>Usually, a Java project will have some dependencies on external JAR files. To reference these JAR files in the project, you need to tell Gradle where to find them. In Gradle, artifacts such as JAR files, are located in a <span class="emphasis"><em>repository</em></span>. A repository can be used for fetching the dependencies of a project, or for publishing the artifacts of a project, or both. For this example, we will use the public Maven repository:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;387.&nbsp;Adding Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}
</pre></div></div><br class="example-break"><p>Let&rsquo;s add some dependencies. Here, we will declare that our production classes have a compile-time dependency on commons collections, and that our test classes have a compile-time dependency on junit:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;388.&nbsp;Adding dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile group: <span class="hl-string">'commons-collections'</span>, name: <span class="hl-string">'commons-collections'</span>, version: <span class="hl-string">'3.2.2'</span>
    testCompile group: <span class="hl-string">'junit'</span>, name: <span class="hl-string">'junit'</span>, version: <span class="hl-string">'4.+'</span>
}
</pre></div></div><br class="example-break"><p>You can find out more in <a class="xref" href="#artifact_dependencies_tutorial"><i>Dependency Management for Java Projects</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:customizing_the_project" class="section-anchor" href="#sec:customizing_the_project"></a>Customizing the project</h3></div></div></div><p>The Java plugin adds a number of properties to your project. These properties have default values which are usually sufficient to get started. It&rsquo;s easy to change these values if they don&rsquo;t suit. Let&rsquo;s look at this for our sample. Here we will specify the version number for our Java project, along with the Java version our source is written in. We also add some attributes to the JAR manifest.</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;389.&nbsp;Customization of MANIFEST.MF</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceCompatibility = <span class="hl-number">1.7</span>
version = <span class="hl-string">'1.0'</span>
jar {
    manifest {
        attributes <span class="hl-string">'Implementation-Title'</span>: <span class="hl-string">'Gradle Quickstart'</span>,
                   <span class="hl-string">'Implementation-Version'</span>: version
    }
}
</pre></div></div><br class="example-break"><div class="tip"><h3 class="title">What properties are available?</h3><p>You can use <code class="literal">gradle properties</code> to list the properties of a project. This will allow you to see the properties added by the Java plugin, and their default values.</p></div><p>The tasks which the Java plugin adds are regular tasks, exactly the same as if they were declared in the build file. This means you can use any of the mechanisms shown in earlier chapters to customize these tasks. For example, you can set the properties of a task, add behaviour to a task, change the dependencies of a task, or replace a task entirely. In our sample, we will configure the <code class="literal">test</code> task, which is of type <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a>, to add a system property when the tests are executed:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;390.&nbsp;Adding a test system property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    systemProperties <span class="hl-string">'property'</span>: <span class="hl-string">'value'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:publishing_the_jar_file" class="section-anchor" href="#sec:publishing_the_jar_file"></a>Publishing the JAR file</h3></div></div></div><p>Usually the JAR file needs to be published somewhere. To do this, you need to tell Gradle where to publish the JAR file. In Gradle, artifacts such as JAR files are published to repositories. In our sample, we will publish to a local directory. You can also publish to a remote location, or multiple locations.</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;391.&nbsp;Publishing the JAR file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">uploadArchives {
    repositories {
       flatDir {
           dirs <span class="hl-string">'repos'</span>
       }
    }
}
</pre></div></div><br class="example-break"><p>To publish the JAR file, run <code class="literal">gradle uploadArchives</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:creating_an_eclipse_project" class="section-anchor" href="#sec:creating_an_eclipse_project"></a>Creating an Eclipse project</h3></div></div></div><p>To create the Eclipse-specific descriptor files, like <code class="literal">.project</code>, you need to add another plugin to your build file:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;392.&nbsp;Eclipse plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'eclipse'</span>
</pre></div></div><br class="example-break"><p>Now execute <code class="literal">gradle eclipse</code> command to generate Eclipse project files. More information about the <code class="literal">eclipse</code> task can be found in <a class="xref" href="#eclipse_plugin"><i>The Eclipse Plugins</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:summary" class="section-anchor" href="#sec:summary"></a>Summary</h3></div></div></div><p>Here&rsquo;s the complete build file for our sample:</p><div class="example"><a name="javaQuickstart"></a><p class="title"><b>Example&nbsp;393.&nbsp;Java example - complete build file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
apply plugin: <span class="hl-string">'eclipse'</span>

sourceCompatibility = <span class="hl-number">1.7</span>
version = <span class="hl-string">'1.0'</span>
jar {
    manifest {
        attributes <span class="hl-string">'Implementation-Title'</span>: <span class="hl-string">'Gradle Quickstart'</span>,
                   <span class="hl-string">'Implementation-Version'</span>: version
    }
}

repositories {
    mavenCentral()
}

dependencies {
    compile group: <span class="hl-string">'commons-collections'</span>, name: <span class="hl-string">'commons-collections'</span>, version: <span class="hl-string">'3.2.2'</span>
    testCompile group: <span class="hl-string">'junit'</span>, name: <span class="hl-string">'junit'</span>, version: <span class="hl-string">'4.+'</span>
}

test {
    systemProperties <span class="hl-string">'property'</span>: <span class="hl-string">'value'</span>
}

uploadArchives {
    repositories {
       flatDir {
           dirs <span class="hl-string">'repos'</span>
       }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:examples" class="section-anchor" href="#sec:examples"></a>Multi-project Java build</h2></div></div></div><p>Now let&rsquo;s look at a typical multi-project build. Below is the layout for the project:</p><div class="example"><a name="javaMultiProject"></a><p class="title"><b>Example&nbsp;394.&nbsp;Multi-project build - hierarchical layout</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">multiproject/
  api/
  services/webservice/
  shared/
  services/shared/
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/java/multiproject</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>Here we have four projects. Project <code class="literal">api</code> produces a JAR file which is shipped to the client to provide them a Java client for your XML webservice. Project <code class="literal">webservice</code> is a webapp which returns XML. Project <code class="literal">shared</code> contains code used both by <code class="literal">api</code> and <code class="literal">webservice</code>. Project <code class="literal">services/shared</code> has code that depends on the <code class="literal">shared</code> project.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_a_multiproject_build" class="section-anchor" href="#sec:defining_a_multiproject_build"></a>Defining a multi-project build</h3></div></div></div><p>To define a multi-project build, you need to create a <span class="emphasis"><em>settings file</em></span>. The settings file lives in the root directory of the source tree, and specifies which projects to include in the build. It must be called <code class="literal">settings.gradle</code>. For this example, we are using a simple hierarchical layout. Here is the corresponding settings file:</p><div class="example"><a name="javaMultiProject"></a><p class="title"><b>Example&nbsp;395.&nbsp;Multi-project build - settings.gradle file</b></p><div class="example-contents"><p><code class="filename">settings.gradle</code></p><pre class="programlisting">include <span class="hl-string">"shared"</span>, <span class="hl-string">"api"</span>, <span class="hl-string">"services:webservice"</span>, <span class="hl-string">"services:shared"</span>
</pre></div></div><br class="example-break"><p>You can find out more about the settings file in <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:common_configuration" class="section-anchor" href="#sec:common_configuration"></a>Common configuration</h3></div></div></div><p>For most multi-project builds, there is some configuration which is common to all projects. In our sample, we will define this common configuration in the root project, using a technique called <span class="emphasis"><em>configuration injection</em></span>. Here, the root project is like a container and the <code class="literal">subprojects</code> method iterates over the elements of this container - the projects in this instance - and injects the specified configuration. This way we can easily define the manifest content for all archives, and some common dependencies:</p><div class="example"><a name="javaMultiProject"></a><p class="title"><b>Example&nbsp;396.&nbsp;Multi-project build - common configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    apply plugin: <span class="hl-string">'java'</span>
    apply plugin: <span class="hl-string">'eclipse-wtp'</span>

    repositories {
       mavenCentral()
    }

    dependencies {
        testCompile <span class="hl-string">'junit:junit:4.12'</span>
    }

    version = <span class="hl-string">'1.0'</span>

    jar {
        manifest.attributes provider: <span class="hl-string">'gradle'</span>
    }
}
</pre></div></div><br class="example-break"><p>Notice that our sample applies the Java plugin to each subproject. This means the tasks and configuration properties we have seen in the previous section are available in each subproject. So, you can compile, test, and JAR all the projects by running <code class="literal">gradle build</code> from the root project directory.</p><p>Also note that these plugins are only applied within the <code class="literal">subprojects</code> section, not at the root level, so the root build will not expect to find Java source files in the root project, only in the subprojects.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:dependencies_between_projects" class="section-anchor" href="#sec:dependencies_between_projects"></a>Dependencies between projects</h3></div></div></div><p>You can add dependencies between projects in the same build, so that, for example, the JAR file of one project is used to compile another project. In the <code class="literal">api</code> build file we will add a dependency on the <code class="literal">shared</code> project. Due to this dependency, Gradle will ensure that project <code class="literal">shared</code> always gets built before project <code class="literal">api</code>.</p><div class="example"><a name="javaMultiProject"></a><p class="title"><b>Example&nbsp;397.&nbsp;Multi-project build - dependencies between projects</b></p><div class="example-contents"><p><code class="filename">api/build.gradle</code></p><pre class="programlisting">dependencies {
    compile project(<span class="hl-string">':shared'</span>)
}
</pre></div></div><br class="example-break"><p>See <a class="xref" href="#disable_dependency_projects">the section called &ldquo;Disabling the build of dependency projects&rdquo;</a> for how to disable this functionality.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:creating_a_distribution" class="section-anchor" href="#sec:creating_a_distribution"></a>Creating a distribution</h3></div></div></div><p>We also add a distribution, that gets shipped to the client:</p><div class="example"><a name="javaMultiProject"></a><p class="title"><b>Example&nbsp;398.&nbsp;Multi-project build - distribution file</b></p><div class="example-contents"><p><code class="filename">api/build.gradle</code></p><pre class="programlisting">task dist(type: Zip) {
    dependsOn spiJar
    from <span class="hl-string">'src/dist'</span>
    into(<span class="hl-string">'libs'</span>) {
        from spiJar.archivePath
        from configurations.runtime
    }
}

artifacts {
   archives dist
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_tutorial_where_to_next" class="section-anchor" href="#sec:java_tutorial_where_to_next"></a>Where to next?</h2></div></div></div><p>In this chapter, you have seen how to do some of the things you commonly need to build a Java based project. This chapter is not exhaustive, and there are many other things you can do with Java projects in Gradle. You can find out more about the Java plugin in <a class="xref" href="#java_plugin"><i>The Java Plugin</i></a>, and you can find more sample Java projects in the <code class="literal">samples/java</code> directory in the Gradle distribution.</p><p>Otherwise, continue on to <a class="xref" href="#artifact_dependencies_tutorial"><i>Dependency Management for Java Projects</i></a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="java_plugin"></a>The Java Plugin</h1></div></div></div><p>The Java plugin adds Java compilation along with testing and bundling capabilities to a project. It serves as the basis for many of the other Gradle plugins.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_usage" class="section-anchor" href="#sec:java_usage"></a>Usage</h2></div></div></div><p>To use the Java plugin, include the following in your build script:</p><div class="example"><a name="useJavaPlugin"></a><p class="title"><b>Example&nbsp;399.&nbsp;Using the Java plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_source_sets" class="section-anchor" href="#sec:java_source_sets"></a>Source sets</h2></div></div></div><p>The Java plugin introduces the concept of a <span class="emphasis"><em>source set</em></span>. A source set is simply a group of source files which are compiled and executed together. These source files may include Java source files and resource files. Other plugins add the ability to include Groovy and Scala source files in a source set. A source set has an associated compile classpath, and runtime classpath.</p><p>One use for source sets is to group source files into logical groups which describe their purpose. For example, you might use a source set to define an integration test suite, or you might use separate source sets to define the API and implementation classes of your project.</p><p>The Java plugin defines two standard source sets, called <code class="literal">main</code> and <code class="literal">test</code>. The <code class="literal">main</code> source set contains your production source code, which is compiled and assembled into a JAR file. The <code class="literal">test</code> source set contains your test source code, which is compiled and executed using JUnit or TestNG. These can be unit tests, integration tests, acceptance tests, or any combination that is useful to you.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_tasks" class="section-anchor" href="#sec:java_tasks"></a>Tasks</h2></div></div></div><p>The Java plugin adds a number of tasks to your project, as shown below.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">compileJava(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Compiles production Java source files using javac.</em></span> Depends on all tasks which produce the compile classpath. This includes the <code class="literal">jar</code> task for project dependencies included in the <code class="literal">compile</code> configuration.</p></dd><dt><span class="term"><code class="literal">processResources(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Copies production resources into the production resources directory.</em></span></p></dd><dt><span class="term"><code class="literal">classes(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles the production classes and resources directories.</em></span></p></dd><dt><span class="term"><code class="literal">compileTestJava(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Compiles test Java source files using javac.</em></span> Depends on <code class="literal">compile</code>, plus all tasks which produce the test compile classpath.</p></dd><dt><span class="term"><code class="literal">processTestResources(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Copies test resources into the test resources directory.</em></span></p></dd><dt><span class="term"><code class="literal">testClasses(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles the test classes and resources directories.</em></span> Depends on <code class="literal">compileTestJava</code> task and <code class="literal">processTestResources</code> task. Some plugins add additional test compilation tasks.</p></dd><dt><span class="term"><code class="literal">jar(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Jar.html" target="_top"><code class="classname">Jar</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles the JAR file.</em></span> Depends on <code class="literal">compile</code>.</p></dd><dt><span class="term"><code class="literal">javadoc(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.javadoc.Javadoc.html" target="_top"><code class="classname">Javadoc</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Generates API documentation for the production Java source, using Javadoc</em></span>. Depends on <code class="literal">compile</code>.</p></dd><dt><span class="term"><code class="literal">test(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Runs the unit tests using JUnit or TestNG.</em></span> Depends on <code class="literal">compile</code>, <code class="literal">compileTest</code>, plus all tasks which produce the test runtime classpath.</p></dd><dt><span class="term"><code class="literal">uploadArchives(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Upload.html" target="_top"><code class="classname">Upload</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Uploads artifacts in the <code class="literal">archives</code> configuration, including the JAR file.</em></span> Depends on the tasks which produce the artifacts in the <code class="literal">archives</code> configuration, including <code class="literal">jar</code>.</p></dd><dt><span class="term"><code class="literal">clean(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Deletes the project build directory.</em></span></p></dd><dt><span class="term"><code class="literal">clean<span class="emphasis"><em>TaskName</em></span>(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Deletes files created by specified task. <code class="literal">cleanJar</code> will delete the JAR file created by the <code class="literal">jar</code> task, and <code class="literal">cleanTest</code> will delete the test results created by the <code class="literal">test</code> task.</em></span></p></dd></dl></div><p>For each source set you add to the project, the Java plugin adds the following compilation tasks:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="java_source_set_tasks" class="section-anchor" href="#java_source_set_tasks"></a>SourceSet Tasks</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Compiles the given source set&rsquo;s Java source files using javac.</em></span> Depends on all tasks which produce the source set&rsquo;s compile classpath.</p></dd><dt><span class="term"><code class="literal">process<span class="emphasis"><em>SourceSet</em></span>Resources(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Copies the given source set&rsquo;s resources into the resources directory.</em></span></p></dd><dt><span class="term"><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles the given source set&rsquo;s classes and resources directories.</em></span> Depends on the <code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java</code> task and the <code class="literal">process<span class="emphasis"><em>SourceSet</em></span>Resources</code> task. Some plugins add additional compilation tasks for the source set.</p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_lifecycle_tasks" class="section-anchor" href="#_lifecycle_tasks"></a>Lifecycle Tasks</h3></div></div></div><p>The Java plugin also adds a number of tasks which form a lifecycle for the project:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">assemble(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles all the archives in the project.</em></span> Depends on all archive tasks in the project, including <code class="literal">jar</code>. Some plugins add additional archive tasks to the project.</p></dd><dt><span class="term"><code class="literal">check(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Performs all verification tasks in the project.</em></span> Depends on all verification tasks in the project, including <code class="literal">test</code>. Some plugins add additional verification tasks to the project.</p></dd><dt><span class="term"><code class="literal">build(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Performs a full build of the project.</em></span> Depends on <code class="literal">check</code> and <code class="literal">assemble</code>.</p></dd><dt><span class="term"><code class="literal">buildNeeded(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Performs a full build of the project and all projects it depends on.</em></span> Depends on <code class="literal">build</code> and <code class="literal">buildNeeded</code> tasks in all project lib dependencies of the <code class="literal">testRuntime</code> configuration.</p></dd><dt><span class="term"><code class="literal">buildDependents(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Performs a full build of the project and all projects which depend on it.</em></span> Depends on <code class="literal">build</code> and <code class="literal">buildDependents</code> tasks in all projects with a project lib dependency on this project in a <code class="literal">testRuntime</code> configuration.</p></dd><dt><span class="term"><code class="literal">build<span class="emphasis"><em>ConfigName</em></span>(type: <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles the artifacts in the specified configuration. The task is added by the Base plugin which is implicitly applied by the Java plugin.</em></span> Depends on the tasks which produce the artifacts in configuration <span class="emphasis"><em>ConfigName</em></span>.</p></dd><dt><span class="term"><code class="literal">upload<span class="emphasis"><em>ConfigName</em></span>(type: <a class="ulink" href="../dsl/org.gradle.api.tasks.Upload.html" target="_top"><code class="classname">Upload</code></a>)</code></span></dt><dd><p><span class="emphasis"><em>Assembles and uploads the artifacts in the specified configuration. The task is added by the Base plugin which is implicitly applied by the Java plugin.</em></span> Depends on the tasks which uploads the artifacts in configuration <span class="emphasis"><em>ConfigName</em></span>.</p></dd></dl></div><p>The following diagram shows the relationships between these tasks.</p><div class="figure"><a name="N16A12"></a><p class="title"><b>Figure&nbsp;14.&nbsp;Java plugin - tasks</b></p><div class="figure-contents"><img src="img/javaPluginTasks.png" alt="Java plugin - tasks"></div></div><br class="figure-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_project_layout" class="section-anchor" href="#sec:java_project_layout"></a>Project layout</h2></div></div></div><p>The Java plugin assumes the project layout shown below. None of these directories need to exist or have anything in them. The Java plugin will compile whatever it finds, and handles anything which is missing.</p><div class="table"><p class="title"><b>Table&nbsp;36.&nbsp;Java plugin - default project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="javalayout"><thead><tr>
<td>Directory</td>
<td></td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/java</code></p></td>
<td></td>
<td><p>Production Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/main/resources</code></p></td>
<td></td>
<td><p>Production resources</p></td>
</tr><tr>
<td><p><code class="literal">src/test/java</code></p></td>
<td></td>
<td><p>Test Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/test/resources</code></p></td>
<td></td>
<td><p>Test resources</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/java</code></p></td>
<td></td>
<td><p>Java source for the given source set</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/resources</code></p></td>
<td></td>
<td><p>Resources for the given source set</p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:changing_java_project_layout" class="section-anchor" href="#sec:changing_java_project_layout"></a>Changing the project layout</h3></div></div></div><p>You configure the project layout by configuring the appropriate source set. This is discussed in more detail in the following sections. Here is a brief example which changes the main Java and resource source directories.</p><div class="example"><a name="customJavaSourceLayout"></a><p class="title"><b>Example&nbsp;400.&nbsp;Custom Java source layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    main {
        java {
            srcDirs = [<span class="hl-string">'src/java'</span>]
        }
        resources {
            srcDirs = [<span class="hl-string">'src/resources'</span>]
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_plugin_and_dependency_management" class="section-anchor" href="#sec:java_plugin_and_dependency_management"></a>Dependency management</h2></div></div></div><p>The Java plugin adds a number of dependency configurations to your project, as shown below. It assigns those configurations to tasks such as <code class="literal">compileJava</code> and <code class="literal">test</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="tab:configurations" class="section-anchor" href="#tab:configurations"></a>Dependency configurations</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">compile</code></span></dt><dd><p><span class="emphasis"><em>Compile time dependencies.</em></span></p></dd><dt><span class="term"><code class="literal">compileOnly</code></span></dt><dd><p><span class="emphasis"><em>Compile time only dependencies, not used at runtime.</em></span></p></dd><dt><span class="term"><code class="literal">compileClasspath</code> extends <code class="literal">compile, compileOnly</code></span></dt><dd><p><span class="emphasis"><em>Compile classpath, used when compiling source.</em></span> Used by task <code class="literal">compileJava</code>.</p></dd><dt><span class="term"><code class="literal">runtime</code> extends <code class="literal">compile</code></span></dt><dd><p><span class="emphasis"><em>Runtime dependencies.</em></span></p></dd><dt><span class="term"><code class="literal">testCompile</code> extends <code class="literal">compile</code></span></dt><dd><p><span class="emphasis"><em>Additional dependencies for compiling tests.</em></span></p></dd><dt><span class="term"><code class="literal">testCompileOnly</code></span></dt><dd><p><span class="emphasis"><em>Additional dependencies only for compiling tests, not used at runtime.</em></span></p></dd><dt><span class="term"><code class="literal">testCompileClasspath</code> extends <code class="literal">testCompile, testCompileOnly</code></span></dt><dd><p><span class="emphasis"><em>Test compile classpath, used when compiling test sources.</em></span> Used by task <code class="literal">compileTestJava</code>.</p></dd><dt><span class="term"><code class="literal">testRuntime</code> extends <code class="literal">runtime, testCompile</code></span></dt><dd><p><span class="emphasis"><em>Additional dependencies for running tests only.</em></span> Used by task <code class="literal">test</code>.</p></dd><dt><span class="term"><code class="literal">archives</code></span></dt><dd><p>Artifacts (e.g. jars) produced by this project. Used by tasks <code class="literal">uploadArchives</code>.</p></dd><dt><span class="term"><code class="literal">default</code> extends <code class="literal">runtime</code></span></dt><dd><p><span class="emphasis"><em>The default configuration used by a project dependency on this project.</em></span> Contains the artifacts and dependencies required by this project at runtime.</p></dd></dl></div><div class="figure"><a name="N16B17"></a><p class="title"><b>Figure&nbsp;15.&nbsp;Java plugin - dependency configurations</b></p><div class="figure-contents"><img src="img/javaPluginConfigurations.png" alt="Java plugin - dependency configurations"></div></div><br class="figure-break"><p>For each source set you add to the project, the Java plugins adds the following dependency configurations:</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="java_source_set_configurations" class="section-anchor" href="#java_source_set_configurations"></a>SourceSet dependency configurations</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Compile</code></span></dt><dd><p><span class="emphasis"><em>Compile time dependencies for the given source set.</em></span></p></dd><dt><span class="term"><code class="literal"><span class="emphasis"><em>sourceSet</em></span>CompileOnly</code></span></dt><dd><p><span class="emphasis"><em>Compile time only dependencies for the given source set, not used at runtime.</em></span></p></dd><dt><span class="term"><code class="literal"><span class="emphasis"><em>sourceSet</em></span>CompileClasspath</code> extends <code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java</code></span></dt><dd><p><span class="emphasis"><em>Compile classpath, used when compiling source.</em></span> Used by <code class="literal"><span class="emphasis"><em>sourceSet</em></span>Compile</code>, <code class="literal"><span class="emphasis"><em>sourceSet</em></span>CompileOnly</code>.</p></dd><dt><span class="term"><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Runtime</code></span></dt><dd><p><span class="emphasis"><em>Runtime dependencies for the given source set.</em></span> Used by <code class="literal"><span class="emphasis"><em>sourceSet</em></span>Compile</code>.</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_convention_properties" class="section-anchor" href="#sec:java_convention_properties"></a>Convention properties</h2></div></div></div><p>The Java plugin adds a number of convention properties to the project, shown below. You can use these properties in your build script as though they were properties of the project object.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_directory_properties" class="section-anchor" href="#_directory_properties"></a>Directory properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">String reportsDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to generate reports into, relative to the build directory.</em></span> Default value: <code class="literal">reports</code></p></dd><dt><span class="term"><code class="literal">(read-only) File reportsDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate reports into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>reportsDirName</em></span></code></p></dd><dt><span class="term"><code class="literal">String testResultsDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to generate test result .xml files into, relative to the build directory.</em></span> Default value: <code class="literal">test-results</code></p></dd><dt><span class="term"><code class="literal">(read-only) File testResultsDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate test result .xml files into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>testResultsDirName</em></span></code></p></dd><dt><span class="term"><code class="literal">String testReportDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to generate the test report into, relative to the reports directory.</em></span> Default value: <code class="literal">tests</code></p></dd><dt><span class="term"><code class="literal">(read-only) File testReportDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate the test report into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>reportsDir</em></span>/testReportDirName</code></p></dd><dt><span class="term"><code class="literal">String libsDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to generate libraries into, relative to the build directory.</em></span> Default value: <code class="literal">libs</code></p></dd><dt><span class="term"><code class="literal">(read-only) File libsDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate libraries into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>libsDirName</em></span></code></p></dd><dt><span class="term"><code class="literal">String distsDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to generate distributions into, relative to the build directory.</em></span> Default value: <code class="literal">distributions</code></p></dd><dt><span class="term"><code class="literal">(read-only) File distsDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate distributions into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>distsDirName</em></span></code></p></dd></dl></div><p><code class="literal">String docsDirName</code>:
:_The name of the directory to generate documentation into, relative to the build directory._ Default value: <code class="literal">docs</code></p><div class="variablelist"><dl><dt><span class="term"><code class="literal">(read-only) File docsDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate documentation into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/<span class="emphasis"><em>docsDirName</em></span></code></p></dd><dt><span class="term"><code class="literal">String dependencyCacheDirName</code></span></dt><dd><p><span class="emphasis"><em>The name of the directory to use to cache source dependency information, relative to the build directory.</em></span> Default value: <code class="literal">dependency-cache</code></p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_other_convention_properties" class="section-anchor" href="#_other_convention_properties"></a>Other convention properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../javadoc/org/gradle/api/tasks/SourceSetContainer.html" target="_top"><code class="classname">SourceSetContainer</code></a> sourceSets</code></span></dt><dd><p><span class="emphasis"><em>Contains the project&rsquo;s source sets.</em></span> Default value: Not null <a class="ulink" href="../javadoc/org/gradle/api/tasks/SourceSetContainer.html" target="_top"><code class="classname">SourceSetContainer</code></a></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/JavaVersion.html" target="_top"><code class="classname">JavaVersion</code></a> sourceCompatibility</code></span></dt><dd><p><span class="emphasis"><em>Java version compatibility to use when compiling Java source.</em></span> Default value: version of the current JVM in use <a class="ulink" href="../javadoc/org/gradle/api/JavaVersion.html" target="_top"><code class="classname">JavaVersion</code></a>. Can also set using a String or a Number, e.g. <code class="literal">'1.5'</code> or <code class="literal">1.5</code>.</p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/JavaVersion.html" target="_top"><code class="classname">JavaVersion</code></a> targetCompatibility</code></span></dt><dd><p><span class="emphasis"><em>Java version to generate classes for.</em></span> Default value: <code class="literal"><span class="emphasis"><em>sourceCompatibility</em></span></code>. Can also set using a String or Number, e.g. <code class="literal">'1.5'</code> or <code class="literal">1.5</code>.</p></dd><dt><span class="term"><code class="literal">String archivesBaseName</code></span></dt><dd><p><span class="emphasis"><em>The basename to use for archives, such as JAR or ZIP files.</em></span> Default value: <code class="literal"><span class="emphasis"><em>projectName</em></span></code></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/java/archives/Manifest.html" target="_top"><code class="classname">Manifest</code></a> manifest</code></span></dt><dd><p><span class="emphasis"><em>The manifest to include in all JAR files.</em></span> Default value: an empty manifest.</p></dd></dl></div><p>These properties are provided by convention objects of type <a class="ulink" href="../dsl/org.gradle.api.plugins.JavaPluginConvention.html" target="_top"><code class="classname">JavaPluginConvention</code></a>, and <a class="ulink" href="../dsl/org.gradle.api.plugins.BasePluginConvention.html" target="_top"><code class="classname">BasePluginConvention</code></a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:working_with_java_source_sets" class="section-anchor" href="#sec:working_with_java_source_sets"></a>Working with source sets</h2></div></div></div><p>You can access the source sets of a project using the <code class="literal">sourceSets</code> property. This is a container for the project&rsquo;s source sets, of type <a class="ulink" href="../javadoc/org/gradle/api/tasks/SourceSetContainer.html" target="_top"><code class="classname">SourceSetContainer</code></a>. There is also a <code class="literal">sourceSets { }</code> script block, which you can pass a closure to configure the source set container. The source set container works pretty much the same way as other containers, such as <code class="literal">tasks</code>.</p><div class="example"><a name="defineSourceSet"></a><p class="title"><b>Example&nbsp;401.&nbsp;Accessing a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// Various ways to access the main source set</span>
println sourceSets.main.output.classesDirs
println sourceSets[<span class="hl-string">'main'</span>].output.classesDirs
sourceSets {
    println main.output.classesDirs
}
sourceSets {
    main {
        println output.classesDirs
    }
}

<span class="hl-comment">// Iterate over the source sets</span>
sourceSets.all {
    println name
}
</pre></div></div><br class="example-break"><p>To configure an existing source set, you simply use one of the above access methods to set the properties of the source set. The properties are described below. Here is an example which configures the main Java and resources directories:</p><div class="example"><a name="configureSourceSet"></a><p class="title"><b>Example&nbsp;402.&nbsp;Configuring the source directories of a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    main {
        java {
            srcDirs = [<span class="hl-string">'src/java'</span>]
        }
        resources {
            srcDirs = [<span class="hl-string">'src/resources'</span>]
        }
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:source_set_properties" class="section-anchor" href="#sec:source_set_properties"></a>Source set properties</h3></div></div></div><p>The following table lists some of the important properties of a source set. You can find more details in the API documentation for <a class="ulink" href="../dsl/org.gradle.api.tasks.SourceSet.html" target="_top"><code class="classname">SourceSet</code></a>.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">(read-only) String name</code></span></dt><dd><p><span class="emphasis"><em>The name of the source set, used to identify it.</em></span> Default value: Not null</p></dd><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../dsl/org.gradle.api.tasks.SourceSetOutput.html" target="_top"><code class="classname">SourceSetOutput</code></a> output</code></span></dt><dd><p><span class="emphasis"><em>The output files of the source set, containing its compiled classes and resources.</em></span> Default value: Not null</p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> output.classesDirs</code></span></dt><dd><p><span class="emphasis"><em>The directories to generate the classes of this source set into.</em></span> Default value: Not null</p></dd><dt><span class="term"><code class="literal">File output.resourcesDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate the resources of this source set into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/resources/<span class="emphasis"><em>name</em></span></code></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> compileClasspath</code></span></dt><dd><p><span class="emphasis"><em>The classpath to use when compiling the source files of this source set.</em></span> Default value: <code class="literal">compile<span class="emphasis"><em>SourceSet</em></span></code> configuration.</p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> runtimeClasspath</code></span></dt><dd><p><span class="emphasis"><em>The classpath to use when executing the classes of this source set.</em></span> Default value: <code class="literal">output</code> + <code class="literal">runtime<span class="emphasis"><em>SourceSet</em></span></code> configuration.</p></dd><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> java</code></span></dt><dd><p><span class="emphasis"><em>The Java source files of this source set. Contains only <code class="literal">.java</code> files found in the Java source directories, and excludes all other files.</em></span> Default value: Not null</p></dd><dt><span class="term"><code class="literal">Set&lt;File&gt; java.srcDirs</code></span></dt><dd><p><span class="emphasis"><em>The source directories containing the Java source files of this source set.</em></span> Default value: <code class="literal">[<span class="emphasis"><em>projectDir</em></span>/src/<span class="emphasis"><em>name</em></span>/java]</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">File java.outputDir</code></span></dt><dd><p><span class="emphasis"><em>The directory to generate compiled Java sources into.</em></span> Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span>/classes/java/<span class="emphasis"><em>sourceSetName</em></span></code>. Can set using anything described in <a class="xref" href="#sec:locating_files">the section called &ldquo;Locating files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> resources</code></span></dt><dd><p><span class="emphasis"><em>The resources of this source set. Contains only resources, and excludes any <code class="literal">.java</code> files found in the resource source directories. Other plugins, such as the Groovy plugin, exclude additional types of files from this collection.</em></span> Default value: Not null</p></dd><dt><span class="term"><code class="literal">Set&lt;File&gt; resources.srcDirs</code></span></dt><dd><p><span class="emphasis"><em>The source directories containing the resources of this source set.</em></span> Default value: <code class="literal">[<span class="emphasis"><em>projectDir</em></span>/src/<span class="emphasis"><em>name</em></span>/resources]</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> allJava</code></span></dt><dd><p><span class="emphasis"><em>All <code class="literal">.java</code> files of this source set. Some plugins, such as the Groovy plugin, add additional Java source files to this collection.</em></span> Default value: <code class="literal">java</code></p></dd><dt><span class="term"><code class="literal">(read-only) <a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> allSource</code></span></dt><dd><p><span class="emphasis"><em>All source files of this source set. This include all resource files and all Java source files. Some plugins, such as the Groovy plugin, add additional source files to this collection.</em></span> Default value: <code class="literal">resources + java</code></p></dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_new_source_sets" class="section-anchor" href="#sec:defining_new_source_sets"></a>Defining new source sets</h3></div></div></div><p>To define a new source set, you simply reference it in the <code class="literal">sourceSets { }</code> block. Here&rsquo;s an example:</p><div class="example"><a name="defineSourceSet"></a><p class="title"><b>Example&nbsp;403.&nbsp;Defining a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    intTest
}
</pre></div></div><br class="example-break"><p>When you define a new source set, the Java plugin adds some dependency configurations for the source set, as shown in <a class="xref" href="#java_source_set_configurations">the section called &ldquo;SourceSet dependency configurations&rdquo;</a>. You can use these configurations to define the compile and runtime dependencies of the source set.</p><div class="example"><a name="sourceSetDependencies"></a><p class="title"><b>Example&nbsp;404.&nbsp;Defining source set dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    intTest
}

dependencies {
    intTestCompile <span class="hl-string">'junit:junit:4.12'</span>
    intTestRuntime <span class="hl-string">'org.ow2.asm:asm-all:4.0'</span>
}
</pre></div></div><br class="example-break"><p>The Java plugin also adds a number of tasks which assemble the classes for the source set, as shown in <a class="xref" href="#java_source_set_tasks">the section called &ldquo;SourceSet Tasks&rdquo;</a>. For example, for a source set called <code class="literal">intTest</code>, compiling the classes for this source set is done by running <code class="literal">gradle intTestClasses</code>.</p><div class="example"><a name="compileSourceSet"></a><p class="title"><b>Example&nbsp;405.&nbsp;Compiling a source set</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle intTestClasses</code></strong></p><pre class="screen">&gt; gradle intTestClasses
:compileIntTestJava
:processIntTestResources
:intTestClasses

BUILD SUCCESSFUL in 0s
2 actionable tasks: 2 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:some_source_set_examples" class="section-anchor" href="#sec:some_source_set_examples"></a>Some source set examples</h3></div></div></div><p>Adding a JAR containing the classes of a source set:</p><div class="example"><a name="configureSourceSet"></a><p class="title"><b>Example&nbsp;406.&nbsp;Assembling a JAR for a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task intTestJar(type: Jar) {
    from sourceSets.intTest.output
}
</pre></div></div><br class="example-break"><p>Generating Javadoc for a source set:</p><div class="example"><a name="configureSourceSet"></a><p class="title"><b>Example&nbsp;407.&nbsp;Generating the Javadoc for a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task intTestJavadoc(type: Javadoc) {
    source sourceSets.intTest.allJava
}
</pre></div></div><br class="example-break"><p>Adding a test suite to run the tests in a source set:</p><div class="example"><a name="configureSourceSet"></a><p class="title"><b>Example&nbsp;408.&nbsp;Running tests in a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task intTest(type: Test) {
    testClassesDirs = sourceSets.intTest.output.classesDirs
    classpath = sourceSets.intTest.runtimeClasspath
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:javadoc" class="section-anchor" href="#sec:javadoc"></a>Javadoc</h2></div></div></div><p>The <code class="literal">javadoc</code> task is an instance of <a class="ulink" href="../dsl/org.gradle.api.tasks.javadoc.Javadoc.html" target="_top"><code class="classname">Javadoc</code></a>. It supports the core Javadoc options and the options of the standard doclet described in the <a class="ulink" href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javadoc.html" target="_top">reference documentation</a> of the Javadoc executable. For a complete list of supported Javadoc options consult the API documentation of the following classes: <a class="ulink" href="../javadoc/org/gradle/external/javadoc/CoreJavadocOptions.html" target="_top"><code class="classname">CoreJavadocOptions</code></a> and <a class="ulink" href="../javadoc/org/gradle/external/javadoc/StandardJavadocDocletOptions.html" target="_top"><code class="classname">StandardJavadocDocletOptions</code></a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_javadoc_properties" class="section-anchor" href="#_javadoc_properties"></a>Javadoc properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> classpath</code></span></dt><dd><p>Default value: <code class="literal">sourceSets.main.output</code> + <code class="literal">sourceSets.main.compileClasspath</code></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a> source</code></span></dt><dd><p>Default value: <code class="literal">sourceSets.main.allJava</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">File destinationDir</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>docsDir</em></span>/javadoc</code></p></dd><dt><span class="term"><code class="literal">String title</code></span></dt><dd><p>Default value: The name and version of the project</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:clean" class="section-anchor" href="#sec:clean"></a>Clean</h2></div></div></div><p>The <code class="literal">clean</code> task is an instance of <a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a>. It simply removes the directory denoted by its <code class="literal">dir</code> property.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_clean_properties" class="section-anchor" href="#_clean_properties"></a>Clean properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">File dir</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>buildDir</em></span></code></p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_resources" class="section-anchor" href="#sec:java_resources"></a>Resources</h2></div></div></div><p>The Java plugin uses the <a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a> task for resource handling. It adds an instance for each source set in the project. You can find out more about the copy task in <a class="xref" href="#sec:copying_files">the section called &ldquo;Copying files&rdquo;</a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_processresources_properties" class="section-anchor" href="#_processresources_properties"></a>ProcessResources properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">Object srcDirs</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>sourceSet</em></span>.resources</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">File destinationDir</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>sourceSet</em></span>.output.resourcesDir</code>. Can set using anything described in <a class="xref" href="#sec:locating_files">the section called &ldquo;Locating files&rdquo;</a>.</p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:compile" class="section-anchor" href="#sec:compile"></a>CompileJava</h2></div></div></div><p>The Java plugin adds a <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a> instance for each source set in the project. Some of the most common configuration options are shown below.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="_compile_properties" class="section-anchor" href="#_compile_properties"></a>Compile properties</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> classpath</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>sourceSet</em></span>.compileClasspath</code></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a> source</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>sourceSet</em></span>.java</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></dd><dt><span class="term"><code class="literal">File destinationDir</code></span></dt><dd><p>Default value: <code class="literal"><span class="emphasis"><em>sourceSet</em></span>.java.outputDir</code></p></dd></dl></div><p>By default, the Java compiler runs in the Gradle process. Setting <code class="literal">options.fork</code> to <code class="literal">true</code> causes compilation to occur in a separate process. In the case of the Ant javac task, this means that a new process will be forked for each compile task, which can slow down compilation. Conversely, Gradle&rsquo;s direct compiler integration (see above) will reuse the same compiler process as much as possible. In both cases, all fork options specified with <code class="literal">options.forkOptions</code> will be honored.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:incremental_compile" class="section-anchor" href="#sec:incremental_compile"></a>Incremental Java compilation</h2></div></div></div><p>Starting with Gradle 2.1, it is possible to compile Java incrementally. See the <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a> task for information on how to enable it.</p><p>Main goals for incremental compilations are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Avoid wasting time compiling source classes that don&rsquo;t have to be compiled. This means faster builds, especially when a change to a source class or a jar does not incur recompilation of many source classes that depend on the changed input.</p></li><li class="listitem"><p>Change as few output classes as possible. Classes that don&rsquo;t need to be recompiled remain unchanged in the output directory. An example scenario when this is really useful is using JRebel - the fewer output classes are changed the quicker the JVM can use refreshed classes.</p></li></ul></div><p>The incremental compilation at a high level:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The detection of the correct set of stale classes is reliable at some expense of speed. The algorithm uses bytecode analysis and deals gracefully with compiler optimizations (inlining of non-private constants), transitive class dependencies, etc. Example: When a class with a public constant changes, we eagerly compile classes that use the same constants to avoid problems with constants inlined by the compiler.</p></li><li class="listitem"><p>To make incremental compilation fast, we cache class analysis results and jar snapshots. The initial incremental compilation can be slower due to the cold caches.</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:incremental_compilation_known_issues" class="section-anchor" href="#sec:incremental_compilation_known_issues"></a>Known issues</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If a compile task fails due to a compile error, it will do a full compilation again the next time it is invoked.</p></li><li class="listitem"><p>Because of type erasure, the incremental compiler is not able to recognize when a type is only used in a type parameter, and never actually used in the code. For example, imagine that you have the following code: <code class="literal">List&lt;? extends A&gt; list = Lists.newArrayList();</code> but that no member of <code class="literal">A</code> is in practice used in the code, then changes to <code class="literal">A</code> will not trigger recompilation of the class. In practice, this should very rarely be an issue.</p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_compile_avoidance" class="section-anchor" href="#sec:java_compile_avoidance"></a>Compile avoidance</h2></div></div></div><p>If a dependent project has changed in an <a class="ulink" href="https://en.wikipedia.org/wiki/Application_binary_interface" target="_top">ABI</a>-compatible way (only its private API has changed), then Java compilation tasks will be up-to-date. This means that if project <code class="literal">A</code> depends on project <code class="literal">B</code> and a class in <code class="literal">B</code> is changed in an ABI-compatible way (typically, changing only the body of a method), then Gradle won&rsquo;t recompile <code class="literal">A</code>.</p><p>Some of the types of changes that do not affect the public API and are ignored:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Changing a method body</p></li><li class="listitem"><p>Changing a comment</p></li><li class="listitem"><p>Adding, removing or changing private methods, fields, or inner classes</p></li><li class="listitem"><p>Adding, removing or changing a resource</p></li><li class="listitem"><p>Changing the name of jars or directories in the classpath</p></li><li class="listitem"><p>Renaming a parameter</p></li></ul></div><p>Compile-avoidance is deactivated if annotation processors are found on the compile classpath, because for annotation processors the implementation details matter. To better separate these concerns, it&rsquo;s recommended to declare annotation processors separately: the <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.CompileOptions.html" target="_top"><code class="classname">CompileOptions</code></a> for the <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.JavaCompile.html" target="_top"><code class="classname">JavaCompile</code></a> task type define a <code class="literal">annotationProcessorPath</code> property that can be used to declare annotation processors. It&rsquo;s recommended to use a distinct configuration for annotation processors:</p><div class="example"><a name="annotationProcessing"></a><p class="title"><b>Example&nbsp;409.&nbsp;Declaring annotation processors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
    apt
}
dependencies {
    <span class="hl-comment">// The dagger compiler and its transitive dependencies will only be found on annotation processing classpath</span>
    apt <span class="hl-string">'com.google.dagger:dagger-compiler:2.8'</span>

    <span class="hl-comment">// And we still need the Dagger annotations on the compile classpath itself</span>
    implementation <span class="hl-string">'com.google.dagger:dagger:2.8'</span>
}

compileJava {
    options.annotationProcessorPath = configurations.apt
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_test" class="section-anchor" href="#sec:java_test"></a>Test</h2></div></div></div><p>The <code class="literal">test</code> task is an instance of <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a>. It automatically detects and executes all unit tests in the <code class="literal">test</code> source set. It also generates a report once test execution is complete. JUnit and TestNG are both supported. Have a look at <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a> for the complete API.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:test_execution" class="section-anchor" href="#sec:test_execution"></a>Test execution</h3></div></div></div><p>Tests are executed in a separate JVM, isolated from the main build process. The <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a> task&rsquo;s API allows you some control over how this happens.</p><p>There are a number of properties which control how the test process is launched. This includes things such as system properties, JVM arguments, and the Java executable to use.</p><p>You can specify whether or not to execute your tests in parallel. Gradle provides parallel test execution by running multiple test processes concurrently. Each test process executes only a single test at a time, so you generally don&rsquo;t need to do anything special to your tests to take advantage of this. The <code class="literal">maxParallelForks</code> property specifies the maximum number of test processes to run at any given time. The default is 1, that is, do not execute the tests in parallel.</p><p>The test process sets the <code class="literal">org.gradle.test.worker</code> system property to a unique identifier for that test process, which you can use, for example, in files names or other resource identifiers.</p><p>You can specify that test processes should be restarted after it has executed a certain number of test classes. This can be a useful alternative to giving your test process a very large heap. The <code class="literal">forkEvery</code> property specifies the maximum number of test classes to execute in a test process. The default is to execute an unlimited number of tests in each test process.</p><p>The task has an <code class="literal">ignoreFailures</code> property to control the behavior when tests fail. The <code class="literal">Test</code> task always executes every test that it detects. It stops the build afterwards if <code class="literal">ignoreFailures</code> is false and there are failing tests. The default value of <code class="literal">ignoreFailures</code> is false.</p><p>The <code class="literal">testLogging</code> property allows you to configure which test events are going to be logged and at which detail level. By default, a concise message will be logged for every failed test. See <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.logging.TestLoggingContainer.html" target="_top"><code class="classname">TestLoggingContainer</code></a> for how to tune test logging to your preferences.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:debugging" class="section-anchor" href="#sec:debugging"></a>Debugging</h3></div></div></div><p>The test task provides a <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html#org.gradle.api.tasks.testing.Test:debug" target="_top"><code class="classname">Test.getDebug()</code></a> property that can be set to launch to make the JVM wait for a debugger to attach to port 5005 before proceeding with test execution.</p><p>This can also be enabled at invocation time via the <code class="literal">--debug-jvm</code> task option (since Gradle 1.12).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test_filtering" class="section-anchor" href="#test_filtering"></a>Test filtering</h3></div></div></div><p>Starting with Gradle 1.10, it is possible to include only specific tests, based on the test name pattern. Filtering is a different mechanism than test class inclusion / exclusion that will be described in the next few paragraphs (<code class="literal">-Dtest.single</code>, <code class="literal">test.include</code> and friends). The latter is based on files, e.g. the physical location of the test implementation class. File-level test selection does not support many interesting scenarios that are possible with test-level filtering. Some of them Gradle handles now and some will be satisfied in future releases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Filtering at the level of specific test methods; executing a single test method</p></li><li class="listitem"><p>Filtering based on custom annotations (future)</p></li><li class="listitem"><p>Filtering based on test hierarchy; executing all tests that extend a certain base class (future)</p></li><li class="listitem"><p>Filtering based on some custom runtime rule, e.g. particular value of a system property or some static state (future)</p></li></ul></div><p>Test filtering feature has following characteristic:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Fully qualified class name or fully qualified method name is supported, e.g. &ldquo;org.gradle.SomeTest&rdquo;, &ldquo;org.gradle.SomeTest.someMethod&rdquo;</p></li><li class="listitem"><p>Wildcard '*' is supported for matching any characters</p></li><li class="listitem"><p>Command line option &ldquo;--tests&rdquo; is provided to conveniently extend the test filter for an individual Gradle execution. This is especially useful for the classic 'single test method execution' use case. When the command line option is used, the inclusions declared in the build script are still honored. That is, the command line filters are always applied on top of the filter definition in the build script. It is possible to supply multiple &ldquo;--tests&rdquo; options and tests matching any of those patterns will be included.</p></li><li class="listitem"><p>Gradle tries to filter the tests given the limitations of the test framework API. Some advanced, synthetic tests may not be fully compatible with filtering. However, the vast majority of tests and use cases should be handled neatly.</p></li><li class="listitem"><p>Test filtering supersedes the file-based test selection. The latter may be completely replaced in future. We will grow the test filtering API and add more kinds of filters.</p></li></ul></div><div class="example"><a name="testfiltering"></a><p class="title"><b>Example&nbsp;410.&nbsp;Filtering tests in the build script</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    filter {
        <span class="hl-comment">//include specific method in any of the tests</span>
        includeTestsMatching <span class="hl-string">"*UiCheck"</span>

        <span class="hl-comment">//include all tests from package</span>
        includeTestsMatching <span class="hl-string">"org.gradle.internal.*"</span>

        <span class="hl-comment">//include all integration tests</span>
        includeTestsMatching <span class="hl-string">"*IntegTest"</span>
    }
}
</pre></div></div><br class="example-break"><p>For more details and examples please see the <a class="ulink" href="../javadoc/org/gradle/api/tasks/testing/TestFilter.html" target="_top"><code class="classname">TestFilter</code></a> reference.</p><p>Some examples of using the command line option:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gradle test --tests org.gradle.SomeTest.someSpecificFeature</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests \*SomeTest.someSpecificFeature</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests \*SomeSpecificTest</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests \*SomeSpecificTestSuite</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests all.in.specific.package\*</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests \*IntegTest</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests \*IntegTest\*ui\*</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests "com.example.MyTestSuite"</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests "com.example.ParameterizedTest"</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests "*ParameterizedTest.foo*"</code></p></li><li class="listitem"><p><code class="literal">gradle test --tests "*ParameterizedTest.*[2]"</code></p></li><li class="listitem"><p><code class="literal">gradle someTestTask --tests \*UiTest someOtherTestTask --tests \*WebTest\*ui</code></p></li></ul></div><p>This is something you can combine with <a class="link" href="#continuous_build">continuous build</a> using <code class="literal">--continuous</code> (or <code class="literal">-t</code>, for short) to re-execute a subset of tests immediately after every change.</p><pre class="screen">gradle test --continuous --tests "com.mypackage.foo.*"</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:single_test_execution_via_system_properties" class="section-anchor" href="#sec:single_test_execution_via_system_properties"></a>Single test execution via System Properties</h3></div></div></div><div class="note"><p>This mechanism has been superseded by 'Test Filtering', described above.</p></div><p>Setting a system property of <span class="emphasis"><em>taskName.single</em></span> = <span class="emphasis"><em>testNamePattern</em></span> will only execute tests that match the specified <span class="emphasis"><em>testNamePattern</em></span>. The <span class="emphasis"><em>taskName</em></span> can be a full multi-project path like &ldquo;:sub1:sub2:test&rdquo; or just the task name. The <span class="emphasis"><em>testNamePattern</em></span> will be used to form an include pattern of &ldquo;**/testNamePattern*.class&rdquo;. If no tests with this pattern can be found, an exception is thrown. This is to shield you from false security. If tests of more than one subproject are executed, the pattern is applied to each subproject. An exception is thrown if no tests can be found for a particular subproject. In such a case you can use the path notation of the pattern, so that the pattern is applied only to the test task of a specific subproject. Alternatively you can specify the fully qualified task name to be executed. You can also specify multiple patterns. Examples:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">gradle -Dtest.single=ThisUniquelyNamedTest test</code></p></li><li class="listitem"><p><code class="literal">gradle -Dtest.single=a/b/ test</code></p></li><li class="listitem"><p><code class="literal">gradle -DintegTest.single=\*IntegrationTest integTest</code></p></li><li class="listitem"><p><code class="literal">gradle -D:proj1:test.single=Customer build</code></p></li><li class="listitem"><p><code class="literal">gradle -D:proj1:integTest.single=c/d/</code></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:test_detection" class="section-anchor" href="#sec:test_detection"></a>Test detection</h3></div></div></div><p>The <code class="literal">Test</code> task detects which classes are test classes by inspecting the compiled test classes. By default it scans all <code class="literal">.class</code> files. You can set custom includes / excludes, only those classes will be scanned. Depending on the test framework used (JUnit / TestNG) the test class detection uses different criteria.</p><p>When using JUnit, we scan for both JUnit 3 and 4 test classes. If any of the following criteria match, the class is considered to be a JUnit test class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Class or a super class extends <code class="literal">TestCase</code> or <code class="literal">GroovyTestCase</code></p></li><li class="listitem"><p>Class or a super class is annotated with <code class="literal">@RunWith</code></p></li><li class="listitem"><p>Class or a super class contain a method annotated with <code class="literal">@Test</code></p></li></ul></div><p>When using TestNG, we scan for methods annotated with <code class="literal">@Test</code>.</p><p>Note that abstract classes are not executed. Gradle also scans up the inheritance tree into jar files on the test classpath.</p><p>If you don&rsquo;t want to use test class detection, you can disable it by setting <code class="literal">scanForTestClasses</code> to false. This will make the test task only use includes / excludes to find test classes. If <code class="literal">scanForTestClasses</code> is false and no include / exclude patterns are specified, the defaults are &ldquo;<code class="literal">**/*Tests.class</code>&rdquo;, &ldquo;<code class="literal">**/*Test.class</code>&rdquo; and &ldquo;<code class="literal">**/Abstract*.class</code>&rdquo; for include and exclude, respectively.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test_grouping" class="section-anchor" href="#test_grouping"></a>Test grouping</h3></div></div></div><p>JUnit and TestNG allows sophisticated groupings of test methods.</p><p>For grouping JUnit test classes and methods JUnit 4.8 introduces the concept of categories.<sup>[<a href="#ftn.N17092" name="N17092" class="footnote">16</a>]</sup> The <code class="literal">test</code> task allows the specification of the JUnit categories you want to include and exclude.</p><div class="example"><a name="junitcategories"></a><p class="title"><b>Example&nbsp;411.&nbsp;JUnit Categories</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    useJUnit {
        includeCategories <span class="hl-string">'org.gradle.junit.CategoryA'</span>
        excludeCategories <span class="hl-string">'org.gradle.junit.CategoryB'</span>
    }
}
</pre></div></div><br class="example-break"><p>The TestNG framework has a quite similar concept. In TestNG you can specify different test groups.<sup>[<a href="#ftn.N170A9" name="N170A9" class="footnote">17</a>]</sup> The test groups that should be included or excluded from the test execution can be configured in the test task.</p><div class="example"><a name="testnggrouping"></a><p class="title"><b>Example&nbsp;412.&nbsp;Grouping TestNG tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    useTestNG {
        excludeGroups <span class="hl-string">'integrationTests'</span>
        includeGroups <span class="hl-string">'unitTests'</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test_execution_order" class="section-anchor" href="#test_execution_order"></a>Test execution order in TestNG</h3></div></div></div><p>TestNG allows explicit control of the execution order of tests.</p><p>The <code class="literal">preserveOrder</code> property controls whether tests are executed in deterministic order. Preserving the order guarantees that the complete test (including <code class="literal">@BeforeXXX</code> and <code class="literal">@AfterXXX</code>) is run in a test thread before the next test is run. While preserving the order of tests is the default behavior when directly working with <code class="literal">testng.xml</code> files, the <a class="ulink" href="https://jitpack.io/com/github/cbeust/testng/master/javadoc/org/testng/TestNG.html" target="_top">TestNG API</a>, that is used for running tests programmatically, as well as Gradle&rsquo;s TestNG integration execute tests in unpredictable order by default.<sup>[<a href="#ftn.N170D3" name="N170D3" class="footnote">18</a>]</sup> Preserving the order of tests was introduced with TestNG version 5.14.5. Setting the <code class="literal">preserveOrder</code> property to <code class="literal">true</code> for an older TestNG version will cause the build to fail.</p><div class="example"><a name="testngpreserveorder"></a><p class="title"><b>Example&nbsp;413.&nbsp;Preserving order of TestNG tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    useTestNG {
        preserveOrder true
    }
}
</pre></div></div><br class="example-break"><p>The <code class="literal">groupByInstance</code> property controls whether tests should be grouped by instances. Grouping by instances will result in resolving test method dependencies for each instance instead of running the dependees of all instances before running the dependants. The default behavior is not to group tests by instances.<sup>[<a href="#ftn.N170F3" name="N170F3" class="footnote">19</a>]</sup> Grouping tests by instances was introduced with TestNG version 6.1. Setting the <code class="literal">groupByInstances</code> property to <code class="literal">true</code> for an older TestNG version will cause the build to fail.</p><div class="example"><a name="testnggroupbyinstances"></a><p class="title"><b>Example&nbsp;414.&nbsp;Grouping TestNG tests by instances</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    useTestNG {
        groupByInstances true
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="test_reporting" class="section-anchor" href="#test_reporting"></a>Test reporting</h3></div></div></div><p>The <code class="literal">Test</code> task generates the following results by default.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An HTML test report.</p></li><li class="listitem"><p>The results in an XML format that is compatible with the Ant JUnit report task. This format is supported by many other tools, such as CI servers.</p></li><li class="listitem"><p>Results in an efficient binary format. The task generates the other results from these binary results.</p></li></ul></div><p>There is also a stand-alone <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.TestReport.html" target="_top"><code class="classname">TestReport</code></a> task type which can generate the HTML test report from the binary results generated by one or more <code class="literal">Test</code> task instances. To use this task type, you need to define a <code class="literal">destinationDir</code> and the test results to include in the report. Here is a sample which generates a combined report for the unit tests from subprojects:</p><div class="example"><a name="subProjectsTestReport"></a><p class="title"><b>Example&nbsp;415.&nbsp;Creating a unit test report for subprojects</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">subprojects {
    apply plugin: <span class="hl-string">'java'</span>

    <span class="hl-comment">// Disable the test report for the individual test task</span>
    test {
        reports.html.enabled = false
    }
}

task testReport(type: TestReport) {
    destinationDir = file(<span class="hl-string">"$buildDir/reports/allTests"</span>)
    <span class="hl-comment">// Include the results from the `test` task in all subprojects</span>
    reportOn subprojects*.test
}
</pre></div></div><br class="example-break"><p>You should note that the <code class="literal">TestReport</code> type combines the results from multiple test tasks and needs to aggregate the results of individual test classes. This means that if a given test class is executed by multiple test tasks, then the test report will include executions of that class, but it can be hard to distinguish individual executions of that class and their output.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="testNgParameterizedReporting" class="section-anchor" href="#testNgParameterizedReporting"></a>TestNG parameterized methods and reporting</h4></div></div></div><p>TestNG supports <a class="ulink" href="http://testng.org/doc/documentation-main.html#parameters" target="_top">parameterizing test methods</a>, allowing a particular test method to be executed multiple times with different inputs. Gradle includes the parameter values in its reporting of the test method execution.</p><p>Given a parameterized test method named <code class="literal">aTestMethod</code> that takes two parameters, it will be reported with the name: <code class="literal">aTestMethod(toStringValueOfParam1, toStringValueOfParam2)</code>. This makes identifying the parameter values for a particular iteration easy.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:convention_values" class="section-anchor" href="#sec:convention_values"></a>Test convention values</h3></div></div></div><div class="variablelist"><dl><dt><span class="term"><code class="literal">File testClassesDirs</code></span></dt><dd><p>Default value: <code class="literal">sourceSets.test.output.classesDirs</code></p></dd><dt><span class="term"><code class="literal"><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a> classpath</code></span></dt><dd><p>Default value: <code class="literal">sourceSets.test.runtimeClasspath</code></p></dd><dt><span class="term"><code class="literal">File testResultsDir</code></span></dt><dd><p>Default value: <code class="literal">testResultsDir</code></p></dd><dt><span class="term"><code class="literal">File testReportDir</code></span></dt><dd><p>Default value: <code class="literal">testReportDir</code></p></dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jar" class="section-anchor" href="#sec:jar"></a>Jar</h2></div></div></div><p>The <code class="literal">jar</code> task creates a JAR file containing the class files and resources of the project. The JAR file is declared as an artifact in the <code class="literal">archives</code> dependency configuration. This means that the JAR is available in the classpath of a dependent project. If you upload your project into a repository, this JAR is declared as part of the dependency descriptor. You can learn more about how to work with archives in <a class="xref" href="#sec:archives">the section called &ldquo;Creating archives&rdquo;</a> and artifact configurations in <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:manifest" class="section-anchor" href="#sub:manifest"></a>Manifest</h3></div></div></div><p>Each jar or war object has a <code class="literal">manifest</code> property with a separate instance of <a class="ulink" href="../javadoc/org/gradle/api/java/archives/Manifest.html" target="_top"><code class="classname">Manifest</code></a>. When the archive is generated, a corresponding <code class="literal">MANIFEST.MF</code> file is written into the archive.</p><div class="example"><a name="manifest"></a><p class="title"><b>Example&nbsp;416.&nbsp;Customization of MANIFEST.MF</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jar {
    manifest {
        attributes(<span class="hl-string">"Implementation-Title"</span>: <span class="hl-string">"Gradle"</span>,
                   <span class="hl-string">"Implementation-Version"</span>: version)
    }
}
</pre></div></div><br class="example-break"><p>You can create stand-alone instances of a <code class="literal">Manifest</code>. You can use that for example, to share manifest information between jars.</p><div class="example"><a name="manifest"></a><p class="title"><b>Example&nbsp;417.&nbsp;Creating a manifest object.</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ext.sharedManifest = manifest {
    attributes(<span class="hl-string">"Implementation-Title"</span>: <span class="hl-string">"Gradle"</span>,
               <span class="hl-string">"Implementation-Version"</span>: version)
}
task fooJar(type: Jar) {
    manifest = project.manifest {
        from sharedManifest
    }
}
</pre></div></div><br class="example-break"><p>You can merge other manifests into any <code class="literal">Manifest</code> object. The other manifests might be either described by a file path or, like in the example above, by a reference to another <code class="literal">Manifest</code> object.</p><div class="example"><a name="manifest"></a><p class="title"><b>Example&nbsp;418.&nbsp;Separate MANIFEST.MF for a particular archive</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task barJar(type: Jar) {
    manifest {
        attributes key1: <span class="hl-string">'value1'</span>
        from sharedManifest, <span class="hl-string">'src/config/basemanifest.txt'</span>
        from(<span class="hl-string">'src/config/javabasemanifest.txt'</span>,
             <span class="hl-string">'src/config/libbasemanifest.txt'</span>) {
            eachEntry { details -&gt;
                <span class="hl-keyword">if</span> (details.baseValue != details.mergeValue) {
                    details.value = baseValue
                }
                <span class="hl-keyword">if</span> (details.key == <span class="hl-string">'foo'</span>) {
                    details.exclude()
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Manifests are merged in the order they are declared by the <code class="literal">from</code> statement. If the base manifest and the merged manifest both define values for the same key, the merged manifest wins by default. You can fully customize the merge behavior by adding <code class="literal">eachEntry</code> actions in which you have access to a <a class="ulink" href="../javadoc/org/gradle/api/java/archives/ManifestMergeDetails.html" target="_top"><code class="classname">ManifestMergeDetails</code></a> instance for each entry of the resulting manifest. The merge is not immediately triggered by the from statement. It is done lazily, either when generating the jar, or by calling <code class="literal">writeTo</code> or <code class="literal">effectiveManifest</code></p><p>You can easily write a manifest to disk.</p><div class="example"><a name="manifest"></a><p class="title"><b>Example&nbsp;419.&nbsp;Saving a MANIFEST.MF to disk</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jar.manifest.writeTo(<span class="hl-string">"$buildDir/mymanifest.mf"</span>)
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:upload" class="section-anchor" href="#sec:upload"></a>Uploading</h2></div></div></div><p>How to upload your archives is described in <a class="xref" href="#artifact_management"><i>Publishing artifacts</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_cross_compilation" class="section-anchor" href="#sec:java_cross_compilation"></a>Compiling and testing Java 6/7</h2></div></div></div><p>Gradle can only run on Java version 7 or higher. However, support for running Gradle on Java 7 has been deprecated and is scheduled to be removed in Gradle 5.0. There are two reasons for deprecating support for Java 7:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Java 7 reached <a class="ulink" href="http://www.oracle.com/technetwork/java/javase/eol-135779.html" target="_top">end of life</a>. Therefore, Oracle ceased public availability of security fixes and upgrades for Java 7 as of April 2015.</p></li><li class="listitem"><p>Once support for Java 7 has ceased (likely with Gradle 5.0), Gradle&rsquo;s implementation can start to use Java 8 APIs optimized for performance and usability.</p></li></ul></div><p>Gradle still supports compiling, testing, generating Javadoc and executing applications for Java 6 and Java 7. Java 5 is not supported.</p><p>To use Java 6 or Java 7, the following tasks need to be configured:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">JavaCompile</code> task to fork and use the correct Java home</p></li><li class="listitem"><p><code class="literal">Javadoc</code> task to use the correct <code class="literal">javadoc</code> executable</p></li><li class="listitem"><p><code class="literal">Test</code> and the <code class="literal">JavaExec</code> task to use the correct <code class="literal">java</code> executable.</p></li></ul></div><p>The following sample shows how the <code class="literal">build.gradle</code> needs to be adjusted. In order to be able to make the build machine-independent, the location of the old Java home and target version should be configured in <code class="literal">GRADLE_USER_HOME/gradle.properties</code> <sup>[<a href="#ftn.N17224" name="N17224" class="footnote">20</a>]</sup> in the user&rsquo;s home directory on each developer machine, as shown in the example.</p><div class="example"><a name="javaCrossCompilation"></a><p class="title"><b>Example&nbsp;420.&nbsp;Configure Java 6 build</b></p><div class="example-contents"><p><code class="filename">gradle.properties</code></p><pre class="programlisting"># in $HOME/.gradle/gradle.properties
javaHome=/Library/Java/JavaVirtualMachines/1.7.0.jdk/Contents/Home
targetJavaVersion=1.7
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">assert hasProperty(<span class="hl-string">'javaHome'</span>): <span class="hl-string">"Set the property 'javaHome' in your your gradle.properties pointing to a Java 6 or 7 installation"</span>
assert hasProperty(<span class="hl-string">'targetJavaVersion'</span>): <span class="hl-string">"Set the property 'targetJavaVersion' in your your gradle.properties to '1.6' or '1.7'"</span>

sourceCompatibility = targetJavaVersion

def javaExecutablesPath = <span class="hl-keyword">new</span> File(javaHome, <span class="hl-string">'bin'</span>)
def javaExecutables = [:].withDefault { execName -&gt;
    def executable = <span class="hl-keyword">new</span> File(javaExecutablesPath, execName)
    assert executable.exists(): <span class="hl-string">"There is no ${execName} executable in ${javaExecutablesPath}"</span>
    executable
}
tasks.withType(AbstractCompile) {
    options.with {
        fork = true
        forkOptions.javaHome = file(javaHome)
    }
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}
</pre></div></div><br class="example-break"></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N17092" name="ftn.N17092" class="para">16</a>] </sup>The JUnit wiki contains a detailed description on how to work with JUnit categories: <a class="ulink" href="https://github.com/junit-team/junit/wiki/Categories" target="_top">https://github.com/junit-team/junit/wiki/Categories</a>.</p></div><div class="footnote"><p><sup>[<a href="#N170A9" name="ftn.N170A9" class="para">17</a>] </sup>The TestNG documentation contains more details about test groups: <a class="ulink" href="http://testng.org/doc/documentation-main.html#test-groups" target="_top">http://testng.org/doc/documentation-main.html#test-groups</a>.</p></div><div class="footnote"><p><sup>[<a href="#N170D3" name="ftn.N170D3" class="para">18</a>] </sup>The TestNG documentation contains more details about test ordering when working with <code class="literal">testng.xml</code> files: <a class="ulink" href="http://testng.org/doc/documentation-main.html#testng-xml" target="_top">http://testng.org/doc/documentation-main.html#testng-xml</a>.</p></div><div class="footnote"><p><sup>[<a href="#N170F3" name="ftn.N170F3" class="para">19</a>] </sup>The TestNG documentation contains more details about grouping tests by instances: <a class="ulink" href="http://testng.org/doc/documentation-main.html#dependencies-with-annotations" target="_top">http://testng.org/doc/documentation-main.html#dependencies-with-annotations</a>.</p></div><div class="footnote"><p><sup>[<a href="#N17224" name="ftn.N17224" class="para">20</a>] </sup>For more details on <code class="literal">gradle.properties</code> see <a class="xref" href="#sec:gradle_configuration_properties">the section called &ldquo;Gradle properties&rdquo;</a></p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="java_library_plugin"></a>The Java Library Plugin</h1></div></div></div><p>The Java Library plugin expands the capabilities of the Java plugin by providing specific knowledge about Java libraries. In particular, a Java library exposes an API to consumers (i.e., other projects using the Java or the Java Library plugin). All the source sets, tasks and configurations exposed by the Java plugin are implicitly available when using this plugin.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_usage" class="section-anchor" href="#sec:java_library_usage"></a>Usage</h2></div></div></div><p>To use the Java Library plugin, include the following in your build script:</p><div class="example"><a name="useJavaLibraryPlugin"></a><p class="title"><b>Example&nbsp;421.&nbsp;Using the Java Library plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-library'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_separation" class="section-anchor" href="#sec:java_library_separation"></a>API and implementation separation</h2></div></div></div><p>The key difference between the standard Java plugin and the Java Library plugin is that the latter introduces the concept of an <span class="emphasis"><em>API</em></span> exposed to consumers. A library is a Java component meant to be consumed by other components. It&rsquo;s a very common use case in multi-project builds, but also as soon as you have external dependencies.</p><p>The plugin exposes two <a class="link" href="#configurations">configurations</a> that can be used to declare dependencies: <code class="literal">api</code> and <code class="literal">implementation</code>. The <code class="literal">api</code> configuration should be used to declare dependencies which are exported by the library API, whereas the <code class="literal">implementation</code> configuration should be used to declare dependencies which are internal to the component.</p><div class="example"><a name="useJavaLibraryPlugin"></a><p class="title"><b>Example&nbsp;422.&nbsp;Declaring API and implementation dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    api <span class="hl-string">'commons-httpclient:commons-httpclient:3.1'</span>
    implementation <span class="hl-string">'org.apache.commons:commons-lang3:3.5'</span>
}
</pre></div></div><br class="example-break"><p>Dependencies appearing in the <code class="literal">api</code> configurations will be transitively exposed to consumers of the library, and as such will appear on the compile classpath of consumers. Dependencies found in the <code class="literal">implementation</code> configuration will, on the other hand, not be exposed to consumers, and therefore not leak into the consumers' compile classpath. This comes with several benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>dependencies do not leak into the compile classpath of consumers anymore, so you will never accidentally depend on a transitive dependency</p></li><li class="listitem"><p>faster compilation thanks to reduced classpath size</p></li><li class="listitem"><p>less recompilations when implementation dependencies change: consumers would not need to be recompiled</p></li><li class="listitem"><p>cleaner publishing: when used in conjunction with the new <code class="literal">maven-publish</code> plugin, Java libraries produce POM files that distinguish exactly between what is required to compile against the library and what is required to use the library at runtime (in other words, don&rsquo;t mix what is needed to compile the library itself and what is needed to compile against the library).</p></li></ul></div><div class="note"><p>The <code class="literal">compile</code> configuration still exists but should not be used as it will not offer the guarantees that the <code class="literal">api</code> and <code class="literal">implementation</code> configurations provide.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_recognizing_dependencies" class="section-anchor" href="#sec:java_library_recognizing_dependencies"></a>Recognizing API and implementation dependencies</h2></div></div></div><p>This section will help you spot API and Implementation dependencies in your code using simple rules of thumb. Basically, an API dependency is a type that is exposed in the library binary interface, often referred to ABI (Application Binary Interface). This includes, but is not limited to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>types used in super classes or interfaces</p></li><li class="listitem"><p>types used in public method parameters, including generic parameter types (where <span class="emphasis"><em>public</em></span> is something that is visible to compilers. I.e. , <span class="emphasis"><em>public</em></span>, <span class="emphasis"><em>protected</em></span> and <span class="emphasis"><em>package private</em></span> members in the Java world)</p></li><li class="listitem"><p>types used in public fields</p></li><li class="listitem"><p>public annotation types</p></li></ul></div><p>In opposition, any type that is used in the following list is irrelevant to the ABI, and therefore should be declared as <code class="literal">implementation</code> dependency:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>types exclusively used in method bodies</p></li><li class="listitem"><p>types exclusively used in private members</p></li><li class="listitem"><p>types exclusively found in internal classes (future versions of Gradle will let you declare which packages belong to the public API)</p></li></ul></div><p>In the following sample, we can make the difference between an API dependency and an implementation dependency:</p><div class="example"><a name="useJavaLibraryPlugin"></a><p class="title"><b>Example&nbsp;423.&nbsp;Making the difference between API and implementation</b></p><div class="example-contents"><p><code class="filename">src/main/java/org/gradle/HttpClientWrapper.java</code></p><pre class="programlisting"><span class="hl-comment">// The following types can appear anywhere in the code</span>
<span class="hl-comment">// but say nothing about API or implementation usage</span>
<span class="hl-keyword">import</span> org.apache.commons.httpclient.*;
<span class="hl-keyword">import</span> org.apache.commons.httpclient.methods.*;
<span class="hl-keyword">import</span> org.apache.commons.lang3.exception.ExceptionUtils;
<span class="hl-keyword">import</span> java.io.IOException;
<span class="hl-keyword">import</span> java.io.UnsupportedEncodingException;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> HttpClientWrapper {

    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> HttpClient client; <span class="hl-comment">// private member: implementation details</span>

    <span class="hl-comment">// HttpClient is used as a parameter of a public method</span>
    <span class="hl-comment">// so "leaks" into the public API of this component</span>
    <span class="hl-keyword">public</span> HttpClientWrapper(HttpClient client) {
        <span class="hl-keyword">this</span>.client = client;
    }

    <span class="hl-comment">// public methods belongs to your API</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">byte</span>[] doRawGet(String url) {
        GetMethod method = <span class="hl-keyword">new</span> GetMethod(url);
        <span class="hl-keyword">try</span> {
            <span class="hl-keyword">int</span> statusCode = doGet(method);
            <span class="hl-keyword">return</span> method.getResponseBody();

        } <span class="hl-keyword">catch</span> (Exception e) {
            ExceptionUtils.rethrow(e); <span class="hl-comment">// this dependency is internal only</span>
        } <span class="hl-keyword">finally</span> {
            method.releaseConnection();
        }
        <span class="hl-keyword">return</span> null;
    }

    <span class="hl-comment">// GetMethod is used in a private method, so doesn't belong to the API</span>
    <span class="hl-keyword">private</span> <span class="hl-keyword">int</span> doGet(GetMethod method) <span class="hl-keyword">throws</span> Exception {
        <span class="hl-keyword">int</span> statusCode = client.executeMethod(method);
        <span class="hl-keyword">if</span> (statusCode != HttpStatus.SC_OK) {
            System.err.println(<span class="hl-string">"Method failed: "</span> + method.getStatusLine());
        }
        <span class="hl-keyword">return</span> statusCode;
    }
}
</pre></div></div><br class="example-break"><p>We can see that our class imports third party classes, but imports alone won&rsquo;t tell us if a dependency is an API or implementation dependency. For this, we need to look at the methods. The public constructor of <code class="literal">HttpClientWrapper</code> uses <code class="literal">HttpClient</code> as a parameter, so it exposed to consumers and therefore belongs to the API.</p><p>On the other hand, the <code class="literal">ExceptionUtils</code> type, coming from the <code class="literal">commons-lang</code> library, is only used in a method body, so it&rsquo;s an implementation dependency.</p><p>Therefore, we can deduce that <code class="literal">commons-httpclient</code> is an API dependency, whereas <code class="literal">commons-lang</code> is an implementation dependency, which directly translates into the build file:</p><div class="example"><a name="useJavaLibraryPlugin"></a><p class="title"><b>Example&nbsp;424.&nbsp;Declaring API and implementation dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    api <span class="hl-string">'commons-httpclient:commons-httpclient:3.1'</span>
    implementation <span class="hl-string">'org.apache.commons:commons-lang3:3.5'</span>
}
</pre></div></div><br class="example-break"><p>As a guideline, you should prefer the <code class="literal">implementation</code> configuration first: leakage of implementation types to consumers would then directly lead to a compile error of consumers, which would be solved either by removing the type from the public API, or promoting the dependency as an API dependency instead.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_configurations_graph" class="section-anchor" href="#sec:java_library_configurations_graph"></a>The Java Library plugin configurations</h2></div></div></div><p>The following graph describes the main configurations setup when the Java Library plugin is in use.</p><div class="informalfigure"><div class="mediaobject"><img src="img/java-library-ignore-deprecated-main.png" alt="java library ignore deprecated main"></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The configurations in <span class="emphasis"><em>green</em></span> are the ones a user should use to declare dependencies</p></li><li class="listitem"><p>The configurations in <span class="emphasis"><em>pink</em></span> are the ones used when a component compiles, or runs against the library</p></li><li class="listitem"><p>The configurations in <span class="emphasis"><em>blue</em></span> are internal to the component, for its own use</p></li><li class="listitem"><p>The configurations in <span class="emphasis"><em>white</em></span> are configurations inherited from the Java plugin</p></li></ul></div><p>And the next graph describes the test configurations setup:</p><div class="informalfigure"><div class="mediaobject"><img src="img/java-library-ignore-deprecated-test.png" alt="java library ignore deprecated test"></div></div><div class="note"><p>The <span class="emphasis"><em>compile</em></span>, <span class="emphasis"><em>testCompile</em></span>, <span class="emphasis"><em>runtime</em></span> and <span class="emphasis"><em>testRuntime</em></span> configurations inherited from the Java plugin are still available but are deprecated. You should avoid using them, as they are only kept for backwards compatibility.</p></div><p>The role of each configuration is described in the following tables:</p><div class="table"><p class="title"><b>Table&nbsp;37.&nbsp;Java Library plugin - configurations used to declare dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1733F"><thead><tr>
<td>Configuration name</td>
<td>Role</td>
<td>Can be consumed</td>
<td>Can be resolved</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>api</p></td>
<td><p>Declaring API dependencies</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>This is where you should declare dependencies which are transitively exported to consumers, for compile.</p></td>
</tr><tr>
<td><p>implementation</p></td>
<td><p>Declaring implementation dependencies</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>This is where you should declare dependencies which are purely internal and not meant to be exposed to consumers.</p></td>
</tr><tr>
<td><p>compileOnly</p></td>
<td><p>Declaring compile only dependencies</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>This is where you should declare dependencies which are only required at compile time, but should not leak into the runtime. This typically includes dependencies which are shaded when found at runtime.</p></td>
</tr><tr>
<td><p>runtimeOnly</p></td>
<td><p>Declaring runtime dependencies</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>This is where you should declare dependencies which are only required at runtime, and not at compile time.</p></td>
</tr><tr>
<td><p>testImplementation</p></td>
<td><p>Test dependencies</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>This is where you should declare dependencies which are used to compile tests.</p></td>
</tr><tr>
<td><p>testCompileOnly</p></td>
<td><p>Declaring test compile only dependencies</p></td>
<td><p>yes</p></td>
<td><p>yes</p></td>
<td><p>This is where you should declare dependencies which are only required at test compile time, but should not leak into the runtime. This typically includes dependencies which are shaded when found at runtime.</p></td>
</tr><tr>
<td><p>testRuntimeOnly</p></td>
<td><p>Declaring test runtime dependencies</p></td>
<td><p>no</p></td>
<td><p>no</p></td>
<td><p>This is where you should declare dependencies which are only required at test runtime, and not at test compile time.</p></td>
</tr></tbody></table></div></div><div class="table"><p class="title"><b>Table&nbsp;38.&nbsp;Java Library plugin - configurations used by consumers</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N173F2"><thead><tr>
<td>Configuration name</td>
<td>Role</td>
<td>Can be consumed</td>
<td>Can be resolved</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>apiElements</p></td>
<td><p>For compiling against this library</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>This configuration is meant to be used by consumers, to retrieve all the elements necessary to compile against this library. Unlike the <code class="literal">default</code> configuration, this doesn&rsquo;t leak implementation or runtime dependencies.</p></td>
</tr><tr>
<td><p>runtimeElements</p></td>
<td><p>For executing this library</p></td>
<td><p>yes</p></td>
<td><p>no</p></td>
<td><p>This configuration is meant to be used by consumers, to retrieve all the elements necessary to run against this library.</p></td>
</tr></tbody></table></div></div><div class="table"><p class="title"><b>Table&nbsp;39.&nbsp;Java Library plugin - configurations used by the library itself</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1743A"><thead><tr>
<td>Configuration name</td>
<td>Role</td>
<td>Can be consumed</td>
<td>Can be resolved</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>compileClasspath</p></td>
<td><p>For compiling this library</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>This configuration contains the compile classpath of this library, and is therefore used when invoking the java compiler to compile it.</p></td>
</tr><tr>
<td><p>runtimeClasspath</p></td>
<td><p>For executing this library</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>This configuration contains the runtime classpath of this library</p></td>
</tr><tr>
<td><p>testCompileClasspath</p></td>
<td><p>For compiling the tests of this library</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>This configuration contains the test compile classpath of this library.</p></td>
</tr><tr>
<td><p>testRuntimeClasspath</p></td>
<td><p>For executing tests of this library</p></td>
<td><p>no</p></td>
<td><p>yes</p></td>
<td><p>This configuration contains the test runtime classpath of this library</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_known_issues" class="section-anchor" href="#sec:java_library_known_issues"></a>Known issues</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:java_library_known_issues_compat" class="section-anchor" href="#sec:java_library_known_issues_compat"></a>Compatibility with other plugins</h3></div></div></div><p>At the moment the Java Library plugin is only wired to behave correctly with the <code class="literal">java</code> plugin. Other plugins, such as the Groovy plugin, may not behave correctly. In particular, if the Groovy plugin is used in addition to the <code class="literal">java-library</code> plugin, then consumers may not get the Groovy classes when they consume the library. To workaround this, you need to explicitly wire the Groovy compile dependency, like this:</p><div class="example"><a name="useGroovyPlugin"></a><p class="title"><b>Example&nbsp;425.&nbsp;Configuring the Groovy plugin to work with Java Library</b></p><div class="example-contents"><p><code class="filename">a/build.gradle</code></p><pre class="programlisting">configurations {
    apiElements {
        outgoing.variants.getByName(<span class="hl-string">'classes'</span>).artifact(
            file: compileGroovy.destinationDir,
            type: ArtifactTypeDefinition.JVM_CLASS_DIRECTORY,
            builtBy: compileGroovy)
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:java_library_known_issues_memory" class="section-anchor" href="#sec:java_library_known_issues_memory"></a>Increased memory usage for consumers</h3></div></div></div><p>When a project uses the Java Library plugin, consumers will use the output classes directory of this project directly on their compile classpath, instead of the jar file if the project uses the Java plugin. An indirect consequence is that up-to-date checking will require more memory, because Gradle will snapshot individual class files instead of a single jar. This may lead to increased memory consumption for large projects.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="web_project_tutorial"></a>Web Application Quickstart</h1></div></div></div><div class="note"><p>This chapter is a work in progress.</p></div><p>This chapter introduces the Gradle support for web applications. Gradle recommends two plugins for web application development: the <a class="link" href="#war_plugin">War plugin</a> and the <a class="ulink" href="https://plugins.gradle.org/plugin/org.akhikhl.gretty" target="_top">Gretty plugin</a>. The War plugin extends the Java plugin to build a WAR file for your project. The Gretty plugin allows you to deploy your web application to an embedded Jetty web container.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:building_a_war_file" class="section-anchor" href="#sec:building_a_war_file"></a>Building a WAR file</h2></div></div></div><p>To build a WAR file, you apply the War plugin to your project:</p><div class="example"><a name="webQuickstart"></a><p class="title"><b>Example&nbsp;426.&nbsp;War plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'war'</span>
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/webApplication/quickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>This also applies the Java plugin to your project. Running <code class="literal">gradle build</code> will compile, test and WAR your project. Gradle will look for the source files to include in the WAR file in <code class="literal">src/main/webapp</code>. Your compiled classes and their runtime dependencies are also included in the WAR file, in the <code class="literal">WEB-INF/classes</code> and <code class="literal">WEB-INF/lib</code> directories, respectively.</p><div class="tip"><h3 class="title">Groovy web applications</h3><p>You can combine multiple plugins in a single project, so you can use the War and Groovy plugins together to build a Groovy based web application. The appropriate Groovy libraries will be added to the WAR file for you.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:running_your_web_application" class="section-anchor" href="#sec:running_your_web_application"></a>Running your web application</h2></div></div></div><p>To run your web application, you apply the Gretty plugin to your project:</p><div class="example"><a name="webQuickstart"></a><p class="title"><b>Example&nbsp;427.&nbsp;Running web application with Gretty plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath <span class="hl-string">'org.akhikhl.gretty:gretty:2.0.0'</span>
    }
}
apply plugin: <span class="hl-string">'org.akhikhl.gretty'</span>
</pre></div></div><br class="example-break"><p>This also applies the War plugin to your project. Running <code class="literal">gradle appRun</code> will run your web application in an embedded servlet container. Running <code class="literal">gradle appRunWar</code> will build the WAR file, and then run it in an embedded web container.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:web_tutorial_summary" class="section-anchor" href="#sec:web_tutorial_summary"></a>Summary</h2></div></div></div><p>You can find out more about the War plugin in <a class="xref" href="#war_plugin"><i>The War Plugin</i></a>. You can find more sample Java projects in the <code class="literal">samples/webApplication</code> directory in the Gradle distribution.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="war_plugin"></a>The War Plugin</h1></div></div></div><p>The War plugin extends the Java plugin to add support for assembling web application WAR files. It disables the default JAR archive generation of the Java plugin and adds a default WAR archive task.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_usage" class="section-anchor" href="#sec:war_usage"></a>Usage</h2></div></div></div><p>To use the War plugin, include the following in your build script:</p><div class="example"><a name="useWarPlugin"></a><p class="title"><b>Example&nbsp;428.&nbsp;Using the War plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'war'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_tasks" class="section-anchor" href="#sec:war_tasks"></a>Tasks</h2></div></div></div><p>The War plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;40.&nbsp;War plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1754A"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">war</code></p></td>
<td><p><code class="literal">compile</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.War.html" target="_top"><code class="classname">War</code></a></p></td>
<td><p>Assembles the application WAR file.</p></td>
</tr></tbody></table></div></div><p>The War plugin adds the following dependencies to tasks added by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;41.&nbsp;War plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17579"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p>assemble</p></td>
<td><p>war</p></td>
</tr></tbody></table></div></div><div class="figure"><a name="N17593"></a><p class="title"><b>Figure&nbsp;16.&nbsp;War plugin - tasks</b></p><div class="figure-contents"><img src="img/warPluginTasks.png" alt="War plugin - tasks"></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_project_layout" class="section-anchor" href="#sec:war_project_layout"></a>Project layout</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;42.&nbsp;War plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1759D"><thead><tr>
<td>Directory</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/webapp</code></p></td>
<td><p>Web application sources</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_dependency_management" class="section-anchor" href="#sec:war_dependency_management"></a>Dependency management</h2></div></div></div><p>The War plugin adds two dependency configurations named <code class="literal">providedCompile</code> and <code class="literal">providedRuntime</code>. Those two configurations have the same scope as the respective <code class="literal">compile</code> and <code class="literal">runtime</code> configurations, except that they are not added to the WAR archive. It is important to note that those <code class="literal">provided</code> configurations work transitively. Let&rsquo;s say you add <code class="literal">commons-httpclient:commons-httpclient:3.0</code> to any of the provided configurations. This dependency has a dependency on <code class="literal">commons-codec</code>. Because this is a &ldquo;provided&rdquo; configuration, this means that neither of these dependencies will be added to your WAR, even if the <code class="literal">commons-codec</code> library is an explicit dependency of your <code class="literal">compile</code> configuration. If you don&rsquo;t want this transitive behavior, simply declare your <code class="literal">provided</code> dependencies like <code class="literal">commons-httpclient:commons-httpclient:3.0@jar</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_convention_properties" class="section-anchor" href="#sec:war_convention_properties"></a>Convention properties</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;43.&nbsp;War plugin - directory properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N175E3"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">webAppDirName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">src/main/webapp</code></p></td>
<td><p>The name of the web application source directory, relative to the project directory.</p></td>
</tr><tr>
<td><p><code class="literal">webAppDir</code></p></td>
<td><p><code class="literal">File</code> (read-only)</p></td>
<td><p><code class="literal"><span class="emphasis"><em>projectDir</em></span>/<span class="emphasis"><em>webAppDirName</em></span></code></p></td>
<td><p>The web application source directory.</p></td>
</tr></tbody></table></div></div><p>These properties are provided by a <a class="ulink" href="../dsl/org.gradle.api.plugins.WarPluginConvention.html" target="_top"><code class="classname">WarPluginConvention</code></a> convention object.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_default_settings" class="section-anchor" href="#sec:war_default_settings"></a>War</h2></div></div></div><p>The default behavior of the War task is to copy the content of <code class="literal">src/main/webapp</code> to the root of the archive. Your <code class="literal">webapp</code> directory may of course contain a <code class="literal">WEB-INF</code> sub-directory, which may contain a <code class="literal">web.xml</code> file. Your compiled classes are compiled to <code class="literal">WEB-INF/classes</code>. All the dependencies of the <code class="literal">runtime</code> <sup>[<a href="#ftn.N17647" name="N17647" class="footnote">21</a>]</sup> configuration are copied to <code class="literal">WEB-INF/lib</code>.</p><p>The <a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.War.html" target="_top"><code class="classname">War</code></a> class in the API documentation has additional useful information.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:war_customizing" class="section-anchor" href="#sec:war_customizing"></a>Customizing</h2></div></div></div><p>Here is an example with the most important customization options:</p><div class="example"><a name="webproject"></a><p class="title"><b>Example&nbsp;429.&nbsp;Customization of war plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations {
   moreLibs
}

repositories {
   flatDir { dirs <span class="hl-string">"lib"</span> }
   jcenter()
}

dependencies {
    compile module(<span class="hl-string">":compile:1.0"</span>) {
        dependency <span class="hl-string">":compile-transitive-1.0@jar"</span>
        dependency <span class="hl-string">":providedCompile-transitive:1.0@jar"</span>
    }
    providedCompile <span class="hl-string">"javax.servlet:servlet-api:2.5"</span>
    providedCompile module(<span class="hl-string">":providedCompile:1.0"</span>) {
        dependency <span class="hl-string">":providedCompile-transitive:1.0@jar"</span>
    }
    runtime <span class="hl-string">":runtime:1.0"</span>
    providedRuntime <span class="hl-string">":providedRuntime:1.0@jar"</span>
    testCompile <span class="hl-string">"junit:junit:4.12"</span>
    moreLibs <span class="hl-string">":otherLib:1.0"</span>
}

war {
    from <span class="hl-string">'src/rootContent'</span> <span class="hl-comment">// adds a file-set to the root of the archive</span>
    webInf { from <span class="hl-string">'src/additionalWebInf'</span> } <span class="hl-comment">// adds a file-set to the WEB-INF dir.</span>
    classpath fileTree(<span class="hl-string">'additionalLibs'</span>) <span class="hl-comment">// adds a file-set to the WEB-INF/lib dir.</span>
    classpath configurations.moreLibs <span class="hl-comment">// adds a configuration to the WEB-INF/lib dir.</span>
    webXml = file(<span class="hl-string">'src/someWeb.xml'</span>) <span class="hl-comment">// copies a file to WEB-INF/web.xml</span>
}
</pre></div></div><br class="example-break"><p>Of course one can configure the different file-sets with a closure to define excludes and includes.</p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N17647" name="ftn.N17647" class="para">21</a>] </sup>The <code class="literal">runtime</code> configuration extends the <code class="literal">compile</code> configuration.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="ear_plugin"></a>The Ear Plugin</h1></div></div></div><p>The Ear plugin adds support for assembling web application EAR files. It adds a default EAR archive task. It doesn&rsquo;t require the Java plugin, but for projects that also use the Java plugin it disables the default JAR archive generation.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_usage" class="section-anchor" href="#sec:ear_usage"></a>Usage</h2></div></div></div><p>To use the Ear plugin, include the following in your build script:</p><div class="example"><a name="earWithWar"></a><p class="title"><b>Example&nbsp;430.&nbsp;Using the Ear plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'ear'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_tasks" class="section-anchor" href="#sec:ear_tasks"></a>Tasks</h2></div></div></div><p>The Ear plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;44.&nbsp;Ear plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1768A"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">ear</code></p></td>
<td><p><code class="literal">compile</code> (only if the Java plugin is also applied)</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a></p></td>
<td><p>Assembles the application EAR file.</p></td>
</tr></tbody></table></div></div><p>The Ear plugin adds the following dependencies to tasks added by the base plugin.</p><div class="table"><p class="title"><b>Table&nbsp;45.&nbsp;Ear plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N176BA"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p>assemble</p></td>
<td><p>ear</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_project_layout" class="section-anchor" href="#sec:ear_project_layout"></a>Project layout</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;46.&nbsp;Ear plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N176D8"><thead><tr>
<td>Directory</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/application</code></p></td>
<td><p>Ear resources, such as a META-INF directory</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_dependency_management" class="section-anchor" href="#sec:ear_dependency_management"></a>Dependency management</h2></div></div></div><p>The Ear plugin adds two dependency configurations: <code class="literal">deploy</code> and <code class="literal">earlib</code>. All dependencies in the <code class="literal">deploy</code> configuration are placed in the root of the EAR archive, and are <span class="emphasis"><em>not</em></span> transitive. All dependencies in the <code class="literal">earlib</code> configuration are placed in the 'lib' directory in the EAR archive and <span class="emphasis"><em>are</em></span> transitive.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_convention_properties" class="section-anchor" href="#sec:ear_convention_properties"></a>Convention properties</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;47.&nbsp;Ear plugin - directory properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1770F"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">appDirName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">src/main/application</code></p></td>
<td><p>The name of the application source directory, relative to the project directory.</p></td>
</tr><tr>
<td><p><code class="literal">libDirName</code></p></td>
<td><p><code class="literal">String</code></p></td>
<td><p><code class="literal">lib</code></p></td>
<td><p>The name of the lib directory inside the generated EAR.</p></td>
</tr><tr>
<td><p><code class="literal">deploymentDescriptor</code></p></td>
<td><p><code class="literal">org.gradle.plugins.<code class="literal">ear.descriptor.</code>DeploymentDescriptor</code></p></td>
<td><p>A deployment descriptor with sensible defaults named <code class="literal">application.xml</code></p></td>
<td><p>Metadata to generate a deployment descriptor file, e.g. <code class="literal">application.xml</code>. If this file already exists in the <code class="literal">appDirName/META-INF</code> then the existing file contents will be used and the explicit configuration in the <code class="literal">ear.deploymentDescriptor</code> will be ignored.</p></td>
</tr></tbody></table></div></div><p>These properties are provided by a <a class="ulink" href="../dsl/org.gradle.plugins.ear.EarPluginConvention.html" target="_top"><code class="classname">EarPluginConvention</code></a> convention object.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_default_settings" class="section-anchor" href="#sec:ear_default_settings"></a>Ear</h2></div></div></div><p>The default behavior of the Ear task is to copy the content of <code class="literal">src/main/application</code> to the root of the archive. If your <code class="literal">application</code> directory doesn&rsquo;t contain a <code class="literal">META-INF/application.xml</code> deployment descriptor then one will be generated for you.</p><p>The <a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a> class in the API documentation has additional useful information.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ear_customizing" class="section-anchor" href="#sec:ear_customizing"></a>Customizing</h2></div></div></div><p>Here is an example with the most important customization options:</p><div class="example"><a name="earCustomized"></a><p class="title"><b>Example&nbsp;431.&nbsp;Customization of ear plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'ear'</span>
apply plugin: <span class="hl-string">'java'</span>

repositories { mavenCentral() }

dependencies {
    <span class="hl-comment">// The following dependencies will be the ear modules and</span>
    <span class="hl-comment">// will be placed in the ear root</span>
    deploy project(path: <span class="hl-string">':war'</span>, configuration: <span class="hl-string">'archives'</span>)

    <span class="hl-comment">// The following dependencies will become ear libs and will</span>
    <span class="hl-comment">// be placed in a dir configured via the libDirName property</span>
    earlib group: <span class="hl-string">'log4j'</span>, name: <span class="hl-string">'log4j'</span>, version: <span class="hl-string">'1.2.15'</span>, ext: <span class="hl-string">'jar'</span>
}

ear {
    appDirName <span class="hl-string">'src/main/app'</span>  <span class="hl-comment">// use application metadata found in this folder</span>
    <span class="hl-comment">// put dependent libraries into APP-INF/lib inside the generated EAR</span>
    libDirName <span class="hl-string">'APP-INF/lib'</span>
    deploymentDescriptor {  <span class="hl-comment">// custom entries for application.xml:</span>
<span class="hl-comment">//      fileName = "application.xml"  // same as the default value</span>
<span class="hl-comment">//      version = "6"  // same as the default value</span>
        applicationName = <span class="hl-string">"customear"</span>
        initializeInOrder = true
        displayName = <span class="hl-string">"Custom Ear"</span>  <span class="hl-comment">// defaults to project.name</span>
        <span class="hl-comment">// defaults to project.description if not set</span>
        description = <span class="hl-string">"My customized EAR for the Gradle documentation"</span>
<span class="hl-comment">//      libraryDirectory = "APP-INF/lib"  // not needed, above libDirName setting does this</span>
<span class="hl-comment">//      module("my.jar", "java")  // won't deploy as my.jar isn't deploy dependency</span>
<span class="hl-comment">//      webModule("my.war", "/")  // won't deploy as my.war isn't deploy dependency</span>
        securityRole <span class="hl-string">"admin"</span>
        securityRole <span class="hl-string">"superadmin"</span>
        withXml { provider -&gt; <span class="hl-comment">// add a custom node to the XML</span>
            provider.asNode().appendNode(<span class="hl-string">"data-source"</span>, <span class="hl-string">"my/data/source"</span>)
        }
    }
}
</pre></div></div><br class="example-break"><p>You can also use customization options that the <a class="ulink" href="../dsl/org.gradle.plugins.ear.Ear.html" target="_top"><code class="classname">Ear</code></a> task provides, such as <code class="literal">from</code> and <code class="literal">metaInf</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:using_custom_app_xml" class="section-anchor" href="#sec:using_custom_app_xml"></a>Using custom descriptor file</h2></div></div></div><p>You may already have appropriate settings in a <code class="literal">application.xml</code> file and want to use that instead of configuring the <code class="literal">ear.deploymentDescriptor</code> section of the build script. To accommodate that goal, place the <code class="literal">META-INF/application.xml</code> in the right place inside your source folders (see the <code class="literal">appDirName</code> property). The file contents will be used and the explicit configuration in the <code class="literal">ear.deploymentDescriptor</code> will be ignored.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="jetty_plugin"></a>The Jetty Plugin</h1></div></div></div><div class="note"><p>This plugin has been removed as of Gradle 4.0. We recommend using the <a class="ulink" href="https://github.com/akhikhl/gretty" target="_top">Gretty plugin</a> instead.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="application_plugin"></a>The Application Plugin</h1></div></div></div><p>The Application plugin facilitates creating an executable JVM application. It makes it easy to start the application locally during development, and to package the application as a TAR and/or ZIP including operating system specific start scripts.</p><p>Applying the Application plugin also implicitly applies the <a class="link" href="#java_plugin">Java plugin</a>. The <code class="literal">main</code> source set is effectively the &ldquo;application&rdquo;.</p><p>Applying the Application plugin also implicitly applies the <a class="link" href="#distribution_plugin">Distribution plugin</a>. A <code class="literal">main</code> distribution is created that packages up the application, including code dependencies and generated start scripts.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:application_usage" class="section-anchor" href="#sec:application_usage"></a>Usage</h2></div></div></div><p>To use the application plugin, include the following in your build script:</p><div class="example"><a name="useApplicationPlugin"></a><p class="title"><b>Example&nbsp;432.&nbsp;Using the application plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'application'</span>
</pre></div></div><br class="example-break"><p>The only mandatory configuration for the plugin is the specification of the main class (i.e. entry point) of the application.</p><div class="example"><a name="useApplicationPlugin"></a><p class="title"><b>Example&nbsp;433.&nbsp;Configure the application main class</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">mainClassName = <span class="hl-string">"org.gradle.sample.Main"</span>
</pre></div></div><br class="example-break"><p>You can run the application by executing the <code class="literal">run</code> task (type: <a class="ulink" href="../dsl/org.gradle.api.tasks.JavaExec.html" target="_top"><code class="classname">JavaExec</code></a>). This will compile the main source set, and launch a new JVM with its classes (along with all runtime dependencies) as the classpath and using the specified main class. You can launch the application in debug mode with <code class="literal">gradle run --debug-jvm</code> (see <a class="ulink" href="../javadoc/org/gradle/api/tasks/JavaExec.html#setDebug-boolean-" target="_top"><code class="classname">JavaExec.setDebug(boolean)</code></a>).</p><p>If your application requires a specific set of JVM settings or system properties, you can configure the <code class="literal">applicationDefaultJvmArgs</code> property. These JVM arguments are applied to the <code class="literal">run</code> task and also considered in the generated start scripts of your distribution.</p><div class="example"><a name="configureApplicationDefaultJvmArgs"></a><p class="title"><b>Example&nbsp;434.&nbsp;Configure default JVM settings</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">applicationDefaultJvmArgs = [<span class="hl-string">"-Dgreeting.language=en"</span>]
</pre></div></div><br class="example-break"><p>If your application&rsquo;s start scripts should be in a different directory than <code class="literal">bin</code>, you can configure the <code class="literal">executableDir</code> property.</p><div class="example"><a name="configureApplicationDefaultJvmArgs"></a><p class="title"><b>Example&nbsp;435.&nbsp;Configure custom directory for start scripts</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">executableDir = <span class="hl-string">"custom_bin_dir"</span>
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_distribution" class="section-anchor" href="#sec:the_distribution"></a>The distribution</h3></div></div></div><p>A distribution of the application can be created, by way of the <a class="link" href="#distribution_plugin">Distribution plugin</a> (which is automatically applied). A <code class="literal">main</code> distribution is created with the following content:</p><div class="table"><p class="title"><b>Table&nbsp;48.&nbsp;Distribution content</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17844"><thead><tr>
<td>Location</td>
<td>Content</td>
</tr></thead><tbody><tr>
<td><p>(root dir)</p></td>
<td><p><code class="literal">src/dist</code></p></td>
</tr><tr>
<td><p><code class="literal">lib</code></p></td>
<td><p>All runtime dependencies and main source set class files.</p></td>
</tr><tr>
<td><p><code class="literal">bin</code></p></td>
<td><p>Start scripts (generated by <code class="literal">createStartScripts</code> task).</p></td>
</tr></tbody></table></div></div><p>Static files to be added to the distribution can be simply added to <code class="literal">src/dist</code>. More advanced customization can be done by configuring the <a class="ulink" href="../javadoc/org/gradle/api/file/CopySpec.html" target="_top"><code class="classname">CopySpec</code></a> exposed by the main distribution.</p><div class="example"><a name="includeTaskOutputInApplicationDistribution"></a><p class="title"><b>Example&nbsp;436.&nbsp;Include output from other tasks in the application distribution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">task createDocs {
    def docs = file(<span class="hl-string">"$buildDir/docs"</span>)
    outputs.dir docs
    doLast {
        docs.mkdirs()
        <span class="hl-keyword">new</span> File(docs, <span class="hl-string">"readme.txt"</span>).write(<span class="hl-string">"Read me!"</span>)
    }
}

distributions {
    main {
        contents {
            from(createDocs) {
                into <span class="hl-string">"docs"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>By specifying that the distribution should include the task&rsquo;s output files (see <a class="xref" href="#sec:task_inputs_outputs">the section called &ldquo;Task inputs and outputs&rdquo;</a>), Gradle knows that the task that produces the files must be invoked before the distribution can be assembled and will take care of this for you.</p><div class="example"><a name="dependentTaskForApplicationDistributionOutput"></a><p class="title"><b>Example&nbsp;437.&nbsp;Automatically creating files for distribution</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle distZip</code></strong></p><pre class="screen">&gt; gradle distZip
:createDocs
:compileJava
:processResources NO-SOURCE
:classes
:jar
:startScripts
:distZip

BUILD SUCCESSFUL in 0s
5 actionable tasks: 5 executed
</pre></div></div><br class="example-break"><p>You can run <code class="literal">gradle installDist</code> to create an image of the application in <code class="literal">build/install/<span class="emphasis"><em>projectName</em></span></code>. You can run <code class="literal">gradle distZip</code> to create a ZIP containing the distribution, <code class="literal">gradle distTar</code> to create an application TAR or <code class="literal">gradle assemble</code> to build both.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:customizing_start_script_generation" class="section-anchor" href="#sec:customizing_start_script_generation"></a>Customizing start script generation</h3></div></div></div><p>The application plugin can generate Unix (suitable for Linux, macOS etc.) and Windows start scripts out of the box. The start scripts launch a JVM with the specified settings defined as part of the original build and runtime environment (e.g. <code class="literal">JAVA_OPTS</code> env var). The default script templates are based on the same scripts used to launch Gradle itself, that ship as part of a Gradle distribution.</p><p>The start scripts are completely customizable. Please refer to the documentation of <a class="ulink" href="../dsl/org.gradle.jvm.application.tasks.CreateStartScripts.html" target="_top"><code class="classname">CreateStartScripts</code></a> for more details and customization examples.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:application_tasks" class="section-anchor" href="#sec:application_tasks"></a>Tasks</h2></div></div></div><p>The Application plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;49.&nbsp;Application plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N178C4"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">run</code></p></td>
<td><p><code class="literal">classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.JavaExec.html" target="_top"><code class="classname">JavaExec</code></a></p></td>
<td><p>Starts the application.</p></td>
</tr><tr>
<td><p><code class="literal">startScripts</code></p></td>
<td><p><code class="literal">jar</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/tasks/application/CreateStartScripts.html" target="_top"><code class="classname">CreateStartScripts</code></a></p></td>
<td><p>Creates OS specific scripts to run the project as a JVM application.</p></td>
</tr><tr>
<td><p><code class="literal">installDist</code></p></td>
<td><p><code class="literal">jar</code>, <code class="literal">startScripts</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Sync.html" target="_top"><code class="classname">Sync</code></a></p></td>
<td><p>Installs the application into a specified directory.</p></td>
</tr><tr>
<td><p><code class="literal">distZip</code></p></td>
<td><p><code class="literal">jar</code>, <code class="literal">startScripts</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a></p></td>
<td><p>Creates a full distribution ZIP archive including runtime libraries and OS specific scripts.</p></td>
</tr><tr>
<td><p><code class="literal">distTar</code></p></td>
<td><p><code class="literal">jar</code>, <code class="literal">startScripts</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a></p></td>
<td><p>Creates a full distribution TAR archive including runtime libraries and OS specific scripts.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:application_convention_properties" class="section-anchor" href="#sec:application_convention_properties"></a>Convention properties</h2></div></div></div><p>The application plugin adds some properties to the project, which you can use to configure its behaviour. See the <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> class in the API documentation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="java_library_distribution_plugin"></a>The Java Library Distribution Plugin</h1></div></div></div><div class="note"><p>The Java library distribution plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The Java library distribution plugin adds support for building a distribution ZIP for a Java library. The distribution contains the JAR file for the library and its dependencies.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_distribution_usage" class="section-anchor" href="#sec:java_library_distribution_usage"></a>Usage</h2></div></div></div><p>To use the Java library distribution plugin, include the following in your build script:</p><div class="example"><a name="usejavaLibraryPlugin"></a><p class="title"><b>Example&nbsp;438.&nbsp;Using the Java library distribution plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-library-distribution'</span>
</pre></div></div><br class="example-break"><p>To define the name for the distribution you have to set the <code class="literal">baseName</code> property as shown below:</p><div class="example"><a name="useApplicationPlugin"></a><p class="title"><b>Example&nbsp;439.&nbsp;Configure the distribution name</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">distributions {
    main{
        baseName = <span class="hl-string">'my-name'</span>
    }
}
</pre></div></div><br class="example-break"><p>The plugin builds a distribution for your library. The distribution will package up the runtime dependencies of the library. All files stored in <code class="literal">src/main/dist</code> will be added to the root of the archive distribution. You can run &ldquo;<code class="literal">gradle distZip</code>&rdquo; to create a ZIP file containing the distribution.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_library_distribution_tasks" class="section-anchor" href="#sec:java_library_distribution_tasks"></a>Tasks</h2></div></div></div><p>The Java library distribution plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;50.&nbsp;Java library distribution plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1799C"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">distZip</code></p></td>
<td><p><code class="literal">jar</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a></p></td>
<td><p>Creates a full distribution ZIP archive including runtime libraries.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="java_library_distribution_resources" class="section-anchor" href="#java_library_distribution_resources"></a>Including other resources in the distribution</h2></div></div></div><p>All of the files from the <code class="literal">src/dist</code> directory are copied. To include any static files in the distribution, simply arrange them in the <code class="literal">src/dist</code> directory, or add them to the content of the distribution.</p><div class="example"><a name="includeTaskOutputInApplicationDistribution"></a><p class="title"><b>Example&nbsp;440.&nbsp;Include files in the distribution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">distributions {
    main {
        baseName = <span class="hl-string">'my-name'</span>
        contents {
            from { <span class="hl-string">'src/dist'</span> }
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="tutorial_groovy_projects"></a>Groovy Quickstart</h1></div></div></div><p>To build a Groovy project, you use the <span class="emphasis"><em>Groovy plugin</em></span>. This plugin extends the Java plugin to add Groovy compilation capabilities to your project. Your project can contain Groovy source code, Java source code, or a mix of the two. In every other respect, a Groovy project is identical to a Java project, which we have already seen in <a class="xref" href="#tutorial_java_projects"><i>Java Quickstart</i></a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:a_basic_groovy_project" class="section-anchor" href="#sec:a_basic_groovy_project"></a>A basic Groovy project</h2></div></div></div><p>Let&rsquo;s look at an example. To use the Groovy plugin, add the following to your build file:</p><div class="example"><a name="groovyQuickstart"></a><p class="title"><b>Example&nbsp;441.&nbsp;Groovy plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/groovy/quickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>This will also apply the Java plugin to the project, if it has not already been applied. The Groovy plugin extends the <code class="literal">compile</code> task to look for source files in directory <code class="literal">src/main/groovy</code>, and the <code class="literal">compileTest</code> task to look for test source files in directory <code class="literal">src/test/groovy</code>. The compile tasks use joint compilation for these directories, which means they can contain a mixture of Java and Groovy source files.</p><p>To use the Groovy compilation tasks, you must also declare the Groovy version to use and where to find the Groovy libraries. You do this by adding a dependency to the <code class="literal">groovy</code> configuration. The <code class="literal">compile</code> configuration inherits this dependency, so the Groovy libraries will be included in classpath when compiling Groovy and Java source. For our sample, we will use Groovy 2.2.0 from the public Maven repository:</p><div class="example"><a name="groovyQuickstart"></a><p class="title"><b>Example&nbsp;442.&nbsp;Dependency on Groovy</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

dependencies {
    compile <span class="hl-string">'org.codehaus.groovy:groovy-all:2.4.10'</span>
}
</pre></div></div><br class="example-break"><p>Here is our complete build file:</p><div class="example"><a name="groovyQuickstart"></a><p class="title"><b>Example&nbsp;443.&nbsp;Groovy example - complete build file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'eclipse'</span>
apply plugin: <span class="hl-string">'groovy'</span>

repositories {
    mavenCentral()
}

dependencies {
    compile <span class="hl-string">'org.codehaus.groovy:groovy-all:2.4.10'</span>
    testCompile <span class="hl-string">'junit:junit:4.12'</span>
}
</pre></div></div><br class="example-break"><p>Running <code class="literal">gradle build</code> will compile, test and JAR your project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_tutorial_summary" class="section-anchor" href="#sec:groovy_tutorial_summary"></a>Summary</h2></div></div></div><p>This chapter describes a very simple Groovy project. Usually, a real project will require more than this. Because a Groovy project <span class="emphasis"><em>is</em></span> a Java project, whatever you can do with a Java project, you can also do with a Groovy project.</p><p>You can find out more about the Groovy plugin in <a class="xref" href="#groovy_plugin"><i>The Groovy Plugin</i></a>, and you can find more sample Groovy projects in the <code class="literal">samples/groovy</code> directory in the Gradle distribution.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="groovy_plugin"></a>The Groovy Plugin</h1></div></div></div><p>The Groovy plugin extends the Java plugin to add support for Groovy projects. It can deal with Groovy code, mixed Groovy and Java code, and even pure Java code (although we don&rsquo;t necessarily recommend to use it for the latter). The plugin supports <span class="emphasis"><em>joint compilation</em></span>, which allows you to freely mix and match Groovy and Java code, with dependencies in both directions. For example, a Groovy class can extend a Java class that in turn extends a Groovy class. This makes it possible to use the best language for the job, and to rewrite any class in the other language if needed.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_usage" class="section-anchor" href="#sec:groovy_usage"></a>Usage</h2></div></div></div><p>To use the Groovy plugin, include the following in your build script:</p><div class="example"><a name="useGroovyPlugin"></a><p class="title"><b>Example&nbsp;444.&nbsp;Using the Groovy plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'groovy'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_tasks" class="section-anchor" href="#sec:groovy_tasks"></a>Tasks</h2></div></div></div><p>The Groovy plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;51.&nbsp;Groovy plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17A67"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">compileGroovy</code></p></td>
<td><p><code class="literal">compileJava</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.compile.GroovyCompile.html" target="_top"><code class="classname">GroovyCompile</code></a></p></td>
<td><p>Compiles production Groovy source files.</p></td>
</tr><tr>
<td><p><code class="literal">compileTestGroovy</code></p></td>
<td><p><code class="literal">compileTestJava</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.compile.GroovyCompile.html" target="_top"><code class="classname">GroovyCompile</code></a></p></td>
<td><p>Compiles test Groovy source files.</p></td>
</tr><tr>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Groovy</code></p></td>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.compile.GroovyCompile.html" target="_top"><code class="classname">GroovyCompile</code></a></p></td>
<td><p>Compiles the given source set&rsquo;s Groovy source files.</p></td>
</tr><tr>
<td><p><code class="literal">groovydoc</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.javadoc.Groovydoc.html" target="_top"><code class="classname">Groovydoc</code></a></p></td>
<td><p>Generates API documentation for the production Groovy source files.</p></td>
</tr></tbody></table></div></div><p>The Groovy plugin adds the following dependencies to tasks added by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;52.&nbsp;Groovy plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17AE0"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">classes</code></p></td>
<td><p><code class="literal">compileGroovy</code></p></td>
</tr><tr>
<td><p><code class="literal">testClasses</code></p></td>
<td><p><code class="literal">compileTestGroovy</code></p></td>
</tr><tr>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes</code></p></td>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Groovy</code></p></td>
</tr></tbody></table></div></div><div class="figure"><a name="N17B19"></a><p class="title"><b>Figure&nbsp;17.&nbsp;Groovy plugin - tasks</b></p><div class="figure-contents"><img src="img/groovyPluginTasks.png" alt="Groovy plugin - tasks"></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_project_layout" class="section-anchor" href="#sec:groovy_project_layout"></a>Project layout</h2></div></div></div><p>The Groovy plugin assumes the project layout shown in <a class="xref" href="#groovylayout" title="Table&nbsp;53.&nbsp;Groovy plugin - project layout">Table&nbsp;53</a>. All the Groovy source directories can contain Groovy <span class="emphasis"><em>and</em></span> Java code. The Java source directories may only contain Java source code.<sup>[<a href="#ftn.N17B2B" name="N17B2B" class="footnote">22</a>]</sup> None of these directories need to exist or have anything in them; the Groovy plugin will simply compile whatever it finds.</p><div class="table"><p class="title"><b>Table&nbsp;53.&nbsp;Groovy plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="groovylayout"><thead><tr>
<td>Directory</td>
<td></td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/java</code></p></td>
<td></td>
<td><p>Production Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/main/resources</code></p></td>
<td></td>
<td><p>Production resources</p></td>
</tr><tr>
<td><p><code class="literal">src/main/groovy</code></p></td>
<td></td>
<td><p>Production Groovy sources. May also contain Java sources for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">src/test/java</code></p></td>
<td></td>
<td><p>Test Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/test/resources</code></p></td>
<td></td>
<td><p>Test resources</p></td>
</tr><tr>
<td><p><code class="literal">src/test/groovy</code></p></td>
<td></td>
<td><p>Test Groovy sources. May also contain Java sources for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/java</code></p></td>
<td></td>
<td><p>Java source for the given source set</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/resources</code></p></td>
<td></td>
<td><p>Resources for the given source set</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/groovy</code></p></td>
<td></td>
<td><p>Groovy sources for the given source set. May also contain Java sources for joint compilation.</p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:changing_groovy_project_layout" class="section-anchor" href="#sec:changing_groovy_project_layout"></a>Changing the project layout</h3></div></div></div><p>Just like the Java plugin, the Groovy plugin allows you to configure custom locations for Groovy production and test sources.</p><div class="example"><a name="customGroovySourceLayout"></a><p class="title"><b>Example&nbsp;445.&nbsp;Custom Groovy source layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    main {
        groovy {
            srcDirs = [<span class="hl-string">'src/groovy'</span>]
        }
    }

    test {
        groovy {
            srcDirs = [<span class="hl-string">'test/groovy'</span>]
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_dependency_management" class="section-anchor" href="#sec:groovy_dependency_management"></a>Dependency management</h2></div></div></div><p>Because Gradle&rsquo;s build language is based on Groovy, and parts of Gradle are implemented in Groovy, Gradle already ships with a Groovy library. Nevertheless, Groovy projects need to explicitly declare a Groovy dependency. This dependency will then be used on compile and runtime class paths. It will also be used to get hold of the Groovy compiler and Groovydoc tool, respectively.</p><p>If Groovy is used for production code, the Groovy dependency should be added to the <code class="literal">compile</code> configuration:</p><div class="example"><a name="quickstartGroovyDependency"></a><p class="title"><b>Example&nbsp;446.&nbsp;Configuration of Groovy dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

dependencies {
    compile <span class="hl-string">'org.codehaus.groovy:groovy-all:2.4.10'</span>
}
</pre></div></div><br class="example-break"><p>If Groovy is only used for test code, the Groovy dependency should be added to the <code class="literal">testCompile</code> configuration:</p><div class="example"><a name="groovyTestDependency"></a><p class="title"><b>Example&nbsp;447.&nbsp;Configuration of Groovy test dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    testCompile <span class="hl-string">'org.codehaus.groovy:groovy-all:2.4.10'</span>
}
</pre></div></div><br class="example-break"><p>To use the Groovy library that ships with Gradle, declare a <code class="literal">localGroovy()</code> dependency. Note that different Gradle versions ship with different Groovy versions; as such, using <code class="literal">localGroovy()</code> is less safe then declaring a regular Groovy dependency.</p><div class="example"><a name="bundledGroovyDependency"></a><p class="title"><b>Example&nbsp;448.&nbsp;Configuration of bundled Groovy dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile localGroovy()
}
</pre></div></div><br class="example-break"><p>The Groovy library doesn&rsquo;t necessarily have to come from a remote repository. It could also come from a local <code class="literal">lib</code> directory, perhaps checked in to source control:</p><div class="example"><a name="groovyFileDependency"></a><p class="title"><b>Example&nbsp;449.&nbsp;Configuration of Groovy file dependency</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    flatDir { dirs <span class="hl-string">'lib'</span> }
}

dependencies {
    compile module(<span class="hl-string">'org.codehaus.groovy:groovy:2.4.10'</span>) {
        dependency(<span class="hl-string">'org.ow2.asm:asm-all:5.0.3'</span>)
        dependency(<span class="hl-string">'antlr:antlr:2.7.7'</span>)
        dependency(<span class="hl-string">'commons-cli:commons-cli:1.2'</span>)
        module(<span class="hl-string">'org.apache.ant:ant:1.9.4'</span>) {
            dependencies(<span class="hl-string">'org.apache.ant:ant-junit:1.9.4@jar'</span>,
                         <span class="hl-string">'org.apache.ant:ant-launcher:1.9.4'</span>)
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:automatic_configuration_of_groovyclasspath" class="section-anchor" href="#sec:automatic_configuration_of_groovyclasspath"></a>Automatic configuration of groovyClasspath</h2></div></div></div><p>The <code class="literal">GroovyCompile</code> and <code class="literal">Groovydoc</code> tasks consume Groovy code in two ways: on their <code class="literal">classpath</code>, and on their <code class="literal">groovyClasspath</code>. The former is used to locate classes referenced by the source code, and will typically contain the Groovy library along with other libraries. The latter is used to load and execute the Groovy compiler and Groovydoc tool, respectively, and should only contain the Groovy library and its dependencies.</p><p>Unless a task&rsquo;s <code class="literal">groovyClasspath</code> is configured explicitly, the Groovy (base) plugin will try to infer it from the task&rsquo;s <code class="literal">classpath</code>. This is done as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If a <code class="literal">groovy-all(-indy)</code> Jar is found on <code class="literal">classpath</code>, that jar will be added to <code class="literal">groovyClasspath</code>.</p></li><li class="listitem"><p>If a <code class="literal">groovy(-indy)</code> jar is found on <code class="literal">classpath</code>, and the project has at least one repository declared, a corresponding <code class="literal">groovy(-indy)</code> repository dependency will be added to <code class="literal">groovyClasspath</code>.</p></li><li class="listitem"><p>Otherwise, execution of the task will fail with a message saying that <code class="literal">groovyClasspath</code> could not be inferred.</p></li></ul></div><p>Note that the &ldquo;<code class="literal">-indy</code>&rdquo; variation of each jar refers to the version with <code class="literal">invokedynamic</code> support.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_convention_properties" class="section-anchor" href="#sec:groovy_convention_properties"></a>Convention properties</h2></div></div></div><p>The Groovy plugin does not add any convention properties to the project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_source_set_properties" class="section-anchor" href="#sec:groovy_source_set_properties"></a>Source set properties</h2></div></div></div><p>The Groovy plugin adds the following convention properties to each source set in the project. You can use these properties in your build script as though they were properties of the source set object.</p><div class="table"><p class="title"><b>Table&nbsp;54.&nbsp;Groovy plugin - source set properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17C69"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">groovy</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> (read-only)</p></td>
<td><p>Not null</p></td>
<td><p>The Groovy source files of this source set. Contains all <code class="literal">.groovy</code> and <code class="literal">.java</code> files found in the Groovy source directories, and excludes all other types of files.</p></td>
</tr><tr>
<td><p><code class="literal">groovy.srcDirs</code></p></td>
<td><p><code class="literal">Set&lt;File&gt;</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></td>
<td><p><code class="literal">[<span class="emphasis"><em>projectDir</em></span>/src/<span class="emphasis"><em>name</em></span>/groovy]</code></p></td>
<td><p>The source directories containing the Groovy source files of this source set. May also contain Java source files for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">allGroovy</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a> (read-only)</p></td>
<td><p>Not null</p></td>
<td><p>All Groovy source files of this source set. Contains only the <code class="literal">.groovy</code> files found in the Groovy source directories.</p></td>
</tr></tbody></table></div></div><p>These properties are provided by a convention object of type <a class="ulink" href="../dsl/org.gradle.api.tasks.GroovySourceSet.html" target="_top"><code class="classname">GroovySourceSet</code></a>.</p><p>The Groovy plugin also modifies some source set properties:</p><div class="table"><p class="title"><b>Table&nbsp;55.&nbsp;Groovy plugin - source set properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17CDE"><thead><tr>
<td>Property name</td>
<td>Change</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">allJava</code></p></td>
<td><p>Adds all <code class="literal">.java</code> files found in the Groovy source directories.</p></td>
</tr><tr>
<td><p><code class="literal">allSource</code></p></td>
<td><p>Adds all source files found in the Groovy source directories.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovyCompile" class="section-anchor" href="#sec:groovyCompile"></a>GroovyCompile</h2></div></div></div><p>The Groovy plugin adds a <a class="ulink" href="../dsl/org.gradle.api.tasks.compile.GroovyCompile.html" target="_top"><code class="classname">GroovyCompile</code></a> task for each source set in the project. The task type extends the <code class="literal">JavaCompile</code> task (see <a class="xref" href="#sec:compile">the section called &ldquo;CompileJava&rdquo;</a>). The <code class="literal">GroovyCompile</code> task supports most configuration options of the official Groovy compiler.</p><div class="table"><p class="title"><b>Table&nbsp;56.&nbsp;Groovy plugin - GroovyCompile properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17D1B"><thead><tr>
<td>Task Property</td>
<td>Type</td>
<td>Default Value</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">classpath</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a></p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>.compileClasspath</code></p></td>
</tr><tr>
<td><p><code class="literal">source</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>.groovy</code></p></td>
</tr><tr>
<td><p><code class="literal">destinationDir</code></p></td>
<td><p><code class="literal">File</code>.</p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>.groovy.outputDir</code></p></td>
</tr><tr>
<td><p><code class="literal">groovyClasspath</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileCollection.html" target="_top"><code class="classname">FileCollection</code></a></p></td>
<td><p><code class="literal">groovy</code> configuration if non-empty; Groovy library found on <code class="literal">classpath</code> otherwise</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_cross_compilation" class="section-anchor" href="#sec:groovy_cross_compilation"></a>Compiling and testing for Java 6 or Java 7</h2></div></div></div><p>The Groovy compiler will always be executed with the same version of Java that was used to start Gradle. You should set <code class="literal">sourceCompatibility</code> and <code class="literal">targetCompatibility</code> to <code class="literal">1.6</code> or <code class="literal">1.7</code>. If you also have Java sources, you can follow the same steps as for the <a class="link" href="#sec:java_cross_compilation">Java plugin</a> to ensure the correct Java compiler is used.</p><div class="example"><a name="groovyCrossCompilation"></a><p class="title"><b>Example&nbsp;450.&nbsp;Configure Java 6 build for Groovy</b></p><div class="example-contents"><p><code class="filename">gradle.properties</code></p><pre class="programlisting"># in $HOME/.gradle/gradle.properties
java6Home=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceCompatibility = <span class="hl-number">1.6</span>
targetCompatibility = <span class="hl-number">1.6</span>

assert hasProperty(<span class="hl-string">'java6Home'</span>) : <span class="hl-string">"Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation"</span>
def javaExecutablesPath = <span class="hl-keyword">new</span> File(java6Home, <span class="hl-string">'bin'</span>)
def javaExecutables = [:].withDefault { execName -&gt;
    def executable = <span class="hl-keyword">new</span> File(javaExecutablesPath, execName)
    assert executable.exists() : <span class="hl-string">"There is no ${execName} executable in ${javaExecutablesPath}"</span>
    executable
}
tasks.withType(AbstractCompile) {
    options.with {
        fork = true
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}
</pre></div></div><br class="example-break"></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N17B2B" name="ftn.N17B2B" class="para">22</a>] </sup>We are using the same conventions as introduced by Russel Winder&rsquo;s Gant tool (<a class="ulink" href="https://gant.github.io/" target="_top">https://gant.github.io/</a>).</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="scala_plugin"></a>The Scala Plugin</h1></div></div></div><p>The Scala plugin extends the Java plugin to add support for Scala projects. It can deal with Scala code, mixed Scala and Java code, and even pure Java code (although we don&rsquo;t necessarily recommend to use it for the latter). The plugin supports <span class="emphasis"><em>joint compilation</em></span>, which allows you to freely mix and match Scala and Java code, with dependencies in both directions. For example, a Scala class can extend a Java class that in turn extends a Scala class. This makes it possible to use the best language for the job, and to rewrite any class in the other language if needed.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_usage" class="section-anchor" href="#sec:scala_usage"></a>Usage</h2></div></div></div><p>To use the Scala plugin, include the following in your build script:</p><div class="example"><a name="useScalaPlugin"></a><p class="title"><b>Example&nbsp;451.&nbsp;Using the Scala plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'scala'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_tasks" class="section-anchor" href="#sec:scala_tasks"></a>Tasks</h2></div></div></div><p>The Scala plugin adds the following tasks to the project.</p><div class="table"><p class="title"><b>Table&nbsp;57.&nbsp;Scala plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17DCC"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">compileScala</code></p></td>
<td><p><code class="literal">compileJava</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaCompile.html" target="_top"><code class="classname">ScalaCompile</code></a></p></td>
<td><p>Compiles production Scala source files.</p></td>
</tr><tr>
<td><p><code class="literal">compileTestScala</code></p></td>
<td><p><code class="literal">compileTestJava</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaCompile.html" target="_top"><code class="classname">ScalaCompile</code></a></p></td>
<td><p>Compiles test Scala source files.</p></td>
</tr><tr>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Scala</code></p></td>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaCompile.html" target="_top"><code class="classname">ScalaCompile</code></a></p></td>
<td><p>Compiles the given source set&rsquo;s Scala source files.</p></td>
</tr><tr>
<td><p><code class="literal">scaladoc</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.scala.ScalaDoc.html" target="_top"><code class="classname">ScalaDoc</code></a></p></td>
<td><p>Generates API documentation for the production Scala source files.</p></td>
</tr></tbody></table></div></div><p>The Scala plugin adds the following dependencies to tasks added by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;58.&nbsp;Scala plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17E45"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">classes</code></p></td>
<td><p><code class="literal">compileScala</code></p></td>
</tr><tr>
<td><p><code class="literal">testClasses</code></p></td>
<td><p><code class="literal">compileTestScala</code></p></td>
</tr><tr>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes</code></p></td>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Scala</code></p></td>
</tr></tbody></table></div></div><div class="figure"><a name="N17E7E"></a><p class="title"><b>Figure&nbsp;18.&nbsp;Scala plugin - tasks</b></p><div class="figure-contents"><img src="img/scalaPluginTasks.png" alt="Scala plugin - tasks"></div></div><br class="figure-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_project_layout" class="section-anchor" href="#sec:scala_project_layout"></a>Project layout</h2></div></div></div><p>The Scala plugin assumes the project layout shown below. All the Scala source directories can contain Scala <span class="emphasis"><em>and</em></span> Java code. The Java source directories may only contain Java source code. None of these directories need to exist or have anything in them; the Scala plugin will simply compile whatever it finds.</p><div class="table"><p class="title"><b>Table&nbsp;59.&nbsp;Scala plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="scalalayout"><thead><tr>
<td>Directory</td>
<td></td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/java</code></p></td>
<td></td>
<td><p>Production Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/main/resources</code></p></td>
<td></td>
<td><p>Production resources</p></td>
</tr><tr>
<td><p><code class="literal">src/main/scala</code></p></td>
<td></td>
<td><p>Production Scala sources. May also contain Java sources for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">src/test/java</code></p></td>
<td></td>
<td><p>Test Java source</p></td>
</tr><tr>
<td><p><code class="literal">src/test/resources</code></p></td>
<td></td>
<td><p>Test resources</p></td>
</tr><tr>
<td><p><code class="literal">src/test/scala</code></p></td>
<td></td>
<td><p>Test Scala sources. May also contain Java sources for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/java</code></p></td>
<td></td>
<td><p>Java source for the given source set</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/resources</code></p></td>
<td></td>
<td><p>Resources for the given source set</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/scala</code></p></td>
<td></td>
<td><p>Scala sources for the given source set. May also contain Java sources for joint compilation.</p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:changing_scala_project_layout" class="section-anchor" href="#sec:changing_scala_project_layout"></a>Changing the project layout</h3></div></div></div><p>Just like the Java plugin, the Scala plugin allows you to configure custom locations for Scala production and test sources.</p><div class="example"><a name="customScalaSourceLayout"></a><p class="title"><b>Example&nbsp;452.&nbsp;Custom Scala source layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceSets {
    main {
        scala {
            srcDirs = [<span class="hl-string">'src/scala'</span>]
        }
    }
    test {
        scala {
            srcDirs = [<span class="hl-string">'test/scala'</span>]
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_dependency_management" class="section-anchor" href="#sec:scala_dependency_management"></a>Dependency management</h2></div></div></div><p>Scala projects need to declare a <code class="literal">scala-library</code> dependency. This dependency will then be used on compile and runtime class paths. It will also be used to get hold of the Scala compiler and Scaladoc tool, respectively.<sup>[<a href="#ftn.N17F37" name="N17F37" class="footnote">23</a>]</sup></p><p>If Scala is used for production code, the <code class="literal">scala-library</code> dependency should be added to the <code class="literal">compile</code> configuration:</p><div class="example"><a name="declareScalaDependency"></a><p class="title"><b>Example&nbsp;453.&nbsp;Declaring a Scala dependency for production code</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

dependencies {
    compile <span class="hl-string">'org.scala-lang:scala-library:2.11.8'</span>
    testCompile <span class="hl-string">'org.scalatest:scalatest_2.11:3.0.0'</span>
    testCompile <span class="hl-string">'junit:junit:4.12'</span>
}
</pre></div></div><br class="example-break"><p>If Scala is only used for test code, the <code class="literal">scala-library</code> dependency should be added to the <code class="literal">testCompile</code> configuration:</p><div class="example"><a name="declareScalaTestDependency"></a><p class="title"><b>Example&nbsp;454.&nbsp;Declaring a Scala dependency for test code</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    testCompile <span class="hl-string">"org.scala-lang:scala-library:2.11.1"</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configure_scala_classpath" class="section-anchor" href="#sec:configure_scala_classpath"></a>Automatic configuration of scalaClasspath</h2></div></div></div><p>The <code class="literal">ScalaCompile</code> and <code class="literal">ScalaDoc</code> tasks consume Scala code in two ways: on their <code class="literal">classpath</code>, and on their <code class="literal">scalaClasspath</code>. The former is used to locate classes referenced by the source code, and will typically contain <code class="literal">scala-library</code> along with other libraries. The latter is used to load and execute the Scala compiler and Scaladoc tool, respectively, and should only contain the <code class="literal">scala-compiler</code> library and its dependencies.</p><p>Unless a task&rsquo;s <code class="literal">scalaClasspath</code> is configured explicitly, the Scala (base) plugin will try to infer it from the task&rsquo;s <code class="literal">classpath</code>. This is done as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If a <code class="literal">scala-library</code> jar is found on <code class="literal">classpath</code>, and the project has at least one repository declared, a corresponding <code class="literal">scala-compiler</code> repository dependency will be added to <code class="literal">scalaClasspath</code>.</p></li><li class="listitem"><p>Otherwise, execution of the task will fail with a message saying that <code class="literal">scalaClasspath</code> could not be inferred.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configure_zinc_compiler" class="section-anchor" href="#sec:configure_zinc_compiler"></a>Configuring the Zinc compiler</h2></div></div></div><p>The Scala plugin uses a configuration named <code class="literal">zinc</code> to resolve the <a class="ulink" href="https://github.com/typesafehub/zinc" target="_top">Zinc compiler</a> and its dependencies. Gradle will provide a default version of Zinc, but if you need to use a particular Zinc version, you can add an explicit dependency like <code class="literal">&ldquo;com.typesafe.zinc:zinc:0.3.6&rdquo;</code> to the <code class="literal">zinc</code> configuration. Gradle supports version 0.3.0 of Zinc and above; however, due to a regression in the Zinc compiler, versions 0.3.2 through 0.3.5.2 cannot be used.</p><div class="example"><a name="declareZincDependency"></a><p class="title"><b>Example&nbsp;455.&nbsp;Declaring a version of the Zinc compiler to use</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    zinc <span class="hl-string">'com.typesafe.zinc:zinc:0.3.9'</span>
}
</pre></div></div><br class="example-break"><div class="note"><p>It is important to take care when declaring your <code class="literal">scala-library</code> dependency. The Zinc compiler itself needs a compatible version of <code class="literal">scala-library</code> that may be different from the version required by your application. Gradle takes care of adding a compatible version of <code class="literal">scala-library</code> for you, but over-broad dependency resolution rules could force an incompatible version to be used instead.</p><p>For example, using <code class="literal">configurations.all</code> to force a particular version of <code class="literal">scala-library</code> would also override the version used by the Zinc compiler:</p><div class="example"><a name="allScalaLibraryDependency"></a><p class="title"><b>Example&nbsp;456.&nbsp;Forcing a scala-library dependency for all configurations</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.all {
    resolutionStrategy.force <span class="hl-string">"org.scala-lang:scala-library:2.11.7"</span>
}
</pre></div></div><br class="example-break"><p>The best way to avoid this problem is to be more selective when configuring the <code class="literal">scala-library</code> dependency (such as not using a <code class="literal">configuration.all</code> rule or using a conditional to prevent the rule from being applied to the <code class="literal">zinc</code> configuration). Sometimes this rule may come from a plugin or other code that you do not have control over. In such a case, you can force a correct version of the library on the <code class="literal">zinc</code> configuration only:</p><div class="example"><a name="zincScalaLibraryDependency"></a><p class="title"><b>Example&nbsp;457.&nbsp;Forcing a scala-library dependency for the zinc configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">configurations.zinc {
    resolutionStrategy.force <span class="hl-string">"org.scala-lang:scala-library:2.10.5"</span>
}
</pre></div></div><br class="example-break"><p>You can diagnose problems with the version of the Zinc compiler selected by running <a class="link" href="#">dependencyInsight</a> for the <code class="literal">zinc</code> configuration.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_convention_properties" class="section-anchor" href="#sec:scala_convention_properties"></a>Convention properties</h2></div></div></div><p>The Scala plugin does not add any convention properties to the project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_source_set_properties" class="section-anchor" href="#sec:scala_source_set_properties"></a>Source set properties</h2></div></div></div><p>The Scala plugin adds the following convention properties to each source set in the project. You can use these properties in your build script as though they were properties of the source set object.</p><div class="table"><p class="title"><b>Table&nbsp;60.&nbsp;Scala plugin - source set properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N17FFF"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">scala</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> (read-only)</p></td>
<td><p>Not null</p></td>
<td><p>The Scala source files of this source set. Contains all <code class="literal">.scala</code> and <code class="literal">.java</code> files found in the Scala source directories, and excludes all other types of files.</p></td>
</tr><tr>
<td><p><code class="literal">scala.srcDirs</code></p></td>
<td><p><code class="literal">Set&lt;File&gt;</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></td>
<td><p><code class="literal">[<span class="emphasis"><em>projectDir</em></span>/src/<span class="emphasis"><em>name</em></span>/scala]</code></p></td>
<td><p>The source directories containing the Scala source files of this source set. May also contain Java source files for joint compilation.</p></td>
</tr><tr>
<td><p><code class="literal">allScala</code></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/file/FileTree.html" target="_top"><code class="classname">FileTree</code></a> (read-only)</p></td>
<td><p>Not null</p></td>
<td><p>All Scala source files of this source set. Contains only the <code class="literal">.scala</code> files found in the Scala source directories.</p></td>
</tr></tbody></table></div></div><p>These convention properties are provided by a convention object of type <a class="ulink" href="../dsl/org.gradle.api.tasks.ScalaSourceSet.html" target="_top"><code class="classname">ScalaSourceSet</code></a>.</p><p>The Scala plugin also modifies some source set properties:</p><div class="table"><p class="title"><b>Table&nbsp;61.&nbsp;Scala plugin - source set properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18074"><thead><tr>
<td>Property name</td>
<td>Change</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">allJava</code></p></td>
<td><p>Adds all <code class="literal">.java</code> files found in the Scala source directories.</p></td>
</tr><tr>
<td><p><code class="literal">allSource</code></p></td>
<td><p>Adds all source files found in the Scala source directories.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_compiling_in_external_process" class="section-anchor" href="#sec:scala_compiling_in_external_process"></a>Compiling in external process</h2></div></div></div><p>Scala compilation takes place in an external process.</p><p>Memory settings for the external process default to the defaults of the JVM. To adjust memory settings, configure the <code class="literal">scalaCompileOptions.forkOptions</code> property as needed:</p><div class="example"><a name="zinc"></a><p class="title"><b>Example&nbsp;458.&nbsp;Adjusting memory settings</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.withType(ScalaCompile) {
    configure(scalaCompileOptions.forkOptions) {
        memoryMaximumSize = <span class="hl-string">'1g'</span>
        jvmArgs = [<span class="hl-string">'-XX:MaxPermSize=512m'</span>]
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_incremental_compilation" class="section-anchor" href="#sec:scala_incremental_compilation"></a>Incremental compilation</h2></div></div></div><p>By compiling only classes whose source code has changed since the previous compilation, and classes affected by these changes, incremental compilation can significantly reduce Scala compilation time. It is particularly effective when frequently compiling small code increments, as is often done at development time.</p><p>The Scala plugin defaults to incremental compilation by integrating with <a class="ulink" href="https://github.com/typesafehub/zinc" target="_top">Zinc</a>, a standalone version of <a class="ulink" href="https://github.com/harrah/xsbt" target="_top">sbt</a>'s incremental Scala compiler. If you want to disable the incremental compilation, set <code class="literal">force = true</code> in your build file:</p><div class="example"><a name="zinc"></a><p class="title"><b>Example&nbsp;459.&nbsp;Forcing all code to be compiled</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.withType(ScalaCompile) {
    scalaCompileOptions.with {
        force = true
    }
}
</pre></div></div><br class="example-break"><p><span class="emphasis"><em>Note:</em></span> This will only cause all classes to be recompiled if at least one input source file has changed. If there are no changes to the source files, the <code class="literal">compileScala</code> task will still be considered <code class="literal">UP-TO-DATE</code> as usual.</p><p>The Zinc-based Scala Compiler supports joint compilation of Java and Scala code. By default, all Java and Scala code under <code class="literal">src/main/scala</code> will participate in joint compilation. Even Java code will be compiled incrementally.</p><p>Incremental compilation requires dependency analysis of the source code. The results of this analysis are stored in the file designated by <code class="literal">scalaCompileOptions.incrementalOptions.analysisFile</code> (which has a sensible default). In a multi-project build, analysis files are passed on to downstream <code class="literal">ScalaCompile</code> tasks to enable incremental compilation across project boundaries. For <code class="literal">ScalaCompile</code> tasks added by the Scala plugin, no configuration is necessary to make this work. For other <code class="literal">ScalaCompile</code> tasks that you might add, the property <code class="literal">scalaCompileOptions.incrementalOptions.publishedCode</code> needs to be configured to point to the classes folder or Jar archive by which the code is passed on to compile class paths of downstream <code class="literal">ScalaCompile</code> tasks. Note that if <code class="literal">publishedCode</code> is not set correctly, downstream tasks may not recompile code affected by upstream changes, leading to incorrect compilation results.</p><p>Note that Zinc&rsquo;s Nailgun based daemon mode is not supported. Instead, we plan to enhance Gradle&rsquo;s own compiler daemon to stay alive across Gradle invocations, reusing the same Scala compiler. This is expected to yield another significant speedup for Scala compilation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:scala_cross_compilation" class="section-anchor" href="#sec:scala_cross_compilation"></a>Compiling and testing for Java 6 or Java 7</h2></div></div></div><p>The Scala compiler ignores Gradle&rsquo;s <code class="literal">targetCompatibility</code> and <code class="literal">sourceCompatibility</code> settings. In Scala 2.11, the Scala compiler always compiles to Java 6 compatible bytecode. In Scala 2.12, the Scala compiler always compiles to Java 8 compatible bytecode. If you also have Java sources, you can follow the same steps as for the <a class="link" href="#sec:java_cross_compilation">Java plugin</a> to ensure the correct Java compiler is used.</p><div class="example"><a name="scalaCrossCompilation"></a><p class="title"><b>Example&nbsp;460.&nbsp;Configure Java 6 build for Scala</b></p><div class="example-contents"><p><code class="filename">gradle.properties</code></p><pre class="programlisting"># in $HOME/.gradle/gradle.properties
java6Home=/Library/Java/JavaVirtualMachines/1.6.0.jdk/Contents/Home
</pre><p><code class="filename">build.gradle</code></p><pre class="programlisting">sourceCompatibility = <span class="hl-number">1.6</span>

assert hasProperty(<span class="hl-string">'java6Home'</span>) : <span class="hl-string">"Set the property 'java6Home' in your your gradle.properties pointing to a Java 6 installation"</span>
def javaExecutablesPath = <span class="hl-keyword">new</span> File(java6Home, <span class="hl-string">'bin'</span>)
def javaExecutables = [:].withDefault { execName -&gt;
    def executable = <span class="hl-keyword">new</span> File(javaExecutablesPath, execName)
    assert executable.exists() : <span class="hl-string">"There is no ${execName} executable in ${javaExecutablesPath}"</span>
    executable
}

tasks.withType(AbstractCompile) {
    options.with {
        fork = true
        forkOptions.javaHome = file(java6Home)
    }
}
tasks.withType(Test) {
    executable = javaExecutables.java
}
tasks.withType(JavaExec) {
    executable = javaExecutables.java
}
tasks.withType(Javadoc) {
    executable = javaExecutables.javadoc
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:eclipse_integration" class="section-anchor" href="#sec:eclipse_integration"></a>Eclipse Integration</h2></div></div></div><p>When the Eclipse plugin encounters a Scala project, it adds additional configuration to make the project work with Scala IDE out of the box. Specifically, the plugin adds a Scala nature and dependency container.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:intellij_idea_integration" class="section-anchor" href="#sec:intellij_idea_integration"></a>IntelliJ IDEA Integration</h2></div></div></div><p>When the IDEA plugin encounters a Scala project, it adds additional configuration to make the project work with IDEA out of the box. Specifically, the plugin adds a Scala SDK (IntelliJ IDEA 14+) and a Scala compiler library that matches the Scala version on the project&rsquo;s class path. The Scala plugin is backwards compatible with earlier versions of IntelliJ IDEA and it is possible to add a Scala facet instead of the default Scala SDK by configuring <code class="literal">targetVersion</code> on <a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html" target="_top"><code class="classname">IdeaModel</code></a>.</p><div class="example"><a name="ideaTargetVersion"></a><p class="title"><b>Example&nbsp;461.&nbsp;Explicitly specify a target IntelliJ IDEA version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">idea {
    targetVersion = <span class="hl-string">"13"</span>
}
</pre></div></div><br class="example-break"></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#N17F37" name="ftn.N17F37" class="para">23</a>] </sup>See <a class="xref" href="#sec:configure_scala_classpath">the section called &ldquo;Automatic configuration of scalaClasspath&rdquo;</a>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="antlr_plugin"></a>The ANTLR Plugin</h1></div></div></div><p>The ANTLR plugin extends the Java plugin to add support for generating parsers using <a class="ulink" href="http://www.antlr.org/" target="_top">ANTLR</a>.</p><div class="note"><p>The ANTLR plugin supports ANTLR version 2, 3 and 4.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_usage" class="section-anchor" href="#sec:antlr_usage"></a>Usage</h2></div></div></div><p>To use the ANTLR plugin, include the following in your build script:</p><div class="example"><a name="useAntlrPlugin"></a><p class="title"><b>Example&nbsp;462.&nbsp;Using the ANTLR plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'antlr'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_tasks" class="section-anchor" href="#sec:antlr_tasks"></a>Tasks</h2></div></div></div><p>The ANTLR plugin adds a number of tasks to your project, as shown below.</p><div class="table"><p class="title"><b>Table&nbsp;62.&nbsp;ANTLR plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18158"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">generateGrammarSource</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a></p></td>
<td><p>Generates the source files for all production ANTLR grammars.</p></td>
</tr><tr>
<td><p><code class="literal">generateTestGrammarSource</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a></p></td>
<td><p>Generates the source files for all test ANTLR grammars.</p></td>
</tr><tr>
<td><p><code class="literal">generate<span class="emphasis"><em>SourceSet</em></span>GrammarSource</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a></p></td>
<td><p>Generates the source files for all ANTLR grammars for the given source set.</p></td>
</tr></tbody></table></div></div><p>The ANTLR plugin adds the following dependencies to tasks added by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;63.&nbsp;ANTLR plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N181B5"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">compileJava</code></p></td>
<td><p><code class="literal">generateGrammarSource</code></p></td>
</tr><tr>
<td><p><code class="literal">compileTestJava</code></p></td>
<td><p><code class="literal">generateTestGrammarSource</code></p></td>
</tr><tr>
<td><p><code class="literal">compile<span class="emphasis"><em>SourceSet</em></span>Java</code></p></td>
<td><p><code class="literal">generate<span class="emphasis"><em>SourceSet</em></span>GrammarSource</code></p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_project_layout" class="section-anchor" href="#sec:antlr_project_layout"></a>Project layout</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;64.&nbsp;ANTLR plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N181F3"><thead><tr>
<td>Directory</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">src/main/antlr</code></p></td>
<td><p>Production ANTLR grammar files. If the ANTLR grammar is organized in packages, the structure in the antlr folder should reflect the package structure. This ensures that the generated sources end up in the correct target subfolder.</p></td>
</tr><tr>
<td><p><code class="literal">src/test/antlr</code></p></td>
<td><p>Test ANTLR grammar files.</p></td>
</tr><tr>
<td><p><code class="literal">src/<span class="emphasis"><em>sourceSet</em></span>/antlr</code></p></td>
<td><p>ANTLR grammar files for the given source set.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_dependency_management" class="section-anchor" href="#sec:antlr_dependency_management"></a>Dependency management</h2></div></div></div><p>The ANTLR plugin adds an <code class="literal">antlr</code> dependency configuration which provides the ANTLR implementation to use. The following example shows how to use ANTLR version 3.</p><div class="example"><a name="declareAntlrVersion"></a><p class="title"><b>Example&nbsp;463.&nbsp;Declare ANTLR version</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}

dependencies {
    antlr <span class="hl-string">"org.antlr:antlr:3.5.2"</span> <span class="hl-comment">// use ANTLR version 3</span>
    <span class="hl-comment">// antlr "org.antlr:antlr4:4.5" // use ANTLR version 4</span>
}
</pre></div></div><br class="example-break"><p>If no dependency is declared, <code class="literal">antlr:antlr:2.7.7</code> will be used as the default. To use a different ANTLR version add the appropriate dependency to the <code class="literal">antlr</code> dependency configuration as above.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_convention_properties" class="section-anchor" href="#sec:antlr_convention_properties"></a>Convention properties</h2></div></div></div><p>The ANTLR plugin does not add any convention properties.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:antlr_source_set_properties" class="section-anchor" href="#sec:antlr_source_set_properties"></a>Source set properties</h2></div></div></div><p>The ANTLR plugin adds the following properties to each source set in the project.</p><div class="table"><p class="title"><b>Table&nbsp;65.&nbsp;ANTLR plugin - source set properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1824E"><thead><tr>
<td>Property name</td>
<td>Type</td>
<td>Default value</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">antlr</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.file.SourceDirectorySet.html" target="_top"><code class="classname">SourceDirectorySet</code></a> (read-only)</p></td>
<td><p>Not null</p></td>
<td><p>The ANTLR grammar files of this source set. Contains all <code class="literal">.g</code> or <code class="literal">.g4</code> files found in the ANTLR source directories, and excludes all other types of files.</p></td>
</tr><tr>
<td><p><code class="literal">antlr.srcDirs</code></p></td>
<td><p><code class="literal">Set&lt;File&gt;</code>. Can set using anything described in <a class="xref" href="#sec:specifying_multiple_files">the section called &ldquo;Specifying a set of input files&rdquo;</a>.</p></td>
<td><p><code class="literal">[<span class="emphasis"><em>projectDir</em></span>/src/<span class="emphasis"><em>name</em></span>/antlr]</code></p></td>
<td><p>The source directories containing the ANTLR grammar files of this source set.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:controlling_the_antlr_generator_process" class="section-anchor" href="#sec:controlling_the_antlr_generator_process"></a>Controlling the ANTLR generator process</h2></div></div></div><p>The ANTLR tool is executed in a forked process. This allows fine grained control over memory settings for the ANTLR process. To set the heap size of an ANTLR process, the <code class="literal">maxHeapSize</code> property of <a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a> can be used. To pass additional command-line arguments, append to the <code class="literal">arguments</code> property of <a class="ulink" href="../dsl/org.gradle.api.plugins.antlr.AntlrTask.html" target="_top"><code class="classname">AntlrTask</code></a>.</p><div class="example"><a name="advanced"></a><p class="title"><b>Example&nbsp;464.&nbsp;setting custom max heap size and extra arguments for ANTLR</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">generateGrammarSource {
    maxHeapSize = <span class="hl-string">"64m"</span>
    arguments += [<span class="hl-string">"-visitor"</span>, <span class="hl-string">"-long-messages"</span>]
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="checkstyle_plugin"></a>The Checkstyle Plugin</h1></div></div></div><p>The Checkstyle plugin performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://checkstyle.sourceforge.net/index.html" target="_top">Checkstyle</a> and generates reports from these checks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_usage" class="section-anchor" href="#sec:checkstyle_usage"></a>Usage</h2></div></div></div><p>To use the Checkstyle plugin, include the following in your build script:</p><div class="example"><a name="useCheckstylePlugin"></a><p class="title"><b>Example&nbsp;465.&nbsp;Using the Checkstyle plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'checkstyle'</span>
</pre></div></div><br class="example-break"><p>The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running <code class="literal">gradle check</code>.</p><p>Note that Checkstyle will run with the same Java version used to run Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_tasks" class="section-anchor" href="#sec:checkstyle_tasks"></a>Tasks</h2></div></div></div><p>The Checkstyle plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;66.&nbsp;Checkstyle plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N182E8"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">checkstyleMain</code></p></td>
<td><p><code class="literal">classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Checkstyle.html" target="_top"><code class="classname">Checkstyle</code></a></p></td>
<td><p>Runs Checkstyle against the production Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">checkstyleTest</code></p></td>
<td><p><code class="literal">testClasses</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Checkstyle.html" target="_top"><code class="classname">Checkstyle</code></a></p></td>
<td><p>Runs Checkstyle against the test Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">checkstyle<span class="emphasis"><em>SourceSet</em></span></code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Checkstyle.html" target="_top"><code class="classname">Checkstyle</code></a></p></td>
<td><p>Runs Checkstyle against the given source set&rsquo;s Java source files.</p></td>
</tr></tbody></table></div></div><p>The Checkstyle plugin adds the following dependencies to tasks defined by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;67.&nbsp;Checkstyle plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18349"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">check</code></p></td>
<td><p>All Checkstyle tasks, including <code class="literal">checkstyleMain</code> and <code class="literal">checkstyleTest</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_project_layout" class="section-anchor" href="#sec:checkstyle_project_layout"></a>Project layout</h2></div></div></div><p>By default, the Checkstyle plugin expects the following project layout, but this can be changed:</p><div class="table"><p class="title"><b>Table&nbsp;68.&nbsp;Checkstyle plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18370"><thead><tr>
<td>File</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">config/checkstyle</code></p></td>
<td><p>Other Checkstyle configuration files (e.g., <code class="literal">suppressions.xml</code>)</p></td>
</tr><tr>
<td><p><code class="literal">config/checkstyle/checkstyle.xml</code></p></td>
<td><p>Checkstyle configuration file</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_dependency_management" class="section-anchor" href="#sec:checkstyle_dependency_management"></a>Dependency management</h2></div></div></div><p>The Checkstyle plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;69.&nbsp;Checkstyle plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1839F"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">checkstyle</code></p></td>
<td><p>The Checkstyle libraries to use</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_configuration" class="section-anchor" href="#sec:checkstyle_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CheckstyleExtension.html" target="_top"><code class="classname">CheckstyleExtension</code></a> class in the API documentation.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:checkstyle_built_in_variables" class="section-anchor" href="#sec:checkstyle_built_in_variables"></a>Built-in variables</h3></div></div></div><p>The Checkstyle plugin defines a <code class="literal">config_loc</code> property that can be used in Checkstyle configuration files to define paths to other configuration files like <code class="literal">suppressions.xml</code>.</p><div class="example"><a name="useConfigLoc"></a><p class="title"><b>Example&nbsp;466.&nbsp;Using the config_loc property</b></p><div class="example-contents"><p><code class="filename">config/checkstyle/checkstyle.xml</code></p><pre class="programlisting"><span class="hl-tag">&lt;module</span> <span class="hl-attribute">name</span>=<span class="hl-value">"SuppressionFilter"</span><span class="hl-tag">&gt;</span>
    <span class="hl-tag">&lt;property</span> <span class="hl-attribute">name</span>=<span class="hl-value">"file"</span> <span class="hl-attribute">value</span>=<span class="hl-value">"${config_loc}/suppressions.xml"</span><span class="hl-tag">/&gt;</span>
<span class="hl-tag">&lt;/module&gt;</span>
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:checkstyle_customize_xsl" class="section-anchor" href="#sec:checkstyle_customize_xsl"></a>Customizing the HTML report</h2></div></div></div><p>The HTML report generated by the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Checkstyle.html" target="_top"><code class="classname">Checkstyle</code></a> task can be customized using a XSLT stylesheet, for example to highlight specific errors or change its appearance:</p><div class="example"><a name="customizeCheckstyleReport"></a><p class="title"><b>Example&nbsp;467.&nbsp;Customizing the HTML report</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.withType(Checkstyle) {
    reports {
        xml.enabled false
        html.enabled true
        html.stylesheet resources.text.fromFile(<span class="hl-string">'config/xsl/checkstyle-custom.xsl'</span>)
    }
}
</pre></div></div><br class="example-break"><p><a class="ulink" href="https://github.com/checkstyle/contribution/tree/master/xsl" target="_top">View a sample Checkstyle stylesheet.</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="codenarc_plugin"></a>The CodeNarc Plugin</h1></div></div></div><p>The CodeNarc plugin performs quality checks on your project&rsquo;s Groovy source files using <a class="ulink" href="http://codenarc.sourceforge.net/index.html" target="_top">CodeNarc</a> and generates reports from these checks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:codenarc_usage" class="section-anchor" href="#sec:codenarc_usage"></a>Usage</h2></div></div></div><p>To use the CodeNarc plugin, include the following in your build script:</p><div class="example"><a name="useCodeNarcPlugin"></a><p class="title"><b>Example&nbsp;468.&nbsp;Using the CodeNarc plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'codenarc'</span>
</pre></div></div><br class="example-break"><p>The plugin adds a number of tasks to the project that perform the quality checks when used with the <a class="link" href="#groovy_plugin">Groovy Plugin</a>. You can execute the checks by running <code class="literal">gradle check</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:codenarc_tasks" class="section-anchor" href="#sec:codenarc_tasks"></a>Tasks</h2></div></div></div><p>The CodeNarc plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;70.&nbsp;CodeNarc plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1841E"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">codenarcMain</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CodeNarc.html" target="_top"><code class="classname">CodeNarc</code></a></p></td>
<td><p>Runs CodeNarc against the production Groovy source files.</p></td>
</tr><tr>
<td><p><code class="literal">codenarcTest</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CodeNarc.html" target="_top"><code class="classname">CodeNarc</code></a></p></td>
<td><p>Runs CodeNarc against the test Groovy source files.</p></td>
</tr><tr>
<td><p><code class="literal">codenarc<span class="emphasis"><em>SourceSet</em></span></code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CodeNarc.html" target="_top"><code class="classname">CodeNarc</code></a></p></td>
<td><p>Runs CodeNarc against the given source set&rsquo;s Groovy source files.</p></td>
</tr></tbody></table></div></div><p>The CodeNarc plugin adds the following dependencies to tasks defined by the Groovy plugin.</p><div class="table"><p class="title"><b>Table&nbsp;71.&nbsp;CodeNarc plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1847A"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">check</code></p></td>
<td><p>All CodeNarc tasks, including <code class="literal">codenarcMain</code> and <code class="literal">codenarcTest</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:codenarc_project_layout" class="section-anchor" href="#sec:codenarc_project_layout"></a>Project layout</h2></div></div></div><p>The CodeNarc plugin expects the following project layout:</p><div class="table"><p class="title"><b>Table&nbsp;72.&nbsp;CodeNarc plugin - project layout</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N184A1"><thead><tr>
<td>File</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">config/codenarc/codenarc.xml</code></p></td>
<td><p>CodeNarc configuration file</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:codenarc_dependency_management" class="section-anchor" href="#sec:codenarc_dependency_management"></a>Dependency management</h2></div></div></div><p>The CodeNarc plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;73.&nbsp;CodeNarc plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N184C2"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">codenarc</code></p></td>
<td><p>The CodeNarc libraries to use</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:codenarc_configuration" class="section-anchor" href="#sec:codenarc_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.CodeNarcExtension.html" target="_top"><code class="classname">CodeNarcExtension</code></a> class in the API documentation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="findbugs_plugin"></a>The FindBugs Plugin</h1></div></div></div><p>The FindBugs plugin performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://findbugs.sourceforge.net" target="_top">FindBugs</a> and generates reports from these checks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:findbugs_usage" class="section-anchor" href="#sec:findbugs_usage"></a>Usage</h2></div></div></div><p>To use the FindBugs plugin, include the following in your build script:</p><div class="example"><a name="useFindBugsPlugin"></a><p class="title"><b>Example&nbsp;469.&nbsp;Using the FindBugs plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'findbugs'</span>
</pre></div></div><br class="example-break"><p>The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running <code class="literal">gradle check</code>.</p><p>Note that Findbugs will run with the same Java version used to run Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:findbugs_tasks" class="section-anchor" href="#sec:findbugs_tasks"></a>Tasks</h2></div></div></div><p>The FindBugs plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;74.&nbsp;FindBugs plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18510"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">findbugsMain</code></p></td>
<td><p><code class="literal">classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugs.html" target="_top"><code class="classname">FindBugs</code></a></p></td>
<td><p>Runs FindBugs against the production Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">findbugsTest</code></p></td>
<td><p><code class="literal">testClasses</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugs.html" target="_top"><code class="classname">FindBugs</code></a></p></td>
<td><p>Runs FindBugs against the test Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">findbugs<span class="emphasis"><em>SourceSet</em></span></code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugs.html" target="_top"><code class="classname">FindBugs</code></a></p></td>
<td><p>Runs FindBugs against the given source set&rsquo;s Java source files.</p></td>
</tr></tbody></table></div></div><p>The FindBugs plugin adds the following dependencies to tasks defined by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;75.&nbsp;FindBugs plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18571"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">check</code></p></td>
<td><p>All FindBugs tasks, including <code class="literal">findbugsMain</code> and <code class="literal">findbugsTest</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:findbugs_dependency_management" class="section-anchor" href="#sec:findbugs_dependency_management"></a>Dependency management</h2></div></div></div><p>The FindBugs plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;76.&nbsp;FindBugs plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18598"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">findbugs</code></p></td>
<td><p>The FindBugs libraries to use</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:findbugs_configuration" class="section-anchor" href="#sec:findbugs_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugsExtension.html" target="_top"><code class="classname">FindBugsExtension</code></a> class in the API documentation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:findbugs_customize_xsl" class="section-anchor" href="#sec:findbugs_customize_xsl"></a>Customizing the HTML report</h2></div></div></div><p>The HTML report generated by the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.FindBugs.html" target="_top"><code class="classname">FindBugs</code></a> task can be customized using a XSLT stylesheet, for example to highlight specific errors or change its appearance:</p><div class="example"><a name="customizeFindbugsReport"></a><p class="title"><b>Example&nbsp;470.&nbsp;Customizing the HTML report</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">tasks.withType(FindBugs) {
    reports {
        xml.enabled false
        html.enabled true
        html.stylesheet resources.text.fromFile(<span class="hl-string">'config/xsl/findbugs-custom.xsl'</span>)
    }
}
</pre></div></div><br class="example-break"><p><a class="ulink" href="https://github.com/findbugsproject/findbugs/tree/master/findbugs/src/xsl" target="_top">View a sample FindBugs stylesheet.</a></p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="jdepend_plugin"></a>The JDepend Plugin</h1></div></div></div><p>The JDepend plugin performs quality checks on your project&rsquo;s source files using <a class="ulink" href="http://clarkware.com/software/JDepend.html" target="_top">JDepend</a> and generates reports from these checks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jdepend_usage" class="section-anchor" href="#sec:jdepend_usage"></a>Usage</h2></div></div></div><p>To use the JDepend plugin, include the following in your build script:</p><div class="example"><a name="useJDependPlugin"></a><p class="title"><b>Example&nbsp;471.&nbsp;Using the JDepend plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'jdepend'</span>
</pre></div></div><br class="example-break"><p>The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running <code class="literal">gradle check</code>.</p><p>Note that JDepend will run with the same Java version used to run Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jdepend_tasks" class="section-anchor" href="#sec:jdepend_tasks"></a>Tasks</h2></div></div></div><p>The JDepend plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;77.&nbsp;JDepend plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N185FF"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">jdependMain</code></p></td>
<td><p><code class="literal">classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.JDepend.html" target="_top"><code class="classname">JDepend</code></a></p></td>
<td><p>Runs JDepend against the production Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">jdependTest</code></p></td>
<td><p><code class="literal">testClasses</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.JDepend.html" target="_top"><code class="classname">JDepend</code></a></p></td>
<td><p>Runs JDepend against the test Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">jdepend<span class="emphasis"><em>SourceSet</em></span></code></p></td>
<td><p><code class="literal"><span class="emphasis"><em>sourceSet</em></span>Classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.JDepend.html" target="_top"><code class="classname">JDepend</code></a></p></td>
<td><p>Runs JDepend against the given source set&rsquo;s Java source files.</p></td>
</tr></tbody></table></div></div><p>The JDepend plugin adds the following dependencies to tasks defined by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;78.&nbsp;JDepend plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18660"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">check</code></p></td>
<td><p>All JDepend tasks, including <code class="literal">jdependMain</code> and <code class="literal">jdependTest</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jdepend_dependency_management" class="section-anchor" href="#sec:jdepend_dependency_management"></a>Dependency management</h2></div></div></div><p>The JDepend plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;79.&nbsp;JDepend plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18687"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">jdepend</code></p></td>
<td><p>The JDepend libraries to use</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jdepend_configuration" class="section-anchor" href="#sec:jdepend_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.JDependExtension.html" target="_top"><code class="classname">JDependExtension</code></a> class in the API documentation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="pmd_plugin"></a>The PMD Plugin</h1></div></div></div><p>The PMD plugin performs quality checks on your project&rsquo;s Java source files using <a class="ulink" href="http://pmd.sourceforge.net" target="_top">PMD</a> and generates reports from these checks.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:pmd_usage" class="section-anchor" href="#sec:pmd_usage"></a>Usage</h2></div></div></div><p>To use the PMD plugin, include the following in your build script:</p><div class="example"><a name="usePmdPlugin"></a><p class="title"><b>Example&nbsp;472.&nbsp;Using the PMD plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'pmd'</span>
</pre></div></div><br class="example-break"><p>The plugin adds a number of tasks to the project that perform the quality checks. You can execute the checks by running <code class="literal">gradle check</code>.</p><p>Note that PMD will run with the same Java version used to run Gradle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:pmd_tasks" class="section-anchor" href="#sec:pmd_tasks"></a>Tasks</h2></div></div></div><p>The PMD plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;80.&nbsp;PMD plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N186D5"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">pmdMain</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Pmd.html" target="_top"><code class="classname">Pmd</code></a></p></td>
<td><p>Runs PMD against the production Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">pmdTest</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Pmd.html" target="_top"><code class="classname">Pmd</code></a></p></td>
<td><p>Runs PMD against the test Java source files.</p></td>
</tr><tr>
<td><p><code class="literal">pmd<span class="emphasis"><em>SourceSet</em></span></code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.plugins.quality.Pmd.html" target="_top"><code class="classname">Pmd</code></a></p></td>
<td><p>Runs PMD against the given source set&rsquo;s Java source files.</p></td>
</tr></tbody></table></div></div><p>The PMD plugin adds the following dependencies to tasks defined by the Java plugin.</p><div class="table"><p class="title"><b>Table&nbsp;81.&nbsp;PMD plugin - additional task dependencies</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18731"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">check</code></p></td>
<td><p>All PMD tasks, including <code class="literal">pmdMain</code> and <code class="literal">pmdTest</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:pmd_dependency_management" class="section-anchor" href="#sec:pmd_dependency_management"></a>Dependency management</h2></div></div></div><p>The PMD plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;82.&nbsp;PMD plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18758"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">pmd</code></p></td>
<td><p>The PMD libraries to use</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:pmd_configuration" class="section-anchor" href="#sec:pmd_configuration"></a>Configuration</h2></div></div></div><p>See the <a class="ulink" href="../dsl/org.gradle.api.plugins.quality.PmdExtension.html" target="_top"><code class="classname">PmdExtension</code></a> class in the API documentation.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="jacoco_plugin"></a>The JaCoCo Plugin</h1></div></div></div><div class="note"><p>The JaCoCo plugin is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL and other configuration may change in later Gradle versions.</p></div><p>The JaCoCo plugin provides code coverage metrics for Java code via integration with <a class="ulink" href="http://www.eclemma.org/jacoco/" target="_top">JaCoCo</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_getting_started" class="section-anchor" href="#sec:jacoco_getting_started"></a>Getting Started</h2></div></div></div><p>To get started, apply the JaCoCo plugin to the project you want to calculate code coverage for.</p><div class="example"><a name="applyJacoco"></a><p class="title"><b>Example&nbsp;473.&nbsp;Applying the JaCoCo plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"jacoco"</span>
</pre></div></div><br class="example-break"><p>If the Java plugin is also applied to your project, a new task named <code class="literal">jacocoTestReport</code> is created that depends on the <code class="literal">test</code> task. The report is available at <code class="literal"><span class="emphasis"><em>$buildDir</em></span>/reports/jacoco/test</code>. By default, a HTML report is generated.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_the_jacoco_plugin" class="section-anchor" href="#sec:configuring_the_jacoco_plugin"></a>Configuring the JaCoCo Plugin</h2></div></div></div><p>The JaCoCo plugin adds a project extension named <code class="literal">jacoco</code> of type <a class="ulink" href="../dsl/org.gradle.testing.jacoco.plugins.JacocoPluginExtension.html" target="_top"><code class="classname">JacocoPluginExtension</code></a>, which allows configuring defaults for JaCoCo usage in your build.</p><div class="example"><a name="configJacoco"></a><p class="title"><b>Example&nbsp;474.&nbsp;Configuring JaCoCo plugin settings</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jacoco {
    toolVersion = <span class="hl-string">"0.7.9"</span>
    reportsDir = file(<span class="hl-string">"$buildDir/customJacocoReportDir"</span>)
}
</pre></div></div><br class="example-break"><div class="table"><p class="title"><b>Table&nbsp;83.&nbsp;Gradle defaults for JaCoCo properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N187C5"><thead><tr>
<td>Property</td>
<td>Gradle default</td>
</tr></thead><tbody><tr>
<td><p>reportsDir</p></td>
<td><p><code class="literal"><span class="emphasis"><em>$buildDir</em></span>/reports/jacoco</code></p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_report_configuration" class="section-anchor" href="#sec:jacoco_report_configuration"></a>JaCoCo Report configuration</h2></div></div></div><p>The <a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html" target="_top"><code class="classname">JacocoReport</code></a> task can be used to generate code coverage reports in different formats. It implements the standard Gradle type <a class="ulink" href="../dsl/org.gradle.api.reporting.Reporting.html" target="_top"><code class="classname">Reporting</code></a> and exposes a report container of type <a class="ulink" href="../javadoc/org/gradle/testing/jacoco/tasks/JacocoReportsContainer.html" target="_top"><code class="classname">JacocoReportsContainer</code></a>.</p><div class="example"><a name="configJacocoReport"></a><p class="title"><b>Example&nbsp;475.&nbsp;Configuring test task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jacocoTestReport {
    reports {
        xml.enabled false
        csv.enabled false
        html.destination file(<span class="hl-string">"${buildDir}/jacocoHtml"</span>)
    }
}
</pre></div></div><br class="example-break"><div class="informalfigure"><div class="mediaobject"><img src="img/jacocoHtmlReport.png" width="903" height="277" alt="JaCoCo HTML report"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_report_violation_rules" class="section-anchor" href="#sec:jacoco_report_violation_rules"></a>Enforcing code coverage metrics</h2></div></div></div><div class="note"><p>This feature requires the use of JaCoCo version 0.6.3 or higher.</p></div><p>The <a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html" target="_top"><code class="classname">JacocoCoverageVerification</code></a> task can be used to verify if code coverage metrics are met based on configured rules. Its API exposes the method <a class="ulink" href="../javadoc/org/gradle/testing/jacoco/tasks/JacocoCoverageVerification.html#violationRules-org.gradle.api.Action-" target="_top"><code class="classname">JacocoCoverageVerification.violationRules(org.gradle.api.Action)</code></a> which is used as main entry point for configuring rules. Invoking any of those methods returns an instance of <a class="ulink" href="../javadoc/org/gradle/testing/jacoco/tasks/rules/JacocoViolationRulesContainer.html" target="_top"><code class="classname">JacocoViolationRulesContainer</code></a> providing extensive configuration options. The build fails if any of the configured rules are not met. JaCoCo only reports the first violated rule.</p><p>Code coverage requirements can be specified for a project as a whole, for individual files, and for particular JaCoCo-specific types of coverage, e.g., lines covered or branches covered. The following example describes the syntax.</p><div class="example"><a name="configViolationRules"></a><p class="title"><b>Example&nbsp;476.&nbsp;Configuring violation rules</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = <span class="hl-number">0.5</span>
            }
        }

        rule {
            enabled = false
            element = <span class="hl-string">'CLASS'</span>
            includes = [<span class="hl-string">'org.gradle.*'</span>]

            limit {
                counter = <span class="hl-string">'LINE'</span>
                value = <span class="hl-string">'TOTALCOUNT'</span>
                maximum = <span class="hl-number">0.3</span>
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testing/jacoco/quickstart</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>The <a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html" target="_top"><code class="classname">JacocoCoverageVerification</code></a> task is not a task dependency of the <code class="literal">check</code> task provided by the Java plugin. There is a good reason for it. The task is currently not incremental as it doesn&rsquo;t declare any outputs. Any violation of the declared rules would automatically result in a failed build when executing the <code class="literal">check</code> task. This behavior might not be desirable for all users. Future versions of Gradle might change the behavior.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_specific_task_configuration" class="section-anchor" href="#sec:jacoco_specific_task_configuration"></a>JaCoCo specific task configuration</h2></div></div></div><p>The JaCoCo plugin adds a <a class="ulink" href="../dsl/org.gradle.testing.jacoco.plugins.JacocoTaskExtension.html" target="_top"><code class="classname">JacocoTaskExtension</code></a> extension to all tasks of type <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a>. This extension allows the configuration of the JaCoCo specific properties of the test task.</p><div class="example"><a name="jacocotesttast"></a><p class="title"><b>Example&nbsp;477.&nbsp;Configuring test task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">test {
    jacoco {
        append = false
        destinationFile = file(<span class="hl-string">"$buildDir/jacoco/jacocoTest.exec"</span>)
        classDumpDir = file(<span class="hl-string">"$buildDir/jacoco/classpathdumps"</span>)
    }
}
</pre></div></div><br class="example-break"><div class="table"><p class="title"><b>Table&nbsp;84.&nbsp;Default values of the JaCoCo Task extension</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1885F"><thead><tr>
<td>Property</td>
<td>Gradle default</td>
</tr></thead><tbody><tr>
<td><p>enabled</p></td>
<td><p>true</p></td>
</tr><tr>
<td><p>destPath</p></td>
<td><p><code class="literal"><span class="emphasis"><em>$buildDir</em></span>/jacoco</code></p></td>
</tr><tr>
<td><p>append</p></td>
<td><p>true</p></td>
</tr><tr>
<td><p>includes</p></td>
<td><p>[]</p></td>
</tr><tr>
<td><p>excludes</p></td>
<td><p>[]</p></td>
</tr><tr>
<td><p>excludeClassLoaders</p></td>
<td><p>[]</p></td>
</tr><tr>
<td><p>includeNoLocationClasses</p></td>
<td><p>false</p></td>
</tr><tr>
<td><p>sessionId</p></td>
<td><p><code class="literal">auto-generated</code></p></td>
</tr><tr>
<td><p>dumpOnExit</p></td>
<td><p><code class="literal">true</code></p></td>
</tr><tr>
<td><p>output</p></td>
<td><p><code class="literal">Output.FILE</code></p></td>
</tr><tr>
<td><p>address</p></td>
<td><p><code class="literal">-</code></p></td>
</tr><tr>
<td><p>port</p></td>
<td><p><code class="literal">-</code></p></td>
</tr><tr>
<td><p>classDumpPath</p></td>
<td><p><code class="literal">-</code></p></td>
</tr><tr>
<td><p>jmx</p></td>
<td><p><code class="literal">false</code></p></td>
</tr></tbody></table></div></div><p>While all tasks of type <a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a> are automatically enhanced to provide coverage information when the <code class="literal">java</code> plugin has been applied, any task that implements <a class="ulink" href="../javadoc/org/gradle/process/JavaForkOptions.html" target="_top"><code class="classname">JavaForkOptions</code></a> can be enhanced by the JaCoCo plugin. That is, any task that forks Java processes can be used to generate coverage information.</p><p>For example you can configure your build to generate code coverage using the <code class="literal">application</code> plugin.</p><div class="example"><a name="jacoco-application-setup"></a><p class="title"><b>Example&nbsp;478.&nbsp;Using application plugin to generate code coverage data</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"application"</span>
apply plugin: <span class="hl-string">"jacoco"</span>

mainClassName = <span class="hl-string">"org.gradle.MyMain"</span>

jacoco {
    applyTo run
}

task applicationCodeCoverageReport(type:JacocoReport){
    executionData run
    sourceSets sourceSets.main
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/testing/jacoco/application</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="example"><a name="jacoco-application-output"></a><p class="title"><b>Example&nbsp;479.&nbsp;Coverage reports generated by applicationCodeCoverageReport</b></p><div class="example-contents"><p>Build layout</p><pre class="programlisting">application/
  build/
    jacoco/
      run.exec
    reports/jacoco/applicationCodeCoverageReport/html/
      index.html
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_tasks" class="section-anchor" href="#sec:jacoco_tasks"></a>Tasks</h2></div></div></div><p>For projects that also apply the Java Plugin, The JaCoCo plugin automatically adds the following tasks:</p><div class="table"><p class="title"><b>Table&nbsp;85.&nbsp;JaCoCo plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1893A"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">jacocoTestReport</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoReport.html" target="_top"><code class="classname">JacocoReport</code></a></p></td>
<td><p>Generates code coverage report for the test task.</p></td>
</tr><tr>
<td><p><code class="literal">jacocoTestCoverageVerification</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.testing.jacoco.tasks.JacocoCoverageVerification.html" target="_top"><code class="classname">JacocoCoverageVerification</code></a></p></td>
<td><p>Verifies code coverage metrics based on specified rules for the test task.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:jacoco_dependency_management" class="section-anchor" href="#sec:jacoco_dependency_management"></a>Dependency management</h2></div></div></div><p>The JaCoCo plugin adds the following dependency configurations:</p><div class="table"><p class="title"><b>Table&nbsp;86.&nbsp;JaCoCo plugin - dependency configurations</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18982"><thead><tr>
<td>Name</td>
<td>Meaning</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">jacocoAnt</code></p></td>
<td><p>The JaCoCo Ant library used for running the <code class="literal">JacocoReport</code>, <code class="literal">JacocoMerge</code> and <code class="literal">JacocoCoverageVerification</code> tasks.</p></td>
</tr><tr>
<td><p><code class="literal">jacocoAgent</code></p></td>
<td><p>The JaCoCo agent library used for instrumenting the code under test.</p></td>
</tr></tbody></table></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="osgi_plugin"></a>The OSGi Plugin</h1></div></div></div><p>The OSGi plugin provides a factory method to create an <a class="ulink" href="../javadoc/org/gradle/api/plugins/osgi/OsgiManifest.html" target="_top"><code class="classname">OsgiManifest</code></a> object. <code class="literal">OsgiManifest</code> extends <a class="ulink" href="../javadoc/org/gradle/api/java/archives/Manifest.html" target="_top"><code class="classname">Manifest</code></a>. To learn more about generic manifest handling, see <a class="xref" href="#sub:manifest">the section called &ldquo;Manifest&rdquo;</a>. If the Java plugins is applied, the OSGi plugin replaces the manifest object of the default jar with an <code class="literal">OsgiManifest</code> object. The replaced manifest is merged into the new one.</p><div class="note"><p>The OSGi plugin makes heavy use of the <a class="ulink" href="http://bnd.bndtools.org/" target="_top">BND tool</a>. A separate <a class="ulink" href="https://github.com/bndtools/bnd/blob/master/biz.aQute.bnd.gradle/README.md" target="_top">plugin implementation</a> is maintained by the BND authors that has more advanced features.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:osgi_usage" class="section-anchor" href="#sec:osgi_usage"></a>Usage</h2></div></div></div><p>To use the OSGi plugin, include the following in your build script:</p><div class="example"><a name="useOsgiPlugin"></a><p class="title"><b>Example&nbsp;480.&nbsp;Using the OSGi plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'osgi'</span>
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:osgi_implicitly_applied_plugins" class="section-anchor" href="#sec:osgi_implicitly_applied_plugins"></a>Implicitly applied plugins</h2></div></div></div><p>Applies the Java base plugin.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:osgi_tasks" class="section-anchor" href="#sec:osgi_tasks"></a>Tasks</h2></div></div></div><p>The OSGi plugin adds the following tasks to the project:</p><div class="table"><p class="title"><b>Table&nbsp;87.&nbsp;OSGi plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N189F2"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">osgiClasses</code></p></td>
<td><p><code class="literal">classes</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Sync.html" target="_top"><code class="classname">Sync</code></a></p></td>
<td><p>Copies all classes from the main source set to a single directory that is processed by BND.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:osgi_convention_object" class="section-anchor" href="#sec:osgi_convention_object"></a>Convention object</h2></div></div></div><p>The OSGi plugin adds the following convention object: <a class="ulink" href="../dsl/org.gradle.api.plugins.osgi.OsgiPluginConvention.html" target="_top"><code class="classname">OsgiPluginConvention</code></a></p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:osgi_convention_properties" class="section-anchor" href="#sec:osgi_convention_properties"></a>Convention properties</h3></div></div></div><p>The OSGi plugin does not add any convention properties to the project.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:osgi_convention_methods" class="section-anchor" href="#sec:osgi_convention_methods"></a>Convention methods</h3></div></div></div><p>The OSGi plugin adds the following methods. For more details, see the API documentation of the convention object.</p><div class="table"><p class="title"><b>Table&nbsp;88.&nbsp;OSGi methods</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18A35"><thead><tr>
<td>Method</td>
<td>Return Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>osgiManifest()</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/plugins/osgi/OsgiManifest.html" target="_top"><code class="classname">OsgiManifest</code></a></p></td>
<td><p>Returns an OsgiManifest object.</p></td>
</tr><tr>
<td><p>osgiManifest(Closure cl)</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/plugins/osgi/OsgiManifest.html" target="_top"><code class="classname">OsgiManifest</code></a></p></td>
<td><p>Returns an OsgiManifest object configured by the closure.</p></td>
</tr></tbody></table></div></div><p>The classes in the classes dir are analyzed regarding their package dependencies and the packages they expose. Based on this the <span class="emphasis"><em>Import-Package</em></span> and the <span class="emphasis"><em>Export-Package</em></span> values of the OSGi Manifest are calculated. If the classpath contains jars with an OSGi bundle, the bundle information is used to specify version information for the <span class="emphasis"><em>Import-Package</em></span> value. Beside the explicit properties of the <code class="literal">OsgiManifest</code> object you can add instructions.</p><div class="example"><a name="osgi"></a><p class="title"><b>Example&nbsp;481.&nbsp;Configuration of OSGi MANIFEST.MF file</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">jar {
    manifest { <span class="hl-comment">// the manifest of the default jar is of type OsgiManifest</span>
        name = <span class="hl-string">'overwrittenSpecialOsgiName'</span>
        instruction <span class="hl-string">'Private-Package'</span>,
                <span class="hl-string">'org.mycomp.package1'</span>,
                <span class="hl-string">'org.mycomp.package2'</span>
        instruction <span class="hl-string">'Bundle-Vendor'</span>, <span class="hl-string">'MyCompany'</span>
        instruction <span class="hl-string">'Bundle-Description'</span>, <span class="hl-string">'Platform2: Metrics 2 Measures Framework'</span>
        instruction <span class="hl-string">'Bundle-DocURL'</span>, <span class="hl-string">'http://www.mycompany.com'</span>
    }
}
task fooJar(type: Jar) {
    manifest = osgiManifest {
        instruction <span class="hl-string">'Bundle-Vendor'</span>, <span class="hl-string">'MyCompany'</span>    
    }
}
</pre></div></div><br class="example-break"><p>The first argument of the instruction call is the key of the property. The other arguments form the value. To learn more about the available instructions have a look at the <a class="ulink" href="http://bnd.bndtools.org/" target="_top">BND tool</a>.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="eclipse_plugin"></a>The Eclipse Plugins</h1></div></div></div><p>The Eclipse plugins generate files that are used by the <a class="ulink" href="http://eclipse.org" target="_top">Eclipse IDE</a>, thus making it possible to import the project into Eclipse (<code class="literal">File</code> - <code class="literal">Import&hellip;</code> - <code class="literal">Existing Projects into Workspace</code>).</p><p>The <code class="literal">eclipse-wtp</code> is automatically applied whenever the <code class="literal">eclipse</code> plugin is applied to a <a class="link" href="#war_plugin">War</a> or <a class="link" href="#ear_plugin">Ear</a> project. For utility projects (i.e. <a class="link" href="#java_plugin">Java</a> projects used by other web projects), you need to apply the <code class="literal">eclipse-wtp</code> plugin explicitly.</p><p>What exactly the <code class="literal">eclipse</code> plugin generates depends on which other plugins are used:</p><div class="table"><p class="title"><b>Table&nbsp;89.&nbsp;Eclipse plugin behavior</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18AB8"><thead><tr>
<td>Plugin</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>None</p></td>
<td><p>Generates minimal <code class="literal">.project</code> file.</p></td>
</tr><tr>
<td><p><a class="link" href="#java_plugin">Java</a></p></td>
<td><p>Adds Java configuration to <code class="literal">.project</code>. Generates <code class="literal">.classpath</code> and JDT settings file.</p></td>
</tr><tr>
<td><p><a class="link" href="#groovy_plugin">Groovy</a></p></td>
<td><p>Adds Groovy configuration to <code class="literal">.project</code> file.</p></td>
</tr><tr>
<td><p><a class="link" href="#scala_plugin">Scala</a></p></td>
<td><p>Adds Scala support to <code class="literal">.project</code> and <code class="literal">.classpath</code> files.</p></td>
</tr><tr>
<td><p><a class="link" href="#war_plugin">War</a></p></td>
<td><p>Adds web application support to <code class="literal">.project</code> file.</p></td>
</tr><tr>
<td><p><a class="link" href="#ear_plugin">Ear</a></p></td>
<td><p>Adds ear application support to <code class="literal">.project</code> file.</p></td>
</tr></tbody></table></div></div><p>The <code class="literal">eclipse-wtp</code> plugin generates all WTP settings files and enhances the <code class="literal">.project</code> file. If a <a class="link" href="#java_plugin">Java</a> or <a class="link" href="#war_plugin">War</a> is applied, <code class="literal">.classpath</code> will be extended to get a proper packaging structure for this utility library or web application project.</p><p>Both Eclipse plugins are open to customization and provide a standardized set of hooks for adding and removing content from the generated files.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:eclipse_usage" class="section-anchor" href="#sec:eclipse_usage"></a>Usage</h2></div></div></div><p>To use either the Eclipse or the Eclipse WTP plugin, include one of the lines in your build script:</p><div class="example"><a name="useEclipsePlugin"></a><p class="title"><b>Example&nbsp;482.&nbsp;Using the Eclipse plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'eclipse'</span>
</pre></div></div><br class="example-break"><div class="example"><a name="useEclipseWtpPlugin"></a><p class="title"><b>Example&nbsp;483.&nbsp;Using the Eclipse WTP plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'eclipse-wtp'</span>
</pre></div></div><br class="example-break"><p><span class="emphasis"><em>Note:</em></span> Internally, the <code class="literal">eclipse-wtp</code> plugin also applies the <code class="literal">eclipse</code> plugin so you don&rsquo;t need to apply both.</p><p>Both Eclipse plugins add a number of tasks to your projects. The main tasks that you will use are the <code class="literal">eclipse</code> and <code class="literal">cleanEclipse</code> tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:eclipse_tasks" class="section-anchor" href="#sec:eclipse_tasks"></a>Tasks</h2></div></div></div><p>The Eclipse plugins add the tasks shown below to a project.</p><div class="table"><p class="title"><b>Table&nbsp;90.&nbsp;Eclipse plugin - tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="eclipsetasks"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">eclipse</code></p></td>
<td><p>all Eclipse configuration file generation tasks</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Generates all Eclipse configuration files</p></td>
</tr><tr>
<td><p><code class="literal">cleanEclipse</code></p></td>
<td><p>all Eclipse configuration file clean tasks</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes all Eclipse configuration files</p></td>
</tr><tr>
<td><p><code class="literal">cleanEclipseProject</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the <code class="literal">.project</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">cleanEclipseClasspath</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the <code class="literal">.classpath</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">cleanEclipseJdt</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the <code class="literal">.settings/org.eclipse.jdt.core.prefs</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">eclipseProject</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseProject.html" target="_top"><code class="classname">GenerateEclipseProject</code></a></p></td>
<td><p>Generates the <code class="literal">.project</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">eclipseClasspath</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseClasspath.html" target="_top"><code class="classname">GenerateEclipseClasspath</code></a></p></td>
<td><p>Generates the <code class="literal">.classpath</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">eclipseJdt</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseJdt.html" target="_top"><code class="classname">GenerateEclipseJdt</code></a></p></td>
<td><p>Generates the <code class="literal">.settings/org.eclipse.jdt.core.prefs</code> file.</p></td>
</tr></tbody></table></div></div><div class="table"><p class="title"><b>Table&nbsp;91.&nbsp;Eclipse WTP plugin - additional tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="eclipsewtptasks"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">cleanEclipseWtpComponent</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the <code class="literal">.settings/org.eclipse.wst.common.component</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">cleanEclipseWtpFacet</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the <code class="literal">.settings/org.eclipse.wst.common.project.facet.core.xml</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">eclipseWtpComponent</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpComponent.html" target="_top"><code class="classname">GenerateEclipseWtpComponent</code></a></p></td>
<td><p>Generates the <code class="literal">.settings/org.eclipse.wst.common.component</code> file.</p></td>
</tr><tr>
<td><p><code class="literal">eclipseWtpFacet</code></p></td>
<td><p><code class="literal">-</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.GenerateEclipseWtpFacet.html" target="_top"><code class="classname">GenerateEclipseWtpFacet</code></a></p></td>
<td><p>Generates the <code class="literal">.settings/org.eclipse.wst.common.project.facet.core.xml</code> file.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:eclipse_configuration" class="section-anchor" href="#sec:eclipse_configuration"></a>Configuration</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;92.&nbsp;Configuration of the Eclipse plugins</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="eclipse-configuration"><thead><tr>
<td>Model</td>
<td>Reference name</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseModel.html" target="_top"><code class="classname">EclipseModel</code></a></p></td>
<td><p><code class="literal">eclipse</code></p></td>
<td><p>Top level element that enables configuration of the Eclipse plugin in a DSL-friendly fashion.</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html" target="_top"><code class="classname">EclipseProject</code></a></p></td>
<td><p><code class="literal">eclipse.project</code></p></td>
<td><p>Allows configuring project information</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html" target="_top"><code class="classname">EclipseClasspath</code></a></p></td>
<td><p><code class="literal">eclipse.classpath</code></p></td>
<td><p>Allows configuring classpath information.</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html" target="_top"><code class="classname">EclipseJdt</code></a></p></td>
<td><p><code class="literal">eclipse.jdt</code></p></td>
<td><p>Allows configuring jdt information (source/target Java compatibility).</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html" target="_top"><code class="classname">EclipseWtpComponent</code></a></p></td>
<td><p><code class="literal">eclipse.wtp.component</code></p></td>
<td><p>Allows configuring wtp component information only if <code class="literal">eclipse-wtp</code> plugin was applied.</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html" target="_top"><code class="classname">EclipseWtpFacet</code></a></p></td>
<td><p><code class="literal">eclipse.wtp.facet</code></p></td>
<td><p>Allows configuring wtp facet information only if <code class="literal">eclipse-wtp</code> plugin was applied.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:eclipse_customizing_the_generated_files" class="section-anchor" href="#sec:eclipse_customizing_the_generated_files"></a>Customizing the generated files</h2></div></div></div><p>The Eclipse plugins allow you to customize the generated metadata files. The plugins provide a DSL for configuring model objects that model the Eclipse view of the project. These model objects are then merged with the existing Eclipse XML metadata to ultimately generate new metadata. The model objects provide lower level hooks for working with domain objects representing the file content before and after merging with the model configuration. They also provide a very low level hook for working directly with the raw XML for adjustment before it is persisted, for fine tuning and configuration that the Eclipse and Eclipse WTP plugins do not model.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:merging_with_eclipse_files" class="section-anchor" href="#sec:merging_with_eclipse_files"></a>Merging</h3></div></div></div><p>Sections of existing Eclipse files that are also the target of generated content will be amended or overwritten, depending on the particular section. The remaining sections will be left as-is.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:complete_rewrite_of_eclipse_files" class="section-anchor" href="#sec:complete_rewrite_of_eclipse_files"></a>Disabling merging with a complete rewrite</h4></div></div></div><p>To completely rewrite existing Eclipse files, execute a clean task together with its corresponding generation task, like &ldquo;<code class="literal">gradle cleanEclipse eclipse</code>&rdquo; (in that order). If you want to make this the default behavior, add &ldquo;<code class="literal">tasks.eclipse.dependsOn(cleanEclipse)</code>&rdquo; to your build script. This makes it unnecessary to execute the clean task explicitly.</p><p>This strategy can also be used for individual files that the plugins would generate. For instance, this can be done for the &ldquo;<code class="literal">.classpath</code>&rdquo; file with &ldquo;<code class="literal">gradle cleanEclipseClasspath eclipseClasspath</code>&rdquo;.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:hooking_into_the_eclipse_generation_lifecycle" class="section-anchor" href="#sec:hooking_into_the_eclipse_generation_lifecycle"></a>Hooking into the generation lifecycle</h3></div></div></div><p>The Eclipse plugins provide objects modeling the sections of the Eclipse files that are generated by Gradle. The generation lifecycle is as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The file is read; or a default version provided by Gradle is used if it does not exist</p></li><li class="listitem"><p>The <code class="literal">beforeMerged</code> hook is executed with a domain object representing the existing file</p></li><li class="listitem"><p>The existing content is merged with the configuration inferred from the Gradle build or defined explicitly in the eclipse DSL</p></li><li class="listitem"><p>The <code class="literal">whenMerged</code> hook is executed with a domain object representing contents of the file to be persisted</p></li><li class="listitem"><p>The <code class="literal">withXml</code> hook is executed with a raw representation of the XML that will be persisted</p></li><li class="listitem"><p>The final XML is persisted</p></li></ol></div><p>The following table lists the domain object used for each of the Eclipse model types:</p><div class="table"><p class="title"><b>Table&nbsp;93.&nbsp;Advanced configuration hooks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="eclipse-plugin-hooks"><thead><tr>
<td>Model</td>
<td><code class="literal">beforeMerged { arg -&gt; }</code> argument type</td>
<td><code class="literal">whenMerged { arg -&gt; }</code> argument type</td>
<td><code class="literal">withXml { arg -&gt; }</code> argument type</td>
<td><code class="literal">withProperties { arg -&gt; }</code> argument type</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseProject.html" target="_top"><code class="classname">EclipseProject</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Project.html" target="_top"><code class="classname">Project</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Project.html" target="_top"><code class="classname">Project</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
<td><p>-</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseClasspath.html" target="_top"><code class="classname">EclipseClasspath</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Classpath.html" target="_top"><code class="classname">Classpath</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Classpath.html" target="_top"><code class="classname">Classpath</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
<td><p>-</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseJdt.html" target="_top"><code class="classname">EclipseJdt</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Jdt.html" target="_top"><code class="classname">Jdt</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/Jdt.html" target="_top"><code class="classname">Jdt</code></a></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html" target="_top"><code class="literal">java.util.Properties</code></a></p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpComponent.html" target="_top"><code class="classname">EclipseWtpComponent</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/WtpComponent.html" target="_top"><code class="classname">WtpComponent</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/WtpComponent.html" target="_top"><code class="classname">WtpComponent</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
<td><p>-</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.eclipse.model.EclipseWtpFacet.html" target="_top"><code class="classname">EclipseWtpFacet</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/WtpFacet.html" target="_top"><code class="classname">WtpFacet</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/eclipse/model/WtpFacet.html" target="_top"><code class="classname">WtpFacet</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
<td><p>-</p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:partial-overwrite" class="section-anchor" href="#sec:partial-overwrite"></a>Partial overwrite of existing content</h4></div></div></div><p>A <a class="link" href="#">complete overwrite</a> causes all existing content to be discarded, thereby losing any changes made directly in the IDE. Alternatively, the <code class="literal">beforeMerged</code> hook makes it possible to overwrite just certain parts of the existing content. The following example removes all existing dependencies from the <code class="literal">Classpath</code> domain object:</p><div class="example"><a name="partialOverwrites"></a><p class="title"><b>Example&nbsp;484.&nbsp;Partial Overwrite for Classpath</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">eclipse.classpath.file {
    beforeMerged { classpath -&gt;
        classpath.entries.removeAll { entry -&gt; entry.kind == <span class="hl-string">'lib'</span> || entry.kind == <span class="hl-string">'var'</span> }
    }
}
</pre></div></div><br class="example-break"><p>The resulting <code class="literal">.classpath</code> file will only contain Gradle-generated dependency entries, but not any other dependency entries that may have been present in the original file. (In the case of dependency entries, this is also the default behavior.) Other sections of the <code class="literal">.classpath</code> file will be either left as-is or merged. The same could be done for the natures in the <code class="literal">.project</code> file:</p><div class="example"><a name="partialOverwritesProject"></a><p class="title"><b>Example&nbsp;485.&nbsp;Partial Overwrite for Project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">eclipse.project.file.beforeMerged { project -&gt;
    project.natures.clear()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:eclipse_modify_domain_objects" class="section-anchor" href="#sec:eclipse_modify_domain_objects"></a>Modifying the fully populated domain objects</h4></div></div></div><p>The <code class="literal">whenMerged</code> hook allows to manipulate the fully populated domain objects. Often this is the preferred way to customize Eclipse files. Here is how you would export all the dependencies of an Eclipse project:</p><div class="example"><a name="exportDependencies"></a><p class="title"><b>Example&nbsp;486.&nbsp;Export Classpath Entries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">eclipse.classpath.file {
    whenMerged { classpath -&gt;
        classpath.entries.findAll { entry -&gt; entry.kind == <span class="hl-string">'lib'</span> }*.exported = false
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:eclipse_modify_xml" class="section-anchor" href="#sec:eclipse_modify_xml"></a>Modifying the XML representation</h4></div></div></div><p>The <code class="literal">withXml</code> hook allows to manipulate the in-memory XML representation just before the file gets written to disk. Although Groovy&rsquo;s XML support makes up for a lot, this approach is less convenient than manipulating the domain objects. In return, you get total control over the generated file, including sections not modeled by the domain objects.</p><div class="example"><a name="wtpWithXml"></a><p class="title"><b>Example&nbsp;487.&nbsp;Customizing the XML</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'eclipse-wtp'</span>

eclipse.wtp.facet.file.withXml { provider -&gt;
    provider.asNode().fixed.find { it.<span class="hl-annotation">@facet</span> == <span class="hl-string">'jst.java'</span> }.<span class="hl-annotation">@facet</span> = <span class="hl-string">'jst2.java'</span>
}
</pre></div></div><br class="example-break"></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="idea_plugin"></a>The IDEA Plugin</h1></div></div></div><p>The IDEA plugin generates files that are used by <a class="ulink" href="http://www.jetbrains.com/idea/" target="_top">IntelliJ IDEA</a>, thus making it possible to open the project from IDEA (<code class="literal">File</code> - <code class="literal">Open Project</code>). Both external dependencies (including associated source and Javadoc files) and project dependencies are considered.</p><p>What exactly the IDEA plugin generates depends on which other plugins are used:</p><div class="table"><p class="title"><b>Table&nbsp;94.&nbsp;IDEA plugin behavior</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N18ECE"><thead><tr>
<td>Plugin</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>None</p></td>
<td><p>Generates an IDEA module file. Also generates an IDEA project and workspace file if the project is the root project.</p></td>
</tr><tr>
<td><p><a class="link" href="#java_plugin">Java</a></p></td>
<td><p>Adds Java configuration to the module and project files.</p></td>
</tr></tbody></table></div></div><p>One focus of the IDEA plugin is to be open to customization. The plugin provides a standardized set of hooks for adding and removing content from the generated files.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:idea_usage" class="section-anchor" href="#sec:idea_usage"></a>Usage</h2></div></div></div><p>To use the IDEA plugin, include this in your build script:</p><div class="example"><a name="useIdeaPlugin"></a><p class="title"><b>Example&nbsp;488.&nbsp;Using the IDEA plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'idea'</span>
</pre></div></div><br class="example-break"><p>The IDEA plugin adds a number of tasks to your project. The main tasks that you will use are the <code class="literal">idea</code> and <code class="literal">cleanIdea</code> tasks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:idea_tasks" class="section-anchor" href="#sec:idea_tasks"></a>Tasks</h2></div></div></div><p>The IDEA plugin adds the tasks shown below to a project. Notice that the <code class="literal">clean</code> task does not depend on the <code class="literal">cleanIdeaWorkspace</code> task. This is because the workspace typically contains a lot of user specific temporary data and it is not desirable to manipulate it outside IDEA.</p><div class="table"><p class="title"><b>Table&nbsp;95.&nbsp;IDEA plugin - Tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="ideatasks"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">idea</code></p></td>
<td><p><code class="literal">ideaProject</code>, <code class="literal">ideaModule</code>, <code class="literal">ideaWorkspace</code></p></td>
<td><p>-</p></td>
<td><p>Generates all IDEA configuration files</p></td>
</tr><tr>
<td><p><code class="literal">cleanIdea</code></p></td>
<td><p><code class="literal">cleanIdeaProject</code>, <code class="literal">cleanIdeaModule</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes all IDEA configuration files</p></td>
</tr><tr>
<td><p><code class="literal">cleanIdeaProject</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the IDEA project file</p></td>
</tr><tr>
<td><p><code class="literal">cleanIdeaModule</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the IDEA module file</p></td>
</tr><tr>
<td><p><code class="literal">cleanIdeaWorkspace</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Delete.html" target="_top"><code class="classname">Delete</code></a></p></td>
<td><p>Removes the IDEA workspace file</p></td>
</tr><tr>
<td><p><code class="literal">ideaProject</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.GenerateIdeaProject.html" target="_top"><code class="classname">GenerateIdeaProject</code></a></p></td>
<td><p>Generates the <code class="literal">.ipr</code> file. This task is only added to the root project.</p></td>
</tr><tr>
<td><p><code class="literal">ideaModule</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.GenerateIdeaModule.html" target="_top"><code class="classname">GenerateIdeaModule</code></a></p></td>
<td><p>Generates the <code class="literal">.iml</code> file</p></td>
</tr><tr>
<td><p><code class="literal">ideaWorkspace</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.GenerateIdeaWorkspace.html" target="_top"><code class="classname">GenerateIdeaWorkspace</code></a></p></td>
<td><p>Generates the <code class="literal">.iws</code> file. This task is only added to the root project.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:idea_configuration" class="section-anchor" href="#sec:idea_configuration"></a>Configuration</h2></div></div></div><div class="table"><p class="title"><b>Table&nbsp;96.&nbsp;Configuration of the idea plugin</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="idea-configuration"><thead><tr>
<td>Model</td>
<td>Reference name</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaModel.html" target="_top"><code class="classname">IdeaModel</code></a></p></td>
<td><p><code class="literal">idea</code></p></td>
<td><p>Top level element that enables configuration of the idea plugin in a DSL-friendly fashion</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html" target="_top"><code class="classname">IdeaProject</code></a></p></td>
<td><p><code class="literal">idea.project</code></p></td>
<td><p>Allows configuring project information</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html" target="_top"><code class="classname">IdeaModule</code></a></p></td>
<td><p><code class="literal">idea.module</code></p></td>
<td><p>Allows configuring module information</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaWorkspace.html" target="_top"><code class="classname">IdeaWorkspace</code></a></p></td>
<td><p><code class="literal">idea.workspace</code></p></td>
<td><p>Allows configuring the workspace XML</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:idea_customizing_the_generated_files" class="section-anchor" href="#sec:idea_customizing_the_generated_files"></a>Customizing the generated files</h2></div></div></div><p>The IDEA plugin provides hooks and behavior for customizing the generated content. The workspace file can effectively only be manipulated via the <code class="literal">withXml</code> hook because its corresponding domain object is essentially empty.</p><p>The tasks recognize existing IDEA files, and merge them with the generated content.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:merging_with_idea_files" class="section-anchor" href="#sec:merging_with_idea_files"></a>Merging</h3></div></div></div><p>Sections of existing IDEA files that are also the target of generated content will be amended or overwritten, depending on the particular section. The remaining sections will be left as-is.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:complete_overwrite_of_idea_files" class="section-anchor" href="#sec:complete_overwrite_of_idea_files"></a>Disabling merging with a complete overwrite</h4></div></div></div><p>To completely rewrite existing IDEA files, execute a clean task together with its corresponding generation task, like &ldquo;<code class="literal">gradle cleanIdea idea</code>&rdquo; (in that order). If you want to make this the default behavior, add &ldquo;<code class="literal">tasks.idea.dependsOn(cleanIdea)</code>&rdquo; to your build script. This makes it unnecessary to execute the clean task explicitly.</p><p>This strategy can also be used for individual files that the plugin would generate. For instance, this can be done for the &ldquo;<code class="literal">.iml</code>&rdquo; file with &ldquo;<code class="literal">gradle cleanIdeaModule ideaModule</code>&rdquo;.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:hooking_into_the_idea_generation_lifecycle" class="section-anchor" href="#sec:hooking_into_the_idea_generation_lifecycle"></a>Hooking into the generation lifecycle</h3></div></div></div><p>The plugin provides objects modeling the sections of the metadata files that are generated by Gradle. The generation lifecycle is as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The file is read; or a default version provided by Gradle is used if it does not exist</p></li><li class="listitem"><p>The <code class="literal">beforeMerged</code> hook is executed with a domain object representing the existing file</p></li><li class="listitem"><p>The existing content is merged with the configuration inferred from the Gradle build or defined explicitly in the eclipse DSL</p></li><li class="listitem"><p>The <code class="literal">whenMerged</code> hook is executed with a domain object representing contents of the file to be persisted</p></li><li class="listitem"><p>The <code class="literal">withXml</code> hook is executed with a raw representation of the XML that will be persisted</p></li><li class="listitem"><p>The final XML is persisted
The following table lists the domain object used for each of the model types:</p></li></ol></div><div class="table"><p class="title"><b>Table&nbsp;97.&nbsp;Idea plugin hooks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="idea-hooks"><thead><tr>
<td>Model</td>
<td><code class="literal">beforeMerged { arg &rarr; }</code> argument type</td>
<td><code class="literal">whenMerged { arg &rarr; }</code> argument type</td>
<td><code class="literal">withXml { arg &rarr; }</code> argument type</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaProject.html" target="_top"><code class="classname">IdeaProject</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Project.html" target="_top"><code class="classname">Project</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Project.html" target="_top"><code class="classname">Project</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaModule.html" target="_top"><code class="classname">IdeaModule</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Module.html" target="_top"><code class="classname">Module</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Module.html" target="_top"><code class="classname">Module</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.plugins.ide.idea.model.IdeaWorkspace.html" target="_top"><code class="classname">IdeaWorkspace</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Workspace.html" target="_top"><code class="classname">Workspace</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/plugins/ide/idea/model/Workspace.html" target="_top"><code class="classname">Workspace</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/XmlProvider.html" target="_top"><code class="classname">XmlProvider</code></a></p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:partial-rewrite" class="section-anchor" href="#sec:partial-rewrite"></a>Partial rewrite of existing content</h4></div></div></div><p>A <a class="link" href="#">complete rewrite</a> causes all existing content to be discarded, thereby losing any changes made directly in the IDE. The <code class="literal">beforeMerged</code> hook makes it possible to overwrite just certain parts of the existing content. The following example removes all existing dependencies from the <code class="literal">Module</code> domain object:</p><div class="example"><a name="partialRewrites"></a><p class="title"><b>Example&nbsp;489.&nbsp;Partial Rewrite for Module</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">idea.module.iml {
    beforeMerged { module -&gt;
        module.dependencies.clear()
    }
}
</pre></div></div><br class="example-break"><p>The resulting module file will only contain Gradle-generated dependency entries, but not any other dependency entries that may have been present in the original file. (In the case of dependency entries, this is also the default behavior.) Other sections of the module file will be either left as-is or merged. The same could be done for the module paths in the project file:</p><div class="example"><a name="partialRewritesProject"></a><p class="title"><b>Example&nbsp;490.&nbsp;Partial Rewrite for Project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">idea.project.ipr {
    beforeMerged { project -&gt;
        project.modulePaths.clear()
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:idea_modify_domain_objects" class="section-anchor" href="#sec:idea_modify_domain_objects"></a>Modifying the fully populated domain objects</h4></div></div></div><p>The <code class="literal">whenMerged</code> hook allows you to manipulate the fully populated domain objects. Often this is the preferred way to customize IDEA files. Here is how you would export all the dependencies of an IDEA module:</p><div class="example"><a name="exportDependencies"></a><p class="title"><b>Example&nbsp;491.&nbsp;Export Dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">idea.module.iml {
    whenMerged { module -&gt;
        module.dependencies*.exported = true
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:idea_modify_xml" class="section-anchor" href="#sec:idea_modify_xml"></a>Modifying the XML representation</h4></div></div></div><p>The <code class="literal">withXml</code> hook allows you to manipulate the in-memory XML representation just before the file gets written to disk. Although Groovy&rsquo;s XML support makes up for a lot, this approach is less convenient than manipulating the domain objects. In return, you get total control over the generated file, including sections not modeled by the domain objects.</p><div class="example"><a name="projectWithXml"></a><p class="title"><b>Example&nbsp;492.&nbsp;Customizing the XML</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">idea.project.ipr {
    withXml { provider -&gt;
        provider.node.component
                .find { it.<span class="hl-annotation">@name</span> == <span class="hl-string">'VcsDirectoryMappings'</span> }
                .mapping.<span class="hl-annotation">@vcs</span> = <span class="hl-string">'Git'</span>
    }
}
</pre></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:further_things_to_consider" class="section-anchor" href="#sec:further_things_to_consider"></a>Further things to consider</h2></div></div></div><p>The paths of dependencies in the generated IDEA files are absolute. If you manually define a path variable pointing to the Gradle dependency cache, IDEA will automatically replace the absolute dependency paths with this path variable. you can configure this path variable via the &ldquo;<code class="literal">idea.pathVariables</code>&rdquo; property, so that it can do a proper merge without creating duplicates.</p></div></div></div><div class="part" title="The Software model"><div class="titlepage"><div><div><h1 class="title"><a name="N19166"></a>The Software model</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="software_model"></a>Rule based model configuration</h1></div></div></div><div class="note"><p>Support for rule based configuration is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p>Rule based model configuration enables <span class="emphasis"><em>configuration logic to itself have dependencies</em></span> on other elements of configuration, and to make use of the resolved states of those other elements of configuration while performing its own configuration.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:background" class="section-anchor" href="#sec:background"></a>Background</h2></div></div></div><p>Rule based model configuration facilitates easier domain modelling: communicating intent (i.e. the what) over mechanics (i.e. the how). Domain modelling is a core tenet of Gradle and provides Gradle with several advantages over prior generation build tools such as Apache Ant that focus on the execution model. It allows humans to understand builds at a level that is meaningful to them.</p><p>As well as helping humans, a strong domain model also helps the dutiful machines. Plugins can more effectively collaborate around a strong domain model (e.g. plugins can say something about Java applications, such as providing conventions). Very importantly, by having a model of the <span class="emphasis"><em>what</em></span> instead of the <span class="emphasis"><em>how</em></span> Gradle can make intelligent choices on just how to do the how.</p><p>Gradle&rsquo;s support for building <a class="link" href="#native_software">native software</a> and <a class="link" href="#play_plugin">Play Framework applications</a> already uses this configuration model. Gradle also includes some initial support for building <a class="link" href="#java_software">Java libraries</a> using this configuration model.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:motivations_for_change" class="section-anchor" href="#sec:motivations_for_change"></a>Motivations for change</h2></div></div></div><p>Domain modelling in Gradle isn&rsquo;t new. The Java plugin&rsquo;s <a class="ulink" href="../dsl/org.gradle.api.tasks.SourceSet.html" target="_top"><code class="classname">SourceSet</code></a> concept is an example of domain modelling, as is the modelling of <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinary.html" target="_top"><code class="classname">NativeBinary</code></a> in the native plugin suite.</p><p>A distinguishing characteristic of Gradle compared to other build tools that also embrace modelling is that Gradle&rsquo;s model is open and collaborative. Gradle is fundamentally a tool for modelling software construction and then realizing the model, via tasks such as compilation etc. Different domain plugins (e.g. Java, C++, Android) provide models that other plugins can collaborate with and build upon.</p><p>While Gradle has long employed sophisticated techniques when it comes to realizing the model (i.e. what we know as building code), the next generation of Gradle builds will employ some of the same techniques to creation of the model itself. By defining build tasks as effectively a graph of dependent functions with explicit inputs and outputs, Gradle is able to order, cache, parallelize and apply other optimizations to the work. Using a &ldquo;graph of tasks&rdquo; for the production of software is a long established idea, and necessary given the complexity of software production. The task graph effectively defines the <span class="emphasis"><em>rules</em></span> of execution that Gradle must follow. The term &ldquo;Rule based model configuration&rdquo; refers to applying the same concepts to building the model that builds the task graph.</p><p>Another key motivation is performance and scale. Aspects of the current approach that Gradle takes to modelling the build reduce parallelism opportunities and limit scalability. The software model is being designed with the requirements of modern software delivery in mind, where immediate responsiveness is critical for projects large and small.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:basic_concepts" class="section-anchor" href="#sec:basic_concepts"></a>Basic Concepts</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_model_space" class="section-anchor" href="#sec:the_model_space"></a>The &ldquo;model space&rdquo;</h3></div></div></div><p>The term &ldquo;model space&rdquo;&nbsp;is used to refer to the formal model, which can be read and modified by rules.</p><p>A counterpart to the model space is the &ldquo;project space&rdquo;, which should be familiar to readers. The &ldquo;project space&rdquo; is a graph of objects (e.g <code class="literal">project.repositories</code>, <code class="literal">project.tasks</code> etc.) having a <a class="ulink" href="../dsl/org.gradle.api.Project.html" target="_top"><code class="classname">Project</code></a> as its root. A build script is effectively adding and configuring objects of this graph. For the most part, the &ldquo;project space&rdquo; is opaque to Gradle. It is an arbitrary graph of objects that Gradle only partially understands.</p><p>Each project also has its own model space, which is distinct from the project space. A key characteristic of the &ldquo;model space&rdquo; is that Gradle knows much more about it (which is knowledge that can be put to good use). The objects in the model space are &ldquo;managed&rdquo;, to a greater extent than objects in the project space. The origin, structure, state, collaborators and relationships of objects in the model space are first class constructs. This is effectively the characteristic that functionally distinguishes the model space from the project space: the objects of the model space are defined in ways that Gradle can understand them intimately, as opposed to an object that is the result of running relatively opaque code. A &ldquo;rule&rdquo;&nbsp;is effectively a building block of this definition.</p><p>The model space will eventually replace the project space, becoming the only &ldquo;space&rdquo;.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:rules" class="section-anchor" href="#sec:rules"></a>Rules</h3></div></div></div><p>The model space is defined by &ldquo;rules&rdquo;. A rule is just a function (in the abstract sense) that either produces a model element, or acts upon a model element. Every rule has a single subject and zero or more inputs. Only the subject can be changed by a rule, while the inputs are effectively immutable.</p><p>Gradle guarantees that all inputs are fully &ldquo;realized&ldquo; before the rule executes. The process of &ldquo;realizing&rdquo; a model element is effectively executing all the rules for which it is the subject, transitioning it to its final state. There is a strong analogy here to Gradle&rsquo;s task graph and task execution model. Just as tasks depend on each other and Gradle ensures that dependencies are satisfied before executing a task, rules effectively depend on each other (i.e. a rule depends on all rules whose subject is one of the inputs) and Gradle ensures that all dependencies are satisfied before executing the rule.</p><p>Model elements are very often defined in terms of other model elements. For example, a compile task&rsquo;s configuration can be defined in terms of the configuration of the source set that it is compiling. In this scenario, the compile task would be the subject of a rule and the source set an input. Such a rule could configure the task subject based on the source set input without concern for how it was configured, who it was configured by or when the configuration was specified.</p><p>There are several ways to declare rules, and in several forms.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:rule_sources" class="section-anchor" href="#sec:rule_sources"></a>Rule sources</h2></div></div></div><p>One way to define rules is via a <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> subclass. If an object extends RuleSource and contains any methods annotated by '@Mutate', then each such method defines a rule. For each such method, the first argument is the subject, and zero or more subsequent arguments may follow and are inputs of the rule.</p><div class="example"><a name="basicRuleSourcePlugin-all"></a><p class="title"><b>Example&nbsp;493.&nbsp;applying a rule source plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> Person {
  <span class="hl-keyword">void</span> setFirstName(String name)
  String getFirstName()

  <span class="hl-keyword">void</span> setLastName(String name)
  String getLastName()
}

<span class="hl-keyword">class</span> PersonRules <span class="hl-keyword">extends</span> RuleSource {
  <span class="hl-annotation">@Model</span> <span class="hl-keyword">void</span> person(Person p) {}

  <span class="hl-comment">//Create a rule that modifies a Person and takes no other inputs</span>
  <span class="hl-annotation">@Mutate</span> <span class="hl-keyword">void</span> setFirstName(Person p) {
    p.firstName = <span class="hl-string">"John"</span>
  }

  <span class="hl-comment">//Create a rule that modifies a ModelMap&lt;Task&gt; and takes as input a Person</span>
  <span class="hl-annotation">@Mutate</span> <span class="hl-keyword">void</span> createHelloTask(ModelMap&lt;Task&gt; tasks, Person p) {
    tasks.create(<span class="hl-string">"hello"</span>) {
      doLast {
        println <span class="hl-string">"Hello $p.firstName $p.lastName!"</span>
      }
    }
  }
}

apply plugin: PersonRules
</pre><p>Output of <strong class="userinput"><code>gradle hello</code></strong></p><pre class="screen">&gt; gradle hello
:hello
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Each of the different methods of the rule source are discrete, independent rules. Their order, or the fact that they belong to the same class, do not affect their behavior.</p><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;494.&nbsp;a model creation rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-annotation">@Model</span> <span class="hl-keyword">void</span> person(Person p) {}
</pre></div></div><br class="example-break"><p>This rule declares that there is a model element at path <code class="literal">"person"</code> (defined by the method name), of type <code class="literal">Person</code>. This is the form of the <a class="ulink" href="../javadoc/org/gradle/model/Model.html" target="_top"><code class="classname">Model</code></a> type rule for <a class="ulink" href="../javadoc/org/gradle/model/Managed.html" target="_top"><code class="classname">Managed</code></a> types. Here, the person object is the rule subject. The method could potentially have a body, that mutated the person instance. It could also potentially have more parameters, which would be the rule inputs.</p><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;495.&nbsp;a model mutation rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">//Create a rule that modifies a Person and takes no other inputs</span>
<span class="hl-annotation">@Mutate</span> <span class="hl-keyword">void</span> setFirstName(Person p) {
  p.firstName = <span class="hl-string">"John"</span>
}
</pre></div></div><br class="example-break"><p>This <a class="ulink" href="../javadoc/org/gradle/model/Mutate.html" target="_top"><code class="classname">Mutate</code></a> rule mutates the person object. The first parameter to the method is the subject. Here, a by-type reference is used as no <a class="ulink" href="../javadoc/org/gradle/model/Path.html" target="_top"><code class="classname">Path</code></a> annotation is present on the parameter. It could also potentially have more parameters, that would be the rule inputs.</p><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;496.&nbsp;creating a task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">//Create a rule that modifies a ModelMap&lt;Task&gt; and takes as input a Person</span>
<span class="hl-annotation">@Mutate</span> <span class="hl-keyword">void</span> createHelloTask(ModelMap&lt;Task&gt; tasks, Person p) {
  tasks.create(<span class="hl-string">"hello"</span>) {
    doLast {
      println <span class="hl-string">"Hello $p.firstName $p.lastName!"</span>
    }
  }
}
</pre></div></div><br class="example-break"><p>This <a class="ulink" href="../javadoc/org/gradle/model/Mutate.html" target="_top"><code class="classname">Mutate</code></a> rule effectively adds a task, by mutating the tasks collection. The subject here is the <code class="literal">"tasks"</code> node, which is available as a <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> of <a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a>. The only input is our person element. As the person is being used as an input here, it will have been realised before executing this rule. That is, the task container effectively <span class="emphasis"><em>depends on</em></span> the person element. If there are other configuration rules for the person element, potentially specified in a build script or other plugin, they will also be guaranteed to have been executed.</p><p>As <code class="literal">Person</code> is a <a class="ulink" href="../javadoc/org/gradle/model/Managed.html" target="_top"><code class="classname">Managed</code></a> type in this example, any attempt to modify the person parameter in this method would result in an exception being thrown. Managed objects enforce immutability at the appropriate point in their lifecycle.</p><p>Rule source plugins can be packaged and distributed in the same manner as other types of plugins (see <a class="xref" href="#custom_plugins"><i>Writing Custom Plugins</i></a>). They also may be applied in the same manner (to project objects) as <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> implementations (i.e. via <a class="ulink" href="../dsl/org.gradle.api.Project.html#org.gradle.api.Project:apply(java.util.Map)" target="_top"><code class="classname">Project.apply(java.util.Map)</code></a>).</p><p>Please see the documentation for <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> for more information on constraints on how rule sources must be implemented and for more types of rules.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:advanced_concepts" class="section-anchor" href="#sec:advanced_concepts"></a>Advanced Concepts</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:model_paths" class="section-anchor" href="#sec:model_paths"></a>Model paths</h3></div></div></div><p>A model path identifies the location of an element relative to the root of its model space. A common representation is a period-delimited set of names. For example, the model path <code class="literal">"tasks"</code> is the path to the element that is the task container. Assuming a task whose name is <code class="literal">hello</code>, the path <code class="literal">"tasks.hello"</code> is the path to this task.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:managed_model_elements" class="section-anchor" href="#sec:managed_model_elements"></a>Managed model elements</h3></div></div></div><p>Currently, any kind of Java object can be part of the model space. However, there is a difference between &ldquo;managed&rdquo; and &ldquo;unmanaged&rdquo;&nbsp;objects.</p><p>A &ldquo;managed&rdquo; object is transparent and enforces immutability once realized. Being transparent means that its structure is understood by the rule infrastructure and as such each of its properties are also individual elements in the model space.</p><p>An &ldquo;unmanaged&rdquo;&nbsp;object is opaque to the model space and does not enforce immutability. Over time, more mechanisms will be available for defining managed model elements culminating in all model elements being managed in some way.</p><p>Managed models can be defined by attaching the <code class="literal">@Managed</code> annotation to an interface:</p><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;497.&nbsp;a managed type</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> Person {
  <span class="hl-keyword">void</span> setFirstName(String name)
  String getFirstName()

  <span class="hl-keyword">void</span> setLastName(String name)
  String getLastName()
}
</pre></div></div><br class="example-break"><p>By defining a getter/setter pair, you are effectively declaring a managed property. A managed property is a property for which Gradle will enforce semantics such as immutability when a node of the model is not the subject of a rule. Therefore, this example declares properties named <span class="emphasis"><em>firstName</em></span> and <span class="emphasis"><em>lastName</em></span> on the managed type <span class="emphasis"><em>Person</em></span>. These properties will only be writable when the view is mutable, that is to say when the <span class="emphasis"><em>Person</em></span> is the subject of a <code class="literal">Rule</code> (see below the explanation for rules).</p><p>Managed properties can be of any scalar type. In addition, properties can also be of any type which is itself managed:</p><div class="informaltable"><table border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="left" valign="top">Property type</th><th align="left" valign="top">Nullable</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">String</code></p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;498.&nbsp;a String property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setFirstName(String name)
String getFirstName()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p><code class="literal">File</code></p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;499.&nbsp;a File property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setHomeDirectory(File homeDir)
File getHomeDirectory()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p><code class="literal">Integer</code>, <code class="literal">Boolean</code>, <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Float</code>, <code class="literal">Long</code>, <code class="literal">Double</code></p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;500.&nbsp;a Long property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setId(Long id)
Long getId()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p><code class="literal">int</code>, <code class="literal">boolean</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">float</code>, <code class="literal">long</code>, <code class="literal">double</code></p></td><td align="left" valign="top"><p>No</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;501.&nbsp;a boolean property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setEmployed(<span class="hl-keyword">boolean</span> isEmployed)
<span class="hl-keyword">boolean</span> isEmployed()
</pre></div></div><br class="example-break">
<div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;502.&nbsp;an int property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setAge(<span class="hl-keyword">int</span> age)
<span class="hl-keyword">int</span> getAge()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p>Another <span class="emphasis"><em>managed</em></span> type.</p></td><td align="left" valign="top"><p>Only if read/write</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;503.&nbsp;a managed property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setMother(Person mother)
Person getMother()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p>An <span class="emphasis"><em>enumeration</em></span> type.</p></td><td align="left" valign="top"><p>Yes</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;504.&nbsp;an enumeration type property</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setMaritalStatus(MaritalStatus status)
MaritalStatus getMaritalStatus()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p>A <code class="literal">ManagedSet</code>. A managed set supports the creation of new named model elements, but not their removal.</p></td><td align="left" valign="top"><p>Only if read/write</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;505.&nbsp;a managed set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">ModelSet&lt;Person&gt; getChildren()
</pre></div></div><br class="example-break"></td></tr><tr><td align="left" valign="top"><p>A <code class="literal">Set</code> or <code class="literal">List</code> of scalar types. All classic operations on collections are supported: add, remove, clear&hellip;</p></td><td align="left" valign="top"><p>Only if read/write</p></td><td align="left" valign="top"><div class="example"><a name="basicRuleSourcePlugin"></a><p class="title"><b>Example&nbsp;506.&nbsp;a scalar collection</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">void</span> setUserGroups(List&lt;String&gt; groups)
List&lt;String&gt; getUserGroups()
</pre></div></div><br class="example-break"></td></tr></tbody></table></div><p>If the type of a property is itself a managed type, it is possible to declare only a getter, in which case you are declaring a read-only property. A read-only property will be instantiated by Gradle, and cannot be replaced with another object of the same type (for example calling a setter). However, the properties of that property can potentially be changed, if, and only if, the property is the subject of a rule. If it&rsquo;s not the case, the property is immutable, like any classic read/write managed property, and properties of the property cannot be changed at all.</p><p>Managed types can be defined out of interfaces or abstract classes and are usually defined in plugins, which are written either in Java or Groovy. Please see the <a class="ulink" href="../javadoc/org/gradle/model/Managed.html" target="_top"><code class="classname">Managed</code></a> annotation for more information on creating managed model objects.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:model_element_types" class="section-anchor" href="#sec:model_element_types"></a>Model element types</h3></div></div></div><p>There are particular types (language types) supported by the model space and can be generalised as follows:</p><div class="table"><p class="title"><b>Table&nbsp;98.&nbsp;Type definitions</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N193CB"><thead><tr>
<td>Type</td>
<td>Definition</td>
</tr></thead><tbody><tr>
<td><p>Scalar</p></td>
<td><p>A scalar type is one of the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>a primitive type (e.g. <code class="literal">int</code>) or its boxed type (e.g <code class="literal">Integer</code>)</p></li><li class="listitem"><p>a <code class="literal">BigInteger</code> or <code class="literal">BigDecimal</code></p></li><li class="listitem"><p>a <code class="literal">String</code></p></li><li class="listitem"><p>a <code class="literal">File</code></p></li><li class="listitem"><p>an enumeration type</p></li></ul></div></td>
</tr><tr>
<td><p>Scalar Collection</p></td>
<td><p>A java.util.List or java.util.Set containing one of the scalar types</p></td>
</tr><tr>
<td><p>Managed type</p></td>
<td><p>Any class which is a valid managed model (i.e.annotated with @<a class="ulink" href="../javadoc/org/gradle/model/Managed.html" target="_top"><code class="classname">Managed</code></a>)</p></td>
</tr><tr>
<td><p>Managed collection</p></td>
<td><p>A <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> or <a class="ulink" href="../javadoc/org/gradle/model/ModelSet.html" target="_top"><code class="classname">ModelSet</code></a></p></td>
</tr></tbody></table></div></div><p>There are various contexts in which these types can be used:</p><div class="table"><p class="title"><b>Table&nbsp;99.&nbsp;Model type support</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N19433"><thead><tr>
<td>Context</td>
<td>Supported types</td>
</tr></thead><tbody><tr>
<td><p>Creating top level model elements</p></td>
<td><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Any managed type</p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> (when the <a class="ulink" href="../javadoc/org/gradle/language/base/plugins/LanguageBasePlugin.html" target="_top"><code class="classname">LanguageBasePlugin</code></a> plugin has been applied)</p></li><li class="listitem"><p>Subtypes of <a class="ulink" href="../dsl/org.gradle.language.base.LanguageSourceSet.html" target="_top"><code class="classname">LanguageSourceSet</code></a> which have been registered via <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a></p></li></ul></div></td>
</tr><tr>
<td><p>Properties of managed model elements</p></td>
<td><p>The properties (attributes) of a managed model elements may be one or more of the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A managed type</p></li><li class="listitem"><p>A type which is annotated with @<a class="ulink" href="../javadoc/org/gradle/model/Unmanaged.html" target="_top"><code class="classname">Unmanaged</code></a></p></li><li class="listitem"><p>A Scalar Collection</p></li><li class="listitem"><p>A Managed collection containing managed types</p></li><li class="listitem"><p>A Managed collection containing <a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a>'s (when the <a class="ulink" href="../javadoc/org/gradle/language/base/plugins/LanguageBasePlugin.html" target="_top"><code class="classname">LanguageBasePlugin</code></a> plugin has been applied)</p></li><li class="listitem"><p>Subtypes of <a class="ulink" href="../dsl/org.gradle.language.base.LanguageSourceSet.html" target="_top"><code class="classname">LanguageSourceSet</code></a> which have been registered via <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a></p></li></ul></div></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:language_source_sets" class="section-anchor" href="#sec:language_source_sets"></a>Language source sets</h3></div></div></div><p><a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a>s and subtypes of <a class="ulink" href="../dsl/org.gradle.language.base.LanguageSourceSet.html" target="_top"><code class="classname">LanguageSourceSet</code></a> (which have been registered via <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a>) can be added to the model space via rules or via the model DSL.</p><div class="example"><a name="model-language-support-all"></a><p class="title"><b>Example&nbsp;507.&nbsp;strongly modelling sources sets</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'java-lang'</span>

<span class="hl-comment">//Creating LanguageSourceSets via rules</span>
<span class="hl-keyword">class</span> LanguageSourceSetRules <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@Model</span>
    <span class="hl-keyword">void</span> mySourceSet(JavaSourceSet javaSource) {
        javaSource.source.srcDir(<span class="hl-string">"src/main/my"</span>)
    }
}
apply plugin: LanguageSourceSetRules

<span class="hl-comment">//Creating LanguageSourceSets via the model DSL</span>
model {
    another(JavaSourceSet) {
        source {
            srcDir <span class="hl-string">"src/main/another"</span>
        }
    }
}

<span class="hl-comment">//Using FunctionalSourceSets</span>
<span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> SourceBundle {
    FunctionalSourceSet getFreeSources()
    FunctionalSourceSet getPaidSources()
}
model {
    sourceBundle(SourceBundle) {
        freeSources.create(<span class="hl-string">"main"</span>, JavaSourceSet)
        freeSources.create(<span class="hl-string">"resources"</span>, JvmResourceSet)
        paidSources.create(<span class="hl-string">"main"</span>, JavaSourceSet)
        paidSources.create(<span class="hl-string">"resources"</span>, JvmResourceSet)
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/modelRules/language-support</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p>Output of <strong class="userinput"><code>gradle help</code></strong></p><pre class="screen">&gt; gradle help
:help
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:references_binding_and_scopes" class="section-anchor" href="#sec:references_binding_and_scopes"></a>References, binding and scopes</h3></div></div></div><p>As previously mentioned, a rule has a subject and zero or more inputs. The rule&rsquo;s subject and inputs are declared as &ldquo;references&rdquo; and are &ldquo;bound&rdquo;&nbsp;to model elements before execution by Gradle. Each rule must effectively forward declare the subject and inputs as references. Precisely how this is done depends on the form of the rule. For example, the rules provided by a <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> declare references as method parameters.</p><p>A reference is either &ldquo;by-path&rdquo; or &ldquo;by-type&rdquo;.</p><p>A &ldquo;by-type&rdquo; reference identifies a particular model element by its type. For example, a reference to the <a class="ulink" href="../javadoc/org/gradle/api/tasks/TaskContainer.html" target="_top"><code class="classname">TaskContainer</code></a> effectively identifies the <code class="literal">"tasks"</code> element in the project model space. The model space is not exhaustively searched for candidates for by-type binding; rather, a rule is given a scope (discussed later) that determines the search space for a by-type binding.</p><p>A &ldquo;by-path&rdquo;&nbsp;reference identifies a particular model element by its path in model space. By-path references are always relative to the rule scope; there is currently no way to path &ldquo;out&rdquo; of the scope. All by-path references also have an associated type, but this does not influence what the reference binds to. The element identified by the path must however by type compatible with the reference, or a fatal &ldquo;binding failure&rdquo; will occur.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:binding_scope" class="section-anchor" href="#sec:binding_scope"></a>Binding scope</h4></div></div></div><p>Rules are bound within a &ldquo;scope&rdquo;, which determines how references bind. Most rules are bound at the project scope (i.e. the root of the model graph for the project). However, rules can be scoped to a node within the graph. The <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html#named-java.lang.String, java.lang.Class-" target="_top"><code class="classname">ModelMap.named(java.lang.String, java.lang.Class)</code></a> method is an example of a mechanism for applying scoped rules. Rules declared in the build script using the <code class="literal">model {}</code> block, or via a <code class="literal">RuleSource</code> applied as a plugin use the root of the model space as the scope. This can be considered the default scope.</p><p>By-path references are always relative to the rule scope. When the scope is the root, this effectively allows binding to any element in the graph. When it is not, then only the children of the scope can be referenced using "by-path" notation.</p><p>When binding by-type references, the following elements are considered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The scope element itself.</p></li><li class="listitem"><p>The immediate children of the scope element.</p></li><li class="listitem"><p>The immediate children of the model space (i.e. project space) root.</p></li></ul></div><p>For the common case, where the rule is effectively scoped to the root, only the immediate children of the root need to be considered.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="binding_all_elements_in_scope" class="section-anchor" href="#binding_all_elements_in_scope"></a>Binding to all elements in a scope matching type</h4></div></div></div><p>Mutating or validating all elements of a given type in some scope is a common use-case. To accommodate this, rules can be applied via the <code class="literal">@Each</code> annotation.</p><p>In the example below, a <code class="literal">@Defaults</code> rule is applied to each <code class="literal">FileItem</code> in the model setting a default file size of "1024". Another rule applies a <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> to every <code class="literal">DirectoryItem</code> that makes sure all file sizes are positive and divisible by "16".</p><div class="example"><a name="ruleSourcePluginEach"></a><p class="title"><b>Example&nbsp;508.&nbsp;a DSL example applying a rule to every element in a scope</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span> <span class="hl-keyword">interface</span> Item <span class="hl-keyword">extends</span> Named {}
<span class="hl-annotation">@Managed</span> <span class="hl-keyword">interface</span> FileItem <span class="hl-keyword">extends</span> Item {
    <span class="hl-keyword">void</span> setSize(<span class="hl-keyword">int</span> size)
    <span class="hl-keyword">int</span> getSize()
}
<span class="hl-annotation">@Managed</span> <span class="hl-keyword">interface</span> DirectoryItem <span class="hl-keyword">extends</span> Item {
    ModelMap&lt;Item&gt; getChildren()
}

<span class="hl-keyword">class</span> PluginRules <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@Defaults</span> <span class="hl-keyword">void</span> setDefaultFileSize(<span class="hl-annotation">@Each</span> FileItem file) {
        file.size = <span class="hl-number">1024</span>
    }

    <span class="hl-annotation">@Rules</span> <span class="hl-keyword">void</span> applyValidateRules(ValidateRules rules, <span class="hl-annotation">@Each</span> DirectoryItem directory)  {}
}
apply plugin: PluginRules

<span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> ValidateRules <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@Validate</span>
    <span class="hl-keyword">void</span> validateSizeIsPositive(ModelMap&lt;FileItem&gt; files) {
        files.each { file -&gt;
            assert file.size &gt; <span class="hl-number">0</span>
        }
    }

    <span class="hl-annotation">@Validate</span>
    <span class="hl-keyword">void</span> validateSizeDivisibleBySixteen(ModelMap&lt;FileItem&gt; files) {
        files.each { file -&gt;
            assert file.size % <span class="hl-number">16</span> == <span class="hl-number">0</span>
        }
    }
}

model {
    root(DirectoryItem) {
        children {
            dir(DirectoryItem) {
                children {
                    file1(FileItem)
                    file2(FileItem) { size = <span class="hl-number">2048</span> }
                }
            }
            file3(FileItem)
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/modelRules/ruleSourcePluginEach</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="model-dsl" class="section-anchor" href="#model-dsl"></a>The model DSL</h2></div></div></div><p>In addition to using a RuleSource, it is also possible to declare a model and rules directly in a build script using the &ldquo;model DSL&rdquo;.</p><div class="tip"><p>The model DSL makes heavy use of various Groovy DSL features. Please have a read of <a class="xref" href="#groovy-dsl-basics">the section called &ldquo;Some Groovy basics&rdquo;</a> for an introduction to these Groovy features.</p></div><p>The general form of the model DSL is:</p><pre class="programlisting">model {
    &laquo;rule-definitions&raquo;
}</pre><p>All rules are nested inside a <code class="literal">model</code> block. There may be any number of rule definitions inside each <code class="literal">model</code> block, and there may be any number of <code class="literal">model</code> blocks in a build script. You can also use a <code class="literal">model</code> block in build scripts that are applied using <code class="literal">apply from: $uri</code>.</p><p>There are currently 2 kinds of rule that you can define using the model DSL: configuration rules, and creation rules.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuration_rules" class="section-anchor" href="#sec:configuration_rules"></a>Configuration rules</h3></div></div></div><p>You can define a rule that configures a particular model element. A configuration rule has the following form:</p><pre class="programlisting">model {
    &laquo;model-path-to-subject&raquo; {
        &laquo;configuration code&raquo;
    }
}</pre><p>Continuing with the example so far of the model element <code class="literal">"person"</code> of type <code class="literal">Person</code> being present, the following DSL snippet adds a configuration rule for the person that sets its <code class="literal">lastName</code> property.</p><div class="example"><a name="modelDslConfigure"></a><p class="title"><b>Example&nbsp;509.&nbsp;DSL configuration rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    person {
        lastName = <span class="hl-string">"Smith"</span>
    }
}
</pre></div></div><br class="example-break"><p>A configuration rule specifies a path to the subject that should be configured and a closure containing the code to run when the subject is configured. The closure is executed with the subject passed as the closure delegate. Exactly what code you can provide in the closure depends on the type of the subject. This is discussed below.</p><p>You should note that the configuration code is not executed immediately but is instead executed only when the subject is required. This is an important behaviour of model rules and allows Gradle to configure only those elements that are required for the build, which helps reduce build time. For example, let&rsquo;s run a task that uses the "person" object:</p><div class="example"><a name="modelDslConfigureRuleRunWhenRequired"></a><p class="title"><b>Example&nbsp;510.&nbsp;Configuration run when required</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    person {
        println <span class="hl-string">"configuring person"</span>
        lastName = <span class="hl-string">"Smith"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle showPerson</code></strong></p><pre class="screen">&gt; gradle showPerson
configuring person
:showPerson
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>You can see that before the task is run, the "person" element is configured by running the rule closure. Now let&rsquo;s run a task that does not require the "person" element:</p><div class="example"><a name="modelDslConfigureRuleNotRunWhenNotRequired"></a><p class="title"><b>Example&nbsp;511.&nbsp;Configuration not run when not required</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle somethingElse</code></strong></p><pre class="screen">&gt; gradle somethingElse
:somethingElse
Not using person

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>In this instance, you can see that the "person" element is not configured at all.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:creation_rules" class="section-anchor" href="#sec:creation_rules"></a>Creation rules</h3></div></div></div><p>It is also possible to create model elements at the root level. The general form of a creation rule is:</p><pre class="programlisting">model {
    &laquo;element-name&raquo;(&laquo;element-type&raquo;) {
        &laquo;initialization code&raquo;
    }
}</pre><p>The following model rule creates the <code class="literal">"person"</code> element:</p><div class="example"><a name="modelDslCreate"></a><p class="title"><b>Example&nbsp;512.&nbsp;DSL creation rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    person(Person) {
        firstName = <span class="hl-string">"John"</span>
    }
}
</pre></div></div><br class="example-break"><p>A creation rule definition specifies the path of the element to create, plus its public type, represented as a Java interface or class. Only certain types of model elements can be created.</p><p>A creation rule may also provide a closure containing the initialization code to run when the element is created. The closure is executed with the element passed as the closure delegate. Exactly what code you can provide in the closure depends on the type of the subject. This is discussed below.</p><p>The initialization closure is optional and can be omitted, for example:</p><div class="example"><a name="modelDslCreateNoConfig"></a><p class="title"><b>Example&nbsp;513.&nbsp;DSL creation rule without initialization</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    barry(Person)
}
</pre></div></div><br class="example-break"><p>You should note that the initialization code is not executed immediately but is instead executed only when the element is required. The initialization code is executed before any configuration rules are run. For example:</p><div class="example"><a name="modelDslInitializationRuleRunsBeforeConfigurationRule"></a><p class="title"><b>Example&nbsp;514.&nbsp;Initialization before configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    person {
        println <span class="hl-string">"configuring person"</span>
        println <span class="hl-string">"last name is $lastName, should be Smythe"</span>
        lastName = <span class="hl-string">"Smythe"</span>
    }
    person(Person) {
        println <span class="hl-string">"creating person"</span>
        firstName = <span class="hl-string">"John"</span>
        lastName = <span class="hl-string">"Smith"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle showPerson</code></strong></p><pre class="screen">&gt; gradle showPerson
creating person
configuring person
last name is Smith, should be Smythe
:showPerson
Hello John Smythe!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Notice that the creation rule appears in the build script <span class="emphasis"><em>after</em></span> the configuration rule, but its code runs before the code of the configuration rule. Gradle collects up all the rules for a particular subject before running any of them, then runs the rules in the appropriate order.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:model_rule_closures" class="section-anchor" href="#sec:model_rule_closures"></a>Model rule closures</h3></div></div></div><p>Most DSL rules take a closure containing some code to run to configure the subject. The code you can use in this closure depends on the type of the subject of the rule.</p><div class="tip"><p>You can use the <a class="link" href="#model-report">model report</a> to determine the type of a particular model element.</p></div><p>In general, a rule closure may contain arbitrary code, mixed with some type specific DSL syntax.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:modelmap_subject" class="section-anchor" href="#sec:modelmap_subject"></a><code class="literal">ModelMap&lt;T&gt;</code> subject</h4></div></div></div><p>A <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> is basically a map of model elements, indexed by some name. When a <code class="literal">ModelMap</code> is used as the subject of a DSL rule, the rule closure can use any of the methods defined on the <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> interface.</p><p>A rule closure with <code class="literal">ModelMap</code> as a subject can also include nested creation or configuration rules. These behave in a similar way to the creation and configuration rules that appear directly under the <code class="literal">model</code> block.</p><p>Here is an example of a nested creation rule:</p><div class="example"><a name="modelDslModelMapNestedCreate"></a><p class="title"><b>Example&nbsp;515.&nbsp;Nested DSL creation rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    people {
        john(Person) {
            firstName = <span class="hl-string">"John"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>As before, a nested creation rule defines a name and public type for the element, and optionally, a closure containing code to use to initialize the element. The code is run only when the element is required in the build.</p><p>Here is an example of a nested configuration rule:</p><div class="example"><a name="modelDslModelMapNestedConfig"></a><p class="title"><b>Example&nbsp;516.&nbsp;Nested DSL configuration rule</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    people {
        john {
            lastName = <span class="hl-string">"Smith"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>As before, a nested configuration rule defines the name of the element to configure and a closure containing code to use to configure the element. The code is run only when the element is required in the build.</p><p><code class="literal">ModelMap</code> introduces several other kinds of rules. For example, you can define a rule that targets each of the elements in the map. The code in the rule closure is executed once for each element in the map, when that element is required. Let&rsquo;s run a task that requires all of the children of the "people" element:</p><div class="example"><a name="modelDslModelMapNestedAll"></a><p class="title"><b>Example&nbsp;517.&nbsp;DSL configuration rule for each element in a map</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    people {
        john(Person) {
            println <span class="hl-string">"creating $it"</span>
            firstName = <span class="hl-string">"John"</span>
            lastName = <span class="hl-string">"Smith"</span>
        }
        all {
            println <span class="hl-string">"configuring $it"</span>
        }
        barry(Person) {
            println <span class="hl-string">"creating $it"</span>
            firstName = <span class="hl-string">"Barry"</span>
            lastName = <span class="hl-string">"Barry"</span>
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle listPeople</code></strong></p><pre class="screen">&gt; gradle listPeople
creating Person 'people.barry'
configuring Person 'people.barry'
creating Person 'people.john'
configuring Person 'people.john'
:listPeople
Hello Barry Barry!
Hello John Smith!

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Any method on <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> that accepts an <a class="ulink" href="../javadoc/org/gradle/api/Action.html" target="_top"><code class="classname">Action</code></a> as its last parameter can also be used to define a nested rule.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:managed_type_subject" class="section-anchor" href="#sec:managed_type_subject"></a><code class="literal">@Managed</code> type subject</h4></div></div></div><p>When a managed type is used as the subject of a DSL rule, the rule closure can use any of the methods defined on the managed type interface.</p><p>A rule closure can also configure the properties of the element using nested closures. For example:</p><div class="example"><a name="modelDslManagedTypeNestedConfigure"></a><p class="title"><b>Example&nbsp;518.&nbsp;Nested DSL property configuration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    person {
        address {
            city = <span class="hl-string">"Melbourne"</span>
        }
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>Currently, the nested closures do not define rules and are executed immediately. Please be aware that this behaviour will change in a future Gradle release.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:all_other_subjects" class="section-anchor" href="#sec:all_other_subjects"></a>All other subjects</h4></div></div></div><p>For all other types, the rule closure can use any of the methods defined by the type. There is no special DSL defined for these elements.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dsl-type-coercion" class="section-anchor" href="#dsl-type-coercion"></a>Automatic type coercion</h3></div></div></div><p>Scalar properties in managed types can be assigned <code class="literal">CharSequence</code> values (e.g. <code class="literal">String</code>, <code class="literal">GString</code>, etc.) and they will be converted to the actual property type for you. This works for all scalar types including `File`s, which will be resolved relative to the current project.</p><div class="example"><a name="modelDslConversions"></a><p class="title"><b>Example&nbsp;519.&nbsp;a DSL example showing type conversions</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">enum Temperature {
   TOO_HOT,
   TOO_COLD,
   JUST_RIGHT
}

<span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> Item {
   <span class="hl-keyword">void</span> setName(String n); String getName()

   <span class="hl-keyword">void</span> setQuantity(<span class="hl-keyword">int</span> q); <span class="hl-keyword">int</span> getQuantity()

   <span class="hl-keyword">void</span> setPrice(<span class="hl-keyword">float</span> p); <span class="hl-keyword">float</span> getPrice()

   <span class="hl-keyword">void</span> setTemperature(Temperature t)
   Temperature getTemperature()

   <span class="hl-keyword">void</span> setDataFile(File f); File getDataFile()
}

<span class="hl-keyword">class</span> ItemRules <span class="hl-keyword">extends</span> RuleSource {
   <span class="hl-annotation">@Model</span>
   <span class="hl-keyword">void</span> item(Item item) {
      def data = item.dataFile.text.trim()
      def (name, quantity, price, temp) = data.split(<span class="hl-string">','</span>)
      item.name = name
      item.quantity = quantity
      item.price = price
      item.temperature = temp
   }

   <span class="hl-annotation">@Defaults</span>
   <span class="hl-keyword">void</span> setDefaults(Item item) {
      item.dataFile = <span class="hl-string">'data.csv'</span>
   }

   <span class="hl-annotation">@Mutate</span>
   <span class="hl-keyword">void</span> createDataTask(ModelMap&lt;Task&gt; tasks, Item item) {
      tasks.create(<span class="hl-string">'showData'</span>) {
         doLast {
            println <span class="hl-string">""</span><span class="hl-string">"
</span>Item <span class="hl-string">'$item.name'</span>
   quantity:    $item.quantity
   price:       $item.price
   temperature: $item.temperature<span class="hl-string">""</span><span class="hl-string">"
</span>         }
      }
   }
}

apply plugin: ItemRules

model {
   item {
      price = <span class="hl-string">"${price * (quantity &lt; 10 ? 2 : 0.5)}"</span>
   }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/modelRules/modelDslCoercion</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>In the above example, an <code class="literal">Item</code> is created and is initialized in <code class="literal">setDefaults()</code> by providing the path to the data file. In the <code class="literal">item()</code> method the resolved <code class="literal">File</code> is parsed to extract and set the data. In the DSL block at the end, the price is adjusted based on the quantity; if there are fewer than 10 remaining the price is doubled, otherwise it is reduced by 50%. The <code class="literal">GString</code> expression is a valid value since it resolves to a <code class="literal">float</code> value in string form.</p><p>Finally, in <code class="literal">createDataTask()</code> we add the <code class="literal">showData</code> task to display all of the configured values.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dsl-rule-input-dependencies" class="section-anchor" href="#dsl-rule-input-dependencies"></a>Declaring input dependencies</h3></div></div></div><p>Rules declared in the DSL may <span class="emphasis"><em>depend</em></span> on other model elements through the use of a special syntax, which is of the form:</p><pre class="programlisting">$.&laquo;path-to-model-element&raquo;</pre><p>Paths are a period separated list of identifiers. To directly depend on the <code class="literal">firstName</code> of the person, the following could be used:</p><pre class="programlisting">$.person.firstName</pre><div class="example"><a name="modelDslRuleInputs"></a><p class="title"><b>Example&nbsp;520.&nbsp;a DSL rule using inputs</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    tasks {
        hello(Task) {
            def p = $.person
            doLast {
                println <span class="hl-string">"Hello $p.firstName $p.lastName!"</span>
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/modelRules/modelDsl</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>In the above snippet, the <code class="literal">$.person</code> construct is an input reference. The construct returns the value of the model element at the specified path, as its default type (i.e. the type advertised by the <a class="link" href="#model-report">Model Report</a>). It may appear anywhere in the rule that an expression may normally appear. It is not limited to the right hand side of variable assignments.</p><p>The input element is guaranteed to be fully configured before the rule executes. That is, all of the rules that mutate the element are guaranteed to have been previously executed, leaving the target element in its final, immutable, state.</p><p>Most model elements enforce immutability when being used as inputs. Any attempt to mutate such an element will result in a runtime error. However, some legacy type objects do not currently implement such checks. Regardless, it is always invalid to attempt to mutate an input to a rule.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="sec:using_modelmap_as_an_input" class="section-anchor" href="#sec:using_modelmap_as_an_input"></a>Using <code class="literal">ModelMap&lt;T&gt;</code> as an input</h4></div></div></div><p>When you use a <a class="ulink" href="../javadoc/org/gradle/model/ModelMap.html" target="_top"><code class="classname">ModelMap</code></a> as input, each item in the map is made available as a property.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="model-report" class="section-anchor" href="#model-report"></a>The model report</h2></div></div></div><p>The built-in <a class="ulink" href="../dsl/org.gradle.api.reporting.model.ModelReport.html" target="_top"><code class="classname">ModelReport</code></a> task displays a hierarchical view of the elements in the model space. Each item prefixed with a <code class="literal">+</code> on the model report is a model element and the visual nesting of these elements correlates to the model path (e.g. <code class="literal">tasks.help</code>). The model report displays the following details about each model element:</p><div class="table"><p class="title"><b>Table&nbsp;100.&nbsp;Model report - model element details</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N196ED"><thead><tr>
<td>Detail</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>Type</p></td>
<td><p>This is the underlying type of the model element and is typically a fully qualified class name.</p></td>
</tr><tr>
<td><p>Value</p></td>
<td><p>Is conditionally displayed on the report when a model element can be represented as a string.</p></td>
</tr><tr>
<td><p>Creator</p></td>
<td><p>Every model element has a creator. A creator signifies the origin of the model element (i.e. what created the model element).</p></td>
</tr><tr>
<td><p>Rules</p></td>
<td><p>Is a listing of the rules, excluding the creator rule, which are executed for a given model element. The order in which the rules are displayed reflects the order in which they are executed.</p></td>
</tr></tbody></table></div></div><div class="example"><a name="basicRuleSourcePlugin-model-task"></a><p class="title"><b>Example&nbsp;521.&nbsp;model task output</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle model</code></strong></p><pre class="screen">&gt; gradle model
:model

------------------------------------------------------------
Root project
------------------------------------------------------------

+ person
      | Type:       Person
      | Creator:     PersonRules#person(Person)
      | Rules:
          person { ... } @ build.gradle line 59, column 3
          PersonRules#setFirstName(Person)
    + age
          | Type:       int
          | Value:      0
          | Creator:     PersonRules#person(Person)
    + children
          | Type:       org.gradle.model.ModelSet&lt;Person&gt;
          | Creator:     PersonRules#person(Person)
    + employed
          | Type:       boolean
          | Value:      false
          | Creator:     PersonRules#person(Person)
    + father
          | Type:       Person
          | Value:      null
          | Creator:     PersonRules#person(Person)
    + firstName
          | Type:       java.lang.String
          | Value:      John
          | Creator:     PersonRules#person(Person)
    + homeDirectory
          | Type:       java.io.File
          | Value:      null
          | Creator:     PersonRules#person(Person)
    + id
          | Type:       java.lang.Long
          | Value:      null
          | Creator:     PersonRules#person(Person)
    + lastName
          | Type:       java.lang.String
          | Value:      Smith
          | Creator:     PersonRules#person(Person)
    + maritalStatus
          | Type:       MaritalStatus
          | Creator:     PersonRules#person(Person)
    + mother
          | Type:       Person
          | Value:      null
          | Creator:     PersonRules#person(Person)
    + userGroups
          | Type:       java.util.List&lt;java.lang.String&gt;
          | Value:      null
          | Creator:     PersonRules#person(Person)
+ tasks
      | Type:       org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt;
      | Creator:     Project.&lt;init&gt;.tasks()
      | Rules:
          PersonRules#createHelloTask(ModelMap&lt;Task&gt;, Person)
    + buildEnvironment
          | Type:       org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
          | Value:      task ':buildEnvironment'
          | Creator:     tasks.addPlaceholderAction(buildEnvironment)
          | Rules:
              copyToTaskContainer
    + components
          | Type:       org.gradle.api.reporting.components.ComponentReport
          | Value:      task ':components'
          | Creator:     tasks.addPlaceholderAction(components)
          | Rules:
              copyToTaskContainer
    + dependencies
          | Type:       org.gradle.api.tasks.diagnostics.DependencyReportTask
          | Value:      task ':dependencies'
          | Creator:     tasks.addPlaceholderAction(dependencies)
          | Rules:
              copyToTaskContainer
    + dependencyInsight
          | Type:       org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
          | Value:      task ':dependencyInsight'
          | Creator:     tasks.addPlaceholderAction(dependencyInsight)
          | Rules:
              HelpTasksPlugin.Rules#addDefaultDependenciesReportConfiguration(DependencyInsightReportTask, ServiceRegistry)
              copyToTaskContainer
    + dependentComponents
          | Type:       org.gradle.api.reporting.dependents.DependentComponentsReport
          | Value:      task ':dependentComponents'
          | Creator:     tasks.addPlaceholderAction(dependentComponents)
          | Rules:
              copyToTaskContainer
    + hello
          | Type:       org.gradle.api.Task
          | Value:      task ':hello'
          | Creator:     PersonRules#createHelloTask(ModelMap&lt;Task&gt;, Person) &gt; create(hello)
          | Rules:
              copyToTaskContainer
    + help
          | Type:       org.gradle.configuration.Help
          | Value:      task ':help'
          | Creator:     tasks.addPlaceholderAction(help)
          | Rules:
              copyToTaskContainer
    + init
          | Type:       org.gradle.buildinit.tasks.InitBuild
          | Value:      task ':init'
          | Creator:     tasks.addPlaceholderAction(init)
          | Rules:
              copyToTaskContainer
    + model
          | Type:       org.gradle.api.reporting.model.ModelReport
          | Value:      task ':model'
          | Creator:     tasks.addPlaceholderAction(model)
          | Rules:
              copyToTaskContainer
    + projects
          | Type:       org.gradle.api.tasks.diagnostics.ProjectReportTask
          | Value:      task ':projects'
          | Creator:     tasks.addPlaceholderAction(projects)
          | Rules:
              copyToTaskContainer
    + properties
          | Type:       org.gradle.api.tasks.diagnostics.PropertyReportTask
          | Value:      task ':properties'
          | Creator:     tasks.addPlaceholderAction(properties)
          | Rules:
              copyToTaskContainer
    + tasks
          | Type:       org.gradle.api.tasks.diagnostics.TaskReportTask
          | Value:      task ':tasks'
          | Creator:     tasks.addPlaceholderAction(tasks)
          | Rules:
              copyToTaskContainer
    + wrapper
          | Type:       org.gradle.api.tasks.wrapper.Wrapper
          | Value:      task ':wrapper'
          | Creator:     tasks.addPlaceholderAction(wrapper)
          | Rules:
              copyToTaskContainer
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:limitations_and_future_direction" class="section-anchor" href="#sec:limitations_and_future_direction"></a>Limitations and future direction</h2></div></div></div><p>Rule based model configuration is the future of Gradle. This area is fledgling, but under very active development. Early experiments have demonstrated that this approach is more efficient, able to provide richer diagnostics and authoring assistance and is more extensible. However, there are currently many limitations.</p><p>The majority of the development to date has been focused on proving the efficacy of the approach, and building the internal rule execution engine and model graph mechanics. The user facing aspects (e.g the DSL, rule source classes) are yet to be optimized for conciseness and general usability. Likewise, many necessary configuration patterns and constructs are not yet able to be expressed via the API.</p><p>In conjunction with the addition of better syntax, a richer toolkit of configuration constructs and generally more expressive power, more tooling will be added that will enable build engineers and users alike to comprehend, modify and extend builds in new ways.</p><p>Due to the inherent nature of the rule based approach, it is more efficient at constructing the build model than today&rsquo;s Gradle. However, in the future Gradle will also leverage the parallelism that this approach enables both at configuration and execution time. Moreover, due to increased transparency of the model Gradle will be able to further reduce build times by caching and pre-computing the build model. Beyond improved general build performance, this will greatly improve the experience when using Gradle from tools such as IDEs.</p><p>As this area of Gradle is under active development, it will be changing rapidly. Please be sure to consult the documentation of Gradle corresponding to the version you are using and to watch for changes announced in the release notes for future versions.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="software_model_concepts"></a>Software model concepts</h1></div></div></div><div class="note"><p>Support for the software model is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p>The software model describes how a piece of software is built and how the components of the software relate to each other. The software model is organized around some key concepts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>A <span class="emphasis"><em>component</em></span> is a general concept that represents some logical piece of software. Examples of components are a command-line application, a web application or a library. A component is often composed of other components. Most Gradle builds will produce at least one component.</p></li><li class="listitem"><p>A <span class="emphasis"><em>library</em></span> is a reusable component that is linked into or combined into some other component. In the Java ecosystem, a library is often built as a Jar file, and then later bundled into an application of some kind. In the native ecosystem, a library may be built as a shared library or static library, or both.</p></li><li class="listitem"><p>A <span class="emphasis"><em>source set</em></span> represents a logical group of source files. Most components are built from source sets of various languages. Some source sets contain source that is written by hand, and some source sets may contain source that is generated from something else.</p></li><li class="listitem"><p>A <span class="emphasis"><em>binary</em></span> represents some output that is built for a component. A component may produce multiple different output binaries. For example, for a C++ library, both a shared library and a static library binary may be produced. Each binary is initially configured to be built from the component sources, but additional source sets can be added to specific binary variants.</p></li><li class="listitem"><p>A <span class="emphasis"><em>variant</em></span> represents some mutually exclusive binary of a component. A library, for example, might target Java 7 and Java 8, effectively producing two distinct binaries: a Java 7 Jar and a Java 8 Jar. These are different variants of the library.</p></li><li class="listitem"><p>The <span class="emphasis"><em>API</em></span> of a library represents the artifacts and dependencies that are required to compile against that library. The API typically consists of a binary together with a set of dependencies.</p></li></ul></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="rule_source"></a>Implementing model rules in a plugin</h1></div></div></div><p>A plugin can define rules by extending <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> and adding methods that define the rules. The plugin class can either extend <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> directly or can implement <a class="ulink" href="../javadoc/org/gradle/api/Plugin.html" target="_top"><code class="classname">Plugin</code></a> and include a nested <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> subclass.</p><p>Refer to the API docs for <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> for more details.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:applying_additional_rules" class="section-anchor" href="#sec:applying_additional_rules"></a>Applying additional rules</h2></div></div></div><p>A rule method annotated with <a class="ulink" href="../javadoc/org/gradle/model/Rules.html" target="_top"><code class="classname">Rules</code></a> can apply a <a class="ulink" href="../javadoc/org/gradle/model/RuleSource.html" target="_top"><code class="classname">RuleSource</code></a> to a target model element.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="java_software"></a>Building Java Libraries</h1></div></div></div><div class="note"><p>Support for building Java libraries using the software model is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p>The Java software plugins are intended to replace the <a class="link" href="#java_plugin">Java plugin</a>, and leverage the Gradle <a class="link" href="#software_model">software model</a> to achieve the best performance, improved expressiveness and support for variant-aware dependency management.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_libraries_features" class="section-anchor" href="#sec:java_libraries_features"></a>Features</h2></div></div></div><p>The Java software plugins provide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Support for building Java libraries and other components that run on the JVM.</p></li><li class="listitem"><p>Support for several source languages.</p></li><li class="listitem"><p>Support for building different variants of the same software, for different Java versions, or for any purpose.</p></li><li class="listitem"><p>Build time definition and enforcement of Java library API.</p></li><li class="listitem"><p>Compile avoidance.</p></li><li class="listitem"><p>Dependency management between Java software components.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_software_model" class="section-anchor" href="#sec:java_software_model"></a>Java Software Model</h2></div></div></div><p>The Java software plugins provide a <span class="emphasis"><em>software model</em></span> that describes Java based software and how it should be built. This Java software model extends the base Gradle <a class="link" href="#software_model_concepts">software model</a>, to add support for building JVM libraries. A <span class="emphasis"><em>JVM library</em></span> is a kind of <a class="link" href="#">library</a> that is built for and runs on the JVM. It may be built from Java source, or from various other languages. All JVM libraries provide an API of some kind.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_libraries_usage" class="section-anchor" href="#sec:java_libraries_usage"></a>Usage</h2></div></div></div><p>To use the Java software plugins, include the following in your build script:</p><div class="example"><a name="javaLibraryQuickstart"></a><p class="title"><b>Example&nbsp;522.&nbsp;Using the Java software plugins</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'jvm-component'</span>
    id <span class="hl-string">'java-lang'</span>
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:creating_a_library" class="section-anchor" href="#sec:creating_a_library"></a>Creating a library</h2></div></div></div><p>A library is created by declaring a <a class="ulink" href="../javadoc/org/gradle/jvm/JvmLibrarySpec.html" target="_top"><code class="classname">JvmLibrarySpec</code></a> under the <code class="literal">components</code> element of the <code class="literal">model</code>:</p><div class="example"><a name="javaLibraryQuickstart"></a><p class="title"><b>Example&nbsp;523.&nbsp;Creating a java library</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(JvmLibrarySpec)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle build</code></strong></p><pre class="screen">&gt; gradle build
:compileMainJarMainJava
:processMainJarMainResources
:createMainJar
:mainApiJar
:mainJar
:assemble
:check UP-TO-DATE
:build

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"><p>This example creates a library named <code class="literal">main</code>, which will implicitly create a <a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a> named <code class="literal">java</code>. The conventions of the <a class="link" href="#java_plugin">legacy Java plugin</a> are observed, where Java sources are expected to be found in <code class="literal">src/main/java</code>, while resources are expected to be found in <code class="literal">src/main/resources</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="source_sets" class="section-anchor" href="#source_sets"></a>Source Sets</h2></div></div></div><p>Source sets represent logical groupings of source files in a library. A library can define multiple source sets and all sources will be compiled and included in the resulting binaries. When a library is added to a build, the following source sets are added by default.</p><div class="table"><p class="title"><b>Table&nbsp;101.&nbsp;Java plugin - default source sets</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N19833"><thead><tr>
<td>Source Set</td>
<td>Type</td>
<td>Directory</td>
</tr></thead><tbody><tr>
<td><p>java</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a></p></td>
<td><p>src/${library.name}/java</p></td>
</tr><tr>
<td><p>resources</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/jvm/JvmResourceSet.html" target="_top"><code class="classname">JvmResourceSet</code></a></p></td>
<td><p>src/${library.name}/resources</p></td>
</tr></tbody></table></div></div><p>It is possible to configure an existing <span class="emphasis"><em>source set</em></span> through the <code class="literal">sources</code> container:</p><div class="example"><a name="javaLibraryQuickstart"></a><p class="title"><b>Example&nbsp;524.&nbsp;Configuring a source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">components {
    main {
        sources {
            java {
                <span class="hl-comment">// configure the "java" source set</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>It is also possible to create an additional source set, using the <a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a> type:</p><div class="example"><a name="javaLibraryQuickstart"></a><p class="title"><b>Example&nbsp;525.&nbsp;Creating a new source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">components {
    main {
        sources {
            mySourceSet(JavaSourceSet) {
                <span class="hl-comment">// configure the "mySourceSet" source set</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_libraries_tasks" class="section-anchor" href="#sec:java_libraries_tasks"></a>Tasks</h2></div></div></div><p>By default, when the plugins above are applied, no new tasks are added to the build. However, when libraries are defined, conventional tasks are added which build and package each binary of the library.</p><p>For each binary of a library, a single lifecycle task is created which executes all tasks associated with building the binary. To build all binaries, the standard <code class="literal">build</code> lifecycle task can be used.</p><div class="table"><p class="title"><b>Table&nbsp;102.&nbsp;Java plugin - lifecycle tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="java_lifecycle_tasks"><thead><tr>
<td>Component Type</td>
<td>Binary Type</td>
<td>Lifecycle Task</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/jvm/JvmLibrarySpec.html" target="_top"><code class="classname">JvmLibrarySpec</code></a></p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/jvm/JvmBinarySpec.html" target="_top"><code class="classname">JvmBinarySpec</code></a></p></td>
<td><p>${library.name}${binary.name}</p></td>
</tr></tbody></table></div></div><p>For each source set added to a library, tasks are added to compile or process the source files for each binary.</p><div class="table"><p class="title"><b>Table&nbsp;103.&nbsp;Java plugin - source set tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="java_sourceset_tasks"><thead><tr>
<td>Source Set Type</td>
<td>Task name</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a></p></td>
<td><p>compile${library.name}${binary.name}${library.name}${sourceset.name}</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/java/tasks/PlatformJavaCompile.html" target="_top"><code class="classname">PlatformJavaCompile</code></a></p></td>
<td><p>Compiles the sources of a given source set.</p></td>
</tr><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/jvm/JvmResourceSet.html" target="_top"><code class="classname">JvmResourceSet</code></a></p></td>
<td><p>process${library.name}${binary.name}${library.name}${sourceset.name}</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/jvm/tasks/ProcessResources.html" target="_top"><code class="classname">ProcessResources</code></a></p></td>
<td><p>Copies the resources in the given source set to the classes output directory.</p></td>
</tr></tbody></table></div></div><p>For each binary in a library, a packaging task is added to create the jar for that binary.</p><div class="table"><p class="title"><b>Table&nbsp;104.&nbsp;Java plugin - packaging tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="java_packaging_tasks"><thead><tr>
<td>Binary Type</td>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../javadoc/org/gradle/jvm/JvmBinarySpec.html" target="_top"><code class="classname">JvmBinarySpec</code></a></p></td>
<td><p>create${library.name}${binary.name}</p></td>
<td><p>all <a class="ulink" href="../javadoc/org/gradle/language/java/tasks/PlatformJavaCompile.html" target="_top"><code class="classname">PlatformJavaCompile</code></a> and <a class="ulink" href="../javadoc/org/gradle/language/jvm/tasks/ProcessResources.html" target="_top"><code class="classname">ProcessResources</code></a> tasks associated with the binary</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.jvm.tasks.Jar.html" target="_top"><code class="classname">Jar</code></a></p></td>
<td><p>Packages the compiled classes and processed resources of the binary.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:java_libraries_finding_out_more_about_your_project" class="section-anchor" href="#sec:java_libraries_finding_out_more_about_your_project"></a>Finding out more about your project</h2></div></div></div><p>Gradle provides a report that you can run from the command-line that shows details about the components and binaries that your project produces. To use this report, just run <code class="literal">gradle components</code>. Below is an example of running this report for one of the sample projects:</p><div class="example"><a name="javaLibraryComponentReport"></a><p class="title"><b>Example&nbsp;526.&nbsp;The components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle components</code></strong></p><pre class="screen">&gt; gradle components
:components

------------------------------------------------------------
Root project
------------------------------------------------------------

JVM library 'main'
------------------

Source sets
    Java source 'main:java'
        srcDir: src/main/java
    Java source 'main:mySourceSet'
        srcDir: src/main/mySourceSet
    JVM resources 'main:resources'
        srcDir: src/main/resources

Binaries
    Jar 'main:jar'
        build using task: :mainJar
        target platform: java7
        tool chain: JDK 7 (1.7)
        classes dir: build/classes/main/jar
        resources dir: build/resources/main/jar
        API Jar file: build/jars/main/jar/api/main.jar
        Jar file: build/jars/main/jar/main.jar

Note: currently not all plugins register their components, so some components may not be visible here.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="dependencies" class="section-anchor" href="#dependencies"></a>Dependencies</h2></div></div></div><p>A component in the Java software model can declare dependencies on other Java libraries. If component <code class="literal">main</code> depends on library <code class="literal">util</code>, this means that the <span class="emphasis"><em>API</em></span> of <code class="literal">util</code> is required when compiling the sources of <code class="literal">main</code>, and the <span class="emphasis"><em>runtime</em></span> of <code class="literal">util</code> is required when running or testing <code class="literal">main</code>. The terms 'API' and 'runtime' are examples of <span class="emphasis"><em>usages</em></span> of a Java library.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:library_usage" class="section-anchor" href="#sec:library_usage"></a>Library usage</h3></div></div></div><p>The 'API' usage of a Java library consists of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Artifact(s): the Jar file(s) containing the public classes of that library</p></li><li class="listitem"><p>Dependencies: the set of other libraries that are required to compile against that library</p></li></ul></div><p>When library <code class="literal">main</code> is compiled with a dependency on <code class="literal">util</code>, the 'API' dependencies of 'util' are resolved transitively, resulting in the complete set of libraries required to compile. For each of these libraries (including 'util'), the 'API' artifacts will be included in the compile classpath.</p><p>Similarly, the 'runtime' usage of a Java library consists of artifacts and dependencies. When a Java component is tested or bundled into an application, the runtime usage of any runtime dependencies will be resolved transitively into the set of libraries required at runtime. The runtime artifacts of these libraries will then be included in the testing or runtime classpath.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:dependency_types" class="section-anchor" href="#sec:dependency_types"></a>Dependency types</h3></div></div></div><p>Two types of Java library dependencies can be declared:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Dependencies on a library defined in a local Gradle project</p></li><li class="listitem"><p>Dependencies on a library published to a Maven repository</p></li></ul></div><p>Dependencies onto libraries published to an Ivy repository are not yet supported.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:declaring_dependencies" class="section-anchor" href="#sec:declaring_dependencies"></a>Declaring dependencies</h3></div></div></div><p>Dependencies may be declared for a specific <a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a>, for an entire <a class="ulink" href="../javadoc/org/gradle/jvm/JvmLibrarySpec.html" target="_top"><code class="classname">JvmLibrarySpec</code></a> or as part of the <a class="ulink" href="../javadoc/org/gradle/jvm/JvmApiSpec.html" target="_top"><code class="classname">JvmApiSpec</code></a> of a component:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;527.&nbsp;Declaring a dependency onto a library</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        server(JvmLibrarySpec) {
            sources {
                java {
                    dependencies {
                        library <span class="hl-string">'core'</span>
                    }
                }
            }
        }

        core(JvmLibrarySpec) {
            dependencies {
                library <span class="hl-string">'commons'</span>
            }
        }

        commons(JvmLibrarySpec) {
            api {
                dependencies {
                    library <span class="hl-string">'collections'</span>
                }
            }
        }

        collections(JvmLibrarySpec)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle serverJar</code></strong></p><pre class="screen">&gt; gradle serverJar
:compileCollectionsJarCollectionsJava
:collectionsApiJar
:compileCommonsJarCommonsJava
:commonsApiJar
:compileCoreJarCoreJava
:processCoreJarCoreResources
:coreApiJar
:compileServerJarServerJava
:createServerJar
:serverApiJar
:serverJar

BUILD SUCCESSFUL in 0s
10 actionable tasks: 10 executed
</pre></div></div><br class="example-break"><p>Dependencies declared for a source set will only be used for compiling that particular source set.</p><p>Dependencies declared for a component will be used when compiling all source sets for the component.</p><p>Dependencies declared for the component <code class="literal">api</code> are used for compiling all source sets for the component, and are also exported as part of the component&rsquo;s API. See <a class="link" href="#">Enforcing API boundaries at compile time</a> for more details.</p><p>The previous example declares a dependency for the <code class="literal">java</code> source set of the <code class="literal">server</code> library onto the <code class="literal">core</code> library of the same project. However, it is possible to create a dependency on a library in a different project as well:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;528.&nbsp;Declaring a dependency onto a project with an explicit library</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">client(JvmLibrarySpec) {
    sources {
        java {
            dependencies {
                project <span class="hl-string">':util'</span> library <span class="hl-string">'main'</span>
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle clientJar</code></strong></p><pre class="screen">&gt; gradle clientJar
:util:compileMainJarMainJava
:util:mainApiJar
:compileClientJarClientJava
:clientApiJar
:createClientJar
:clientJar

BUILD SUCCESSFUL in 0s
5 actionable tasks: 5 executed
</pre></div></div><br class="example-break"><p>When the target project defines a single library, the <code class="literal">library</code> selector can be omitted altogether:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;529.&nbsp;Declaring a dependency onto a project with an implicit library</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    project <span class="hl-string">':util'</span>
}
</pre></div></div><br class="example-break"><p>Dependencies onto libraries published to Maven repositories can be declared via <code class="literal">module identifiers</code> consisting of a <code class="literal">group name</code>, a <code class="literal">module name</code> plus an optional <code class="literal">version selector</code>:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;530.&nbsp;Declaring a dependency onto a library published to a Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">verifier(JvmLibrarySpec) {
    dependencies {
        module <span class="hl-string">'asm'</span>          group <span class="hl-string">'org.ow2.asm'</span> version <span class="hl-string">'5.0.4'</span>
        module <span class="hl-string">'asm-analysis'</span> group <span class="hl-string">'org.ow2.asm'</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle verifierJar</code></strong></p><pre class="screen">&gt; gradle verifierJar
:compileVerifierJarVerifierJava
:createVerifierJar
:verifierApiJar
:verifierJar

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed
</pre></div></div><br class="example-break"><p>A shorthand notation for module identifiers can also be used:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;531.&nbsp;Declaring a module dependency using shorthand notation</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    module <span class="hl-string">'org.ow2.asm:asm:5.0.4'</span>
    module <span class="hl-string">'org.ow2.asm:asm-analysis'</span>
}
</pre></div></div><br class="example-break"><p>Module dependencies will be resolved against the configured repositories as usual:</p><div class="example"><a name="javaLibraryMultiComponents"></a><p class="title"><b>Example&nbsp;532.&nbsp;Configuring repositories for dependency resolution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}
</pre></div></div><br class="example-break"><p>The <a class="ulink" href="../javadoc/org/gradle/platform/base/DependencySpecContainer.html" target="_top"><code class="classname">DependencySpecContainer</code></a> class provides a complete reference of the dependencies DSL.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="defining_api" class="section-anchor" href="#defining_api"></a>Defining a Library API</h2></div></div></div><p>Every library has an API, which consists of artifacts and dependencies that are required to compile against the library. The library may be explicitly declared for a component, or may be implied based on other component metadata.</p><p>By default, all <code class="literal">public</code> types of a library are considered to be part of its API. In many cases this is not ideal; a library will contain many public types that intended for internal use within that library. By explicitly declaring an API for a Java library, Gradle can provide compile-time encapsulation of these internal-but-public types. The types to include in a library API are declared at the package level. Packages containing API types are considered to be <span class="emphasis"><em>exported</em></span>.</p><p>By default, dependencies of a library are <span class="emphasis"><em>not</em></span> considered to be part of its API. By explicitly declaring a dependency as part of the library API, this dependency will then be made available to consumers when compiling. Dependencies declared this way are considered to be <span class="emphasis"><em>exported</em></span>, and are known as 'API dependencies'.</p><div class="note"><p>JDK 9 will introduce <span class="emphasis"><em>Jigsaw</em></span>, the reference implementation of the <span class="emphasis"><em>Java Module System</em></span>. Jigsaw will provide both compile-time and run-time enforcement of API encapsulation.</p><p>Gradle anticipates the arrival of JDK 9 and the Java Module System with an approach to specifying and enforcing API encapsulation at compile-time. This allows Gradle users to leverage the many benefits of strong encapsulation, and prepare their software projects for migration to JDK 9.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:some_terminology" class="section-anchor" href="#sec:some_terminology"></a>Some terminology</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>An <span class="emphasis"><em>API</em></span> is a set of classes, interfaces, methods that are exposed to a consumer.</p></li><li class="listitem"><p>An <span class="emphasis"><em>API specification</em></span> is the specification of classes, interfaces or methods that belong to an API, together with the set of dependencies that are part of the API. It can be found in various forms, like <code class="literal">module-info.java</code> in Jigsaw, or the <code class="literal">api { &hellip; }</code> block that Gradle defines as part of those stories. Usually, we can simplify this to a list of packages, called <span class="emphasis"><em>exported packages</em></span>.</p></li><li class="listitem"><p>A <span class="emphasis"><em>runtime jar</em></span> consists of <span class="emphasis"><em>API classes</em></span> and <span class="emphasis"><em>non-API classes</em></span> used at execution time. There can be multiple runtime jars depending on combinations of the variant dimensions: target platform, hardware infrastructure, target application server, &hellip;</p></li><li class="listitem"><p><span class="emphasis"><em>API classes</em></span> are classes of a <span class="emphasis"><em>variant</em></span> which match the <span class="emphasis"><em>API specification</em></span></p></li><li class="listitem"><p><span class="emphasis"><em>Non-API classes</em></span> are classes of a <span class="emphasis"><em>variant</em></span> which do not match the <span class="emphasis"><em>API specification</em></span>.</p></li><li class="listitem"><p>A <span class="emphasis"><em>stubbed API class</em></span> is an <span class="emphasis"><em>API class</em></span> for which its implementation and non public members have been removed. It is meant to be used when a consumer is going to be compiled against an <span class="emphasis"><em>API</em></span>.</p></li><li class="listitem"><p>An <span class="emphasis"><em>API jar</em></span> is a collection of <span class="emphasis"><em>API classes</em></span>. There can be multiple API jars depending on the combinations of variant dimensions.</p></li><li class="listitem"><p>A <span class="emphasis"><em>stubbed API jar</em></span> is a collection of <span class="emphasis"><em>stubbed API classes</em></span>. There can be multiple stubbed API jars depending on the combinations of variant dimensions.</p></li><li class="listitem"><p>An <span class="emphasis"><em>ABI (application binary interface)</em></span> corresponds to the public signature of an API, that is to say the set of stubbed API classes that it exposes (and their API visible members).</p></li></ul></div><p>We avoid the use of the term <span class="emphasis"><em>implementation</em></span> because it is too vague: both <span class="emphasis"><em>API classes</em></span> and <span class="emphasis"><em>Non-API classes</em></span> can have an implementation. For example, an <span class="emphasis"><em>API class</em></span> can be an interface, but also a concrete class. Implementation is an overloaded term in the Java ecosystem, and often refers to a class implementing an interface. This is not the case here: a concrete class can be member of an API, but to compile against an API, you don&rsquo;t need the implementation of the class: all you need is the signatures.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:specifying_api_classes" class="section-anchor" href="#sec:specifying_api_classes"></a>Specifying API classes</h3></div></div></div><div class="example"><a name="apiSpecification"></a><p class="title"><b>Example&nbsp;533.&nbsp;Specifying api packages</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(JvmLibrarySpec) {
            api {
                exports <span class="hl-string">'org.gradle'</span>
                exports <span class="hl-string">'org.gradle.utils'</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:specifying_api_dependencies" class="section-anchor" href="#sec:specifying_api_dependencies"></a>Specifying API dependencies</h3></div></div></div><div class="example"><a name="apiDependencies"></a><p class="title"><b>Example&nbsp;534.&nbsp;Specifying api dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">commons(JvmLibrarySpec) {
    api {
        dependencies {
            library <span class="hl-string">'collections'</span>
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:compile_avoidance" class="section-anchor" href="#sec:compile_avoidance"></a>Compile avoidance</h3></div></div></div><p>When you define an API for your library, Gradle enforces the usage of that API at compile-time. This comes with 3 direct consequences:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Trying to use a non-API class in a dependency will now result in a compilation error.</p></li><li class="listitem"><p>Changing the implementation of an API class will not result in recompilation of consumers if the ABI doesn&rsquo;t change (that is to say, all public methods have the same signature but not necessarily the same body).</p></li><li class="listitem"><p>Changing the implementation of a non-API class will not result in recompilation of consumers. This means that changes to non-API classes will not trigger recompilation of downstream dependencies, because the ABI of the component doesn&rsquo;t change.</p></li></ul></div><p>Given a <span class="emphasis"><em>main</em></span> component that exports <code class="literal">org.gradle</code>, <code class="literal">org.gradle.utils</code> and defines those classes:</p><div class="example"><a name="apiSpecification-main-classes"></a><p class="title"><b>Example&nbsp;535.&nbsp;Main sources</b></p><div class="example-contents"><p><code class="filename">src/main/java/org/gradle/Person.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {
    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> String name;

    <span class="hl-keyword">public</span> Person(String name) {
        <span class="hl-keyword">this</span>.name = name;
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> name;
    }
}
</pre><p><code class="filename">src/main/java/org/gradle/internal/PersonInternal.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle.internal;

<span class="hl-keyword">import</span> org.gradle.Person;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> PersonInternal <span class="hl-keyword">extends</span> Person {
    <span class="hl-keyword">public</span> PersonInternal(String name) {
        <span class="hl-keyword">super</span>(name);
    }
}
</pre><p><code class="filename">src/main/java/org/gradle/utils/StringUtils.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle.utils;

<span class="hl-keyword">public</span> <span class="hl-keyword">abstract</span> <span class="hl-keyword">class</span> StringUtils {

}
</pre></div></div><br class="example-break"><p>Compiling a component <span class="emphasis"><em>client</em></span> that declares a dependency onto <span class="emphasis"><em>main</em></span> will succeed:</p><div class="example"><a name="apiSpecification-client"></a><p class="title"><b>Example&nbsp;536.&nbsp;Client component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        client(JvmLibrarySpec) {
            sources {
                java {
                    dependencies {
                        library <span class="hl-string">'main'</span>
                    }
                }
            }
        }
    }
}
</pre><p><code class="filename">src/client/java/org/gradle/Client.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Client {
    <span class="hl-keyword">private</span> Person person;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPerson(Person p) { <span class="hl-keyword">this</span>.person = p; }
    <span class="hl-keyword">public</span> Person getPerson() { <span class="hl-keyword">return</span> person; }
}
</pre><p>Output of <strong class="userinput"><code>gradle :clientJar</code></strong></p><pre class="screen">&gt; gradle :clientJar
:compileMainJarMainJava
:processMainJarMainResources
:mainApiJar
:compileClientJarClientJava
:clientApiJar
:createClientJar
:clientJar

BUILD SUCCESSFUL in 0s
6 actionable tasks: 6 executed
</pre></div></div><br class="example-break"><p>But trying to compile a component <span class="emphasis"><em>brokenclient</em></span> that declares a dependency onto <span class="emphasis"><em>main</em></span> but uses an non-API class of <span class="emphasis"><em>main</em></span> will result in a compile-time error:</p><div class="example"><a name="apiSpecification-brokenclient"></a><p class="title"><b>Example&nbsp;537.&nbsp;Broken client component</b></p><div class="example-contents"><p><code class="filename">src/brokenclient/java/org/gradle/Client.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle;

<span class="hl-keyword">import</span> org.gradle.internal.PersonInternal;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Client {
    <span class="hl-keyword">private</span> PersonInternal person;

    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> setPerson(PersonInternal p) { <span class="hl-keyword">this</span>.person = p; }
    <span class="hl-keyword">public</span> PersonInternal getPerson() { <span class="hl-keyword">return</span> person; }
}
</pre><p>Output of <strong class="userinput"><code>gradle :brokenclientJar</code></strong></p><pre class="screen">&gt; gradle :brokenclientJar
:compileMainJarMainJava
:processMainJarMainResources
:mainApiJar
:compileBrokenclientJarBrokenclientJava FAILED
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"><p>On the other hand, if <span class="emphasis"><em>Person.java</em></span> in <span class="emphasis"><em>client</em></span> is updated and its API hasn&rsquo;t changed, <span class="emphasis"><em>client</em></span> will not be recompiled.</p><div class="example"><a name="apiSpecification-client"></a><p class="title"><b>Example&nbsp;538.&nbsp;Making non-API implementation-only change</b></p><div class="example-contents"><p><code class="filename">src/main/java/org/gradle/Person.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> Person {
    <span class="hl-keyword">private</span> <span class="hl-keyword">final</span> String name;

    <span class="hl-keyword">public</span> Person(String name) {
        <span class="hl-comment">// we updated the body if this method</span>
        <span class="hl-comment">// but the signature doesn't change</span>
        <span class="hl-comment">// so we will not recompile components</span>
        <span class="hl-comment">// that depend on this class</span>
        <span class="hl-keyword">this</span>.name = name.toUpperCase();
    }

    <span class="hl-keyword">public</span> String getName() {
        <span class="hl-keyword">return</span> name;
    }
}
</pre></div></div><br class="example-break"><p>This is in particular important for incremental builds of large projects, where we can avoid the compilation of dependencies in chain, and then dramatically reduce build duration:</p><div class="example"><a name="apiSpecification-client"></a><p class="title"><b>Example&nbsp;539.&nbsp;Recompiling the client</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle :clientJar</code></strong></p><pre class="screen">&gt; gradle :clientJar
:compileMainJarMainJava
:processMainJarMainResources UP-TO-DATE
:mainApiJar
:compileClientJarClientJava UP-TO-DATE
:clientApiJar UP-TO-DATE
:createClientJar UP-TO-DATE
:clientJar UP-TO-DATE

BUILD SUCCESSFUL in 0s
6 actionable tasks: 2 executed, 4 up-to-date
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:platform_aware_dependency_management" class="section-anchor" href="#sec:platform_aware_dependency_management"></a>Platform aware dependency management</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:specifying_the_target_platform" class="section-anchor" href="#sec:specifying_the_target_platform"></a>Specifying the target platform</h3></div></div></div><p>The software model extracts the target platform as a core concept. In the Java world, this means that a library can be built, or resolved, against a specific version of Java. For example, if you compile a library for Java 5, we know that such a library can be consumed by a library built for Java 6, but the opposite is not true. Gradle lets you define which platforms a library targets, and will take care of:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>generating a binary for each target platform (eg, a Java 5 jar as well as a Java 6 jar)</p></li><li class="listitem"><p>resolving dependencies against a matching platform</p></li></ul></div><p>The <code class="literal">targetPlatform</code> DSL defines which platforms a library should be built against:</p><div class="example"><a name="javaLibraryTargetPlatforms"></a><p class="title"><b>Example&nbsp;540.&nbsp;Declaring target platforms</b></p><div class="example-contents"><p><code class="filename">core/build.gradle</code></p><pre class="programlisting">model {
    components {
        main(JvmLibrarySpec) {
            targetPlatform <span class="hl-string">'java5'</span>
            targetPlatform <span class="hl-string">'java6'</span>
        }
   }
}
</pre><p>Output of <strong class="userinput"><code>gradle :core:build</code></strong></p><pre class="screen">&gt; gradle :core:build
:core:compileMainJava5JarMainJava
:core:processMainJava5JarMainResources
:core:createMainJava5Jar
:core:mainJava5ApiJar
:core:mainJava5Jar
:core:compileMainJava6JarMainJava
:core:compileMainJava6JarMainJava6JarJava
:core:processMainJava6JarMainResources
:core:createMainJava6Jar
:core:mainJava6ApiJar
:core:mainJava6Jar
:core:assemble
:core:check UP-TO-DATE
:core:build

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed
</pre></div></div><br class="example-break"><p>When building the application, Gradle generates two binaries: <code class="literal">java5MainJar</code> and <code class="literal">java6MainJar</code> corresponding to the target versions of Java. These artifacts will participate in dependency resolution as described <a class="link" href="#java_dependency_resolution">here</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:binary_specific_source_sets" class="section-anchor" href="#sec:binary_specific_source_sets"></a>Binary specific source sets</h3></div></div></div><p>For each <a class="ulink" href="../javadoc/org/gradle/jvm/JvmLibrarySpec.html" target="_top"><code class="classname">JvmLibrarySpec</code></a> it is possible to define additional source sets for each binary. A common use case for this is having specific dependencies for each variant and source sets that conform to those dependencies. The example below configures a <code class="literal">java6</code> source set on the <code class="literal">main.java6Jar</code> binary:</p><div class="example"><a name="javaLibraryTargetPlatforms-java6MainJar"></a><p class="title"><b>Example&nbsp;541.&nbsp;Declaring binary specific sources</b></p><div class="example-contents"><p><code class="filename">core/build.gradle</code></p><pre class="programlisting">main {
    binaries.java6Jar {
        sources {
            java(JavaSourceSet) {
                source.srcDir <span class="hl-string">'src/main/java6'</span>
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle clean :core:mainJava6Jar</code></strong></p><pre class="screen">&gt; gradle clean :core:mainJava6Jar
:core:clean UP-TO-DATE
:server:clean UP-TO-DATE
:core:compileMainJava6JarMainJava
:core:compileMainJava6JarMainJava6JarJava
:core:processMainJava6JarMainResources
:core:createMainJava6Jar
:core:mainJava6ApiJar
:core:mainJava6Jar

BUILD SUCCESSFUL in 0s
7 actionable tasks: 5 executed, 2 up-to-date
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="java_dependency_resolution" class="section-anchor" href="#java_dependency_resolution"></a>Dependency resolution</h3></div></div></div><p>When a library targets multiple versions of Java and depends on another library, Gradle will make its best effort to resolve the dependency to the most appropriate version of the dependency library. In practice, this means that Gradle chooses the <span class="emphasis"><em>highest compatible</em></span> version:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>for a binary <code class="literal">B</code> built for Java <code class="literal">n</code></p></li><li class="listitem"><p>for a dependency binary <code class="literal">D</code> built for Java <code class="literal">m</code></p></li><li class="listitem"><p><code class="literal">D</code> is compatible with <code class="literal">B</code> if <code class="literal">m&lt;=n</code></p></li><li class="listitem"><p>for multiple compatible binaries <code class="literal">D(java 5), D(java 6), &hellip;D(java m)</code>, choose the compatible D binary with the highest Java version</p></li></ul></div><div class="example"><a name="javaLibraryTargetPlatforms-server"></a><p class="title"><b>Example&nbsp;542.&nbsp;Declaring target platforms</b></p><div class="example-contents"><p><code class="filename">server/build.gradle</code></p><pre class="programlisting">model {
    components {
        main(JvmLibrarySpec) {
            targetPlatform <span class="hl-string">'java5'</span>
            targetPlatform <span class="hl-string">'java6'</span>
            sources {
                java {
                    dependencies {
                        project <span class="hl-string">':core'</span> library <span class="hl-string">'main'</span>
                    }
                }
            }
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle clean :server:build</code></strong></p><pre class="screen">&gt; gradle clean :server:build
:core:clean UP-TO-DATE
:server:clean UP-TO-DATE
:core:compileMainJava5JarMainJava
:core:processMainJava5JarMainResources
:core:mainJava5ApiJar
:server:compileMainJava5JarMainJava
:server:createMainJava5Jar
:server:mainJava5ApiJar
:server:mainJava5Jar
:core:compileMainJava6JarMainJava
:core:compileMainJava6JarMainJava6JarJava
:core:processMainJava6JarMainResources
:core:mainJava6ApiJar
:server:compileMainJava6JarMainJava
:server:createMainJava6Jar
:server:mainJava6ApiJar
:server:mainJava6Jar
:server:assemble
:server:check UP-TO-DATE
:server:build

BUILD SUCCESSFUL in 0s
15 actionable tasks: 13 executed, 2 up-to-date
</pre></div></div><br class="example-break"><p>In the example above, Gradle automatically chooses the Java 6 variant of the dependency for the Java 6 variant of the <code class="literal">server</code> component, and chooses the Java 5 version of the dependency for the Java 5 variant of the <code class="literal">server</code> component.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:custom_variant_resolution" class="section-anchor" href="#sec:custom_variant_resolution"></a>Custom variant resolution</h2></div></div></div><p>The Java plugin, in addition to the target platform resolution, supports resolution of custom variants. Custom variants can be defined on custom binary types, as long as they extend <a class="ulink" href="../javadoc/org/gradle/jvm/JarBinarySpec.html" target="_top"><code class="classname">JarBinarySpec</code></a>. Users interested in testing this incubating feature can check out the documentation of the <a class="ulink" href="../javadoc/org/gradle/platform/base/Variant.html" target="_top"><code class="classname">Variant</code></a> annotation.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:testing_java_libraries" class="section-anchor" href="#sec:testing_java_libraries"></a>Testing Java libraries</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:standalone_junit_test_suites" class="section-anchor" href="#sec:standalone_junit_test_suites"></a>Standalone JUnit test suites</h3></div></div></div><p>The Java software model supports defining standalone JUnit test suites as components of the model. Standalone test suite are components that are self contained, in the sense that there is no component under test: everything being tested must belong to the test suite sources.</p><p>A test suite is declared by creating a component of type <a class="ulink" href="../javadoc/org/gradle/jvm/test/JUnitTestSuiteSpec.html" target="_top"><code class="classname">JUnitTestSuiteSpec</code></a>, which is available when you apply the <code class="literal">junit-test-suite</code> plugin:</p><div class="example"><a name="testing-junit-standalone"></a><p class="title"><b>Example&nbsp;543.&nbsp;Using the JUnit plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'jvm-component'</span>
    id <span class="hl-string">'java-lang'</span>
    id <span class="hl-string">'junit-test-suite'</span>
}

model {
    testSuites {
        test(JUnitTestSuiteSpec) {
            jUnitVersion <span class="hl-string">'4.12'</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>In the example above, <code class="literal">test</code> is the name of our test suite. By convention, Gradle will create two source sets for the test suite, based on the name of the component: one for Java sources, and the other for resources: <code class="literal">src/test/java</code> and <code class="literal">src/test/resources</code>. If the component was named <code class="literal">integTest</code>, then sources and resources would have been found respectively in <code class="literal">src/integTest/java</code> and <code class="literal">src/integTest/resources</code>.</p><p>Once the component is created, the test suite can be executed running the <code class="literal">&lt;&lt;test suite name&gt;&gt;BinaryTest</code> task:</p><div class="example"><a name="testing-junit-standalone-run"></a><p class="title"><b>Example&nbsp;544.&nbsp;Executing the test suite</b></p><div class="example-contents"><p><code class="filename">src/test/java/org/gradle/MyTest.java</code></p><pre class="programlisting"><span class="hl-keyword">package</span> org.gradle;

<span class="hl-keyword">import</span> org.junit.Test;

<span class="hl-keyword">import</span> <span class="hl-keyword">static</span> org.junit.Assert.*;

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> MyTest {
    <span class="hl-annotation">@Test</span>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> myTestMethod() {
        assertEquals(<span class="hl-number">4</span>, <span class="hl-string">"test"</span>.length());
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle testBinaryTest</code></strong></p><pre class="screen">&gt; gradle testBinaryTest
:compileTestBinaryTestJava
:processTestBinaryTestResources
:testBinaryTest

BUILD SUCCESSFUL in 0s
3 actionable tasks: 3 executed
</pre></div></div><br class="example-break"><p>It is possible to configure source sets in a <a class="link" href="#source_sets">similar way as libraries</a>.</p><p>A test suite being a component can also <a class="link" href="#dependencies">declare dependencies onto other components</a>.</p><p>A test suite can also contain resources, in which case it is possible to configure the resource processing task:</p><div class="example"><a name="testing-junit-standalone-resources"></a><p class="title"><b>Example&nbsp;545.&nbsp;Executing the test suite</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    tasks.processTestBinaryTestResources {
        <span class="hl-comment">// uncomment lines</span>
        filter { String line -&gt;
            line.replaceAll(<span class="hl-string">'&lt;!-- (.+?) --&gt;'</span>, <span class="hl-string">'$1'</span>)
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:testing_jvm_libraries_with_junit" class="section-anchor" href="#sec:testing_jvm_libraries_with_junit"></a>Testing JVM libraries with JUnit</h3></div></div></div><p>It is likely that you will want to test another JVM component. The Java software model supports it exactly like standalone test suites, by just declaring an additional component under test:</p><div class="example"><a name="testing-junit-component-under-test"></a><p class="title"><b>Example&nbsp;546.&nbsp;Declaring a component under test</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(JvmLibrarySpec)
    }
    testSuites {
        test(JUnitTestSuiteSpec) {
            jUnitVersion <span class="hl-string">'4.12'</span>
            testing $.components.main
        }
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle testMainJarBinaryTest</code></strong></p><pre class="screen">&gt; gradle testMainJarBinaryTest
:compileMainJarMainJava
:processMainJarMainResources
:compileTestMainJarBinaryTestJava
:testMainJarBinaryTest

BUILD SUCCESSFUL in 0s
4 actionable tasks: 4 executed
</pre></div></div><br class="example-break"><p>Note that the syntax to choose the component under test is a reference (<code class="literal">$.</code>). You can select any <code class="literal">JvmComponentSpec</code> as the component under test. It&rsquo;s also worth noting that when you declare a component under test, a test suite is created for each binary of the component under test (for example, if the component under test has a Java 7 and Java 8 version, 2 different test suite binaries would be automatically created).</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="declaring_java_toolchains" class="section-anchor" href="#declaring_java_toolchains"></a>Declaring Java toolchains</h2></div></div></div><p>You can declare the list of local JVM installations using the <code class="literal">javaInstallations</code> model block. Gradle will use this information to locate your JVMs and probe their versions. Please note that this information is not yet used by Gradle to select the appropriate JDK or JRE when compiling your Java sources, or when executing Java applications. A local Java installation can be declared using the <code class="literal">LocalJava</code> type, independently of the fact they are a JDK or a JRE:</p><div class="example"><a name="javaLibraryPlugin/toolchains"></a><p class="title"><b>Example&nbsp;547.&nbsp;Declaring local Java installations</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    javaInstallations {
        openJdk6(LocalJava) {
            path <span class="hl-string">'/usr/lib/jvm/jdk1.6.0-amd64'</span>
        }
        oracleJre7(LocalJava) {
            path <span class="hl-string">'/usr/lib/jvm/jre1.7.0'</span>
        }
        ibmJdk8(LocalJava) {
            path <span class="hl-string">'/usr/lib/jvm/jdk1.8.0'</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="play_plugin"></a>Building Play applications</h1></div></div></div><div class="note"><p>Support for building Play applications is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p><a class="ulink" href="https://www.playframework.com/" target="_top">Play</a> is a modern web application framework. The Play plugin adds support for building, testing and running Play applications with Gradle.</p><p>The Play plugin makes use of the Gradle <a class="link" href="#software_model">software model</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_usage" class="section-anchor" href="#sec:play_usage"></a>Usage</h2></div></div></div><p>To use the Play plugin, include the following in your build script to apply the <code class="literal">play</code> plugin and add the Lightbend repositories:</p><div class="example"><a name="usePlayPlugin"></a><p class="title"><b>Example&nbsp;548.&nbsp;Using the Play plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'play'</span>
}

repositories {
    jcenter()
    maven {
        name <span class="hl-string">"lightbend-maven-release"</span>
        url <span class="hl-string">"https://repo.lightbend.com/lightbend/maven-releases"</span>
    }
    ivy {
        name <span class="hl-string">"lightbend-ivy-release"</span>
        url <span class="hl-string">"https://repo.lightbend.com/lightbend/ivy-releases"</span>
        layout <span class="hl-string">"ivy"</span>
    }
}
</pre></div></div><br class="example-break"><p>Note that defining the Lightbend repositories is necessary. In future versions of Gradle, this will be replaced with a more convenient syntax.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_limitations" class="section-anchor" href="#sec:play_limitations"></a>Limitations</h2></div></div></div><p>The Play plugin currently has a few limitations.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Gradle does not yet support aggregate reverse routes introduced in Play 2.4.x.</p></li><li class="listitem"><p>A given project may only define a single Play application. This means that a single project cannot build more than one Play application. However, a multi-project build can have many projects that each define their own Play application.</p></li><li class="listitem"><p>Play applications can only target a single &ldquo;platform&rdquo; (combination of Play, Scala and Java version) at a time. This means that it is currently not possible to define multiple variants of a Play application that, for example, produce jars for both Scala 2.10 and 2.11. This limitation may be lifted in future Gradle versions.</p></li><li class="listitem"><p>Support for generating IDE configurations for Play applications is limited to <a class="link" href="#idea_plugin">IDEA</a>.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_software_model" class="section-anchor" href="#sec:play_software_model"></a>Software Model</h2></div></div></div><p>The Play plugin uses a <span class="emphasis"><em>software model</em></span> to describe a Play application and how to build it. The Play software model extends the base Gradle <a class="link" href="#software_model_concepts">software model</a> to add support for building Play applications. A Play application is represented by a <a class="ulink" href="../dsl/org.gradle.play.PlayApplicationSpec.html" target="_top"><code class="classname">PlayApplicationSpec</code></a> component type. The plugin automatically creates a single <a class="ulink" href="../dsl/org.gradle.play.PlayApplicationBinarySpec.html" target="_top"><code class="classname">PlayApplicationBinarySpec</code></a> instance when it is applied. Additional Play components cannot be added to a project.</p><div class="figure"><a name="N19D03"></a><p class="title"><b>Figure&nbsp;19.&nbsp;Play plugin - software model</b></p><div class="figure-contents"><img src="img/playPluginModel.png" alt="Play plugin - software model"></div></div><br class="figure-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_play_application_component" class="section-anchor" href="#sec:the_play_application_component"></a>The Play application component</h3></div></div></div><p>A Play application component describes the application to be built and consists of several configuration elements. One type of element that describes the application are the source sets that define where the application controller, route, template and model class source files should be found. These source sets are logical groupings of files of a particular type and a default source set for each type is created when the <code class="literal">play</code> plugin is applied.</p><div class="table"><p class="title"><b>Table&nbsp;105.&nbsp;Default Play source sets</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N19D12"><thead><tr>
<td>Source Set</td>
<td>Type</td>
<td>Directory</td>
<td>Filters</td>
</tr></thead><tbody><tr>
<td><p>java</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/java/JavaSourceSet.html" target="_top"><code class="classname">JavaSourceSet</code></a></p></td>
<td><p>app</p></td>
<td><p>**/*.java</p></td>
</tr><tr>
<td><p>scala</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/scala/ScalaLanguageSourceSet.html" target="_top"><code class="classname">ScalaLanguageSourceSet</code></a></p></td>
<td><p>app</p></td>
<td><p>**/*.scala</p></td>
</tr><tr>
<td><p>routes</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.language.routes.RoutesSourceSet.html" target="_top"><code class="classname">RoutesSourceSet</code></a></p></td>
<td><p>conf</p></td>
<td><p>routes, *.routes</p></td>
</tr><tr>
<td><p>twirlTemplates</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.language.twirl.TwirlSourceSet.html" target="_top"><code class="classname">TwirlSourceSet</code></a></p></td>
<td><p>app</p></td>
<td><p>**/*.scala.*</p></td>
</tr><tr>
<td><p>javaScript</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.language.javascript.JavaScriptSourceSet.html" target="_top"><code class="classname">JavaScriptSourceSet</code></a></p></td>
<td><p>app/assets</p></td>
<td><p>**/*.js</p></td>
</tr></tbody></table></div></div><p>These source sets can be configured or additional source sets can be added to the Play component. See <a class="link" href="#configuring_play">Configuring Play</a> for further information.</p><p>Another element of configuring a Play application is the <span class="emphasis"><em>platform</em></span>. To build a Play application, Gradle needs to understand which versions of Play, Scala and Java to use. The Play component specifies this requirement as a <a class="ulink" href="../dsl/org.gradle.play.platform.PlayPlatform.html" target="_top"><code class="classname">PlayPlatform</code></a>. If these values are not configured, a default version of Play, Scala and Java will be used. See <a class="link" href="#configuring_play_platform">Targeting a certain version of Play</a> for information on configuring the Play platform.</p><p>Note that only a single platform can be specified for a given Play component. This means that only a single version of Play, Scala and Java can be used to build a Play component. In other words, a Play component can only produce one set of outputs, and those outputs will be built using the versions specified by the platform configured on the component.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:the_play_application_binary" class="section-anchor" href="#sec:the_play_application_binary"></a>The Play application binary</h3></div></div></div><p>A Play application component is compiled and packaged to produce a set of outputs which are represented by a <a class="ulink" href="../dsl/org.gradle.play.PlayApplicationBinarySpec.html" target="_top"><code class="classname">PlayApplicationBinarySpec</code></a>. The Play binary specifies the jar files produced by building the component as well as providing elements by which additional content can be added to those jar files. It also exposes the tasks involved in building the component and creating the binary.</p><p>See <a class="link" href="#configuring_play">Configuring Play</a> for examples of configuring the Play binary.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_project_layout" class="section-anchor" href="#sec:play_project_layout"></a>Project Layout</h2></div></div></div><p>The Play plugin follows the typical Play application layout. You can <a class="link" href="#configuring_play_sourcesets">configure source sets</a> to include additional directories or change the defaults.</p><pre class="screen"> app                 &rarr; Application source code.
&nbsp;&nbsp;  assets          &rarr; Assets that require compilation.
&nbsp;&nbsp; &nbsp;&nbsp;  javascripts &rarr; JavaScript source code to be minified.
&nbsp;&nbsp;  controllers     &rarr; Application controller source code.
&nbsp;&nbsp;  models          &rarr; Application business source code.
&nbsp;&nbsp;  views           &rarr; Application UI templates.
 build.gradle        &rarr; Your project's build script.
 conf                &rarr; Main application configuration file and routes files.
 public              &rarr; Public assets.
&nbsp;&nbsp;  images          &rarr; Application image files.
&nbsp;&nbsp;  javascripts     &rarr; Typically JavaScript source code.
&nbsp;&nbsp;  stylesheets     &rarr; Typically CSS source code.
 test                &rarr; Test source code.</pre></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_tasks" class="section-anchor" href="#sec:play_tasks"></a>Tasks</h2></div></div></div><p>The Play plugin hooks into the normal Gradle lifecycle tasks such as <code class="literal">assemble</code>, <code class="literal">check</code> and <code class="literal">build</code>, but it also adds several additional tasks which form the lifecycle of a Play project:</p><div class="table"><p class="title"><b>Table&nbsp;106.&nbsp;Play plugin - lifecycle tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="play_lifecycle_tasks"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">playBinary</code></p></td>
<td><p>All compile tasks for source sets added to the Play application.</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Performs a build of just the Play application.</p></td>
</tr><tr>
<td><p><code class="literal">dist</code></p></td>
<td><p><code class="literal">createPlayBinaryZipDist</code>, <code class="literal">createPlayBinaryTarDist</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Assembles the Play distribution.</p></td>
</tr><tr>
<td><p><code class="literal">stage</code></p></td>
<td><p><code class="literal">stagePlayBinaryDist</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Stages the Play distribution.</p></td>
</tr></tbody></table></div></div><p>The plugin also provides tasks for running, testing and packaging your Play application:</p><div class="table"><p class="title"><b>Table&nbsp;107.&nbsp;Play plugin - running and testing tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N19E33"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">runPlayBinary</code></p></td>
<td><p><code class="literal">playBinary</code> to build Play application.</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.play.tasks.PlayRun.html" target="_top"><code class="classname">PlayRun</code></a></p></td>
<td><p>Runs the Play application for local development. See <a class="link" href="#play_continuous_build">how this works with continuous build.</a></p></td>
</tr><tr>
<td><p><code class="literal">testPlayBinary</code></p></td>
<td><p><code class="literal">playBinary</code> to build Play application and <code class="literal">compilePlayBinaryTests</code>.</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.testing.Test.html" target="_top"><code class="classname">Test</code></a></p></td>
<td><p>Runs JUnit/TestNG tests for the Play application.</p></td>
</tr></tbody></table></div></div><p>For the different types of sources in a Play application, the plugin adds the following compilation tasks:</p><div class="table"><p class="title"><b>Table&nbsp;108.&nbsp;Play plugin - source set tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="play_source_set_tasks"><thead><tr>
<td>Task name</td>
<td>Source Type</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">compilePlayBinaryScala</code></p></td>
<td><p>Scala and Java</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/language/scala/tasks/PlatformScalaCompile.html" target="_top"><code class="classname">PlatformScalaCompile</code></a></p></td>
<td><p>Compiles all Scala and Java sources defined by the Play application.</p></td>
</tr><tr>
<td><p><code class="literal">compilePlayBinaryPlayTwirlTemplates</code></p></td>
<td><p>Twirl templates</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.play.tasks.TwirlCompile.html" target="_top"><code class="classname">TwirlCompile</code></a></p></td>
<td><p>Compiles Twirl templates with the Twirl compiler. Gradle supports all of the built-in Twirl template formats (HTML, XML, TXT and JavaScript). Twirl templates need to match the pattern <code class="literal">*.scala.*</code>.</p></td>
</tr><tr>
<td><p><code class="literal">compilePlayBinaryPlayRoutes</code></p></td>
<td><p>Play Route files</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.play.tasks.RoutesCompile.html" target="_top"><code class="classname">RoutesCompile</code></a></p></td>
<td><p>Compiles routes files into Scala sources.</p></td>
</tr><tr>
<td><p><code class="literal">minifyPlayBinaryJavaScript</code></p></td>
<td><p>JavaScript files</p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.play.tasks.JavaScriptMinify.html" target="_top"><code class="classname">JavaScriptMinify</code></a></p></td>
<td><p>Minifies JavaScript files with the Google Closure compiler.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_finding_out_more_about_your_project" class="section-anchor" href="#sec:play_finding_out_more_about_your_project"></a>Finding out more about your project</h2></div></div></div><p>Gradle provides a report that you can run from the command-line that shows some details about the components and binaries that your project produces. To use this report, just run <code class="literal">gradle components</code>. Below is an example of running this report for one of the sample projects:</p><div class="example"><a name="playComponentReport"></a><p class="title"><b>Example&nbsp;549.&nbsp;The components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle components</code></strong></p><pre class="screen">&gt; gradle components
:components

------------------------------------------------------------
Root project
------------------------------------------------------------

Play Application 'play'
-----------------------

Source sets
    Java source 'play:java'
        srcDir: app
        includes: **/*.java
    JavaScript source 'play:javaScript'
        srcDir: app/assets
        includes: **/*.js
    JVM resources 'play:resources'
        srcDir: conf
    Routes source 'play:routes'
        srcDir: conf
        includes: routes, *.routes
    Scala source 'play:scala'
        srcDir: app
        includes: **/*.scala
    Twirl template source 'play:twirlTemplates'
        srcDir: app
        includes: **/*.scala.*

Binaries
    Play Application Jar 'play:binary'
        build using task: :playBinary
        target platform: Play Platform (Play 2.3.10, Scala: 2.11, Java: Java SE 8)
        toolchain: Default Play Toolchain
        classes dir: build/playBinary/classes
        resources dir: build/playBinary/resources
        JAR file: build/playBinary/lib/basic.jar

Note: currently not all plugins register their components, so some components may not be visible here.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="play_continuous_build" class="section-anchor" href="#play_continuous_build"></a>Running a Play application</h2></div></div></div><p>The <code class="literal">runPlayBinary</code> task starts the Play application under development. During development it is beneficial to execute this task as a <a class="link" href="#continuous_build">continuous build</a>. Continuous build is a generic feature that supports automatically re-running a build when inputs change. The <code class="literal">runPlayBinary</code> task is &ldquo;continuous build aware&rdquo;&nbsp;in that it behaves differently when run as part of a continuous build.</p><p>When not run as part of a continuous build, the <code class="literal">runPlayBinary</code> task will <span class="emphasis"><em>block</em></span> the build. That is, the task will not complete as long as the application is running. When running as part of a continuous build, the task will start the application if not running and otherwise propagate any changes to the code of the application to the running instance. This is useful for quickly iterating on your Play application with an edit-&gt;rebuild-&gt;refresh cycle. Changes to your application will not take affect until the end of the overall build.</p><p>To enable continuous build, run Gradle with <code class="literal">-t runPlayBinary</code> or <code class="literal">--continuous runPlayBinary</code>.</p><p>Users of Play used to such a workflow with Play&rsquo;s default build system should note that compile errors are handled differently. If a build failure occurs during a continuous build, the Play application will not be reloaded. Instead, you will be presented with an exception message. The exception message will only contain the overall cause of the build failure. More detailed information will only be available from the console.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="configuring_play" class="section-anchor" href="#configuring_play"></a>Configuring a Play application</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="configuring_play_platform" class="section-anchor" href="#configuring_play_platform"></a>Targeting a certain version of Play</h3></div></div></div><p>By default, Gradle uses Play 2.3.10, Scala 2.11 and the version of Java used to start the build. A Play application can select a different version by specifying a target <a class="ulink" href="../dsl/org.gradle.play.PlayApplicationSpec.html#org.gradle.play.PlayApplicationSpec:platform(java.lang.Object)" target="_top"><code class="classname">PlayApplicationSpec.platform(java.lang.Object)</code></a> on the Play application component.</p><div class="example"><a name="specifyPlayVersion"></a><p class="title"><b>Example&nbsp;550.&nbsp;Selecting a version of the Play Framework</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            platform play: <span class="hl-string">'2.5.18'</span>, scala: <span class="hl-string">'2.11'</span>, java: <span class="hl-string">'1.8'</span>
            injectedRoutesGenerator = true
        }
    }
}
</pre></div></div><br class="example-break"><p>The following versions of Play and Scala are supported:</p><div class="table"><p class="title"><b>Table&nbsp;109.&nbsp;Play supported versions</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N19F43"><thead><tr>
<td>Play</td>
<td>Scala</td>
<td>Java</td>
</tr></thead><tbody><tr>
<td><p>2.6.x</p></td>
<td><p>2.11 and 2.12</p></td>
<td><p>1.8</p></td>
</tr><tr>
<td><p>2.5.x</p></td>
<td><p>2.11</p></td>
<td><p>1.8</p></td>
</tr><tr>
<td><p>2.4.x</p></td>
<td><p>2.10 and 2.11</p></td>
<td><p>1.8</p></td>
</tr><tr>
<td><p>2.3.x</p></td>
<td><p>2.10 and 2.11</p></td>
<td><p>1.6, 1.7 and 1.8</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:adding_dependencies" class="section-anchor" href="#sec:adding_dependencies"></a>Adding dependencies</h3></div></div></div><p>You can add compile, test and runtime dependencies to a Play application through <a class="ulink" href="../dsl/org.gradle.api.artifacts.Configuration.html" target="_top"><code class="classname">Configuration</code></a> created by the Play plugin.</p><p>If you are coming from SBT, the Play SBT plugin provides short names for common dependencies. For instance, if your project has a dependency on <code class="literal">ws</code>, you will need to add a dependency to <code class="literal">com.typesafe.play:play-ws_2.11:2.3.9</code> where <code class="literal">2.11</code> is your Scala version and <code class="literal">2.3.9</code> is your Play framework version.</p><p>Other dependencies that have short names, such as <code class="literal">jacksons</code> may actually be multiple dependencies. For those dependencies, you will need to work out the dependency coordinates from a dependency report.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">play</code> is used for compile time dependencies.</p></li><li class="listitem"><p><code class="literal">playTest</code> is used for test compile time dependencies.</p></li><li class="listitem"><p><code class="literal">playRun</code> is used for run time dependencies.</p></li></ul></div><div class="example"><a name="addPlayDependencies"></a><p class="title"><b>Example&nbsp;551.&nbsp;Adding dependencies to a Play application</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    play <span class="hl-string">"commons-lang:commons-lang:2.6"</span>
}
</pre></div></div><br class="example-break"><div class="note"><p>Play 2.6 has a more modular architecture and, because of that, you may need to add some dependencies manually. For example, <a class="ulink" href="https://playframework.com/documentation/2.6.x/Migration26#Guice-DI-support-moved-to-separate-module" target="_top">Guice support was moved to a separated module</a>. Considering the following definition for a Play 2.6 project:</p><div class="example"><a name="play26Project"></a><p class="title"><b>Example&nbsp;552.&nbsp;A Play 2.6 project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            platform play: <span class="hl-string">'2.6.7'</span>, scala: <span class="hl-string">'2.12'</span>, java: <span class="hl-string">'1.8'</span>
            injectedRoutesGenerator = true
        }
    }
}
</pre></div></div><br class="example-break"><p>You can add Guice dependency like:</p><div class="example"><a name="play26ProjectDependencies"></a><p class="title"><b>Example&nbsp;553.&nbsp;Adding Guice dependency in Play 2.6 project</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    play <span class="hl-string">"com.typesafe.play:play-guice_2.12:2.6.7"</span>
}
</pre></div></div><br class="example-break"><p>Of course, pay attention to keep Play version and Scala version for the dependency consistent with the platform versions.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="configuring_play_sourcesets" class="section-anchor" href="#configuring_play_sourcesets"></a>Configuring the default source sets</h3></div></div></div><p>You can further configure the default source sets to do things like add new directories, add filters, etc.</p><div class="example"><a name="addExtraPlaySourcesets"></a><p class="title"><b>Example&nbsp;554.&nbsp;Configuring extra source sets to a Play application</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            sources {
                java {
                    source.srcDir <span class="hl-string">"additional/java"</span>
                }
                javaScript {
                    source {
                        srcDir <span class="hl-string">"additional/javascript"</span>
                        exclude <span class="hl-string">"**/old_*.js"</span>
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:adding_extra_source_sets" class="section-anchor" href="#sec:adding_extra_source_sets"></a>Adding extra source sets</h3></div></div></div><p>If your Play application has additional sources that exist in non-standard directories, you can add extra source sets that Gradle will automatically add to the appropriate compile tasks.</p><div class="example"><a name="addExtraPlaySourcesets"></a><p class="title"><b>Example&nbsp;555.&nbsp;Adding extra source sets to a Play application</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            sources {
                extraJava(JavaSourceSet) {
                    source.srcDir <span class="hl-string">"extra/java"</span>
                }
                extraTwirl(TwirlSourceSet) {
                    source.srcDir <span class="hl-string">"extra/twirl"</span>
                }
                extraRoutes(RoutesSourceSet) {
                    source.srcDir <span class="hl-string">"extra/routes"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuring_compiler_options" class="section-anchor" href="#sec:configuring_compiler_options"></a>Configuring compiler options</h3></div></div></div><p>If your Play application requires additional Scala compiler flags, you can add these arguments directly to the Scala compiler task.</p><div class="example"><a name="configureScalaCompiler"></a><p class="title"><b>Example&nbsp;556.&nbsp;Configuring Scala compiler options</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            binaries.all {
                tasks.withType(PlatformScalaCompile) {
                    scalaCompileOptions.additionalParameters = [<span class="hl-string">"-feature"</span>, <span class="hl-string">"-language:implicitConversions"</span>]
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuring_routes_style" class="section-anchor" href="#sec:configuring_routes_style"></a>Configuring routes style</h3></div></div></div><div class="note"><p>The injected router is only supported in Play Framework 2.4 or better.</p></div><p>If your Play application&rsquo;s router uses dependency injection to access your controllers, you&rsquo;ll need to configure your application to <span class="emphasis"><em>not</em></span> use the default static router. Under the covers, the Play plugin is using the <code class="literal">InjectedRoutesGenerator</code> instead of the default <code class="literal">StaticRoutesGenerator</code> to generate the router classes.</p><div class="example"><a name="configureRoutesCompiler"></a><p class="title"><b>Example&nbsp;557.&nbsp;Configuring routes style</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            injectedRoutesGenerator = true
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:configuring_twirl_templates" class="section-anchor" href="#sec:configuring_twirl_templates"></a>Configuring Twirl templates</h3></div></div></div><p>A custom Twirl template format can be configured independently for each Twirl source set. See the <a class="ulink" href="../dsl/org.gradle.language.twirl.TwirlSourceSet.html" target="_top"><code class="classname">TwirlSourceSet</code></a> for an example.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:injecting_a_custom_asset_pipeline" class="section-anchor" href="#sec:injecting_a_custom_asset_pipeline"></a>Injecting a custom asset pipeline</h3></div></div></div><p>Gradle Play support comes with a simplistic asset processing pipeline that minifies JavaScript assets. However, many organizations have their own custom pipeline for processing assets. You can easily hook the results of your pipeline into the Play binary by utilizing the <a class="ulink" href="../dsl/org.gradle.play.PublicAssets.html" target="_top"><code class="classname">PublicAssets</code></a> property on the binary.</p><div class="example"><a name="customAssetsPipeline"></a><p class="title"><b>Example&nbsp;558.&nbsp;Configuring a custom asset pipeline</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        play {
            binaries.all { binary -&gt;
                tasks.create(<span class="hl-string">"addCopyrightToPlay${binary.name.capitalize()}Assets"</span>, AddCopyrights) { copyrightTask -&gt;
                    source <span class="hl-string">"raw-assets"</span>
                    copyrightFile = project.file(<span class="hl-string">'copyright.txt'</span>)
                    destinationDir = project.file(<span class="hl-string">"${buildDir}/play${binary.name.capitalize()}/addCopyRights"</span>)

                    <span class="hl-comment">// Hook this task into the binary</span>
                    binary.assets.addAssetDir destinationDir
                    binary.assets.builtBy copyrightTask
                }
            }
        }
    }
}

<span class="hl-keyword">class</span> AddCopyrights <span class="hl-keyword">extends</span> SourceTask {
    <span class="hl-annotation">@InputFile</span>
    File copyrightFile

    <span class="hl-annotation">@OutputDirectory</span>
    File destinationDir

    <span class="hl-annotation">@TaskAction</span>
    <span class="hl-keyword">void</span> generateAssets() {
        String copyright = copyrightFile.text
        getSource().files.each { File file -&gt;
            File outputFile = <span class="hl-keyword">new</span> File(destinationDir, file.name)
            outputFile.text = <span class="hl-string">"${copyright}\n${file.text}"</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:multiproject_play_applications" class="section-anchor" href="#sec:multiproject_play_applications"></a>Multi-project Play applications</h2></div></div></div><p>Play applications can be built in multi-project builds as well. Simply apply the <code class="literal">play</code> plugin in the appropriate subprojects and create any project dependencies on the <code class="literal">play</code> configuration.</p><div class="example"><a name="playMultiProjectDependencies"></a><p class="title"><b>Example&nbsp;559.&nbsp;Configuring dependencies on Play subprojects</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    play project(<span class="hl-string">":admin"</span>)
    play project(<span class="hl-string">":user"</span>)
    play project(<span class="hl-string">":util"</span>)
}
</pre></div></div><br class="example-break"><p>See the <code class="literal">play/multiproject</code> sample provided in the Gradle distribution for a working example.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="packaging_play_distribution" class="section-anchor" href="#packaging_play_distribution"></a>Packaging a Play application for distribution</h2></div></div></div><p>Gradle provides the capability to package your Play application so that it can easily be distributed and run in a target environment. The distribution package (zip file) contains the Play binary jars, all dependencies, and generated scripts that set up the classpath and run the application in a Play-specific <a class="ulink" href="http://netty.io" target="_top">Netty</a> container.</p><p>The distribution can be created by running the <code class="literal">dist</code> lifecycle task and places the distribution in the <code class="literal">$buildDir/distributions</code> directory. Alternatively, one can validate the contents by running the <code class="literal">stage</code> lifecycle task which copies the files to the <code class="literal">$buildDir/stage</code> directory using the layout of the distribution package.</p><div class="table"><p class="title"><b>Table&nbsp;110.&nbsp;Play distribution tasks</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1A084"><thead><tr>
<td>Task name</td>
<td>Depends on</td>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">createPlayBinaryStartScripts</code></p></td>
<td><p>-</p></td>
<td><p><a class="ulink" href="../javadoc/org/gradle/api/tasks/application/CreateStartScripts.html" target="_top"><code class="classname">CreateStartScripts</code></a></p></td>
<td><p>Generates scripts to run the Play application distribution.</p></td>
</tr><tr>
<td><p><code class="literal">stagePlayBinaryDist</code></p></td>
<td><p><code class="literal">playBinary</code>, <code class="literal">createPlayBinaryStartScripts</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.Copy.html" target="_top"><code class="classname">Copy</code></a></p></td>
<td><p>Copies all jar files, dependencies and scripts into a staging directory.</p></td>
</tr><tr>
<td><p><code class="literal">createPlayBinaryZipDist</code></p></td>
<td></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Zip.html" target="_top"><code class="classname">Zip</code></a></p></td>
<td><p>Bundles the Play application as a standalone distribution packaged as a zip.</p></td>
</tr><tr>
<td><p><code class="literal">createPlayBinaryTarDist</code></p></td>
<td></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.tasks.bundling.Tar.html" target="_top"><code class="classname">Tar</code></a></p></td>
<td><p>Bundles the Play application as a standalone distribution packaged as a tar.</p></td>
</tr><tr>
<td><p><code class="literal">stage</code></p></td>
<td><p><code class="literal">stagePlayBinaryDist</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Lifecycle task for staging a Play distribution.</p></td>
</tr><tr>
<td><p><code class="literal">dist</code></p></td>
<td><p><code class="literal">createPlayBinaryZipDist</code>, <code class="literal">createPlayBinaryTarDist</code></p></td>
<td><p><a class="ulink" href="../dsl/org.gradle.api.Task.html" target="_top"><code class="classname">Task</code></a></p></td>
<td><p>Lifecycle task for creating a Play distribution.</p></td>
</tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="adding_files_to_play_distribution" class="section-anchor" href="#adding_files_to_play_distribution"></a>Adding additional files to your Play application distribution</h3></div></div></div><p>You can add additional files to the distribution package using the <a class="ulink" href="../javadoc/org/gradle/api/distribution/Distribution.html" target="_top"><code class="classname">Distribution</code></a> API.</p><div class="example"><a name="addFilesToPlayDistribution"></a><p class="title"><b>Example&nbsp;560.&nbsp;Add extra files to a Play application distribution</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    distributions {
        playBinary {
            contents {
                from(<span class="hl-string">"README.md"</span>)
                from(<span class="hl-string">"scripts"</span>) {
                    into <span class="hl-string">"bin"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="play_ide" class="section-anchor" href="#play_ide"></a>Building a Play application with an IDE</h2></div></div></div><p>If you want to generate IDE metadata configuration for your Play project, you need to apply the appropriate IDE plugin. Gradle supports generating IDE metadata for IDEA only for Play projects at this time.</p><p>To generate IDEA&rsquo;s metadata, apply the <code class="literal">idea</code> plugin along with the <code class="literal">play</code> plugin.</p><div class="example"><a name="applyPlayIde"></a><p class="title"><b>Example&nbsp;561.&nbsp;Applying both the Play and IDEA plugins</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">plugins {
    id <span class="hl-string">'play'</span>
    id <span class="hl-string">'idea'</span>
}
</pre></div></div><br class="example-break"><p>Source code generated by routes and Twirl templates cannot be generated by IDEA directly, so changes made to those files will not affect compilation until the next Gradle build. You can run the Play application with Gradle in <a class="link" href="#continuous_build">continuous build</a> to automatically rebuild and reload the application whenever something changes.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:play_resources" class="section-anchor" href="#sec:play_resources"></a>Resources</h2></div></div></div><p>For additional information about developing Play applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Play types in the Gradle DSL Guide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.PlayApplicationBinarySpec.html" target="_top"><code class="classname">PlayApplicationBinarySpec</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.PlayApplicationSpec.html" target="_top"><code class="classname">PlayApplicationSpec</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.platform.PlayPlatform.html" target="_top"><code class="classname">PlayPlatform</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.JvmClasses.html" target="_top"><code class="classname">JvmClasses</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.PublicAssets.html" target="_top"><code class="classname">PublicAssets</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.distribution.PlayDistributionContainer.html" target="_top"><code class="classname">PlayDistributionContainer</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.tasks.JavaScriptMinify.html" target="_top"><code class="classname">JavaScriptMinify</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.tasks.PlayRun.html" target="_top"><code class="classname">PlayRun</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.tasks.RoutesCompile.html" target="_top"><code class="classname">RoutesCompile</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.play.tasks.TwirlCompile.html" target="_top"><code class="classname">TwirlCompile</code></a></p></li></ul></div></li><li class="listitem"><p><a class="ulink" href="https://www.playframework.com/documentation" target="_top">Play Framework Documentation</a>.</p></li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="native_software"></a>Building native software</h1></div></div></div><div class="note"><p>Support for building native software is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p>The native software plugins add support for building native software components, such as executables or shared libraries, from code written in C++, C and other languages. While many excellent build tools exist for this space of software development, Gradle offers developers its trademark power and flexibility together with dependency management practices more traditionally found in the JVM development space.</p><p>The native software plugins make use of the Gradle <a class="link" href="#software_model">software model</a>.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:native_features" class="section-anchor" href="#sec:native_features"></a>Features</h2></div></div></div><p>The native software plugins provide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Support for building native libraries and applications on Windows, Linux, macOS and other platforms.</p></li><li class="listitem"><p>Support for several source languages.</p></li><li class="listitem"><p>Support for building different variants of the same software, for different architectures, operating systems, or for any purpose.</p></li><li class="listitem"><p>Incremental parallel compilation, precompiled headers.</p></li><li class="listitem"><p>Dependency management between native software components.</p></li><li class="listitem"><p>Unit test execution.</p></li><li class="listitem"><p>Generate Visual studio solution and project files.</p></li><li class="listitem"><p>Deep integration with various tool chain, including discovery of installed tool chains.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:supported_languages" class="section-anchor" href="#sec:supported_languages"></a>Supported languages</h2></div></div></div><p>The following source languages are currently supported:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C</p></li><li class="listitem"><p>C++</p></li><li class="listitem"><p>Objective-C</p></li><li class="listitem"><p>Objective-C++</p></li><li class="listitem"><p>Assembly</p></li><li class="listitem"><p>Windows resources</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native-binaries:tool-chain-support" class="section-anchor" href="#native-binaries:tool-chain-support"></a>Tool chain support</h2></div></div></div><p>Gradle offers the ability to execute the same build using different tool chains. When you build a native binary, Gradle will attempt to locate a tool chain installed on your machine that can build the binary. You can fine tune exactly how this works, see <a class="xref" href="#native_binaries:tool_chain">the section called &ldquo;Tool chains&rdquo;</a> for details.</p><p>The following tool chains are supported:</p><div class="informaltable"><table border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="left" valign="top">Operating System</th><th align="left" valign="top">Tool Chain</th><th align="left" valign="top">Notes</th></tr></thead><tbody><tr><td align="left" valign="top"><p>Linux</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>Linux</p></td><td align="left" valign="top"><p><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>macOS</p></td><td align="left" valign="top"><p>XCode</p></td><td align="left" valign="top"><p>Uses the Clang tool chain bundled with XCode.</p></td></tr><tr><td align="left" valign="top"><p>Windows</p></td><td align="left" valign="top"><p><a class="ulink" href="http://www.microsoft.com/visualstudio/en-us" target="_top">Visual C++</a></p></td><td align="left" valign="top"><p>Windows XP and later, Visual C++ 2010/2012/2013/2015/2017.</p></td></tr><tr><td align="left" valign="top"><p>Windows</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://cygwin.com" target="_top">Cygwin 32</a></p></td><td align="left" valign="top"><p>Windows XP and later.</p></td></tr><tr><td align="left" valign="top"><p>Windows</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://www.mingw.org/" target="_top">MinGW</a></p></td><td align="left" valign="top"><p>Windows XP and later. <a class="ulink" href="http://mingw-w64.sourceforge.net" target="_top">Mingw-w64</a> is currently not supported.</p></td></tr></tbody></table></div><p>The following tool chains are unofficially supported. They generally work fine, but are not tested continuously:</p><div class="informaltable"><table border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="left" valign="top">Operating System</th><th align="left" valign="top">Tool Chain</th><th align="left" valign="top">Notes</th></tr></thead><tbody><tr><td align="left" valign="top"><p>macOS</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> from Macports</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>macOS</p></td><td align="left" valign="top"><p><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a> from Macports</p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>Windows</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a> with <a class="ulink" href="http://cygwin.com" target="_top">Cygwin 64</a></p></td><td align="left" valign="top"><p>Windows XP and later.</p></td></tr><tr><td align="left" valign="top"><p>UNIX-like</p></td><td align="left" valign="top"><p><a class="ulink" href="http://gcc.gnu.org/" target="_top">GCC</a></p></td><td align="left" valign="top">&nbsp;</td></tr><tr><td align="left" valign="top"><p>UNIX-like</p></td><td align="left" valign="top"><p><a class="ulink" href="http://clang.llvm.org" target="_top">Clang</a></p></td><td align="left" valign="top">&nbsp;</td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:tool_chain_installation" class="section-anchor" href="#sec:tool_chain_installation"></a>Tool chain installation</h2></div></div></div><div class="note"><p>Note that if you are using GCC then you currently need to install support for C++, even if you are not building from C++ source. This restriction will be removed in a future Gradle version.</p></div><p>To build native software, you will need to have a compatible tool chain installed:</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:windows" class="section-anchor" href="#sec:windows"></a>Windows</h3></div></div></div><p>To build on Windows, install a compatible version of Visual Studio. The native plugins will discover the Visual Studio installations and select the latest version. There is no need to mess around with environment variables or batch scripts. This works fine from a Cygwin shell or the Windows command-line.</p><p>Alternatively, you can install Cygwin with GCC or MinGW. Clang is currently not supported.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:macOS" class="section-anchor" href="#sec:macOS"></a>macOS</h3></div></div></div><p>To build on macOS, you should install XCode. The native plugins will discover the XCode installation using the system PATH.</p><p>The native plugins also work with GCC and Clang bundled with Macports. To use one of the Macports tool chains, you will need to make the tool chain the default using the <code class="literal">port select</code> command and add Macports to the system PATH.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:linux" class="section-anchor" href="#sec:linux"></a>Linux</h3></div></div></div><p>To build on Linux, install a compatible version of GCC or Clang. The native plugins will discover GCC or Clang using the system PATH.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:native_software_model" class="section-anchor" href="#sec:native_software_model"></a>Native software model</h2></div></div></div><p>The native software model builds on the base Gradle <a class="link" href="#software_model_concepts">software model</a>.</p><p>To build native software using Gradle, your project should define one or more <span class="emphasis"><em>native components</em></span>. Each component represents either an executable or a library that Gradle should build. A project can define any number of components. Gradle does not define any components by default.</p><p>For each component, Gradle defines a <span class="emphasis"><em>source set</em></span> for each language that the component can be built from. A source set is essentially just a set of source directories containing source files. For example, when you apply the <code class="literal">c</code> plugin and define a library called <code class="literal">helloworld</code>, Gradle will define, by default, a source set containing the C source files in the <code class="literal">src/helloworld/c</code> directory. It will use these source files to build the <code class="literal">helloworld</code> library. This is described in more detail below.</p><p>For each component, Gradle defines one or more <span class="emphasis"><em>binaries</em></span> as output. To build a binary, Gradle will take the source files defined for the component, compile them as appropriate for the source language, and link the result into a binary file. For an executable component, Gradle can produce executable binary files. For a library component, Gradle can produce both static and shared library binary files. For example, when you define a library called <code class="literal">helloworld</code> and build on Linux, Gradle will, by default, produce <code class="literal">libhelloworld.so</code> and <code class="literal">libhelloworld.a</code> binaries.</p><p>In many cases, more than one binary can be produced for a component. These binaries may vary based on the tool chain used to build, the compiler/linker flags supplied, the dependencies provided, or additional source files provided. Each native binary produced for a component is referred to as a <span class="emphasis"><em>variant</em></span>. Binary variants are discussed in detail below.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:parallel_compilation" class="section-anchor" href="#sec:parallel_compilation"></a>Parallel Compilation</h2></div></div></div><p>Gradle uses the single build worker pool to concurrently compile and link native components, by default. No special configuration is required to enable concurrent building.</p><p>By default, the worker pool size is determined by the number of available processors on the build machine (as reported to the build JVM). To explicitly set the number of workers use the <code class="literal">--max-workers</code> command-line option or <code class="literal">org.gradle.workers.max</code> system property. There is generally no need to change this setting from its default.</p><p>The build worker pool is shared across all build tasks. This means that when using <a class="link" href="#sec:parallel_execution">parallel project execution</a>, the maximum number of concurrent individual compilation operations does not increase. For example, if the build machine has 4 processing cores and 10 projects are compiling in parallel, Gradle will only use 4 total workers, not 40.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:building_a_library" class="section-anchor" href="#sec:building_a_library"></a>Building a library</h2></div></div></div><p>To build either a static or shared native library, you define a library component in the <code class="literal">components</code> container. The following sample defines a library called <code class="literal">hello</code>:</p><div class="example"><a name="cppLibraries"></a><p class="title"><b>Example&nbsp;562.&nbsp;Defining a library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        hello(NativeLibrarySpec)
    }
}
</pre></div></div><br class="example-break"><p>A library component is represented using <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a>. Each library component can produce at least one shared library binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html" target="_top"><code class="classname">SharedLibraryBinarySpec</code></a>) and at least one static library binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html" target="_top"><code class="classname">StaticLibraryBinarySpec</code></a>).</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:building_an_executable" class="section-anchor" href="#sec:building_an_executable"></a>Building an executable</h2></div></div></div><p>To build a native executable, you define an executable component in the <code class="literal">components</code> container. The following sample defines an executable called <code class="literal">main</code>:</p><div class="example"><a name="cppExecutables"></a><p class="title"><b>Example&nbsp;563.&nbsp;Defining executable components</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(NativeExecutableSpec) {
            sources {
               c.lib library: <span class="hl-string">"hello"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>An executable component is represented using <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a>. Each executable component can produce at least one executable binary (<a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html" target="_top"><code class="classname">NativeExecutableBinarySpec</code></a>).</p><p>For each component defined, Gradle adds a <a class="ulink" href="../javadoc/org/gradle/language/base/FunctionalSourceSet.html" target="_top"><code class="classname">FunctionalSourceSet</code></a> with the same name. Each of these functional source sets will contain a language-specific source set for each of the languages supported by the project.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:dependents" class="section-anchor" href="#sec:dependents"></a>Assembling or building dependents</h2></div></div></div><p>Sometimes, you may need to <span class="emphasis"><em>assemble</em></span> (compile and link) or <span class="emphasis"><em>build</em></span> (compile, link and test) a component or binary and its <span class="emphasis"><em>dependents</em></span> (things that depend upon the component or binary). The native software model provides tasks that enable this capability. First, the <span class="emphasis"><em>dependent components</em></span> report gives insight about the relationships between each component. Second, the <span class="emphasis"><em>build and assemble dependents</em></span> tasks allow you to assemble or build a component and its dependents in one step.</p><p>In the following example, the build file defines <code class="literal">OpenSSL</code> as a dependency of <code class="literal">libUtil</code> and <code class="literal">libUtil</code> as a dependency of <code class="literal">LinuxApp</code> and <code class="literal">WindowsApp</code>. Test suites are treated similarly. Dependents can be thought of as reverse dependencies.</p><div class="figure"><a name="N1A3CF"></a><p class="title"><b>Figure&nbsp;20.&nbsp;Dependent Components Example</b></p><div class="figure-contents"><img src="img/nativeDependents.png" alt="Dependent Components Example"></div></div><br class="figure-break"><div class="note"><p>By following the dependencies backwards, you can see <code class="literal">LinuxApp</code> and <code class="literal">WindowsApp</code> are <span class="emphasis"><em>dependents</em></span> of <code class="literal">libUtil</code>. When <code class="literal">libUtil</code> is changed, Gradle will need to recompile or relink <code class="literal">LinuxApp</code> and <code class="literal">WindowsApp</code>.</p></div><p>When you <span class="emphasis"><em>assemble</em></span> dependents of a component, the component and all of its dependents are compiled and linked, including any test suite binaries. Gradle&rsquo;s up-to-date checks are used to only compile or link if something has changed. For instance, if you have changed source files in a way that do not affect the headers of your project, Gradle will be able to skip compilation for dependent components and only need to re-link with the new library. Tests are not run when assembling a component.</p><p>When you <span class="emphasis"><em>build</em></span> dependents of a component, the component and all of its dependent binaries are compiled, linked <span class="emphasis"><em>and checked</em></span>. Checking components means running any <a class="link" href="#sec:check_tasks">check task</a> including executing any test suites, so tests <span class="emphasis"><em>are</em></span> run when building a component.</p><p>In the following sections, we will demonstrate the usage of the <code class="literal">assembleDependents*</code>, <code class="literal">buildDependents*</code> and <code class="literal">dependentComponents</code> tasks with a sample build that contains a CUnit test suite. The build script for the sample is the following:</p><div class="example"><a name="nativeDependentComponentsSample"></a><p class="title"><b>Example&nbsp;564.&nbsp;Sample build</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"c"</span>
apply plugin: <span class="hl-string">'cunit-test-suite'</span>

model {
    flavors {
        passing
        failing
    }
    platforms {
        x8<span class="hl-number">6</span> {
            architecture <span class="hl-string">"x86"</span>
        }
    }
    components {
        operators(NativeLibrarySpec) {
            targetPlatform <span class="hl-string">"x86"</span>
        }
    }
    testSuites {
        operatorsTest(CUnitTestSuiteSpec) {
            testing $.components.operators
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/cunit</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:dependents_report" class="section-anchor" href="#sec:dependents_report"></a>Dependent components report</h3></div></div></div><p>Gradle provides a report that you can run from the command-line that shows a graph of components in your project and components that depend upon them. The following is an example of running <code class="literal">gradle dependentComponents</code> on the sample project:</p><div class="example"><a name="nativeDependentComponentsReport"></a><p class="title"><b>Example&nbsp;565.&nbsp;Dependent components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle dependentComponents</code></strong></p><pre class="screen">&gt; gradle dependentComponents
:dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary

Some test suites were not shown, use --test-suites or --all to show them.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><div class="note"><p>See <a class="ulink" href="../dsl/org.gradle.api.reporting.dependents.DependentComponentsReport.html" target="_top"><code class="classname">DependentComponentsReport</code></a> API documentation for more details.</p></div><p>By default, non-buildable binaries and test suites are hidden from the report. The <code class="literal">dependentComponents</code> task provides options that allow you to see all dependents by using the <code class="literal">--all</code> option:</p><div class="example"><a name="nativeDependentComponentsReportAll"></a><p class="title"><b>Example&nbsp;566.&nbsp;Dependent components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle dependentComponents --all</code></strong></p><pre class="screen">&gt; gradle dependentComponents --all
:dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
|    \--- operatorsTest:failingCUnitExe (t)
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary
     \--- operatorsTest:passingCUnitExe (t)

operatorsTest - Components that depend on Cunit test suite 'operatorsTest'
+--- operatorsTest:failingCUnitExe (t)
\--- operatorsTest:passingCUnitExe (t)

(t) - Test suite binary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Here is the corresponding report for the <code class="literal">operators</code> component, showing dependents of all its binaries:</p><div class="example"><a name="nativeAssembleDependentComponentsReport"></a><p class="title"><b>Example&nbsp;567.&nbsp;Report of components that depends on the operators component</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle dependentComponents --component operators</code></strong></p><pre class="screen">&gt; gradle dependentComponents --component operators
:dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary

Some test suites were not shown, use --test-suites or --all to show them.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"><p>Here is the corresponding report for the <code class="literal">operators</code> component, showing dependents of all its binaries, including test suites:</p><div class="example"><a name="nativeBuildDependentComponentsReport"></a><p class="title"><b>Example&nbsp;568.&nbsp;Report of components that depends on the operators component, including test suites</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle dependentComponents --test-suites --component operators</code></strong></p><pre class="screen">&gt; gradle dependentComponents --test-suites --component operators
:dependentComponents

------------------------------------------------------------
Root project
------------------------------------------------------------

operators - Components that depend on native library 'operators'
+--- operators:failingSharedLibrary
+--- operators:failingStaticLibrary
|    \--- operatorsTest:failingCUnitExe (t)
+--- operators:passingSharedLibrary
\--- operators:passingStaticLibrary
     \--- operatorsTest:passingCUnitExe (t)

(t) - Test suite binary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:assemble_dependents" class="section-anchor" href="#sec:assemble_dependents"></a>Assembling dependents</h3></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a>, Gradle will create a task named <code class="literal">assembleDependents<span class="emphasis"><em>${component.name}${binary.variant}</em></span></code> that <span class="emphasis"><em>assembles</em></span> (compile and link) the binary and all of its dependent binaries.</p><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeComponentSpec.html" target="_top"><code class="classname">NativeComponentSpec</code></a>, Gradle will create a task named <code class="literal">assembleDependents<span class="emphasis"><em>${component.name}</em></span></code> that <span class="emphasis"><em>assembles</em></span> all the binaries of the component and all of their dependent binaries.</p><p>For example, to assemble the dependents of the "passing" flavor of the "static" library binary of the "operators" component, you would run the <code class="literal">assembleDependentsOperatorsPassingStaticLibrary</code> task:</p><div class="example"><a name="nativeAssembleDependentComponents"></a><p class="title"><b>Example&nbsp;569.&nbsp;Assemble components that depends on the passing/static binary of the operators component</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1</code></strong></p><pre class="screen">&gt; gradle assembleDependentsOperatorsPassingStaticLibrary --max-workers=1
:compileOperatorsTestPassingCUnitExeOperatorsC
:operatorsTestCUnitLauncher
:compileOperatorsTestPassingCUnitExeOperatorsTestC
:compileOperatorsTestPassingCUnitExeOperatorsTestCunitLauncher
:linkOperatorsTestPassingCUnitExe
:operatorsTestPassingCUnitExe
:assembleDependentsOperatorsTestPassingCUnitExe
:compileOperatorsPassingStaticLibraryOperatorsC
:createOperatorsPassingStaticLibrary
:operatorsPassingStaticLibrary
:assembleDependentsOperatorsPassingStaticLibrary

BUILD SUCCESSFUL in 0s
7 actionable tasks: 7 executed
</pre></div></div><br class="example-break"><p>In the output above, the targeted binary gets assembled as well as the test suite binary that depends on it.</p><p>You can also assemble <span class="emphasis"><em>all</em></span> of the dependents of a component (i.e. of all its binaries/variants) using the corresponding component task, e.g. <code class="literal">assembleDependentsOperators</code>. This is useful if you have many combinations of build types, flavors and platforms and want to assemble all of them.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:build_dependents" class="section-anchor" href="#sec:build_dependents"></a>Building dependents</h3></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a>, Gradle will create a task named <code class="literal">buildDependents<span class="emphasis"><em>${component.name}${binary.variant}</em></span></code> that <span class="emphasis"><em>builds</em></span> (compile, link and check) the binary and all of its dependent binaries.</p><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeComponentSpec.html" target="_top"><code class="classname">NativeComponentSpec</code></a>, Gradle will create a task named <code class="literal">buildDependents<span class="emphasis"><em>${component.name}</em></span></code> that <span class="emphasis"><em>builds</em></span> all the binaries of the component and all of their dependent binaries.</p><p>For example, to build the dependents of the "passing" flavor of the "static" library binary of the "operators" component, you would run the <code class="literal">buildDependentsOperatorsPassingStaticLibrary</code> task:</p><div class="example"><a name="nativeBuildDependentComponents"></a><p class="title"><b>Example&nbsp;570.&nbsp;Build components that depends on the passing/static binary of the operators component</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1</code></strong></p><pre class="screen">&gt; gradle buildDependentsOperatorsPassingStaticLibrary --max-workers=1
:compileOperatorsTestPassingCUnitExeOperatorsC
:operatorsTestCUnitLauncher
:compileOperatorsTestPassingCUnitExeOperatorsTestC
:compileOperatorsTestPassingCUnitExeOperatorsTestCunitLauncher
:linkOperatorsTestPassingCUnitExe
:operatorsTestPassingCUnitExe
:installOperatorsTestPassingCUnitExe
:runOperatorsTestPassingCUnitExe
:checkOperatorsTestPassingCUnitExe
:buildDependentsOperatorsTestPassingCUnitExe
:compileOperatorsPassingStaticLibraryOperatorsC
:createOperatorsPassingStaticLibrary
:operatorsPassingStaticLibrary
:buildDependentsOperatorsPassingStaticLibrary

BUILD SUCCESSFUL in 0s
9 actionable tasks: 9 executed
</pre></div></div><br class="example-break"><p>In the output above, the targeted binary as well as the test suite binary that depends on it are built and the test suite has run.</p><p>You can also build <span class="emphasis"><em>all</em></span> of the dependents of a component (i.e. of all its binaries/variants) using the corresponding component task, e.g. <code class="literal">buildDependentsOperators</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:native_tasks" class="section-anchor" href="#sec:native_tasks"></a>Tasks</h2></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> that can be produced by a build, a single <span class="emphasis"><em>lifecycle task</em></span> is constructed that can be used to create that binary, together with a set of other tasks that do the actual work of compiling, linking or assembling the binary.</p><div class="informaltable"><table border="1"><colgroup><col width="25%"><col width="25%"><col width="25%"><col width="25%"></colgroup><thead><tr><th align="left" valign="top">Component Type</th><th align="left" valign="top">Native Binary Type</th><th align="left" valign="top">Lifecycle task</th><th align="left" valign="top">Location of created binary</th></tr></thead><tbody><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html" target="_top"><code class="classname">NativeExecutableBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${component.name}</em></span>Executable</code></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${project.buildDir}</em></span>/exe/<span class="emphasis"><em>${component.name}</em></span>/<span class="emphasis"><em>${component.name}</em></span></code></p></td></tr><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html" target="_top"><code class="classname">SharedLibraryBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${component.name}</em></span>SharedLibrary</code></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${project.buildDir}</em></span>/libs/<span class="emphasis"><em>${component.name}</em></span>/shared/lib<span class="emphasis"><em>${component.name}</em></span>.so</code></p></td></tr><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html" target="_top"><code class="classname">StaticLibraryBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${component.name}</em></span>StaticLibrary</code></p></td><td align="left" valign="top"><p><code class="literal"><span class="emphasis"><em>${project.buildDir}</em></span>/libs/<span class="emphasis"><em>${component.name}</em></span>/static/<span class="emphasis"><em>${component.name}</em></span>.a</code></p></td></tr></tbody></table></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:check_tasks" class="section-anchor" href="#sec:check_tasks"></a>Check tasks</h3></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> that can be produced by a build, a single <span class="emphasis"><em>check task</em></span> is constructed that can be used to assemble and check that binary.</p><div class="informaltable"><table border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="left" valign="top">Component Type</th><th align="left" valign="top">Native Binary Type</th><th align="left" valign="top">Check task</th></tr></thead><tbody><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableBinarySpec.html" target="_top"><code class="classname">NativeExecutableBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal">check<span class="emphasis"><em>${component.name}</em></span>Executable</code></p></td></tr><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.SharedLibraryBinarySpec.html" target="_top"><code class="classname">SharedLibraryBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal">check<span class="emphasis"><em>${component.name}</em></span>SharedLibrary</code></p></td></tr><tr><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a></p></td><td align="left" valign="top"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.StaticLibraryBinarySpec.html" target="_top"><code class="classname">StaticLibraryBinarySpec</code></a></p></td><td align="left" valign="top"><p><code class="literal">check<span class="emphasis"><em>${component.name}</em></span>StaticLibrary</code></p></td></tr></tbody></table></div><p>The built-in <code class="literal">check</code> task depends on all the <span class="emphasis"><em>check tasks</em></span> for binaries in the project. Without either <a class="link" href="#native_binaries:cunit">CUnit</a> or <a class="link" href="#native_binaries:google_test">GoogleTest</a> plugins, the binary check task only depends on the <span class="emphasis"><em>lifecycle task</em></span> that assembles the binary, see <a class="xref" href="#sec:native_tasks">the section called &ldquo;Tasks&rdquo;</a>.</p><p>When the <a class="link" href="#native_binaries:cunit">CUnit</a> or <a class="link" href="#native_binaries:google_test">GoogleTest</a> plugins are applied, the task that executes the test suites for a component are automatically wired to the appropriate <span class="emphasis"><em>check task</em></span>.</p><p>You can also add custom check tasks as follows:</p><div class="example"><a name="nativeComponentCustomCheck"></a><p class="title"><b>Example&nbsp;571.&nbsp;Adding a custom check task</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"cpp"</span>
<span class="hl-comment">// You don't need to apply the plugin below if you're already using CUnit or GoogleTest support</span>
apply plugin: TestingModelBasePlugin

task myCustomCheck {
    doLast {
        println <span class="hl-string">'Executing my custom check'</span>
    }
}

model {
    components {
        hello(NativeLibrarySpec) {
            binaries.all {
                <span class="hl-comment">// Register our custom check task to all binaries of this component</span>
                checkedBy $.tasks.myCustomCheck
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/custom-check</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>Now, running <code class="literal">check</code> or any of the <span class="emphasis"><em>check tasks</em></span> for the <code class="literal">hello</code> binaries will run the custom check task:</p><div class="example"><a name="nativeComponentCustomCheckOutput"></a><p class="title"><b>Example&nbsp;572.&nbsp;Running checks for a given binary</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle checkHelloSharedLibrary</code></strong></p><pre class="screen">&gt; gradle checkHelloSharedLibrary
:myCustomCheck
Executing my custom check
:checkHelloSharedLibrary

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:working_with_shared_libraries" class="section-anchor" href="#sec:working_with_shared_libraries"></a>Working with shared libraries</h3></div></div></div><p>For each executable binary produced, the <code class="literal">cpp</code> plugin provides an <code class="literal">install${binary.name}</code> task, which creates a development install of the executable, along with the shared libraries it requires. This allows you to run the executable without needing to install the shared libraries in their final locations.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:finding_out_more_about_your_project" class="section-anchor" href="#sec:finding_out_more_about_your_project"></a>Finding out more about your project</h2></div></div></div><p>Gradle provides a report that you can run from the command-line that shows some details about the components and binaries that your project produces. To use this report, just run <code class="literal">gradle components</code>. Below is an example of running this report for one of the sample projects:</p><div class="example"><a name="nativeComponentReport"></a><p class="title"><b>Example&nbsp;573.&nbsp;The components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle components</code></strong></p><pre class="screen">&gt; gradle components
:components

------------------------------------------------------------
Root project
------------------------------------------------------------

Native library 'hello'
----------------------

Source sets
    C++ source 'hello:cpp'
        srcDir: src/hello/cpp

Binaries
    Shared library 'hello:sharedLibrary'
        build using task: :helloSharedLibrary
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        shared library file: build/libs/hello/shared/libhello.dylib
    Static library 'hello:staticLibrary'
        build using task: :helloStaticLibrary
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        static library file: build/libs/hello/static/libhello.a

Native executable 'main'
------------------------

Source sets
    C++ source 'main:cpp'
        srcDir: src/main/cpp

Binaries
    Executable 'main:executable'
        build using task: :mainExecutable
        install using task: :installMainExecutable
        build type: build type 'debug'
        flavor: flavor 'default'
        target platform: platform 'current'
        tool chain: Tool chain 'clang' (Clang)
        executable file: build/exe/main/main

Note: currently not all plugins register their components, so some components may not be visible here.

BUILD SUCCESSFUL in 0s
1 actionable task: 1 executed
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:languages" class="section-anchor" href="#native_binaries:languages"></a>Language support</h2></div></div></div><p>Presently, Gradle supports building native software from any combination of source languages listed below. A native binary project will contain one or more named <code class="literal">FunctionalSourceSet</code> instances (eg 'main', 'test', etc), each of which can contain <code class="literal">LanguageSourceSet</code>s containing source files, one for each language.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>C</p></li><li class="listitem"><p>C++</p></li><li class="listitem"><p>Objective-C</p></li><li class="listitem"><p>Objective-C++</p></li><li class="listitem"><p>Assembly</p></li><li class="listitem"><p>Windows resources</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:cpp_sources" class="section-anchor" href="#sec:cpp_sources"></a>C++ sources</h3></div></div></div><p>C++ language support is provided by means of the <code class="literal">'cpp'</code> plugin.</p><div class="example"><a name="cppPlugin"></a><p class="title"><b>Example&nbsp;574.&nbsp;The 'cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'cpp'</span>
</pre></div></div><br class="example-break"><p>C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>, which defines a set of C++ source files and optionally a set of exported header files (for a library). By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> contains <code class="literal">.cpp</code> source files in <code class="literal">src/${name}/cpp</code>, and header files in <code class="literal">src/${name}/headers</code>.</p><p>While the <code class="literal">cpp</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a>, it is possible to extend or override these defaults to allow for a different project layout.</p><div class="example"><a name="cppSourceSet"></a><p class="title"><b>Example&nbsp;575.&nbsp;C++ source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    cpp {
        source {
            srcDir <span class="hl-string">"src/source"</span>
            include <span class="hl-string">"**/*.cpp"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>For a library named 'main', header files in <code class="literal">src/main/headers</code> are considered the "public" or "exported" headers. Header files that should not be exported should be placed inside the <code class="literal">src/main/cpp</code> directory (though be aware that such header files should always be referenced in a manner relative to the file including them).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:c_sources" class="section-anchor" href="#sec:c_sources"></a>C sources</h3></div></div></div><p>C language support is provided by means of the <code class="literal">'c'</code> plugin.</p><div class="example"><a name="cPlugin"></a><p class="title"><b>Example&nbsp;576.&nbsp;The 'c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'c'</span>
</pre></div></div><br class="example-break"><p>C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>, which defines a set of C source files and optionally a set of exported header files (for a library). By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> contains <code class="literal">.c</code> source files in <code class="literal">src/${name}/c</code>, and header files in <code class="literal">src/${name}/headers</code>.</p><p>While the <code class="literal">c</code> plugin defines these default locations for each <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a>, it is possible to extend or override these defaults to allow for a different project layout.</p><div class="example"><a name="cSourceSet"></a><p class="title"><b>Example&nbsp;577.&nbsp;C source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    c {
        source {
            srcDir <span class="hl-string">"src/source"</span>
            include <span class="hl-string">"**/*.c"</span>
        }
        exportedHeaders {
            srcDir <span class="hl-string">"src/include"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>For a library named 'main', header files in <code class="literal">src/main/headers</code> are considered the "public" or "exported" headers. Header files that should not be exported should be placed inside the <code class="literal">src/main/c</code> directory (though be aware that such header files should always be referenced in a manner relative to the file including them).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:assembler_sources" class="section-anchor" href="#sec:assembler_sources"></a>Assembler sources</h3></div></div></div><p>Assembly language support is provided by means of the <code class="literal">'assembler'</code> plugin.</p><div class="example"><a name="assemblerPlugin"></a><p class="title"><b>Example&nbsp;578.&nbsp;The 'assembler' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'assembler'</span>
</pre></div></div><br class="example-break"><p>Assembler sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a>, which defines a set of Assembler source files. By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.assembler.AssemblerSourceSet.html" target="_top"><code class="classname">AssemblerSourceSet</code></a> contains <code class="literal">.s</code> source files under <code class="literal">src/${name}/asm</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:objectivec_sources" class="section-anchor" href="#sec:objectivec_sources"></a>Objective-C sources</h3></div></div></div><p>Objective-C language support is provided by means of the <code class="literal">'objective-c'</code> plugin.</p><div class="example"><a name="objectiveCPlugin"></a><p class="title"><b>Example&nbsp;579.&nbsp;The 'objective-c' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'objective-c'</span>
</pre></div></div><br class="example-break"><p>Objective-C sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a>, which defines a set of Objective-C source files. By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivec.ObjectiveCSourceSet.html" target="_top"><code class="classname">ObjectiveCSourceSet</code></a> contains <code class="literal">.m</code> source files under <code class="literal">src/${name}/objectiveC</code>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:objectivecpp_sources" class="section-anchor" href="#sec:objectivecpp_sources"></a>Objective-C++ sources</h3></div></div></div><p>Objective-C++ language support is provided by means of the <code class="literal">'objective-cpp'</code> plugin.</p><div class="example"><a name="objectiveCppPlugin"></a><p class="title"><b>Example&nbsp;580.&nbsp;The 'objective-cpp' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'objective-cpp'</span>
</pre></div></div><br class="example-break"><p>Objective-C++ sources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a>, which defines a set of Objective-C++ source files. By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.objectivecpp.ObjectiveCppSourceSet.html" target="_top"><code class="classname">ObjectiveCppSourceSet</code></a> contains <code class="literal">.mm</code> source files under <code class="literal">src/${name}/objectiveCpp</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuring_the_compiler_assembler_and_linker" class="section-anchor" href="#sec:configuring_the_compiler_assembler_and_linker"></a>Configuring the compiler, assembler and linker</h2></div></div></div><p>Each binary to be produced is associated with a set of compiler and linker settings, which include command-line arguments as well as macro definitions. These settings can be applied to all binaries, an individual binary, or selectively to a group of binaries based on some criteria.</p><div class="example"><a name="allBinarySettings"></a><p class="title"><b>Example&nbsp;581.&nbsp;Settings that apply to all binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    binaries {
        all {
            <span class="hl-comment">// Define a preprocessor macro for every binary</span>
            cppCompiler.define <span class="hl-string">"NDEBUG"</span>

            <span class="hl-comment">// Define toolchain-specific compiler and linker options</span>
            <span class="hl-keyword">if</span> (toolChain in Gcc) {
                cppCompiler.args <span class="hl-string">"-O2"</span>, <span class="hl-string">"-fno-access-control"</span>
                linker.args <span class="hl-string">"-Xlinker"</span>, <span class="hl-string">"-S"</span>
            }
            <span class="hl-keyword">if</span> (toolChain in VisualCpp) {
                cppCompiler.args <span class="hl-string">"/Zi"</span>
                linker.args <span class="hl-string">"/DEBUG"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Each binary is associated with a particular <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a>, allowing settings to be targeted based on this value.</p><p>It is easy to apply settings to all binaries of a particular type:</p><div class="example"><a name="allSharedLibraryBinarySettings"></a><p class="title"><b>Example&nbsp;582.&nbsp;Settings that apply to all shared libraries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-comment">// For any shared library binaries built with Visual C++,</span>
<span class="hl-comment">// define the DLL_EXPORT macro</span>
model {
    binaries {
        withType(SharedLibraryBinarySpec) {
            <span class="hl-keyword">if</span> (toolChain in VisualCpp) {
                cCompiler.args <span class="hl-string">"/Zi"</span>
                cCompiler.define <span class="hl-string">"DLL_EXPORT"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Furthermore, it is possible to specify settings that apply to all binaries produced for a particular <code class="literal">executable</code> or <code class="literal">library</code> component:</p><div class="example"><a name="componentBinarySettings"></a><p class="title"><b>Example&nbsp;583.&nbsp;Settings that apply to all binaries produced for the 'main' executable component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(NativeExecutableSpec) {
            targetPlatform <span class="hl-string">"x86"</span>
            binaries.all {
                <span class="hl-keyword">if</span> (toolChain in VisualCpp) {
                    sources {
                        platformAsm(AssemblerSourceSet) {
                            source.srcDir <span class="hl-string">"src/main/asm_i386_masm"</span>
                        }
                    }
                    assembler.args <span class="hl-string">"/Zi"</span>
                } <span class="hl-keyword">else</span> {
                    sources {
                        platformAsm(AssemblerSourceSet) {
                            source.srcDir <span class="hl-string">"src/main/asm_i386_gcc"</span>
                        }
                    }
                    assembler.args <span class="hl-string">"-g"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>The example above will apply the supplied configuration to all <code class="literal">executable</code> binaries built.</p><p>Similarly, settings can be specified to target binaries for a component that are of a particular type: eg all shared libraries for the main library component.</p><div class="example"><a name="sharedLibraryArgs"></a><p class="title"><b>Example&nbsp;584.&nbsp;Settings that apply only to shared libraries produced for the 'main' library component</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        main(NativeLibrarySpec) {
            binaries.withType(SharedLibraryBinarySpec) {
                <span class="hl-comment">// Define a preprocessor macro that only applies to shared libraries</span>
                cppCompiler.define <span class="hl-string">"DLL_EXPORT"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:windows-resources" class="section-anchor" href="#native_binaries:windows-resources"></a>Windows Resources</h2></div></div></div><p>When using the <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a> tool chain, Gradle is able to compile Window Resource (<code class="literal">rc</code>) files and link them into a native binary. This functionality is provided by the <code class="literal">'windows-resources'</code> plugin.</p><div class="example"><a name="windowsResourcesPlugin"></a><p class="title"><b>Example&nbsp;585.&nbsp;The 'windows-resources' plugin</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">'windows-resources'</span>
</pre></div></div><br class="example-break"><p>Windows resources to be included in a native binary are provided via a <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a>, which defines a set of Windows Resource source files. By default, for any named component the <a class="ulink" href="../dsl/org.gradle.language.rc.WindowsResourceSet.html" target="_top"><code class="classname">WindowsResourceSet</code></a> contains <code class="literal">.rc</code> source files under <code class="literal">src/${name}/rc</code>.</p><p>As with other source types, you can configure the location of the windows resources that should be included in the binary.</p><div class="example"><a name="windowsResourceSet"></a><p class="title"><b>Example&nbsp;586.&nbsp;Configuring the location of Windows resource sources</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">sources {
    rc {
        source {
            srcDirs <span class="hl-string">"src/hello/rc"</span>
        }
        exportedHeaders {
            srcDirs <span class="hl-string">"src/hello/headers"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>You are able to construct a resource-only library by providing Windows Resource sources with no other language sources, and configure the linker as appropriate:</p><div class="example"><a name="resourceOnlyDll"></a><p class="title"><b>Example&nbsp;587.&nbsp;Building a resource-only dll</b></p><div class="example-contents"><p><code class="filename">build-resource-only-dll.gradle</code></p><pre class="programlisting">model {
    components {
        helloRes(NativeLibrarySpec) {
            binaries.all {
                rcCompiler.args <span class="hl-string">"/v"</span>
                linker.args <span class="hl-string">"/noentry"</span>, <span class="hl-string">"/machine:x86"</span>
            }
            sources {
                rc {
                    source {
                        srcDirs <span class="hl-string">"src/hello/rc"</span>
                    }
                    exportedHeaders {
                        srcDirs <span class="hl-string">"src/hello/headers"</span>
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>The example above also demonstrates the mechanism of passing extra command-line arguments to the resource compiler. The <code class="literal">rcCompiler</code> extension is of type <a class="ulink" href="../dsl/org.gradle.nativeplatform.PreprocessingTool.html" target="_top"><code class="classname">PreprocessingTool</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:library_dependencies" class="section-anchor" href="#sec:library_dependencies"></a>Library Dependencies</h2></div></div></div><p>Dependencies for native components are binary libraries that export header files. The header files are used during compilation, with the compiled binary dependency being used during linking and execution. Header files should be organized into subdirectories to prevent clashes of commonly named headers. For instance, if your <code class="literal">mylib</code> project has a <code class="literal">logging.h</code> header, it will make it less likely the wrong header is used if you include it as <code class="literal">"mylib/logging.h"</code> instead of <code class="literal">"logging.h"</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:dependencies_within_the_same_project" class="section-anchor" href="#sec:dependencies_within_the_same_project"></a>Dependencies within the same project</h3></div></div></div><p>A set of sources may depend on header files provided by another binary component within the same project. A common example is a native executable component that uses functions provided by a separate native library component.</p><p>Such a library dependency can be added to a source set associated with the <code class="literal">executable</code> component:</p><div class="example"><a name="cppSourceLibrary"></a><p class="title"><b>Example&nbsp;588.&nbsp;Providing a library dependency to the source set</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">sources {
    cpp {
        lib library: <span class="hl-string">"hello"</span>
    }
}
</pre></div></div><br class="example-break"><p>Alternatively, a library dependency can be provided directly to the <code class="literal">NativeExecutableBinarySpec</code> for the <code class="literal">executable</code>.</p><div class="example"><a name="cppBinaryLibrary"></a><p class="title"><b>Example&nbsp;589.&nbsp;Providing a library dependency to the binary</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        hello(NativeLibrarySpec) {
            sources {
                c {
                    source {
                        srcDir <span class="hl-string">"src/source"</span>
                        include <span class="hl-string">"**/*.c"</span>
                    }
                    exportedHeaders {
                        srcDir <span class="hl-string">"src/include"</span>
                    }
                }
            }
        }
        main(NativeExecutableSpec) {
            sources {
                cpp {
                    source {
                        srcDir <span class="hl-string">"src/source"</span>
                        include <span class="hl-string">"**/*.cpp"</span>
                    }
                }
            }
            binaries.all {
                <span class="hl-comment">// Each executable binary produced uses the 'hello' static library binary</span>
                lib library: <span class="hl-string">'hello'</span>, linkage: <span class="hl-string">'static'</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:project_dependencies" class="section-anchor" href="#sec:project_dependencies"></a>Project Dependencies</h3></div></div></div><p>For a component produced in a different Gradle project, the notation is similar.</p><div class="example"><a name="cppProjectDependencies"></a><p class="title"><b>Example&nbsp;590.&nbsp;Declaring project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">project(<span class="hl-string">":lib"</span>) {
    apply plugin: <span class="hl-string">"cpp"</span>
    model {
        components {
            main(NativeLibrarySpec)
        }

        <span class="hl-comment">// For any shared library binaries built with Visual C++,</span>
        <span class="hl-comment">// define the DLL_EXPORT macro</span>
        binaries {
            withType(SharedLibraryBinarySpec) {
                <span class="hl-keyword">if</span> (toolChain in VisualCpp) {
                    cppCompiler.define <span class="hl-string">"DLL_EXPORT"</span>
                }
            }
        }
    }
}

project(<span class="hl-string">":exe"</span>) {
    apply plugin: <span class="hl-string">"cpp"</span>

    model {
        components {
            main(NativeExecutableSpec) {
                sources {
                    cpp {
                        lib project: <span class="hl-string">':lib'</span>, library: <span class="hl-string">'main'</span>
                    }
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:preCompiledHeaders" class="section-anchor" href="#native_binaries:preCompiledHeaders"></a>Precompiled Headers</h2></div></div></div><p>Precompiled headers are a performance optimization that reduces the cost of compiling widely used headers multiple times. This feature <span class="emphasis"><em>precompiles</em></span> a header such that the compiled object file can be reused when compiling each source file rather than recompiling the header each time. This support is available for C, C++, Objective-C, and Objective-C++ builds.</p><p>To configure a precompiled header, first a header file needs to be defined that includes all of the headers that should be precompiled. It must be specified as the first included header in every source file where the precompiled header should be used. It is assumed that this header file, and any headers it contains, make use of header guards so that they can be included in an idempotent manner. If header guards are not used in a header file, it is possible the header could be compiled more than once and could potentially lead to a broken build.</p><div class="example"><a name="preCompiledHeaderFile"></a><p class="title"><b>Example&nbsp;591.&nbsp;Creating a precompiled header file</b></p><div class="example-contents"><p><code class="filename">src/hello/headers/pch.h</code></p><pre class="programlisting">#ifndef PCH_H
#define PCH_H
#include &lt;iostream&gt;
#include "hello.h"
#endif
</pre></div></div><br class="example-break"><div class="example"><a name="preCompiledHeaderFile"></a><p class="title"><b>Example&nbsp;592.&nbsp;Including a precompiled header file in a source file</b></p><div class="example-contents"><p><code class="filename">src/hello/cpp/hello.cpp</code></p><pre class="programlisting">#include "pch.h"

void LIB_FUNC Greeter::hello () {
    std::cout &lt;&lt; "Hello world!" &lt;&lt; std::endl;
}
</pre></div></div><br class="example-break"><p>Precompiled headers are specified on a source set. Only one precompiled header file can be specified on a given source set and will be applied to all source files that declare it as the first include. If a source files does not include this header file as the first header, the file will be compiled in the normal manner (without making use of the precompiled header object file). The string provided should be the same as that which is used in the "#include" directive in the source files.</p><div class="example"><a name="preCompiledHeaderConfig"></a><p class="title"><b>Example&nbsp;593.&nbsp;Configuring a precompiled header</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        hello(NativeLibrarySpec) {
            sources {
                cpp {
                    preCompiledHeader <span class="hl-string">"pch.h"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>A precompiled header must be included in the same way for all files that use it. Usually, this means the header file should exist in the source set "headers" directory or in a directory included on the compiler include path.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:variants" class="section-anchor" href="#native_binaries:variants"></a>Native Binary Variants</h2></div></div></div><p>For each executable or library defined, Gradle is able to build a number of different native binary variants. Examples of different variants include debug vs release binaries, 32-bit vs 64-bit binaries, and binaries produced with different custom preprocessor flags.</p><p>Binaries produced by Gradle can be differentiated on <a class="link" href="#native_binaries:build_type">build type</a>, <a class="link" href="#native_binaries:platform">platform</a>, and <a class="link" href="#native_binaries:flavor">flavor</a>. For each of these 'variant dimensions', it is possible to specify a set of available values as well as target each component at one, some or all of these. For example, a plugin may define a range of support platforms, but you may choose to only target Windows-x86 for a particular component.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:build_type" class="section-anchor" href="#native_binaries:build_type"></a>Build types</h3></div></div></div><p>A <code class="literal">build type</code> determines various non-functional aspects of a binary, such as whether debug information is included, or what optimisation level the binary is compiled with. Typical build types are 'debug' and 'release', but a project is free to define any set of build types.</p><div class="example"><a name="buildTypes"></a><p class="title"><b>Example&nbsp;594.&nbsp;Defining build types</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    buildTypes {
        debug
        release
    }
}
</pre></div></div><br class="example-break"><p>If no build types are defined in a project, then a single, default build type called 'debug' is added.</p><p>For a build type, a Gradle project will typically define a set of compiler/linker flags per tool chain.</p><div class="example"><a name="buildTypeConfig"></a><p class="title"><b>Example&nbsp;595.&nbsp;Configuring debug binaries</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    binaries {
        all {
            <span class="hl-keyword">if</span> (toolChain in Gcc &amp;&amp; buildType == buildTypes.debug) {
                cppCompiler.args <span class="hl-string">"-g"</span>
            }
            <span class="hl-keyword">if</span> (toolChain in VisualCpp &amp;&amp; buildType == buildTypes.debug) {
                cppCompiler.args <span class="hl-string">'/Zi'</span>
                cppCompiler.define <span class="hl-string">'DEBUG'</span>
                linker.args <span class="hl-string">'/DEBUG'</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>At this stage, it is completely up to the build script to configure the relevant compiler/linker flags for each build type. Future versions of Gradle will automatically include the appropriate debug flags for any 'debug' build type, and may be aware of various levels of optimisation as well.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:platform" class="section-anchor" href="#native_binaries:platform"></a>Platform</h3></div></div></div><p>An executable or library can be built to run on different operating systems and cpu architectures, with a variant being produced for each platform. Gradle defines each OS/architecture combination as a <a class="ulink" href="../dsl/org.gradle.nativeplatform.platform.NativePlatform.html" target="_top"><code class="classname">NativePlatform</code></a>, and a project may define any number of platforms. If no platforms are defined in a project, then a single, default platform 'current' is added.</p><div class="note"><p>Presently, a <code class="literal">Platform</code> consists of a defined operating system and architecture. As we continue to develop the native binary support in Gradle, the concept of Platform will be extended to include things like C-runtime version, Windows SDK, ABI, etc. Sophisticated builds may use the extensibility of Gradle to apply additional attributes to each platform, which can then be queried to specify particular includes, preprocessor macros or compiler arguments for a native binary.</p></div><div class="example"><a name="platforms"></a><p class="title"><b>Example&nbsp;596.&nbsp;Defining platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    platforms {
        x8<span class="hl-number">6</span> {
            architecture <span class="hl-string">"x86"</span>
        }
        x6<span class="hl-number">4</span> {
            architecture <span class="hl-string">"x86_64"</span>
        }
        itanium {
            architecture <span class="hl-string">"ia-64"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>For a given variant, Gradle will attempt to find a <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a> that is able to build for the target platform. Available tool chains are searched in the order defined. See the <a class="link" href="#native_binaries:tool_chain">tool chains</a> section below for more details.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="native_binaries:flavor" class="section-anchor" href="#native_binaries:flavor"></a>Flavor</h3></div></div></div><p>Each component can have a set of named <code class="literal">flavors</code>, and a separate binary variant can be produced for each flavor. While the <code class="literal">build type</code> and <code class="literal">target platform</code> variant dimensions have a defined meaning in Gradle, each project is free to define any number of flavors and apply meaning to them in any way.</p><p>An example of component flavors might differentiate between 'demo', 'paid' and 'enterprise' editions of the component, where the same set of sources is used to produce binaries with different functions.</p><div class="example"><a name="flavors"></a><p class="title"><b>Example&nbsp;597.&nbsp;Defining flavors</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    flavors {
        english
        french
    }
    components {
        hello(NativeLibrarySpec) {
            binaries.all {
                <span class="hl-keyword">if</span> (flavor == flavors.french) {
                    cppCompiler.define <span class="hl-string">"FRENCH"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>In the example above, a library is defined with a 'english' and 'french' flavor. When compiling the 'french' variant, a separate macro is defined which leads to a different binary being produced.</p><p>If no flavor is defined for a component, then a single default flavor named 'default' is used.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:selecting_the_build_types_platforms_and_flavors_for_a_component" class="section-anchor" href="#sec:selecting_the_build_types_platforms_and_flavors_for_a_component"></a>Selecting the build types, platforms and flavors for a component</h3></div></div></div><p>For a default component, Gradle will attempt to create a native binary variant for each and every combination of <code class="literal">buildType</code> and <code class="literal">flavor</code> defined for the project. It is possible to override this on a per-component basis, by specifying the set of <code class="literal">targetBuildTypes</code> and/or <code class="literal">targetFlavors</code>. By default, Gradle will build for the default platform, see <a class="link" href="#native_binaries:platform">above</a>, unless specified explicitly on a per-component basis by specifying a set of <code class="literal">targetPlatforms</code>.</p><div class="example"><a name="targets"></a><p class="title"><b>Example&nbsp;598.&nbsp;Targeting a component at particular platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    components {
        hello(NativeLibrarySpec) {
            targetPlatform <span class="hl-string">"x86"</span>
            targetPlatform <span class="hl-string">"x64"</span>
        }
        main(NativeExecutableSpec) {
            targetPlatform <span class="hl-string">"x86"</span>
            targetPlatform <span class="hl-string">"x64"</span>
            sources {
                cpp.lib library: <span class="hl-string">'hello'</span>, linkage: <span class="hl-string">'static'</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>Here you can see that the <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetPlatform(java.lang.String)" target="_top"><code class="classname">TargetedNativeComponent.targetPlatform(java.lang.String)</code></a> method is used to specify a platform that the <code class="literal">NativeExecutableSpec</code> named <code class="literal">main</code> should be built for.</p><p>A similar mechanism exists for selecting <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetBuildTypes(java.lang.String[])" target="_top"><code class="classname">TargetedNativeComponent.targetBuildTypes(java.lang.String[])</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.TargetedNativeComponent.html#org.gradle.nativeplatform.TargetedNativeComponent:targetFlavors(java.lang.String[])" target="_top"><code class="classname">TargetedNativeComponent.targetFlavors(java.lang.String[])</code></a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:building_all_possible_variants" class="section-anchor" href="#sec:building_all_possible_variants"></a>Building all possible variants</h3></div></div></div><p>When a set of build types, target platforms, and flavors is defined for a component, a <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> model element is created for every possible combination of these. However, in many cases it is not possible to build a particular variant, perhaps because no tool chain is available to build for a particular platform.</p><p>If a binary variant cannot be built for any reason, then the <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> associated with that variant will not be <code class="literal">buildable</code>. It is possible to use this property to create a task to generate all possible variants on a particular machine.</p><div class="example"><a name="buildable"></a><p class="title"><b>Example&nbsp;599.&nbsp;Building all possible variants</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    tasks {
        buildAllExecutables(Task) {
            dependsOn $.binaries.findAll { it.buildable }
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:tool_chain" class="section-anchor" href="#native_binaries:tool_chain"></a>Tool chains</h2></div></div></div><p>A single build may utilize different tool chains to build variants for different platforms. To this end, the core 'native-binary' plugins will attempt to locate and make available supported tool chains. However, the set of tool chains for a project may also be explicitly defined, allowing additional cross-compilers to be configured as well as allowing the install directories to be specified.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_tool_chains" class="section-anchor" href="#sec:defining_tool_chains"></a>Defining tool chains</h3></div></div></div><p>The supported tool chain types are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a></p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.VisualCpp.html" target="_top"><code class="classname">VisualCpp</code></a></p></li></ul></div><div class="example"><a name="toolChains"></a><p class="title"><b>Example&nbsp;600.&nbsp;Defining tool chains</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            <span class="hl-comment">// Specify the installDir if Visual Studio cannot be located</span>
            <span class="hl-comment">// installDir "C:/Apps/Microsoft Visual Studio 10.0"</span>
        }
        gcc(Gcc) {
            <span class="hl-comment">// Uncomment to use a GCC install that is not in the PATH</span>
            <span class="hl-comment">// path "/usr/bin/gcc"</span>
        }
        clang(Clang)
    }
}
</pre></div></div><br class="example-break"><p>Each tool chain implementation allows for a certain degree of configuration (see the API documentation for more details).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_tool_chains" class="section-anchor" href="#sec:using_tool_chains"></a>Using tool chains</h3></div></div></div><p>It is not necessary or possible to specify the tool chain that should be used to build. For a given variant, Gradle will attempt to locate a <a class="ulink" href="../javadoc/org/gradle/nativeplatform/toolchain/NativeToolChain.html" target="_top"><code class="classname">NativeToolChain</code></a> that is able to build for the target platform. Available tool chains are searched in the order defined.</p><div class="note"><p>When a platform does not define an architecture or operating system, the default target of the tool chain is assumed. So if a platform does not define a value for <code class="literal">operatingSystem</code>, Gradle will find the first available tool chain that can build for the specified <code class="literal">architecture</code>.</p></div><p>The core Gradle tool chains are able to target the following architectures out of the box. In each case, the tool chain will target the current operating system. See the next section for information on cross-compiling for other operating systems.</p><div class="informaltable"><table border="1"><colgroup><col width="50%"><col width="50%"></colgroup><thead><tr><th align="left" valign="top">Tool Chain</th><th align="left" valign="top">Architectures</th></tr></thead><tbody><tr><td align="left" valign="top"><p>GCC</p></td><td align="left" valign="top"><p>x86, x86_64</p></td></tr><tr><td align="left" valign="top"><p>Clang</p></td><td align="left" valign="top"><p>x86, x86_64</p></td></tr><tr><td align="left" valign="top"><p>Visual C++</p></td><td align="left" valign="top"><p>x86, x86_64, ia-64</p></td></tr></tbody></table></div><p>So for GCC running on linux, the supported target platforms are 'linux/x86' and 'linux/x86_64'. For GCC running on Windows via Cygwin, platforms 'windows/x86' and 'windows/x86_64' are supported. (The Cygwin POSIX runtime is not yet modelled as part of the platform, but will be in the future.)</p><p>If no target platforms are defined for a project, then all binaries are built to target a default platform named 'current'. This default platform does not specify any <code class="literal">architecture</code> or <code class="literal">operatingSystem</code> value, hence using the default values of the first available tool chain.</p><p>Gradle provides a <span class="emphasis"><em>hook</em></span> that allows the build author to control the exact set of arguments passed to a tool chain executable. This enables the build author to work around any limitations in Gradle, or assumptions that Gradle makes. The arguments hook should be seen as a 'last-resort' mechanism, with preference given to truly modelling the underlying domain.</p><div class="example"><a name="withArguments"></a><p class="title"><b>Example&nbsp;601.&nbsp;Reconfigure tool arguments</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        visualCpp(VisualCpp) {
            eachPlatform {
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span class="hl-string">"-DFRENCH"</span>
                }
            }
        }
        clang(Clang) {
            eachPlatform {
                cCompiler.withArguments { args -&gt;
                    Collections.replaceAll(args, <span class="hl-string">"CUSTOM"</span>, <span class="hl-string">"-DFRENCH"</span>)
                }
                linker.withArguments { args -&gt;
                    args.remove <span class="hl-string">"CUSTOM"</span>
                }
                staticLibArchiver.withArguments { args -&gt;
                    args.remove <span class="hl-string">"CUSTOM"</span>
                }
            }
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:crosscompiling_with_gcc" class="section-anchor" href="#sec:crosscompiling_with_gcc"></a>Cross-compiling with GCC</h3></div></div></div><p>Cross-compiling is possible with the <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Gcc.html" target="_top"><code class="classname">Gcc</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.toolchain.Clang.html" target="_top"><code class="classname">Clang</code></a> tool chains, by adding support for additional target platforms. This is done by specifying a target platform for a toolchain. For each target platform a custom configuration can be specified.</p><div class="example"><a name="targetPlatforms"></a><p class="title"><b>Example&nbsp;602.&nbsp;Defining target platforms</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    toolChains {
        gcc(Gcc) {
            target(<span class="hl-string">"arm"</span>){
                cppCompiler.withArguments { args -&gt;
                    args &lt;&lt; <span class="hl-string">"-m32"</span>
                }
                linker.withArguments { args -&gt;
                    args &lt;&lt; <span class="hl-string">"-m32"</span>
                }
            }
            target(<span class="hl-string">"sparc"</span>)
        }
    }
    platforms {
        arm {
            architecture <span class="hl-string">"arm"</span>
        }
        sparc {
            architecture <span class="hl-string">"sparc"</span>
        }
    }
    components {
        main(NativeExecutableSpec) {
            targetPlatform <span class="hl-string">"arm"</span>
            targetPlatform <span class="hl-string">"sparc"</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:visual_studio" class="section-anchor" href="#native_binaries:visual_studio"></a>Visual Studio IDE integration</h2></div></div></div><p>Gradle has the ability to generate Visual Studio project and solution files for the native components defined in your build. This ability is added by the <code class="literal">visual-studio</code> plugin. For a multi-project build, all projects with native components should have this plugin applied.</p><p>When the <code class="literal">visual-studio</code> plugin is applied, a task name <code class="literal">${component.name}VisualStudio</code> is created for each defined component. This task will generate a Visual Studio Solution file for the named component. This solution will include a Visual Studio Project for that component, as well as linking to project files for each depended-on binary.</p><p>The content of the generated visual studio files can be modified via API hooks, provided by the <code class="literal">visualStudio</code> extension. Take a look at the 'visual-studio' sample, or see <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:projects" target="_top"><code class="classname">VisualStudioExtension.getProjects()</code></a> and <a class="ulink" href="../dsl/org.gradle.ide.visualstudio.VisualStudioExtension.html#org.gradle.ide.visualstudio.VisualStudioExtension:solutions" target="_top"><code class="classname">VisualStudioExtension.getSolutions()</code></a> in the API documentation for more details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:cunit" class="section-anchor" href="#native_binaries:cunit"></a>CUnit support</h2></div></div></div><p>The Gradle <code class="literal">cunit</code> plugin provides support for compiling and executing CUnit tests in your native-binary project. For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a> defined in your project, Gradle will create a matching <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component, named <code class="literal">${component.name}Test</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:cunit_sources" class="section-anchor" href="#sec:cunit_sources"></a>CUnit sources</h3></div></div></div><p>Gradle will create a <a class="ulink" href="../dsl/org.gradle.language.c.CSourceSet.html" target="_top"><code class="classname">CSourceSet</code></a> named 'cunit' for each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component in the project. This source set should contain the cunit test files for the component under test. Source files can be located in the conventional location (<code class="literal">src/${component.name}Test/cunit</code>) or can be configured like any other source set.</p><p>Gradle initialises the CUnit test registry and executes the tests, utilising some generated CUnit launcher sources. Gradle will expect and call a function with the signature <code class="literal">void gradle_cunit_register()</code> that you can use to configure the actual CUnit suites and tests to execute.</p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;603.&nbsp;Registering CUnit tests</b></p><div class="example-contents"><p><code class="filename">suite_operators.c</code></p><pre class="programlisting">#include &lt;CUnit/Basic.h&gt;
#include "gradle_cunit_register.h"
#include "test_operators.h"

int suite_init(void) {
    return 0;
}

int suite_clean(void) {
    return 0;
}

void gradle_cunit_register() {
    CU_pSuite pSuiteMath = CU_add_suite("operator tests", suite_init, suite_clean);
    CU_add_test(pSuiteMath, "test_plus", test_plus);
    CU_add_test(pSuiteMath, "test_minus", test_minus);
}
</pre></div></div><br class="example-break"><div class="note"><p>Due to this mechanism, your CUnit sources may not contain a <code class="literal">main</code> method since this will clash with the method provided by Gradle.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:building_cunit_executables" class="section-anchor" href="#sec:building_cunit_executables"></a>Building CUnit executables</h3></div></div></div><p>A <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteSpec.html" target="_top"><code class="classname">CUnitTestSuiteSpec</code></a> component has an associated <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> or <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a> component. For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> configured for the main component, a matching <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a> will be configured on the test suite component. These test suite binaries can be configured in a similar way to any other binary instance:</p><div class="example"><a name="cunitSources"></a><p class="title"><b>Example&nbsp;604.&nbsp;Configuring CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    binaries {
        withType(CUnitTestSuiteBinarySpec) {
            lib library: <span class="hl-string">"cunit"</span>, linkage: <span class="hl-string">"static"</span>

            <span class="hl-keyword">if</span> (flavor == flavors.failing) {
                cCompiler.define <span class="hl-string">"PLUS_BROKEN"</span>
            }
        }
    }
}
</pre></div></div><br class="example-break"><div class="note"><p>Both the CUnit sources provided by your project and the generated launcher require the core CUnit headers and libraries. Presently, this library dependency must be provided by your project for each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:running_cunit_tests" class="section-anchor" href="#sec:running_cunit_tests"></a>Running CUnit tests</h3></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.cunit.CUnitTestSuiteBinarySpec.html" target="_top"><code class="classname">CUnitTestSuiteBinarySpec</code></a>, Gradle will create a task to execute this binary, which will run all of the registered CUnit tests. Test results will be found in the <code class="literal"><span class="emphasis"><em>${build.dir}</em></span>/test-results</code> directory.</p><div class="example"><a name="completeCUnitExample"></a><p class="title"><b>Example&nbsp;605.&nbsp;Running CUnit tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: <span class="hl-string">"c"</span>
apply plugin: <span class="hl-string">'cunit-test-suite'</span>

model {
    flavors {
        passing
        failing
    }
    platforms {
        x8<span class="hl-number">6</span> {
            architecture <span class="hl-string">"x86"</span>
        }
    }
    repositories {
        libs(PrebuiltLibraries) {
            cunit {
                headers.srcDir <span class="hl-string">"libs/cunit/2.1-2/include"</span>
                binaries.withType(StaticLibraryBinary) {
                    staticLibraryFile =
                        file(<span class="hl-string">"libs/cunit/2.1-2/lib/"</span> +
                             findCUnitLibForPlatform(targetPlatform))
                }
            }
        }
    }
    components {
        operators(NativeLibrarySpec) {
            targetPlatform <span class="hl-string">"x86"</span>
        }
    }
    testSuites {
        operatorsTest(CUnitTestSuiteSpec) {
            testing $.components.operators
        }
    }
}
model {
    binaries {
        withType(CUnitTestSuiteBinarySpec) {
            lib library: <span class="hl-string">"cunit"</span>, linkage: <span class="hl-string">"static"</span>

            <span class="hl-keyword">if</span> (flavor == flavors.failing) {
                cCompiler.define <span class="hl-string">"PLUS_BROKEN"</span>
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/cunit</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div><p>Output of <strong class="userinput"><code>gradle -q runOperatorsTestFailingCUnitExe</code></strong></p><pre class="screen">&gt; gradle -q runOperatorsTestFailingCUnitExe

There were test failures:
  1. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/c/test_plus.c:6  - plus(0, -2) == -2
  2. /home/user/gradle/samples/native-binaries/cunit/src/operatorsTest/c/test_plus.c:7  - plus(2, 2) == 4

</pre></div></div><br class="example-break"><div class="note"><p>The current support for CUnit is quite rudimentary. Plans for future integration include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Allow tests to be declared with Javadoc-style annotations.</p></li><li class="listitem"><p>Improved HTML reporting, similar to that available for JUnit.</p></li><li class="listitem"><p>Real-time feedback for test execution.</p></li><li class="listitem"><p>Support for additional test frameworks.</p></li></ul></div></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="native_binaries:google_test" class="section-anchor" href="#native_binaries:google_test"></a>GoogleTest support</h2></div></div></div><p>The Gradle <code class="literal">google-test</code> plugin provides support for compiling and executing GoogleTest tests in your native-binary project. For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> and <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a> defined in your project, Gradle will create a matching <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html" target="_top"><code class="classname">GoogleTestTestSuiteSpec</code></a> component, named <code class="literal">${component.name}Test</code>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:googletest_sources" class="section-anchor" href="#sec:googletest_sources"></a>GoogleTest sources</h3></div></div></div><p>Gradle will create a <a class="ulink" href="../dsl/org.gradle.language.cpp.CppSourceSet.html" target="_top"><code class="classname">CppSourceSet</code></a> named 'cpp' for each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html" target="_top"><code class="classname">GoogleTestTestSuiteSpec</code></a> component in the project. This source set should contain the GoogleTest test files for the component under test. Source files can be located in the conventional location (<code class="literal">src/${component.name}Test/cpp</code>) or can be configured like any other source set.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:building_googletest_executables" class="section-anchor" href="#sec:building_googletest_executables"></a>Building GoogleTest executables</h3></div></div></div><p>A <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteSpec.html" target="_top"><code class="classname">GoogleTestTestSuiteSpec</code></a> component has an associated <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeExecutableSpec.html" target="_top"><code class="classname">NativeExecutableSpec</code></a> or <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeLibrarySpec.html" target="_top"><code class="classname">NativeLibrarySpec</code></a> component. For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.NativeBinarySpec.html" target="_top"><code class="classname">NativeBinarySpec</code></a> configured for the main component, a matching <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html" target="_top"><code class="classname">GoogleTestTestSuiteBinarySpec</code></a> will be configured on the test suite component. These test suite binaries can be configured in a similar way to any other binary instance:</p><div class="example"><a name="googleTestSources"></a><p class="title"><b>Example&nbsp;606.&nbsp;Registering GoogleTest tests</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">model {
    binaries {
        withType(GoogleTestTestSuiteBinarySpec) {
            lib library: <span class="hl-string">"googleTest"</span>, linkage: <span class="hl-string">"static"</span>

            <span class="hl-keyword">if</span> (flavor == flavors.failing) {
                cppCompiler.define <span class="hl-string">"PLUS_BROKEN"</span>
            }

            <span class="hl-keyword">if</span> (targetPlatform.operatingSystem.linux) {
                cppCompiler.args <span class="hl-string">'-pthread'</span>
                linker.args <span class="hl-string">'-pthread'</span>
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/native-binaries/google-test</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><div class="note"><p>The GoogleTest sources provided by your project require the core GoogleTest headers and libraries. Presently, this library dependency must be provided by your project for each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html" target="_top"><code class="classname">GoogleTestTestSuiteBinarySpec</code></a>.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:running_googletest_tests" class="section-anchor" href="#sec:running_googletest_tests"></a>Running GoogleTest tests</h3></div></div></div><p>For each <a class="ulink" href="../dsl/org.gradle.nativeplatform.test.googletest.GoogleTestTestSuiteBinarySpec.html" target="_top"><code class="classname">GoogleTestTestSuiteBinarySpec</code></a>, Gradle will create a task to execute this binary, which will run all of the registered GoogleTest tests. Test results will be found in the <code class="literal"><span class="emphasis"><em>${build.dir}</em></span>/test-results</code> directory.</p><div class="note"><p>The current support for GoogleTest is quite rudimentary. Plans for future integration include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Improved HTML reporting, similar to that available for JUnit.</p></li><li class="listitem"><p>Real-time feedback for test execution.</p></li><li class="listitem"><p>Support for additional test frameworks.</p></li></ul></div></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="software_model_extend"></a>Extending the software model</h1></div></div></div><div class="note"><p>Support for the software model is currently <a class="link" href="#feature_lifecycle">incubating</a>. Please be aware that the DSL, APIs and other configuration may change in later Gradle versions.</p></div><p>One of the strengths of Gradle has always been its extensibility, and its adaptability to new domains. The software model takes this extensibility to a new level, enabling the deep modeling of specific domains via richly typed DSLs. The following chapter describes how the model and the corresponding DSLs can be extended to support domains like <a class="link" href="#java_software">Java</a>, <a class="link" href="#play_plugin">Play Framework</a> or <a class="link" href="#native_software">native software development</a>. Before reading this you should be familiar with the Gradle software model <a class="link" href="#software_model">rule based configuration</a> and <a class="link" href="#software_model_concepts">concepts</a>.</p><p>The following build script is an example of using a custom software model for building Markdown based documentation:</p><div class="example"><a name="sm-extensible-build-script"></a><p class="title"><b>Example&nbsp;607.&nbsp;an example of using a custom software model</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> sample.documentation.DocumentationComponent
<span class="hl-keyword">import</span> sample.documentation.TextSourceSet
<span class="hl-keyword">import</span> sample.markdown.MarkdownSourceSet

apply plugin:sample.documentation.DocumentationPlugin
apply plugin:sample.markdown.MarkdownPlugin

model {
    components {
        docs(DocumentationComponent) {
            sources {
                reference(TextSourceSet)
                userguide(MarkdownSourceSet) {
                    generateIndex = true
                    smartQuotes = true
                }
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/customModel/languageType/</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>The rest of this chapter is dedicated to explaining what is going on behind this build script.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:concepts" class="section-anchor" href="#sec:concepts"></a>Concepts</h2></div></div></div><p>A custom software model type has a public type, a base interface and internal views. Multiple such types then collaborate to define a custom software model.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:public_type_and_base_interfaces" class="section-anchor" href="#sec:public_type_and_base_interfaces"></a>Public type and base interfaces</h3></div></div></div><p>Extended types declare a <span class="emphasis"><em>public type</em></span> that extends a <span class="emphasis"><em>base interface</em></span>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Components extend the <a class="ulink" href="../dsl/org.gradle.platform.base.ComponentSpec.html" target="_top"><code class="classname">ComponentSpec</code></a> base interface</p></li><li class="listitem"><p>Binaries extend the <a class="ulink" href="../dsl/org.gradle.platform.base.BinarySpec.html" target="_top"><code class="classname">BinarySpec</code></a> base interface</p></li><li class="listitem"><p>Source sets extend the <a class="ulink" href="../dsl/org.gradle.language.base.LanguageSourceSet.html" target="_top"><code class="classname">LanguageSourceSet</code></a> base interface</p></li></ul></div><p>The <span class="emphasis"><em>public type</em></span> is exposed to build logic.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:internal_views" class="section-anchor" href="#sec:internal_views"></a>Internal views</h3></div></div></div><p>Adding internal views to your model type, you can make some data visible to build logic via a public type, while hiding the rest of the data behind the internal view types. This is covered in a <a class="link" href="#software-model-extend-internal-views">dedicated section</a> below.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:components_all_the_way_down" class="section-anchor" href="#sec:components_all_the_way_down"></a>Components all the way down</h3></div></div></div><p>Components are composed of other components. A source set is just a special kind of component representing sources. It might be that the sources are provided, or generated. Similarly, some components are composed of different binaries, which are built by tasks. All buildable components are built by tasks. In the software model, you will write rules to generate both binaries from components and tasks from binaries.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:components" class="section-anchor" href="#sec:components"></a>Components</h2></div></div></div><p>To declare a custom component type one must extend <a class="ulink" href="../dsl/org.gradle.platform.base.ComponentSpec.html" target="_top"><code class="classname">ComponentSpec</code></a>, or one of the following, depending on the use case:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/platform/base/SourceComponentSpec.html" target="_top"><code class="classname">SourceComponentSpec</code></a> represents a component which has sources</p></li><li class="listitem"><p><a class="ulink" href="../dsl/org.gradle.platform.base.VariantComponentSpec.html" target="_top"><code class="classname">VariantComponentSpec</code></a> represents a component which generates different binaries based on context (target platforms, build flavors, &hellip;). Such a component generally produces multiple binaries.</p></li><li class="listitem"><p><a class="ulink" href="../javadoc/org/gradle/platform/base/GeneralComponentSpec.html" target="_top"><code class="classname">GeneralComponentSpec</code></a> is a convenient base interface for components that are built from sources and variant-aware. This is the typical case for a lot of software components, and therefore it should be in most of the cases the base type to be extended.</p></li></ul></div><p>The core software model includes more types that can be used as base for extension. For example: <a class="ulink" href="../dsl/org.gradle.platform.base.LibrarySpec.html" target="_top"><code class="classname">LibrarySpec</code></a> and <a class="ulink" href="../javadoc/org/gradle/platform/base/ApplicationSpec.html" target="_top"><code class="classname">ApplicationSpec</code></a> can also be extended in this manner. Theses are no-op extensions of <code class="literal">GeneralComponentSpec</code> used to describe a software model better by distinguishing libraries and applications components. <a class="ulink" href="../javadoc/org/gradle/testing/base/TestSuiteSpec.html" target="_top"><code class="classname">TestSuiteSpec</code></a> should be used for all components that describe a test suite.</p><div class="example"><a name="component-declaration"></a><p class="title"><b>Example&nbsp;608.&nbsp;Declare a custom component</b></p><div class="example-contents"><p><code class="filename">DocumentationComponent.groovy</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> DocumentationComponent <span class="hl-keyword">extends</span> GeneralComponentSpec {}
</pre></div></div><br class="example-break"><p>Types extending <code class="literal">ComponentSpec</code> are registered via a rule annotated with <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a>:</p><div class="example"><a name="component-registration"></a><p class="title"><b>Example&nbsp;609.&nbsp;Register a custom component</b></p><div class="example-contents"><p><code class="filename">DocumentationPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> DocumentationPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@ComponentType</span>
    <span class="hl-keyword">void</span> registerComponent(TypeBuilder&lt;DocumentationComponent&gt; builder) {}
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:binaries" class="section-anchor" href="#sec:binaries"></a>Binaries</h2></div></div></div><p>To declare a custom binary type one must extend <a class="ulink" href="../dsl/org.gradle.platform.base.BinarySpec.html" target="_top"><code class="classname">BinarySpec</code></a>.</p><div class="example"><a name="binary-declaration"></a><p class="title"><b>Example&nbsp;610.&nbsp;Declare a custom binary</b></p><div class="example-contents"><p><code class="filename">DocumentationBinary.groovy</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> DocumentationBinary <span class="hl-keyword">extends</span> BinarySpec {
    File getOutputDir()
    <span class="hl-keyword">void</span> setOutputDir(File outputDir)
}
</pre></div></div><br class="example-break"><p>Types extending <code class="literal">BinarySpec</code> are registered via a rule annotated with <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a>:</p><div class="example"><a name="binary-registration"></a><p class="title"><b>Example&nbsp;611.&nbsp;Register a custom binary</b></p><div class="example-contents"><p><code class="filename">DocumentationPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> DocumentationPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@ComponentType</span>
    <span class="hl-keyword">void</span> registerBinary(TypeBuilder&lt;DocumentationBinary&gt; builder) {}
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:source_sets" class="section-anchor" href="#sec:source_sets"></a>Source sets</h2></div></div></div><p>To declare a custom source set type one must extend <a class="ulink" href="../dsl/org.gradle.language.base.LanguageSourceSet.html" target="_top"><code class="classname">LanguageSourceSet</code></a>.</p><div class="example"><a name="markdown-lang-declaration"></a><p class="title"><b>Example&nbsp;612.&nbsp;Declare a custom source set</b></p><div class="example-contents"><p><code class="filename">MarkdownSourceSet.groovy</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span>
<span class="hl-keyword">interface</span> MarkdownSourceSet <span class="hl-keyword">extends</span> LanguageSourceSet {
    <span class="hl-keyword">boolean</span> isGenerateIndex()
    <span class="hl-keyword">void</span> setGenerateIndex(<span class="hl-keyword">boolean</span> generateIndex)

    <span class="hl-keyword">boolean</span> isSmartQuotes()
    <span class="hl-keyword">void</span> setSmartQuotes(<span class="hl-keyword">boolean</span> smartQuotes)
}
</pre></div></div><br class="example-break"><p>Types extending <code class="literal">LanguageSourceSet</code> are registered via a rule annotated with <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentType.html" target="_top"><code class="classname">ComponentType</code></a>:</p><div class="example"><a name="markdown-lang-registration"></a><p class="title"><b>Example&nbsp;613.&nbsp;Register a custom source set</b></p><div class="example-contents"><p><code class="filename">MarkdownPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> MarkdownPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@ComponentType</span>
    <span class="hl-keyword">void</span> registerMarkdownLanguage(TypeBuilder&lt;MarkdownSourceSet&gt; builder) {}
}
</pre></div></div><br class="example-break"><p>Setting the <span class="emphasis"><em>language name</em></span> is mandatory.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:putting_it_all_together" class="section-anchor" href="#sec:putting_it_all_together"></a>Putting it all together</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:generating_binaries_from_components" class="section-anchor" href="#sec:generating_binaries_from_components"></a>Generating binaries from components</h3></div></div></div><p>Binaries generation from components is done via rules annotated with <a class="ulink" href="../javadoc/org/gradle/platform/base/ComponentBinaries.html" target="_top"><code class="classname">ComponentBinaries</code></a>. This rule generates a <code class="literal">DocumentationBinary</code> named <code class="literal">exploded</code> for each <code class="literal">DocumentationComponent</code> and sets its <code class="literal">outputDir</code> property:</p><div class="example"><a name="binaries-gen"></a><p class="title"><b>Example&nbsp;614.&nbsp;Generates documentation binaries</b></p><div class="example-contents"><p><code class="filename">DocumentationPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> DocumentationPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@ComponentBinaries</span>
    <span class="hl-keyword">void</span> generateDocBinaries(ModelMap&lt;DocumentationBinary&gt; binaries, VariantComponentSpec component, <span class="hl-annotation">@Path("buildDir")</span> File buildDir) {
        binaries.create(<span class="hl-string">"exploded"</span>) { binary -&gt;
            outputDir = <span class="hl-keyword">new</span> File(buildDir, <span class="hl-string">"${component.name}/${binary.name}"</span>)
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:generating_tasks_from_binaries" class="section-anchor" href="#sec:generating_tasks_from_binaries"></a>Generating tasks from binaries</h3></div></div></div><p>Tasks generation from binaries is done via rules annotated with <a class="ulink" href="../javadoc/org/gradle/platform/base/BinaryTasks.html" target="_top"><code class="classname">BinaryTasks</code></a>. This rule generates a <code class="literal">Copy</code> task for each <code class="literal">TextSourceSet</code> of each <code class="literal">DocumentationBinary</code>:</p><div class="example"><a name="text-tasks-gen"></a><p class="title"><b>Example&nbsp;615.&nbsp;Generates tasks for text source sets</b></p><div class="example-contents"><p><code class="filename">DocumentationPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> DocumentationPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@BinaryTasks</span>
    <span class="hl-keyword">void</span> generateTextTasks(ModelMap&lt;Task&gt; tasks, <span class="hl-keyword">final</span> DocumentationBinary binary) {
        binary.inputs.withType(TextSourceSet) { textSourceSet -&gt;
            def taskName = binary.tasks.taskName(<span class="hl-string">"compile"</span>, textSourceSet.name)
            def outputDir = <span class="hl-keyword">new</span> File(binary.outputDir, textSourceSet.name)
            tasks.create(taskName, Copy) {
                from textSourceSet.source
                destinationDir = outputDir
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>This rule generates a <code class="literal">MarkdownCompileTask</code> task for each <code class="literal">MarkdownSourceSet</code> of each <code class="literal">DocumentationBinary</code>:</p><div class="example"><a name="markdown-tasks-gen"></a><p class="title"><b>Example&nbsp;616.&nbsp;Register a custom source set</b></p><div class="example-contents"><p><code class="filename">MarkdownPlugin.groovy</code></p><pre class="programlisting"><span class="hl-keyword">class</span> MarkdownPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@BinaryTasks</span>
    <span class="hl-keyword">void</span> processMarkdownDocumentation(ModelMap&lt;Task&gt; tasks, <span class="hl-keyword">final</span> DocumentationBinary binary) {
        binary.inputs.withType(MarkdownSourceSet) { markdownSourceSet -&gt;
            def taskName = binary.tasks.taskName(<span class="hl-string">"compile"</span>, markdownSourceSet.name)
            def outputDir = <span class="hl-keyword">new</span> File(binary.outputDir, markdownSourceSet.name)
            tasks.create(taskName, MarkdownHtmlCompile) { compileTask -&gt;
                compileTask.source = markdownSourceSet.source
                compileTask.destinationDir = outputDir
                compileTask.smartQuotes = markdownSourceSet.smartQuotes
                compileTask.generateIndex = markdownSourceSet.generateIndex
            }
        }
    }
}
</pre></div></div><br class="example-break"><p>See the sample source for more on the <code class="literal">MarkdownCompileTask</code> task.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:using_your_custom_model" class="section-anchor" href="#sec:using_your_custom_model"></a>Using your custom model</h3></div></div></div><p>This build script demonstrate usage of the custom model defined in the sections above:</p><div class="example"><a name="sm-extensible-build-script-re"></a><p class="title"><b>Example&nbsp;617.&nbsp;an example of using a custom software model</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">import</span> sample.documentation.DocumentationComponent
<span class="hl-keyword">import</span> sample.documentation.TextSourceSet
<span class="hl-keyword">import</span> sample.markdown.MarkdownSourceSet

apply plugin:sample.documentation.DocumentationPlugin
apply plugin:sample.markdown.MarkdownPlugin

model {
    components {
        docs(DocumentationComponent) {
            sources {
                reference(TextSourceSet)
                userguide(MarkdownSourceSet) {
                    generateIndex = true
                    smartQuotes = true
                }
            }
        }
    }
}
</pre><div class="exampleLocation"><p><span class="emphasis"><em>Note:</em></span> The code for this example can be found at <code class="filename">samples/customModel/languageType/</code> in the &lsquo;-all&rsquo; distribution of Gradle.</p></div></div></div><br class="example-break"><p>And in the components reports for such a build script we can see our model types properly registered:</p><div class="example"><a name="softwareModelExtend-components"></a><p class="title"><b>Example&nbsp;618.&nbsp;components report</b></p><div class="example-contents"><p>Output of <strong class="userinput"><code>gradle -q components</code></strong></p><pre class="screen">&gt; gradle -q components

------------------------------------------------------------
Root project
------------------------------------------------------------

DocumentationComponent 'docs'
-----------------------------

Source sets
    Markdown source 'docs:userguide'
        srcDir: src/docs/userguide
    Text source 'docs:reference'
        srcDir: src/docs/reference

Binaries
    DocumentationBinary 'docs:exploded'
        build using task: :docsExploded

Note: currently not all plugins register their components, so some components may not be visible here.</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="software-model-extend-internal-views" class="section-anchor" href="#software-model-extend-internal-views"></a>About internal views</h2></div></div></div><p>Internal views can be added to an already registered type or to a new custom type. In other words, using internal views, you can attach extra properties to already registered components, binaries and source sets types like <code class="literal">JvmLibrarySpec</code>, <code class="literal">JarBinarySpec</code> or <code class="literal">JavaSourceSet</code> and to the custom types you write.</p><p>Let&rsquo;s start with a simple component public type and its internal view declarations:</p><div class="example"><a name="iv-type-declaration"></a><p class="title"><b>Example&nbsp;619.&nbsp;public type and internal view declaration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-annotation">@Managed</span> <span class="hl-keyword">interface</span> MyComponent <span class="hl-keyword">extends</span> ComponentSpec {
    String getPublicData()
    <span class="hl-keyword">void</span> setPublicData(String data)
}
<span class="hl-annotation">@Managed</span> <span class="hl-keyword">interface</span> MyComponentInternal <span class="hl-keyword">extends</span> MyComponent {
    String getInternalData()
    <span class="hl-keyword">void</span> setInternalData(String internal)
}
</pre></div></div><br class="example-break"><p>The type registration is as follows:</p><div class="example"><a name="iv-type-registration"></a><p class="title"><b>Example&nbsp;620.&nbsp;type registration</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> MyPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@ComponentType</span>
    <span class="hl-keyword">void</span> registerMyComponent(TypeBuilder&lt;MyComponent&gt; builder) {
        builder.internalView(MyComponentInternal)
    }
}
</pre></div></div><br class="example-break"><p>The <code class="literal">internalView(type)</code> method of the type builder can be called several times. This is how you would add several internal views to a type.</p><p>Now, let&rsquo;s mutate both public and internal data using some rule:</p><div class="example"><a name="iv-view-mutation"></a><p class="title"><b>Example&nbsp;621.&nbsp;public and internal data mutation</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting"><span class="hl-keyword">class</span> MyPlugin <span class="hl-keyword">extends</span> RuleSource {
    <span class="hl-annotation">@Mutate</span>
    <span class="hl-keyword">void</span> mutateMyComponents(ModelMap&lt;MyComponentInternal&gt; components) {
        components.all { component -&gt;
            component.publicData = <span class="hl-string">"Some PUBLIC data"</span>
            component.internalData = <span class="hl-string">"Some INTERNAL data"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>Our <code class="literal">internalData</code> property should not be exposed to build logic. Let&rsquo;s check this using the <code class="literal">model</code> task on the following build file:</p><div class="example"><a name="softwareModelExtend-iv-model"></a><p class="title"><b>Example&nbsp;622.&nbsp;example build script and model report output</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">apply plugin: MyPlugin
model {
    components {
        my(MyComponent)
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q model</code></strong></p><pre class="screen">&gt; gradle -q model

------------------------------------------------------------
Root project
------------------------------------------------------------

+ components
      | Type:       org.gradle.platform.base.ComponentSpecContainer
      | Creator:     ComponentBasePlugin.PluginRules#components(ComponentSpecContainer)
      | Rules:
          components { ... } @ build.gradle line 42, column 5
          MyPlugin#mutateMyComponents(ModelMap&lt;MyComponentInternal&gt;)
    + my
          | Type:       MyComponent
          | Creator:     components { ... } @ build.gradle line 42, column 5 &gt; create(my)
          | Rules:
              MyPlugin#mutateMyComponents(ModelMap&lt;MyComponentInternal&gt;) &gt; all()
        + publicData
              | Type:       java.lang.String
              | Value:      Some PUBLIC data
              | Creator:     components { ... } @ build.gradle line 42, column 5 &gt; create(my)
+ tasks
      | Type:       org.gradle.model.ModelMap&lt;org.gradle.api.Task&gt;
      | Creator:     Project.&lt;init&gt;.tasks()
    + assemble
          | Type:       org.gradle.api.DefaultTask
          | Value:      task ':assemble'
          | Creator:     tasks.addPlaceholderAction(assemble)
          | Rules:
              copyToTaskContainer
    + build
          | Type:       org.gradle.api.DefaultTask
          | Value:      task ':build'
          | Creator:     tasks.addPlaceholderAction(build)
          | Rules:
              copyToTaskContainer
    + buildEnvironment
          | Type:       org.gradle.api.tasks.diagnostics.BuildEnvironmentReportTask
          | Value:      task ':buildEnvironment'
          | Creator:     tasks.addPlaceholderAction(buildEnvironment)
          | Rules:
              copyToTaskContainer
    + check
          | Type:       org.gradle.api.DefaultTask
          | Value:      task ':check'
          | Creator:     tasks.addPlaceholderAction(check)
          | Rules:
              copyToTaskContainer
    + clean
          | Type:       org.gradle.api.tasks.Delete
          | Value:      task ':clean'
          | Creator:     tasks.addPlaceholderAction(clean)
          | Rules:
              copyToTaskContainer
    + components
          | Type:       org.gradle.api.reporting.components.ComponentReport
          | Value:      task ':components'
          | Creator:     tasks.addPlaceholderAction(components)
          | Rules:
              copyToTaskContainer
    + dependencies
          | Type:       org.gradle.api.tasks.diagnostics.DependencyReportTask
          | Value:      task ':dependencies'
          | Creator:     tasks.addPlaceholderAction(dependencies)
          | Rules:
              copyToTaskContainer
    + dependencyInsight
          | Type:       org.gradle.api.tasks.diagnostics.DependencyInsightReportTask
          | Value:      task ':dependencyInsight'
          | Creator:     tasks.addPlaceholderAction(dependencyInsight)
          | Rules:
              HelpTasksPlugin.Rules#addDefaultDependenciesReportConfiguration(DependencyInsightReportTask, ServiceRegistry)
              copyToTaskContainer
    + dependentComponents
          | Type:       org.gradle.api.reporting.dependents.DependentComponentsReport
          | Value:      task ':dependentComponents'
          | Creator:     tasks.addPlaceholderAction(dependentComponents)
          | Rules:
              copyToTaskContainer
    + help
          | Type:       org.gradle.configuration.Help
          | Value:      task ':help'
          | Creator:     tasks.addPlaceholderAction(help)
          | Rules:
              copyToTaskContainer
    + init
          | Type:       org.gradle.buildinit.tasks.InitBuild
          | Value:      task ':init'
          | Creator:     tasks.addPlaceholderAction(init)
          | Rules:
              copyToTaskContainer
    + model
          | Type:       org.gradle.api.reporting.model.ModelReport
          | Value:      task ':model'
          | Creator:     tasks.addPlaceholderAction(model)
          | Rules:
              copyToTaskContainer
    + projects
          | Type:       org.gradle.api.tasks.diagnostics.ProjectReportTask
          | Value:      task ':projects'
          | Creator:     tasks.addPlaceholderAction(projects)
          | Rules:
              copyToTaskContainer
    + properties
          | Type:       org.gradle.api.tasks.diagnostics.PropertyReportTask
          | Value:      task ':properties'
          | Creator:     tasks.addPlaceholderAction(properties)
          | Rules:
              copyToTaskContainer
    + tasks
          | Type:       org.gradle.api.tasks.diagnostics.TaskReportTask
          | Value:      task ':tasks'
          | Creator:     tasks.addPlaceholderAction(tasks)
          | Rules:
              copyToTaskContainer
    + wrapper
          | Type:       org.gradle.api.tasks.wrapper.Wrapper
          | Value:      task ':wrapper'
          | Creator:     tasks.addPlaceholderAction(wrapper)
          | Rules:
              copyToTaskContainer
</pre></div></div><br class="example-break"><p>We can see in this report that <code class="literal">publicData</code> is present and that <code class="literal">internalData</code> is not.</p></div></div></div><div class="part" title="Glossary"><div class="titlepage"><div><div><h1 class="title"><a name="N1AD43"></a>Glossary</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="dependency_types"></a>Dependency Types</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:module_dependencies" class="section-anchor" href="#sub:module_dependencies"></a>External module dependencies</h2></div></div></div><p>External module dependencies are the most common dependencies. They refer to a module in an external repository.</p><div class="example"><a name="moduleDependencies"></a><p class="title"><b>Example&nbsp;623.&nbsp;Module dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime group: <span class="hl-string">'org.springframework'</span>, name: <span class="hl-string">'spring-core'</span>, version: <span class="hl-string">'2.5'</span>
    runtime <span class="hl-string">'org.springframework:spring-core:2.5'</span>,
            <span class="hl-string">'org.springframework:spring-aop:2.5'</span>
    runtime(
        [group: <span class="hl-string">'org.springframework'</span>, name: <span class="hl-string">'spring-core'</span>, version: <span class="hl-string">'2.5'</span>],
        [group: <span class="hl-string">'org.springframework'</span>, name: <span class="hl-string">'spring-aop'</span>, version: <span class="hl-string">'2.5'</span>]
    )
    runtime(<span class="hl-string">'org.hibernate:hibernate:3.0.5'</span>) {
        transitive = true
    }
    runtime group: <span class="hl-string">'org.hibernate'</span>, name: <span class="hl-string">'hibernate'</span>, version: <span class="hl-string">'3.0.5'</span>, transitive: true
    runtime(group: <span class="hl-string">'org.hibernate'</span>, name: <span class="hl-string">'hibernate'</span>, version: <span class="hl-string">'3.0.5'</span>) {
        transitive = true
    }
}
</pre></div></div><br class="example-break"><p>See the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html" target="_top"><code class="classname">DependencyHandler</code></a> class in the API documentation for more examples and a complete reference.</p><p>Gradle provides different notations for module dependencies. There is a string notation and a map notation. A module dependency has an API which allows further configuration. Have a look at <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ExternalModuleDependency.html" target="_top"><code class="classname">ExternalModuleDependency</code></a> to learn all about the API. This API provides properties and configuration methods. Via the string notation you can define a subset of the properties. With the map notation you can define all properties. To have access to the complete API, either with the map or with the string notation, you can assign a single dependency to a configuration together with a closure.</p><div class="note"><p>If you declare a module dependency, Gradle looks for a module descriptor file (<code class="literal">pom.xml</code> or <code class="literal">ivy.xml</code>) in the repositories. If such a module descriptor file exists, it is parsed and the artifacts of this module (e.g. <code class="literal">hibernate-3.0.5.jar</code>) as well as its dependencies (e.g. cglib) are downloaded. If no such module descriptor file exists, Gradle looks for a file called <code class="literal">hibernate-3.0.5.jar</code> to retrieve. In Maven, a module can have one and only one artifact. In Gradle and Ivy, a module can have multiple artifacts. Each artifact can have a different set of dependencies.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:file_dependencies" class="section-anchor" href="#sub:file_dependencies"></a>File dependencies</h2></div></div></div><p>File dependencies allow you to directly add a set of files to a configuration, without first adding them to a repository. This can be useful if you cannot, or do not want to, place certain files in a repository. Or if you do not want to use any repositories at all for storing your dependencies.</p><p>To add some files as a dependency for a configuration, you simply pass a <a class="link" href="#sec:file_collections">file collection</a> as a dependency:</p><div class="example"><a name="file-dependencies"></a><p class="title"><b>Example&nbsp;624.&nbsp;File dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    runtime files(<span class="hl-string">'libs/a.jar'</span>, <span class="hl-string">'libs/b.jar'</span>)
    runtime fileTree(dir: <span class="hl-string">'libs'</span>, include: <span class="hl-string">'*.jar'</span>)
}
</pre></div></div><br class="example-break"><p>File dependencies are not included in the published dependency descriptor for your project. However, file dependencies are included in transitive project dependencies within the same build. This means they cannot be used outside the current build, but they can be used with the same build.</p><p>You can declare which tasks produce the files for a file dependency. You might do this when, for example, the files are generated by the build.</p><div class="example"><a name="generatedFileDependencies"></a><p class="title"><b>Example&nbsp;625.&nbsp;Generated file dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile files(<span class="hl-string">"$buildDir/classes"</span>) {
        builtBy <span class="hl-string">'compile'</span>
    }
}

task compile {
    doLast {
        println <span class="hl-string">'compiling classes'</span>
    }
}

task list(dependsOn: configurations.compile) {
    doLast {
        println <span class="hl-string">"classpath = ${configurations.compile.collect { File file -&gt; file.name }}"</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q list</code></strong></p><pre class="screen">&gt; gradle -q list
compiling classes
classpath = [classes]
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:project_dependencies" class="section-anchor" href="#sub:project_dependencies"></a>Project dependencies</h2></div></div></div><p>Gradle distinguishes between external dependencies and dependencies on projects which are part of the same multi-project build. For the latter you can declare <span class="emphasis"><em>Project Dependencies</em></span>.</p><div class="example"><a name="project-dependencies"></a><p class="title"><b>Example&nbsp;626.&nbsp;Project dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile project(<span class="hl-string">':shared'</span>)
}
</pre></div></div><br class="example-break"><p>For more information see the API documentation for <a class="ulink" href="../javadoc/org/gradle/api/artifacts/ProjectDependency.html" target="_top"><code class="classname">ProjectDependency</code></a>.</p><p>Multi-project builds are discussed in <a class="xref" href="#multi_project_builds"><i>Authoring Multi-Project Builds</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:gradle_distribution_dependencies" class="section-anchor" href="#sub:gradle_distribution_dependencies"></a>Gradle distribution-specific dependencies</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:api_dependencies" class="section-anchor" href="#sub:api_dependencies"></a>Gradle API dependency</h3></div></div></div><p>You can declare a dependency on the API of the current version of Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleApi()" target="_top"><code class="classname">DependencyHandler.gradleApi()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins.</p><div class="example"><a name="gradle-api-dependencies"></a><p class="title"><b>Example&nbsp;627.&nbsp;Gradle API dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile gradleApi()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:testkit_dependencies" class="section-anchor" href="#sub:testkit_dependencies"></a>Gradle TestKit dependency</h3></div></div></div><p>You can declare a dependency on the TestKit API of the current version of Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:gradleTestKit()" target="_top"><code class="classname">DependencyHandler.gradleTestKit()</code></a> method. This is useful for writing and executing functional tests for Gradle plugins and build scripts.</p><div class="example"><a name="gradle-testkit-dependencies"></a><p class="title"><b>Example&nbsp;628.&nbsp;Gradle TestKit dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    testCompile gradleTestKit()
}
</pre></div></div><br class="example-break"><p><a class="xref" href="#test_kit"><i>Testing Build Logic with TestKit</i></a> explains the use of TestKit by example.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:groovy_dependencies" class="section-anchor" href="#sub:groovy_dependencies"></a>Local Groovy dependency</h3></div></div></div><p>You can declare a dependency on the Groovy that is distributed with Gradle by using the <a class="ulink" href="../dsl/org.gradle.api.artifacts.dsl.DependencyHandler.html#org.gradle.api.artifacts.dsl.DependencyHandler:localGroovy()" target="_top"><code class="classname">DependencyHandler.localGroovy()</code></a> method. This is useful when you are developing custom Gradle tasks or plugins in Groovy.</p><div class="example"><a name="local-groovy-dependencies"></a><p class="title"><b>Example&nbsp;629.&nbsp;Gradle's Groovy dependencies</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">dependencies {
    compile localGroovy()
}
</pre></div></div><br class="example-break"></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1><a name="repository_types"></a>Repository Types</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:flat_dir_resolver" class="section-anchor" href="#sec:flat_dir_resolver"></a>Flat directory repository</h2></div></div></div><p>Some projects might prefer to store dependencies on a shared drive or as part of the project source code instead of a binary repository product. If you want to use a (flat) filesystem directory as a repository, simply type:</p><div class="example"><a name="flatDirMulti"></a><p class="title"><b>Example&nbsp;630.&nbsp;Flat repository resolver</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    flatDir {
        dirs <span class="hl-string">'lib'</span>
    }
    flatDir {
        dirs <span class="hl-string">'lib1'</span>, <span class="hl-string">'lib2'</span>
    }
}
</pre></div></div><br class="example-break"><p>This adds repositories which look into one or more directories for finding dependencies. Note that this type of repository does not support any meta-data formats like Ivy XML or Maven POM files. Instead, Gradle will dynamically generate a module descriptor (without any dependency information) based on the presence of artifacts. However, as Gradle prefers to use modules whose descriptor has been created from real meta-data rather than being generated, flat directory repositories cannot be used to override artifacts with real meta-data from other repositories. For example, if Gradle finds only <code class="literal">jmxri-1.2.1.jar</code> in a flat directory repository, but <code class="literal">jmxri-1.2.1.pom</code> in another repository that supports meta-data, it will use the second repository to provide the module.</p><p>For the use case of overriding remote artifacts with local ones consider using an Ivy or Maven repository instead whose URL points to a local directory. If you only work with flat directory repositories you don&rsquo;t need to set all attributes of a dependency.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:maven_central" class="section-anchor" href="#sub:maven_central"></a>Maven Central repository</h2></div></div></div><p>Maven Central is a popular repository hosting open source libraries for consumption by Java projects.</p><p>To declare the <a class="ulink" href="https://repo.maven.apache.org/maven2/" target="_top">central Maven repository</a> for your build add this to your script:</p><div class="example"><a name="mavenCentral"></a><p class="title"><b>Example&nbsp;631.&nbsp;Adding central Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenCentral()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:maven_jcenter" class="section-anchor" href="#sub:maven_jcenter"></a>JCenter Maven repository</h2></div></div></div><p><a class="ulink" href="http://bintray.com" target="_top">Bintray</a>'s JCenter is an up-to-date collection of all popular Maven OSS artifacts, including artifacts published directly to Bintray.</p><p>To declare the <a class="ulink" href="https://jcenter.bintray.com" target="_top">JCenter Maven repository</a> add this to your build script:</p><div class="example"><a name="mavenJcenter"></a><p class="title"><b>Example&nbsp;632.&nbsp;Adding Bintray's JCenter Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    jcenter()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:maven_google" class="section-anchor" href="#sub:maven_google"></a>Google Maven repository</h2></div></div></div><p>The Google repository hosts Android-specific artifacts including the Android SDK. For usage examples, see the <a class="ulink" href="https://developer.android.com/studio/build/dependencies.html#google-maven" target="_top">relevant documentation</a>.</p><p>To declare the <a class="ulink" href="https://dl.google.com/dl/android/maven2/" target="_top">Google Maven repository</a> add this to your build script:</p><div class="example"><a name="mavenGoogleRepo"></a><p class="title"><b>Example&nbsp;633.&nbsp;Adding Google Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    google()
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:maven_local" class="section-anchor" href="#sub:maven_local"></a>Local Maven repository</h2></div></div></div><p>Gradle can consume dependencies available in the <a class="ulink" href="https://maven.apache.org/guides/introduction/introduction-to-repositories.html" target="_top">local Maven repository</a>. Declaring this repository is beneficial for teams that publish to the local Maven repository with one project and consume the artifacts by Gradle in another project.</p><div class="note"><p>Gradle stores resolved dependencies in <a class="link" href="#sec:dependency_cache">its own cache</a>. A build does not need to declare the local Maven repository even if you resolve dependencies from a Maven-based, remote repository.</p></div><p>To declare the local Maven cache as a repository add this to your build script:</p><div class="example"><a name="mavenLocalRepo"></a><p class="title"><b>Example&nbsp;634.&nbsp;Adding the local Maven cache as a repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    mavenLocal()
}
</pre></div></div><br class="example-break"><p>Gradle uses the same logic as Maven to identify the location of your local Maven cache. If a local repository location is defined in a <code class="literal">settings.xml</code>, this location will be used. The <code class="literal">settings.xml</code> in <code class="literal"><span class="emphasis"><em>USER_HOME</em></span>/.m2</code> takes precedence over the <code class="literal">settings.xml</code> in <code class="literal"><span class="emphasis"><em>M2_HOME</em></span>/conf</code>. If no <code class="literal">settings.xml</code> is available, Gradle uses the default location <code class="literal"><span class="emphasis"><em>USER_HOME</em></span>/.m2/repository</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:maven_repo" class="section-anchor" href="#sub:maven_repo"></a>Custom Maven repositories</h2></div></div></div><p>Many organizations host dependencies in an in-house Maven repository only accessible within the company&rsquo;s network. Gradle can declare Maven repositories by URL.</p><p>For adding a custom Maven repository you can do:</p><div class="example"><a name="mavenLikeRepo"></a><p class="title"><b>Example&nbsp;635.&nbsp;Adding custom Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Sometimes a repository will have the POMs published to one location, and the JARs and other artifacts published at another location. To define such a repository, you can do:</p><div class="example"><a name="mavenLikeRepoWithJarRepo"></a><p class="title"><b>Example&nbsp;636.&nbsp;Adding additional Maven repositories for JAR files</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        <span class="hl-comment">// Look for POMs and artifacts, such as JARs, here</span>
        url <span class="hl-string">"http://repo2.mycompany.com/maven2"</span>
        <span class="hl-comment">// Look for artifacts here if not found at the above location</span>
        artifactUrls <span class="hl-string">"http://repo.mycompany.com/jars"</span>
        artifactUrls <span class="hl-string">"http://repo.mycompany.com/jars2"</span>
    }
}
</pre></div></div><br class="example-break"><p>Gradle will look at the first URL for the POM and the JAR. If the JAR can&rsquo;t be found there, the artifact URLs are used to look for JARs.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:accessing_password_protected_maven_repositories" class="section-anchor" href="#sec:accessing_password_protected_maven_repositories"></a>Accessing password-protected Maven repositories</h3></div></div></div><p>You can specify credentials for Maven repositories secured by basic authentication.</p><div class="example"><a name="mavenPasswordProtectedRepo"></a><p class="title"><b>Example&nbsp;637.&nbsp;Accessing password-protected Maven repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"http://repo.mycompany.com/maven2"</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:ivy_repositories" class="section-anchor" href="#sec:ivy_repositories"></a>Custom Ivy repositories</h2></div></div></div><p>Organizations might decide to host dependencies in an in-house Ivy repository. Gradle can declare Ivy repositories by URL.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_an_ivy_repository_with_a_standard_layout" class="section-anchor" href="#sec:defining_an_ivy_repository_with_a_standard_layout"></a>Defining an Ivy repository with a standard layout</h3></div></div></div><p>To declare an Ivy repository using the standard layout no additional customization is needed. You just declare the URL.</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;638.&nbsp;Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_a_named_layout_for_an_ivy_repository" class="section-anchor" href="#sec:defining_a_named_layout_for_an_ivy_repository"></a>Defining a named layout for an Ivy repository</h3></div></div></div><p>You can specify that your repository conforms to the Ivy or Maven default layout by using a named layout.</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;639.&nbsp;Ivy repository with named layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span class="hl-string">"maven"</span>
    }
}
</pre></div></div><br class="example-break"><p>Valid named layout values are <code class="literal">'gradle'</code> (the default), <code class="literal">'maven'</code>, <code class="literal">'ivy'</code> and <code class="literal">'pattern'</code>. See <a class="ulink" href="../dsl/org.gradle.api.artifacts.repositories.IvyArtifactRepository.html#org.gradle.api.artifacts.repositories.IvyArtifactRepository:layout(java.lang.String, groovy.lang.Closure)" target="_top"><code class="classname">IvyArtifactRepository.layout(java.lang.String, groovy.lang.Closure)</code></a> in the API documentation for details of these named layouts.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:defining_custom_pattern_layout_for_an_ivy_repository" class="section-anchor" href="#sec:defining_custom_pattern_layout_for_an_ivy_repository"></a>Defining custom pattern layout for an Ivy repository</h3></div></div></div><p>To define an Ivy repository with a non-standard layout, you can define a <code class="literal">'pattern'</code> layout for the repository:</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;640.&nbsp;Ivy repository with pattern layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span class="hl-string">"pattern"</span>, {
            artifact <span class="hl-string">"[module]/[revision]/[type]/[artifact].[ext]"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>To define an Ivy repository which fetches Ivy files and artifacts from different locations, you can define separate patterns to use to locate the Ivy files and artifacts:</p><p>Each <code class="literal">artifact</code> or <code class="literal">ivy</code> specified for a repository adds an <span class="emphasis"><em>additional</em></span> pattern to use. The patterns are used in the order that they are defined.</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;641.&nbsp;Ivy repository with multiple custom patterns</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span class="hl-string">"pattern"</span>, {
            artifact <span class="hl-string">"3rd-party-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            artifact <span class="hl-string">"company-artifacts/[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            ivy <span class="hl-string">"ivy-files/[organisation]/[module]/[revision]/ivy.xml"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>Optionally, a repository with pattern layout can have its <code class="literal">'organisation'</code> part laid out in Maven style, with forward slashes replacing dots as separators. For example, the organisation <code class="literal">my.company</code> would then be represented as <code class="literal">my/company</code>.</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;642.&nbsp;Ivy repository with Maven compatible layout</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
        layout <span class="hl-string">"pattern"</span>, {
            artifact <span class="hl-string">"[organisation]/[module]/[revision]/[artifact]-[revision].[ext]"</span>
            m2compatible = true
        }
    }
}
</pre></div></div><br class="example-break"></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:accessing_password_protected_ivy_repositories" class="section-anchor" href="#sec:accessing_password_protected_ivy_repositories"></a>Accessing password-protected Ivy repositories</h3></div></div></div><p>You can specify credentials for Ivy repositories secured by basic authentication.</p><div class="example"><a name="ivyRepository"></a><p class="title"><b>Example&nbsp;643.&nbsp;Ivy repository with authentication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    ivy {
        url <span class="hl-string">"http://repo.mycompany.com"</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
    }
}
</pre></div></div><br class="example-break"></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sub:supported_transport_protocols" class="section-anchor" href="#sub:supported_transport_protocols"></a>Supported repository transport protocols</h2></div></div></div><p>Maven and Ivy repositories support the use of various transport protocols. At the moment the following protocols are supported:</p><div class="table"><p class="title"><b>Table&nbsp;111.&nbsp;Repository transport protocols</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1AF68"><thead><tr>
<td>Type</td>
<td>Credential types</td>
</tr></thead><tbody><tr>
<td><p><code class="literal">file</code></p></td>
<td><p>none</p></td>
</tr><tr>
<td><p><code class="literal">http</code></p></td>
<td><p>username/password</p></td>
</tr><tr>
<td><p><code class="literal">https</code></p></td>
<td><p>username/password</p></td>
</tr><tr>
<td><p><code class="literal">sftp</code></p></td>
<td><p>username/password</p></td>
</tr><tr>
<td><p><code class="literal">s3</code></p></td>
<td><p>access key/secret key/session token or Environment variables</p></td>
</tr><tr>
<td><p><code class="literal">gcs</code></p></td>
<td><p><a class="ulink" href="https://developers.google.com/identity/protocols/application-default-credentials" target="_top">default application credentials</a> sourced from well known files, Environment variables etc.</p></td>
</tr></tbody></table></div></div><div class="note"><p>Username and password should never be checked in plain text into version control as part of your build file. You can store the credentials in a local <code class="literal">gradle.properties</code> file and use one of the open source Gradle plugins for encrypting and consuming credentials e.g. the <a class="ulink" href="https://plugins.gradle.org/plugin/nu.studer.credentials" target="_top">credentials plugin</a>.</p></div><p>The transport protocol is part of the URL definition for a repository. The following build script demonstrates how to create a HTTP-based Maven and Ivy repository:</p><div class="example"><a name="mavenIvyRepositoriesNoAuth"></a><p class="title"><b>Example&nbsp;644.&nbsp;Declaring a Maven and Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"http://repo.mycompany.com/maven2"</span>
    }

    ivy {
        url <span class="hl-string">"http://repo.mycompany.com/repo"</span>
    }
}
</pre></div></div><br class="example-break"><p>The following example shows how to declare SFTP repositories:</p><div class="example"><a name="mavenIvyRepositoriesAuth"></a><p class="title"><b>Example&nbsp;645.&nbsp;Using the SFTP protocol for a repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"sftp://repo.mycompany.com:22/maven2"</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
    }

    ivy {
        url <span class="hl-string">"sftp://repo.mycompany.com:22/repo"</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>When using an AWS S3 backed repository you need to authenticate using <a class="ulink" href="../dsl/org.gradle.api.credentials.AwsCredentials.html" target="_top"><code class="classname">AwsCredentials</code></a>, providing access-key and a private-key. The following example shows how to declare a S3 backed repository and providing AWS credentials:</p><div class="example"><a name="mavenIvyS3RepositoriesAuth"></a><p class="title"><b>Example&nbsp;646.&nbsp;Declaring a S3 backed Maven and Ivy repository</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"s3://myCompanyBucket/maven2"</span>
        credentials(AwsCredentials) {
            accessKey <span class="hl-string">"someKey"</span>
            secretKey <span class="hl-string">"someSecret"</span>
            <span class="hl-comment">// optional</span>
            sessionToken <span class="hl-string">"someSTSToken"</span>
        }
    }

    ivy {
        url <span class="hl-string">"s3://myCompanyBucket/ivyrepo"</span>
        credentials(AwsCredentials) {
            accessKey <span class="hl-string">"someKey"</span>
            secretKey <span class="hl-string">"someSecret"</span>
            <span class="hl-comment">// optional</span>
            sessionToken <span class="hl-string">"someSTSToken"</span>
        }
    }
}
</pre></div></div><br class="example-break"><p>You can also delegate all credentials to the AWS sdk by using the AwsImAuthentication. The following example shows how:</p><div class="example"><a name="mavenIvyS3RepositoriesAuthWithIam"></a><p class="title"><b>Example&nbsp;647.&nbsp;Declaring a S3 backed Maven and Ivy repository using IAM</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"s3://myCompanyBucket/maven2"</span>
        authentication {
           awsIm(AwsImAuthentication) <span class="hl-comment">// load from EC2 role or env var</span>
        }
    }

    ivy {
        url <span class="hl-string">"s3://myCompanyBucket/ivyrepo"</span>
        authentication {
           awsIm(AwsImAuthentication)
        }
    }
}
</pre></div></div><br class="example-break"><p>When using a Google Cloud Storage backed repository default application credentials will be used with no further configuration required:</p><div class="example"><a name="mavenIvyGCSRepositoriesAuthDefault"></a><p class="title"><b>Example&nbsp;648.&nbsp;Declaring a Google Cloud Storage backed Maven and Ivy repository using default application credentials</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">"gcs://myCompanyBucket/maven2"</span>
    }

    ivy {
        url <span class="hl-string">"gcs://myCompanyBucket/ivyrepo"</span>
    }
}
</pre></div></div><br class="example-break"><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:s3_configuration_properties" class="section-anchor" href="#sub:s3_configuration_properties"></a>S3 configuration properties</h3></div></div></div><p>The following system properties can be used to configure the interactions with s3 repositories:</p><div class="table"><p class="title"><b>Table&nbsp;112.&nbsp;S3 configuration properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1B00E"><thead><tr>
<td>Property</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>org.gradle.s3.endpoint</p></td>
<td><p>Used to override the AWS S3 endpoint when using a non AWS, S3 API compatible, storage service.</p></td>
</tr><tr>
<td><p>org.gradle.s3.maxErrorRetry</p></td>
<td><p>Specifies the maximum number of times to retry a request in the event that the S3 server responds with a HTTP 5xx status code. When not specified a default value of 3 is used.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:s3_url_formats" class="section-anchor" href="#sub:s3_url_formats"></a>S3 URL formats</h3></div></div></div><p>S3 URL&rsquo;s are 'virtual-hosted-style' and must be in the following format <code class="literal">s3://&lt;bucketName&gt;[.&lt;regionSpecificEndpoint&gt;]/&lt;s3Key&gt;</code></p><p>e.g. <code class="literal">s3://myBucket.s3.eu-central-1.amazonaws.com/maven/release</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">myBucket</code> is the AWS S3 bucket name.</p></li><li class="listitem"><p><code class="literal">s3.eu-central-1.amazonaws.com</code> is the <span class="emphasis"><em>optional</em></span> <a class="ulink" href="http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region" target="_top">region specific endpoint</a>.</p></li><li class="listitem"><p><code class="literal">/maven/release</code> is the AWS S3 key (unique identifier for an object within a bucket)</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:s3_proxy_settings" class="section-anchor" href="#sub:s3_proxy_settings"></a>S3 proxy settings</h3></div></div></div><p>A proxy for S3 can be configured using the following system properties:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">https.proxyHost</code></p></li><li class="listitem"><p><code class="literal">https.proxyPort</code></p></li><li class="listitem"><p><code class="literal">https.proxyUser</code></p></li><li class="listitem"><p><code class="literal">https.proxyPassword</code></p></li><li class="listitem"><p><code class="literal">http.nonProxyHosts</code></p></li></ul></div><p>If the 'org.gradle.s3.endpoint' property has been specified with a http (not https) URI the following system proxy settings can be used:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">http.proxyHost</code></p></li><li class="listitem"><p><code class="literal">http.proxyPort</code></p></li><li class="listitem"><p><code class="literal">http.proxyUser</code></p></li><li class="listitem"><p><code class="literal">http.proxyPassword</code></p></li><li class="listitem"><p><code class="literal">http.nonProxyHosts</code></p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="s3_v4_signatures" class="section-anchor" href="#s3_v4_signatures"></a>AWS S3 V4 Signatures (AWS4-HMAC-SHA256)</h3></div></div></div><p>Some of the AWS S3 regions (eu-central-1 - Frankfurt) require that all HTTP requests are signed in accordance with AWS&rsquo;s <a class="ulink" href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html" target="_top">signature version 4</a>. It is recommended to specify S3 URL&rsquo;s containing the region specific endpoint when using buckets that require V4 signatures. e.g. <code class="literal">s3://somebucket.s3.eu-central-1.amazonaws.com/maven/release</code></p><div class="note"><p>When a region-specific endpoint is not specified for buckets requiring V4 Signatures, Gradle will use the default AWS region (us-east-1) and the
following warning will appear on the console:</p><p>Attempting to re-send the request to &hellip;. with AWS V4 authentication. To avoid this warning in the future, use region-specific endpoint to access buckets located in regions that require V4 signing.</p><p>Failing to specify the region-specific endpoint for buckets requiring V4 signatures means:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">3 round-trips to AWS, as opposed to one, for every file upload and download.</code></p></li><li class="listitem"><p><code class="literal">Depending on location - increased network latencies and slower builds.</code></p></li><li class="listitem"><p><code class="literal">Increased likelihood of transmission failures.</code></p></li></ul></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:gcs_configuration_properties" class="section-anchor" href="#sub:gcs_configuration_properties"></a>Google Cloud Storage configuration properties</h3></div></div></div><p>The following system properties can be used to configure the interactions with <a class="ulink" href="https://cloud.google.com/storage/" target="_top">Google Cloud Storage</a> repositories:</p><div class="table"><p class="title"><b>Table&nbsp;113.&nbsp;Google Cloud Storage configuration properties</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1B0B1"><thead><tr>
<td>Property</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p>org.gradle.gcs.endpoint</p></td>
<td><p>Used to override the Google Cloud Storage endpoint when using a non-Google Cloud Platform, Google Cloud Storage API compatible, storage service.</p></td>
</tr><tr>
<td><p>org.gradle.gcs.servicePath</p></td>
<td><p>Used to override the Google Cloud Storage root service path which the Google Cloud Storage client builds requests from, defaults to <code class="literal">/</code>.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:gcs_url_formats" class="section-anchor" href="#sub:gcs_url_formats"></a>Google Cloud Storage URL formats</h3></div></div></div><p>Google Cloud Storage URL&rsquo;s are 'virtual-hosted-style' and must be in the following format <code class="literal">gcs://&lt;bucketName&gt;/&lt;objectKey&gt;</code></p><p>e.g. <code class="literal">gcs://myBucket/maven/release</code></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">myBucket</code> is the Google Cloud Storage bucket name.</p></li><li class="listitem"><p><code class="literal">/maven/release</code> is the Google Cloud Storage key (unique identifier for an object within a bucket)</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:authentication_schemes" class="section-anchor" href="#sub:authentication_schemes"></a>Configuring HTTP authentication schemes</h3></div></div></div><p>When configuring a repository using HTTP or HTTPS transport protocols, multiple authentication schemes are available. By default, Gradle will attempt to use all schemes that are supported by the Apache HttpClient library, <a class="ulink" href="http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html#d5e625" target="_top">documented here</a>. In some cases, it may be preferable to explicitly specify which authentication schemes should be used when exchanging credentials with a remote server. When explicitly declared, only those schemes are used when authenticating to a remote repository. The following example show how to configure a repository to use only digest authentication:</p><div class="example"><a name="digestAuthentication"></a><p class="title"><b>Example&nbsp;649.&nbsp;Configure repository to use only digest authentication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">'https://repo.mycompany.com/maven2'</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
        authentication {
            digest(DigestAuthentication)
        }
    }
}
</pre></div></div><br class="example-break"><p>Currently supported authentication schemes are:</p><div class="table"><p class="title"><b>Table&nbsp;114.&nbsp;Authentication schemes</b></p><div class="table-contents"><table colsep="1" frame="all" rowsep="1" id="N1B105"><thead><tr>
<td>Type</td>
<td>Description</td>
</tr></thead><tbody><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.authentication.http.BasicAuthentication.html" target="_top"><code class="classname">BasicAuthentication</code></a></p></td>
<td><p>Basic access authentication over HTTP. When using this scheme, credentials are sent preemptively.</p></td>
</tr><tr>
<td><p><a class="ulink" href="../dsl/org.gradle.authentication.http.DigestAuthentication.html" target="_top"><code class="classname">DigestAuthentication</code></a></p></td>
<td><p>Digest access authentication over HTTP.</p></td>
</tr></tbody></table></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sub:preemptive_authentication" class="section-anchor" href="#sub:preemptive_authentication"></a>Using preemptive authentication</h3></div></div></div><p>Gradle&rsquo;s default behavior is to only submit credentials when a server responds with an authentication challenge in the form of a HTTP 401 response. In some cases, the server will respond with a different code (ex. for repositories hosted on GitHub a 404 is returned) causing dependency resolution to fail. To get around this behavior, credentials may be sent to the server preemptively. To enable preemptive authentication simply configure your repository to explicitly use the <a class="ulink" href="../dsl/org.gradle.authentication.http.BasicAuthentication.html" target="_top"><code class="classname">BasicAuthentication</code></a> scheme:</p><div class="example"><a name="preemptiveAuthentication"></a><p class="title"><b>Example&nbsp;650.&nbsp;Configure repository to use preemptive authentication</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">repositories {
    maven {
        url <span class="hl-string">'https://repo.mycompany.com/maven2'</span>
        credentials {
            username <span class="hl-string">"user"</span>
            password <span class="hl-string">"password"</span>
        }
        authentication {
            basic(BasicAuthentication)
        }
    }
}
</pre></div></div><br class="example-break"></div></div></div></div><div class="part" title="Appendix"><div class="titlepage"><div><div><h1 class="title"><a name="N1B144"></a>Appendix</h1></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1><a name="sample_list"></a>Appendix&nbsp;A.&nbsp;Gradle Samples</h1></div></div></div><p>Listed below are some of the stand-alone samples which are included in the Gradle distribution. You can find these samples in the <code class="filename">
      <em class="replaceable"><code>GRADLE_HOME</code></em>/samples</code> directory of the distribution.</p><div class="table"><p class="title"><b>Table&nbsp;A.1.&nbsp;Samples included in the distribution</b></p><div class="table-contents"><table id="N1B155"><thead><td>Sample</td><td>Description</td></thead><tr>
      <td>
        <code class="filename">announce</code>
      </td>
      <td>
        <p>A project which uses the announce plugin</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">application</code>
      </td>
      <td>
        <p>A project which uses the application plugin</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">buildCache/build-src</code>
      </td>
      <td>
        <p>Configure the build cache consistently for <code class="literal">buildSrc</code> and the main build</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">buildCache/configure-built-in-caches</code>
      </td>
      <td>
        <p>Configuration options for the build cache</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">buildCache/developer-ci-setup</code>
      </td>
      <td>
        <p>
        Recommended cache configuration: Developer push to a local build cache and pull from local and remote build cache,
        continuous integration server pushes to and pulls from the remote cache.
    </p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">buildCache/http-build-cache</code>
      </td>
      <td>
        <p>Use a remote HTTP build cache</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">buildDashboard</code>
      </td>
      <td>
        <p>A project which uses the build-dashboard plugin</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">codeQuality</code>
      </td>
      <td>
        <p>A project which uses the various code quality plugins.</p>
      </td>
    </tr><tr>
      <td>
        <a class="link" href="#-2109641661">
          <code class="filename">customBuildLanguage</code>
        </a>
      </td>
      <td>
        <p>This sample demonstrates how to add some custom elements to the build DSL. It also demonstrates the use of
        custom plug-ins to organize build logic.
    </p>
      </td>
    </tr><tr>
      <td>
        <a class="link" href="#1030412118">
          <code class="filename">customDistribution</code>
        </a>
      </td>
      <td>
        <p>This sample demonstrates how to create a custom Gradle distribution and use it with the Gradle wrapper.</p>
      </td>
    </tr><tr>
      <td>
        <a class="link" href="#-67209235">
          <code class="filename">customPlugin</code>
        </a>
      </td>
      <td>
        <p>A set of projects that show how to implement, test, publish and use a custom plugin and task.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">ear/earCustomized/ear</code>
      </td>
      <td>
        <p>Web application ear project with customized contents</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">ear/earWithWar</code>
      </td>
      <td>
        <p>Web application ear project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">groovy/crossCompilation</code>
      </td>
      <td>
        <p>A project doing cross compilation for a Groovy Project to Java 6</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">groovy/customizedLayout</code>
      </td>
      <td>
        <p>Groovy project with a custom source layout</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">groovy/mixedJavaAndGroovy</code>
      </td>
      <td>
        <p>Project containing a mix of Java and Groovy source</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">groovy/multiproject</code>
      </td>
      <td>
        <p>Build made up of multiple Groovy projects. Also demonstrates how to exclude certain source files, and the use
        of a custom Groovy AST transformation.
    </p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">groovy/quickstart</code>
      </td>
      <td>
        <p>Groovy quickstart sample</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java-library/multiproject</code>
      </td>
      <td>
        <p>Java Library multiproject</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java-library/quickstart</code>
      </td>
      <td>
        <p>Java Library quickstart project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java/base</code>
      </td>
      <td>
        <p>Java base project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java/crossCompilation</code>
      </td>
      <td>
        <p>A project doing cross compilation to Java 6</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java/customizedLayout</code>
      </td>
      <td>
        <p>Java project with a custom source layout</p>
      </td>
    </tr><tr>
      <td>
        <a class="link" href="#-755788896">
          <code class="filename">java/multiproject</code>
        </a>
      </td>
      <td>
        <p>This sample demonstrates how an application can be composed using multiple Java projects.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java/quickstart</code>
      </td>
      <td>
        <p>Java quickstart project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">java/withIntegrationTests</code>
      </td>
      <td>
        <p>This sample demonstrates how to use a source set to add an integration test suite to a Java project.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">javaGradlePlugin</code>
      </td>
      <td>
        <p>
        This example demonstrates the use of the java gradle plugin development plugin.  By applying the plugin, the java plugin
        is automatically applied as well as the gradleApi() dependency.  Furthermore, validations are performed against the
        plugin metadata during jar execution.
    </p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">maven/pomGeneration</code>
      </td>
      <td>
        <p>Demonstrates how to deploy and install to a Maven repository. Also demonstrates how to deploy a javadoc JAR
        along with the main JAR, how to customize the contents of the generated POM, and how to deploy snapshots and
        releases to different repositories.
    </p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">maven/quickstart</code>
      </td>
      <td>
        <p>Demonstrates how to deploy and install artifacts to a Maven repository.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">osgi</code>
      </td>
      <td>
        <p>A project which builds an OSGi bundle</p>
      </td>
    </tr><tr>
      <td>
        <a class="link" href="#-1028226086">
          <code class="filename">plugins</code>
        </a>
      </td>
      <td>
        <p>A set of projects that show how to implement, test, publish and use a custom plugins with the latest technology.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">providers/fileAndDirectoryProperty</code>
      </td>
      <td>
        <p>A set of examples using the Provider API for File-like properties</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">providers/implicitTaskDependency</code>
      </td>
      <td>
        <p>An example project using the Provider API to model the relationship between a producer and consumer task.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">providers/listProperty</code>
      </td>
      <td>
        <p>A set of examples using the Provider API for collection properties</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">providers/propertyAndProvider</code>
      </td>
      <td>
        <p>An example of using the Provider API with the Groovy Gradle DSL</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/crossCompilation</code>
      </td>
      <td>
        <p>A project doing cross compilation for a Scala project to Java 6</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/customizedLayout</code>
      </td>
      <td>
        <p>Scala project with a custom source layout</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/force</code>
      </td>
      <td>
        <p>Scala quickstart project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/mixedJavaAndScala</code>
      </td>
      <td>
        <p>A project containing a mix of Java and Scala source.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/quickstart</code>
      </td>
      <td>
        <p>Scala quickstart project</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">scala/zinc</code>
      </td>
      <td>
        <p>Scala project using the Zinc based Scala compiler.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">testing/testReport</code>
      </td>
      <td>
        <p>Generates an HTML test report that includes the test results from all subprojects.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">toolingApi/customModel</code>
      </td>
      <td>
        <p>A sample of how a plugin can expose its own custom tooling model to tooling API clients.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">toolingApi/eclipse</code>
      </td>
      <td>
        <p>An application that uses the tooling API to build the Eclipse model for a project.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">toolingApi/idea</code>
      </td>
      <td>
        <p>An application that uses the tooling API to extract information needed by IntelliJ IDEA.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">toolingApi/model</code>
      </td>
      <td>
        <p>An application that uses the tooling API to build the model for a Gradle build.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">toolingApi/runBuild</code>
      </td>
      <td>
        <p>An application that uses the tooling API to run a Gradle task.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">userguide/distribution</code>
      </td>
      <td>
        <p>A project which uses the distribution plugin</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">userguide/javaLibraryDistribution</code>
      </td>
      <td>
        <p>A project which uses the Java library distribution plugin</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">webApplication/customized</code>
      </td>
      <td>
        <p>Web application with customized WAR contents.</p>
      </td>
    </tr><tr>
      <td>
        <code class="filename">webApplication/quickstart</code>
      </td>
      <td>
        <p>Web application quickstart project</p>
      </td>
    </tr></table></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="-2109641661" class="section-anchor" href="#-2109641661"></a>Sample <code class="filename">customBuildLanguage</code>
    </h2></div></div></div><p>This sample demonstrates how to add some custom elements to the build DSL. It also demonstrates the use of
        custom plug-ins to organize build logic.
    </p><p>The build is composed of 2 types of projects. The first type of project represents a product, and the second
        represents a product module. Each product includes one or more product modules, and each product module may be
        included in multiple products. That is, there is a many-to-many relationship between these products and product
        modules. For each product, the build produces a ZIP containing the runtime classpath for each product module
        included in the product. The ZIP also contains some product-specific files.
    </p><p>The custom elements can be seen in the build script for the product projects (for example,
        <code class="filename">basicEdition/build.gradle</code>). Notice that the build script uses the
        <code class="literal">product { }</code> element. This is a custom element.
    </p><p>The build scripts of each project contain only declarative elements. The bulk of the work is done by 2
        custom plug-ins found in <code class="filename">buildSrc/src/main/groovy</code>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="1030412118" class="section-anchor" href="#1030412118"></a>Sample <code class="filename">customDistribution</code>
    </h2></div></div></div><p>This sample demonstrates how to create a custom Gradle distribution and use it with the Gradle wrapper.</p><p>This sample contains the following projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="filename">plugin</code> directory contains the project that implements a custom plugin, and bundles the plugin into a custom
                Gradle distribution.</p></li><li class="listitem"><p>The <code class="filename">consumer</code> directory contains the project that uses the custom distribution.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="-67209235" class="section-anchor" href="#-67209235"></a>Sample <code class="filename">customPlugin</code>
    </h2></div></div></div><p>A set of projects that show how to implement, test, publish and use a custom plugin and task.</p><p>This sample contains the following projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="filename">plugin</code> directory contains the project that implements and publishes the plugin.</p></li><li class="listitem"><p>The <code class="filename">consumer</code> directory contains the project that uses the plugin.</p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="-755788896" class="section-anchor" href="#-755788896"></a>Sample <code class="filename">java/multiproject</code>
    </h2></div></div></div><p>This sample demonstrates how an application can be composed using multiple Java projects.</p><p>This build creates a client-server application which is distributed as 2 archives. First, there is a client
        ZIP which includes an API JAR, which a 3rd party application would compile against, and a client runtime. Then,
        there is a server WAR which provides a web service.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="-1028226086" class="section-anchor" href="#-1028226086"></a>Sample <code class="filename">plugins</code>
    </h2></div></div></div><p>A set of projects that show how to implement, test, publish and use a custom plugins with the latest technology.</p><p>This sample contains the following projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="filename">buildscript</code> directory contains a project that uses the old <code class="code">buildscript</code> syntax for using plugins.</p></li><li class="listitem"><p>The <code class="filename">dsl</code> directory contains the a project that uses the new <code class="code">plugins</code> syntax for using plugins.</p></li><li class="listitem"><p>
                The <code class="filename">publishing</code> directory contains a complete example of the modern publishing plugins working with the java-gradle-plugin
                to produce two plugins shipped in the same jar and being published to both an ivy and maven repository.
            </p></li><li class="listitem"><p>
                The <code class="filename">consuming</code> directory contains an example of resolving plugins from custom repositories instead the Gradle Plugin Portal.
            </p></li></ul></div></div></div><div class="appendix"><div class="titlepage"><div><div><h1><a name="potential_traps"></a>Appendix&nbsp;B.&nbsp;Potential Traps</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:groovy_script_variables" class="section-anchor" href="#sec:groovy_script_variables"></a>Groovy script variables</h2></div></div></div><p>For Gradle users it is important to understand how Groovy deals with script variables. Groovy has two types of script variables. One with a local scope and one with a script-wide scope.</p><div class="example"><a name="scope"></a><p class="title"><b>Example&nbsp;B.1.&nbsp;Variables scope: local and script wide</b></p><div class="example-contents"><p><code class="filename">scope.groovy</code></p><pre class="programlisting">String localScope1 = <span class="hl-string">'localScope1'</span>
def localScope2 = <span class="hl-string">'localScope2'</span>
scriptScope = <span class="hl-string">'scriptScope'</span>

println localScope1
println localScope2
println scriptScope

closure = {
    println localScope1
    println localScope2
    println scriptScope
}

def method() {
    <span class="hl-keyword">try</span> {
        localScope1
    } <span class="hl-keyword">catch</span> (MissingPropertyException e) {
        println <span class="hl-string">'localScope1NotAvailable'</span>
    }
    <span class="hl-keyword">try</span> {
        localScope2
    } <span class="hl-keyword">catch</span>(MissingPropertyException e) {
        println <span class="hl-string">'localScope2NotAvailable'</span>
    }
    println scriptScope
}

closure.call()
method()
</pre><p>Output of <strong class="userinput"><code>groovy scope.groovy</code></strong></p><pre class="screen">&gt; groovy scope.groovy
localScope1
localScope2
scriptScope
localScope1
localScope2
scriptScope
localScope1NotAvailable
localScope2NotAvailable
scriptScope
</pre></div></div><br class="example-break"><p>Variables which are declared with a type modifier are visible within closures but not visible within methods.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:configuration_and_execution_phase" class="section-anchor" href="#sec:configuration_and_execution_phase"></a>Configuration and execution phase</h2></div></div></div><p>It is important to keep in mind that Gradle has a distinct configuration and execution phase (see <a class="xref" href="#build_lifecycle"><i>Build Lifecycle</i></a>).</p><div class="example"><a name="mkdirTrap"></a><p class="title"><b>Example&nbsp;B.2.&nbsp;Distinct configuration and execution phase</b></p><div class="example-contents"><p><code class="filename">build.gradle</code></p><pre class="programlisting">def classesDir = file(<span class="hl-string">'build/classes'</span>)
classesDir.mkdirs()
task clean(type: Delete) {
    delete <span class="hl-string">'build'</span>
}
task compile(dependsOn: <span class="hl-string">'clean'</span>) {
    doLast {
        <span class="hl-keyword">if</span> (!classesDir.isDirectory()) {
            println <span class="hl-string">'The class directory does not exist. I can not operate'</span>
            <span class="hl-comment">// do something</span>
        }
        <span class="hl-comment">// do something</span>
    }
}
</pre><p>Output of <strong class="userinput"><code>gradle -q compile</code></strong></p><pre class="screen">&gt; gradle -q compile
The class directory does not exist. I can not operate
</pre></div></div><br class="example-break"><p>As the creation of the directory happens during the configuration phase, the <code class="literal">clean</code> task removes the directory during the execution phase.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1><a name="feature_lifecycle"></a>Appendix&nbsp;C.&nbsp;The Feature Lifecycle</h1></div></div></div><p>Gradle is under constant development and improvement. New versions are delivered on a regular and frequent basis (approximately every 6 weeks). Continuous improvement combined with frequent delivery allows new features to be made available to users early and for invaluable real world feedback to be incorporated into the development process. Getting new functionality into the hands of users regularly is a core value of the Gradle platform. At the same time, API and feature stability is taken very seriously and is also considered a core value of the Gradle platform. This is something that is engineered into the development process by design choices and automated testing, and is formalised by <a class="xref" href="#backwards_compatibility">the section called &ldquo;Backwards Compatibility Policy&rdquo;</a>.</p><p>The Gradle <span class="emphasis"><em>feature lifecycle</em></span> has been designed to meet these goals. It also serves to clearly communicate to users of Gradle what the state of a feature is. The term <span class="emphasis"><em>feature</em></span> typically means an API or DSL method or property in this context, but it is not restricted to this definition. Command line arguments and modes of execution (e.g. the Build Daemon) are two examples of other kinds of features.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:states" class="section-anchor" href="#sec:states"></a>States</h2></div></div></div><p>Features can be in one of 4 states:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Internal</p></li><li class="listitem"><p>Incubating</p></li><li class="listitem"><p>Public</p></li><li class="listitem"><p>Deprecated</p></li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:internal" class="section-anchor" href="#sec:internal"></a>Internal</h3></div></div></div><p>Internal features are not designed for public use and are only intended to be used by Gradle itself. They can change in any way at any point in time without any notice. Therefore, we recommend avoiding the use of such features. Internal features are not documented. If it appears in this User Guide, the DSL Reference or the API Reference documentation then the feature is not internal.</p><p>Internal features may evolve into public features.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:incubating_state" class="section-anchor" href="#sec:incubating_state"></a>Incubating</h3></div></div></div><p>Features are introduced in the <span class="emphasis"><em>incubating</em></span> state to allow real world feedback to be incorporated into the feature before it is made public and locked down to provide backwards compatibility. It also gives users who are willing to accept potential future changes early access to the feature so they can put it into use immediately.</p><p>A feature in an incubating state may change in future Gradle versions until it is no longer incubating. Changes to incubating features for a Gradle release will be highlighted in the release notes for that release. The incubation period for new features varies depending on the scope, complexity and nature of the feature.</p><p>Features in incubation are clearly indicated to be so. In the source code, all methods/properties/classes that are incubating are annotated with <a class="ulink" href="../javadoc/org/gradle/api/Incubating.html" target="_top"><code class="classname">Incubating</code></a>, which is also used to specially mark them in the DSL and API references. If an incubating feature is discussed in this User Guide, it will be explicitly said to be in the incubating state.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:public" class="section-anchor" href="#sec:public"></a>Public</h3></div></div></div><p>The default state for a non-internal feature is <span class="emphasis"><em>public</em></span>. Anything that is documented in the User Guide, DSL Reference or API references that is not explicitly said to be incubating or deprecated is considered public. Features are said to be <span class="emphasis"><em>promoted</em></span> from an incubating state to public. The release notes for each release indicate which previously incubating features are being promoted by the release.</p><p>A public feature will <span class="emphasis"><em>never</em></span> be removed or intentionally changed without undergoing deprecation. All public features are subject to the backwards compatibility policy.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="sec:deprecated" class="section-anchor" href="#sec:deprecated"></a>Deprecated</h3></div></div></div><p>Some features will become superseded or irrelevant due to the natural evolution of Gradle. Such features will eventually be removed from Gradle after being <span class="emphasis"><em>deprecated</em></span>. A deprecated feature will <span class="emphasis"><em>never</em></span> be changed, until it is finally removed according to the backwards compatibility policy.</p><p>Deprecated features are clearly indicated to be so. In the source code, all methods/properties/classes that are deprecated are annotated with &ldquo;<code class="literal">@java.lang.Deprecated</code>&rdquo; which is reflected in the DSL and API references. In most cases, there is a replacement for the deprecated element, and this will be described in the documentation. Using a deprecated feature will also result in a runtime warning in Gradle&rsquo;s output.</p><p>Use of deprecated features should be avoided. The release notes for each release indicate any features that are being deprecated by the release.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="backwards_compatibility" class="section-anchor" href="#backwards_compatibility"></a>Backwards Compatibility Policy</h2></div></div></div><p>Gradle provides backwards compatibility across major versions (e.g. <code class="literal">1.x</code>, <code class="literal">2.x</code>, etc.). Once a public feature is introduced or promoted in a Gradle release it will remain indefinitely or until it is deprecated. Once deprecated, it may be removed in the next major release. Deprecated features may be supported across major releases, but this is not guaranteed.</p></div></div><div class="appendix"><div class="titlepage"><div><div><h1><a name="licenses"></a>Appendix&nbsp;D.&nbsp;Documentation licenses</h1></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:gradle_documentation" class="section-anchor" href="#sec:gradle_documentation"></a>Gradle Documentation</h2></div></div></div><p><span class="emphasis"><em>Copyright &copy; 2007-2016 Gradle, Inc.</em></span></p><p>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a name="sec:_header_link_icon_" class="section-anchor" href="#sec:_header_link_icon_"></a>Header link icon</h2></div></div></div><p><span class="emphasis"><em><a class="ulink" href="https://commons.wikimedia.org/wiki/File:VisualEditor_-_Icon_-_Link.svg" target="_top">Copyright &copy; 2011&ndash;2013 VisualEditor team.</a></em></span></p><p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p><p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p><p>The Software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.</p></div></div></div></div></body></html>