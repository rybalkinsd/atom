#Задание 3. Реализация клиент - серверного протокола
Сдача - 29 ноября на занятии. Целое занятие будет посвящено защите работ

##Что есть на данный момент:  
###zagar-client
Готовая реализация клиента игры. Клиент умеет отрисовывать клетки, вирусы, еду и leaderboard.

###zagar-server
Основа для сервера игры.

###zagar-protocol
Содержит описатели пакетов, которыми обмениваются клиент и сервер

##Клиент-серверное взаимодействие
Сервер и клиент общаются друг с другом с помощью пакетов, содержащих json, поверх webSockets. Структура пакета определяется классом-описателем пакета. (см. Lecture 7)

##Взаимодействие сервисов внутри сервера
![alt text](https://github.com/rybalkinsd/atom/blob/master/tasks/%233-client-server-protocol/services.png "How do services interact")

Сервер содержит 3 сервиса (потока):
- *Mechanics* - здесь выполняется игровая логика
- *ClientConnectionService* - этот сервис посылает сообщения на клиент
- *AccountService* - этот сервис принимает и обрабатывает запрсы на авторизацию

Сервисы взаимодействуют друг с другом с помощью обмена сообщниями через MessageSystem

##MessageSystem
Система, позволяющая потокобезопасно (через ConcurrenyLinkeQueue) посылать сообщения из одного сервиса в другой. Сообщения содержат исполняемый код. Таким образом MessageSystem позволяет выполнять код в нужном сервисе.

Пример: replication - процесс передачи состояния сервера на клиент. В конце каждого тика механики мы хотим посылать состояние сервера на клиент, Для этого:

1. мы посылаем ReplicateMsg с сервера в ClientConnectionService
2. в clientConnectionService создаем PacketReplicate и шлем его на клиент

#Задача
полная реализация клиент-серверного протокола на сервере и написание утилит для тестирования клиент-серверного взаимодействия.
Часть протокола, связанная с авторизацией уже реализована. Ваша задача - реализовать часть, необходимую для игрового взаимодействия.

**Замечание**

Клиент-серверный протокол использует модель игровой механики, которую Вы реализовали в ДЗ1. Вы можете интегрировать свою модель или использовать ту, что мы Вам предотавили.

###Клиент-серверный протокол

0. **(optional) - игтегрируйте модель из ДЗ1 в игру.**

1. **Залоггируйте прием пакетов в игровой механике:**
  - CommandEjectMass - пакет, сообщающий, что клетка должна выкинуть массу вперед
  - CommandMove - пакет, сообщающий, куда сдвинулась клетка
  - CommandSplit - пакет, сообщающий, что клетка должна разделиться

    1. Залоггируйте получение сообщений в потоке сервиса GameMechanics. То есть, необходимо сначала переслать полученное сообщение в Mechanics и там его залоггировать. Позже на месте логгирования Вы реализуете ировую механику, связанную с обработкой пакета.
    2. Напишите тест, имитирующий отправку пакетов из клиента. Тест должен показывать, что пакеты логгируются в потоке GameMechanics

###Конфигурация сервера для тестирования
Во многих тестах требуется поднятие сервера в той или иной конфигурации (Особенно это актуально при тестировании игровой механики)

2. **Реализуйте конфигурацию мастер-сервера с помощью файла**
  
  Вы должны реализовать конфигурацию с помощью пар ключ-значение. Вы можете использовать любой формат файла, поддерживающий пары ключ-значение, например ini или [properties](  https://docs.oracle.com/javase/tutorial/essential/environment/properties.html).

  Поддержите следующие параметры:
  1. accountServerPort
  2. clientConnectionPort
  Следующие параметры должны быть заданы в виде пути до класса и находиться с помощью Reflection API:
  3. replicator
  4. matchMaker
  5. services - разделенные запятой пути до сервисов
  6. Все символы после # должны игнорироваться, как комментарии

###Репликация
Наиболее важная часть клиент-серверного взаимодействия - репликация игрового состояния с сервера на клиент. Под репликой понимается игровое состояние, пересылаемое и сервера на клиент. В протоколе репликация представлена пакетом CommandReplicate. Наивная реализация FullStateReplicator, предоставленная в zagar-server, пересылает всё состояние сервера на каждый клиент на каждом тике.

3. **Тестирование репликации**
  1. Предоставьте реализацию Replicator, которая принимает на вход json с репликой.
  2. Напишите тест, который поднимает сервер с таким репликатором.
При подключении клиентом к такому тестовому серверу вы должны увидеть отрисованную реплику.
вход - файл .json, содержащий реплику

4. **Тестирование leaderboard**
  1. Предоставьте реализацию LeaderBoard, которая берет список лидеров из файла .json
  2. Напишите тест, поднимающий сервер с такой LeaderBoard.
При подключении клиентом к такому серверу вы должны увидеть отрисованный Leaderboard
